1667
#method_before
@Before
public void setUp() throws Exception {
    util = new Util();
    project = new ProjectConfig(new Project.NameKey("project"));
    InMemoryRepository inMemoryRepo = util.add(project);
    repo = new TestRepository<InMemoryRepository>(inMemoryRepo);
}
#method_after
@Before
public void setUp() throws Exception {
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    Account.Id userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    user = userFactory.create(userId);
    Project.NameKey name = new Project.NameKey("project");
    InMemoryRepository inMemoryRepo = repoManager.createRepository(name);
    project = new ProjectConfig(name);
    project.load(inMemoryRepo);
    repo = new TestRepository<InMemoryRepository>(inMemoryRepo);
}
#end_block

#method_before
@Test
public void canReadCommitWhenAllRefsVisible() throws Exception {
    allow(project, READ, DEVS, "refs/*");
    ObjectId id = repo.branch("master").commit().create();
    ProjectControl pc = util.user(project, DEVS);
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(id)));
}
#method_after
@Test
public void canReadCommitWhenAllRefsVisible() throws Exception {
    allow(project, READ, REGISTERED_USERS, "refs/*");
    ObjectId id = repo.branch("master").commit().create();
    ProjectControl pc = newProjectControl();
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id)));
}
#end_block

#method_before
@Test
public void canReadCommitIfRefVisible() throws Exception {
    allow(project, READ, DEVS, "refs/heads/branch1");
    deny(project, READ, DEVS, "refs/heads/branch2");
    ObjectId id1 = repo.branch("branch1").commit().create();
    ObjectId id2 = repo.branch("branch2").commit().create();
    ProjectControl pc = util.user(project, DEVS);
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(id1)));
    assertFalse(pc.canReadCommit(rw, rw.parseCommit(id2)));
}
#method_after
@Test
public void canReadCommitIfRefVisible() throws Exception {
    allow(project, READ, REGISTERED_USERS, "refs/heads/branch1");
    deny(project, READ, REGISTERED_USERS, "refs/heads/branch2");
    ObjectId id1 = repo.branch("branch1").commit().create();
    ObjectId id2 = repo.branch("branch2").commit().create();
    ProjectControl pc = newProjectControl();
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id1)));
    assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(id2)));
}
#end_block

#method_before
@Test
public void canReadCommitIfReachableFromVisibleRef() throws Exception {
    allow(project, READ, DEVS, "refs/heads/branch1");
    deny(project, READ, DEVS, "refs/heads/branch2");
    RevCommit parent1 = repo.commit().create();
    repo.branch("branch1").commit().parent(parent1).create();
    RevCommit parent2 = repo.commit().create();
    repo.branch("branch2").commit().parent(parent2).create();
    ProjectControl pc = util.user(project, DEVS);
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(rw, rw.parseCommit(parent2)));
}
#method_after
@Test
public void canReadCommitIfReachableFromVisibleRef() throws Exception {
    allow(project, READ, REGISTERED_USERS, "refs/heads/branch1");
    deny(project, READ, REGISTERED_USERS, "refs/heads/branch2");
    RevCommit parent1 = repo.commit().create();
    repo.branch("branch1").commit().parent(parent1).create();
    RevCommit parent2 = repo.commit().create();
    repo.branch("branch2").commit().parent(parent2).create();
    ProjectControl pc = newProjectControl();
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(parent2)));
}
#end_block

#method_before
@Test
public void cannotReadAfterRollbackWithRestrictedRead() throws Exception {
    allow(project, READ, DEVS, "refs/heads/branch1");
    RevCommit parent1 = repo.commit().create();
    ObjectId id1 = repo.branch("branch1").commit().parent(parent1).create();
    ProjectControl pc = util.user(project, DEVS);
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1)));
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(id1)));
    repo.branch("branch1").update(parent1);
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(rw, rw.parseCommit(id1)));
}
#method_after
@Test
public void cannotReadAfterRollbackWithRestrictedRead() throws Exception {
    allow(project, READ, REGISTERED_USERS, "refs/heads/branch1");
    RevCommit parent1 = repo.commit().create();
    ObjectId id1 = repo.branch("branch1").commit().parent(parent1).create();
    ProjectControl pc = newProjectControl();
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1)));
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id1)));
    repo.branch("branch1").update(parent1);
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(id1)));
}
#end_block

#method_before
@Test
public void canReadAfterRollbackWithAllRefsVisible() throws Exception {
    allow(project, READ, DEVS, "refs/*");
    RevCommit parent1 = repo.commit().create();
    ObjectId id1 = repo.branch("branch1").commit().parent(parent1).create();
    ProjectControl pc = util.user(project, DEVS);
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1)));
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(id1)));
    repo.branch("branch1").update(parent1);
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(rw, rw.parseCommit(id1)));
}
#method_after
@Test
public void canReadAfterRollbackWithAllRefsVisible() throws Exception {
    allow(project, READ, REGISTERED_USERS, "refs/*");
    RevCommit parent1 = repo.commit().create();
    ObjectId id1 = repo.branch("branch1").commit().parent(parent1).create();
    ProjectControl pc = newProjectControl();
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1)));
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id1)));
    repo.branch("branch1").update(parent1);
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(id1)));
}
#end_block

#method_before
public boolean allRefsAreVisible() {
    return allRefsAreVisibleExcept(Collections.<String>emptySet());
}
#method_after
public boolean allRefsAreVisible() {
    return allRefsAreVisible(Collections.<String>emptySet());
}
#end_block

#method_before
public boolean allRefsAreVisible() {
    return allRefsAreVisibleExcept(Collections.<String>emptySet());
}
#method_after
public boolean allRefsAreVisible(Set<String> ignore) {
    return user instanceof InternalUser || canPerformOnAllRefs(Permission.READ, ignore);
}
#end_block

#method_before
private boolean canPerformOnAllRefs(String permission, Set<String> except) {
    boolean canPerform = false;
    Set<String> patterns = allRefPatterns(permission);
    if (patterns.contains(AccessSection.ALL)) {
        // 
        for (final String pattern : patterns) {
            if (controlForRef(pattern).canPerform(permission)) {
                canPerform = true;
            } else if (except.contains(pattern)) {
                continue;
            } else {
                return false;
            }
        }
    }
    return canPerform;
}
#method_after
private boolean canPerformOnAllRefs(String permission, Set<String> ignore) {
    boolean canPerform = false;
    Set<String> patterns = allRefPatterns(permission);
    if (patterns.contains(AccessSection.ALL)) {
        // 
        for (final String pattern : patterns) {
            if (controlForRef(pattern).canPerform(permission)) {
                canPerform = true;
            } else if (ignore.contains(pattern)) {
                continue;
            } else {
                return false;
            }
        }
    }
    return canPerform;
}
#end_block

#method_before
public boolean canReadCommit(RevWalk rw, RevCommit commit) {
    Project.NameKey projName = state.getProject().getNameKey();
    try {
        Repository repo = repoManager.openRepository(projName);
        try {
            RefDatabase refDb = repo.getRefDatabase();
            List<Ref> allRefs = Lists.newLinkedList();
            allRefs.addAll(refDb.getRefs(Constants.R_HEADS).values());
            allRefs.addAll(refDb.getRefs(Constants.R_TAGS).values());
            List<Ref> canReadRefs = Lists.newLinkedList();
            for (Ref r : allRefs) {
                if (controlForRef(r.getName()).canPerform(Permission.READ)) {
                    canReadRefs.add(r);
                }
            }
            if (!canReadRefs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, canReadRefs)) {
                return true;
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get());
        log.error(msg, e);
    }
    return false;
}
#method_after
public boolean canReadCommit(ReviewDb db, RevWalk rw, RevCommit commit) {
    try {
        Repository repo = repoManager.openRepository(getProject().getNameKey());
        try {
            VisibleRefFilter filter = new VisibleRefFilter(tagCache, changeCache, repo, this, db, true);
            Map<String, Ref> visibleRefs = filter.filter(repo.getAllRefs(), true);
            if (!visibleRefs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, visibleRefs.values())) {
                return true;
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), getProject().getNameKey());
        log.error(msg, e);
    }
    return false;
}
#end_block

#method_before
public static Id fromRef(String ref) {
    int cs = startIndex(ref);
    if (cs < 0) {
        return null;
    }
    int ce = nextNonDigit(ref, cs);
    int patchSetId = PatchSet.Id.fromRef(ref, ce);
    if (patchSetId >= 0 || ref.substring(ce).equals(RefNames.META_SUFFIX)) {
        return new Change.Id(Integer.parseInt(ref.substring(cs, ce)));
    }
    return null;
}
#method_after
public static Id fromRef(String ref) {
    int cs = startIndex(ref);
    if (cs < 0) {
        return null;
    }
    int ce = nextNonDigit(ref, cs);
    if (ref.substring(ce).equals(RefNames.META_SUFFIX) || PatchSet.Id.fromRef(ref, ce) >= 0) {
        return new Change.Id(Integer.parseInt(ref.substring(cs, ce)));
    }
    return null;
}
#end_block

#method_before
static int startIndex(String ref) {
    if (ref == null || !ref.startsWith(REFS_CHANGES)) {
        return -1;
    }
    // Last 2 digits.
    int ls = REFS_CHANGES.length();
    int le = nextNonDigit(ref, ls);
    if (le - ls != 2 || le >= ref.length() || ref.charAt(le) != '/') {
        return -1;
    }
    // Change ID.
    int cs = le + 1;
    if (cs >= ref.length() || ref.charAt(cs) == '0') {
        return -1;
    }
    int ce = nextNonDigit(ref, cs);
    if (ce >= ref.length() || ref.charAt(le) != '/') {
        return -1;
    }
    switch(ce - cs) {
        case 0:
            return -1;
        case 1:
            if (ref.charAt(ls) != '0' || ref.charAt(ls + 1) != ref.charAt(cs)) {
                return -1;
            }
            break;
        default:
            if (ref.charAt(ls) != ref.charAt(ce - 2) || ref.charAt(ls + 1) != ref.charAt(ce - 1)) {
                return -1;
            }
            break;
    }
    return cs;
}
#method_after
static int startIndex(String ref) {
    if (ref == null || !ref.startsWith(REFS_CHANGES)) {
        return -1;
    }
    // Last 2 digits.
    int ls = REFS_CHANGES.length();
    int le = nextNonDigit(ref, ls);
    if (le - ls != 2 || le >= ref.length() || ref.charAt(le) != '/') {
        return -1;
    }
    // Change ID.
    int cs = le + 1;
    if (cs >= ref.length() || ref.charAt(cs) == '0') {
        return -1;
    }
    int ce = nextNonDigit(ref, cs);
    if (ce >= ref.length() || ref.charAt(ce) != '/') {
        return -1;
    }
    switch(ce - cs) {
        case 0:
            return -1;
        case 1:
            if (ref.charAt(ls) != '0' || ref.charAt(ls + 1) != ref.charAt(cs)) {
                return -1;
            }
            break;
        default:
            if (ref.charAt(ls) != ref.charAt(ce - 2) || ref.charAt(ls + 1) != ref.charAt(ce - 1)) {
                return -1;
            }
            break;
    }
    return cs;
}
#end_block

#method_before
@Test
public void parsePatchSetRefNames() {
    assertRef(1, "refs/changes/01/1/1");
    assertRef(1234, "refs/changes/34/1234/56");
    // Invalid characters.
    assertNotRef("refs/changes/0x/1/1");
    assertNotRef("refs/changes/01/x/1");
    assertNotRef("refs/changes/01/1/x");
    // Truncations.
    assertNotRef("refs/changes/");
    assertNotRef("refs/changes/1");
    assertNotRef("refs/changes/01");
    assertNotRef("refs/changes/01/");
    assertNotRef("refs/changes/01/1/");
    assertNotRef("refs/changes/01/1/1/");
    assertNotRef("refs/changes/01//1/1");
    // Leading zeroes.
    assertNotRef("refs/changes/01/01/1");
    assertNotRef("refs/changes/01/1/01");
    // Mismatched last 2 digits.
    assertNotRef("refs/changes/35/1234/56");
}
#method_after
@Test
public void parsePatchSetRefNames() {
    assertRef(1, "refs/changes/01/1/1");
    assertRef(1234, "refs/changes/34/1234/56");
    // Invalid characters.
    assertNotRef("refs/changes/0x/1/1");
    assertNotRef("refs/changes/01/x/1");
    assertNotRef("refs/changes/01/1/x");
    // Truncations.
    assertNotRef("refs/changes/");
    assertNotRef("refs/changes/1");
    assertNotRef("refs/changes/01");
    assertNotRef("refs/changes/01/");
    assertNotRef("refs/changes/01/1/");
    assertNotRef("refs/changes/01/1/1/");
    assertNotRef("refs/changes/01//1/1");
    // Leading zeroes.
    assertNotRef("refs/changes/01/01/1");
    assertNotRef("refs/changes/01/1/01");
    // Mismatched last 2 digits.
    assertNotRef("refs/changes/35/1234/56");
    // Something other than patch set after change.
    assertNotRef("refs/changes/34/1234/0");
    assertNotRef("refs/changes/34/1234/foo");
    assertNotRef("refs/changes/34/1234|56");
    assertNotRef("refs/changes/34/1234foo");
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return getCurrentUser().getCapabilities().canAdministrateServer() || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return getCurrentUser().getCapabilities().canAdministrateServer() || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public void testBlockLabelRange_ParentBlocksChild() {
    grantLabel(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    grantLabel(util.getParentConfig(), LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*").setBlock();
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertTrue("u can vote -1", range.contains(-1));
    assertTrue("u can vote +1", range.contains(1));
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote 2", range.contains(2));
}
#method_after
public void testBlockLabelRange_ParentBlocksChild() {
    grant(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    grant(util.getParentConfig(), LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*").setBlock();
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertTrue("u can vote -1", range.contains(-1));
    assertTrue("u can vote +1", range.contains(1));
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote 2", range.contains(2));
}
#end_block

#method_before
public void testUnblockRange() {
    grantLabel(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/*").setBlock();
    grantLabel(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertTrue("u can vote -2", range.contains(-2));
    assertTrue("u can vote +2", range.contains(2));
}
#method_after
public void testUnblockRange() {
    grant(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/*").setBlock();
    grant(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertTrue("u can vote -2", range.contains(-2));
    assertTrue("u can vote +2", range.contains(2));
}
#end_block

#method_before
public void testUnblockRangeOnMoreSpecificRef_Fails() {
    grantLabel(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/*").setBlock();
    grantLabel(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/master");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote +2", range.contains(-2));
}
#method_after
public void testUnblockRangeOnMoreSpecificRef_Fails() {
    grant(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/*").setBlock();
    grant(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/master");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote +2", range.contains(-2));
}
#end_block

#method_before
public void testUnblockRangeOnLargerScope_Fails() {
    grantLabel(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/master").setBlock();
    grantLabel(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote +2", range.contains(-2));
}
#method_after
public void testUnblockRangeOnLargerScope_Fails() {
    grant(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/master").setBlock();
    grant(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote +2", range.contains(-2));
}
#end_block

#method_before
public void testUnblockInLocalRange_Fails() {
    grantLabel(util.getParentConfig(), LABEL + "Code-Review", -1, 1, ANONYMOUS, "refs/heads/*").setBlock();
    grantLabel(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote 2", range.contains(2));
}
#method_after
public void testUnblockInLocalRange_Fails() {
    grant(util.getParentConfig(), LABEL + "Code-Review", -1, 1, ANONYMOUS, "refs/heads/*").setBlock();
    grant(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote 2", range.contains(2));
}
#end_block

#method_before
static PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#method_after
static public PermissionRule grant(ProjectConfig project, String permissionName, int min, int max, AccountGroup.UUID group, String ref) {
    PermissionRule rule = newRule(project, group);
    rule.setMin(min);
    rule.setMax(max);
    return grant(project, permissionName, rule, ref);
}
#end_block

#method_before
static PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#method_after
static private PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#end_block

#method_before
private ProjectState newProjectState(ProjectConfig local) {
    PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager gitMgr = null;
    ProjectControl.AssistedFactory projectControlFactory = null;
    RulesCache rulesCache = null;
    SitePaths sitePaths = null;
    List<CommentLinkInfo> commentLinks = null;
    all.put(local.getProject().getNameKey(), new ProjectState(sitePaths, projectCache, allProjectsName, projectControlFactory, envFactory, gitMgr, rulesCache, commentLinks, local));
    return all.get(local.getProject().getNameKey());
}
#method_after
private ProjectState newProjectState(ProjectConfig local) {
    add(local);
    return all.get(local.getProject().getNameKey());
}
#end_block

#method_before
private Iterable<Project.NameKey> scan() throws BadRequestException {
    if (matchPrefix != null) {
        return projectCache.byName(matchPrefix);
    } else if (matchSubstring != null) {
        return Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

            public boolean apply(Project.NameKey in) {
                return in.get().toLowerCase(Locale.US).contains(matchSubstring.toLowerCase(Locale.US));
            }
        });
    } else if (matchRegex != null) {
        if (matchRegex.startsWith("^")) {
            matchRegex = matchRegex.substring(1);
            if (matchRegex.endsWith("$") && !matchRegex.endsWith("\\$")) {
                matchRegex = matchRegex.substring(0, matchRegex.length() - 1);
            }
        }
        try {
            final RunAutomaton a = new RunAutomaton(new RegExp(matchRegex).toAutomaton());
            return Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

                public boolean apply(Project.NameKey in) {
                    return a.run(in.get());
                }
            });
        } catch (IllegalArgumentException e) {
            throw new BadRequestException(e.getMessage());
        }
    } else {
        return projectCache.all();
    }
}
#method_after
private Iterable<Project.NameKey> scan() throws BadRequestException {
    if (matchPrefix != null) {
        return projectCache.byName(matchPrefix);
    } else if (matchSubstring != null) {
        return Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

            public boolean apply(Project.NameKey in) {
                return in.get().toLowerCase(Locale.US).contains(matchSubstring.toLowerCase(Locale.US));
            }
        });
    } else if (matchRegex != null) {
        if (matchRegex.startsWith("^")) {
            matchRegex = matchRegex.substring(1);
            if (matchRegex.endsWith("$") && !matchRegex.endsWith("\\$")) {
                matchRegex = matchRegex.substring(0, matchRegex.length() - 1);
            }
        }
        if (matchRegex.equals(".*")) {
            return projectCache.all();
        }
        try {
            final RunAutomaton a = new RunAutomaton(new RegExp(matchRegex).toAutomaton());
            return Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

                public boolean apply(Project.NameKey in) {
                    return a.run(in.get());
                }
            });
        } catch (IllegalArgumentException e) {
            throw new BadRequestException(e.getMessage());
        }
    } else {
        return projectCache.all();
    }
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Map<String, ?> json_data = buildData(req);
    renderJson(req, res, json_data, json_data.getClass());
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesAccess access = getAccess(req);
    RepositoryDescription desc = access.getRepositoryDescription();
    renderJson(req, res, desc, new TypeToken<RepositoryDescription>() {
    }.getType());
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RemoteCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RemoteCacheAdminModule());
    modules.add(createIndexModule());
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(createIndexModule());
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    if (executor == null) {
        return;
    }
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    if (executor == null) {
        return;
    }
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("TABLE address_id");
    drop("TABLE addresses");
    drop("TABLE cnt");
    drop("TABLE bar");
    drop("TABLE foo");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    if (executor == null) {
        return;
    }
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("TABLE address_id");
    drop("TABLE addresses");
    drop("TABLE cnt");
    drop("TABLE bar");
    drop("TABLE foo");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
private static File asTemp(InputStream in, String prefix, String suffix, File dir) throws IOException {
    File tmp = File.createTempFile(prefix, suffix, dir);
    boolean keep = false;
    try {
        FileOutputStream out = new FileOutputStream(tmp);
        try {
            byte[] data = new byte[8192];
            int n;
            while ((n = in.read(data)) > 0) {
                out.write(data, 0, n);
            }
            keep = true;
            return tmp;
        } finally {
            out.close();
        }
    } finally {
        if (!keep) {
            tmp.delete();
        }
    }
}
#method_after
static File asTemp(InputStream in, String prefix, String suffix, File dir) throws IOException {
    File tmp = File.createTempFile(prefix, suffix, dir);
    boolean keep = false;
    try (FileOutputStream out = new FileOutputStream(tmp)) {
        byte[] data = new byte[8192];
        int n;
        while ((n = in.read(data)) > 0) {
            out.write(data, 0, n);
        }
        keep = true;
        return tmp;
    } finally {
        if (!keep) {
            tmp.delete();
        }
    }
}
#end_block

#method_before
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJsPlugin(fileName) && !serverPluginFactory.handles(file)) {
            log.warn("Skipping non-plugin file " + fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJsPlugin(fileName) && !serverPluginFactory.handles(file)) {
            log.warn("No Plugin provider was found that handles this file format: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        if (newPlugin.getCleanupHandle() != null) {
            cleanupHandles.put(newPlugin, newPlugin.getCleanupHandle());
        }
        name = newPlugin.getName();
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        if (newPlugin.getCleanupHandle() != null) {
            cleanupHandles.put(newPlugin, newPlugin.getCleanupHandle());
        }
        /*
       * Pluggable plugin provider may have assigned a plugin name that could be
       * actually different from the initial one assigned during scan. It is
       * safer then to reassign it.
       */
        name = newPlugin.getName();
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (serverPluginFactory.handles(srcPlugin)) {
        name = serverPluginFactory.getPluginName(srcPlugin);
        return loadServerPlugin(name, srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#method_after
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (serverPluginFactory.handles(srcPlugin)) {
        return loadServerPlugin(srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#end_block

#method_before
private ServerPlugin loadServerPlugin(String name, File scriptFile, FileSnapshot snapshot) throws InvalidPluginException {
    return serverPluginFactory.get(scriptFile, pluginUserFactory.create(name), snapshot, getPluginCanonicalWebUrl(name), getPluginDataDir(name));
}
#method_after
private ServerPlugin loadServerPlugin(File scriptFile, FileSnapshot snapshot) throws InvalidPluginException {
    String name = serverPluginFactory.getPluginName(scriptFile);
    return serverPluginFactory.get(scriptFile, snapshot, new PluginDescription(pluginUserFactory.create(name), getPluginCanonicalWebUrl(name), getPluginDataDir(name)));
}
#end_block

#method_before
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name. Values are
// the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#method_after
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name initially assigned from its filename.
// Values are the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
// name are disabled.
// 
// NOTE: Bear in mind that the plugin name can be reassigned after load by the
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#end_block

#method_before
@Override
public String getPluginName(File srcFile) {
    try {
        return Objects.firstNonNull(getGerritJarPluginName(srcFile), PluginLoader.nameOf(srcFile));
    } catch (IOException e) {
        throw new IllegalArgumentException("Invalid plugin file " + srcFile + ": cannot get plugin name", e);
    }
}
#method_after
@Override
public String getPluginName(File srcFile) {
    try {
        return Objects.firstNonNull(getJarPluginName(srcFile), PluginLoader.nameOf(srcFile));
    } catch (IOException e) {
        throw new IllegalArgumentException("Invalid plugin file " + srcFile + ": cannot get plugin name", e);
    }
}
#end_block

#method_before
@Override
public ServerPlugin get(File srcFile, PluginUser pluginUser, FileSnapshot snapshot, String pluginCanonicalWebUrl, File pluginDataDir) throws InvalidPluginException {
    try {
        File tmp;
        String name = getPluginName(srcFile);
        FileInputStream in = new FileInputStream(srcFile);
        String extension = getExtension(srcFile);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
            return loadJarPlugin(name, srcFile, snapshot, tmp, pluginCanonicalWebUrl, pluginUser, pluginDataDir);
        } finally {
            in.close();
        }
    } catch (IOException | ClassNotFoundException e) {
        throw new InvalidPluginException("Cannot load Jar plugin " + srcFile, e);
    }
}
#method_after
@Override
public ServerPlugin get(File srcFile, FileSnapshot snapshot, PluginDescription description) throws InvalidPluginException {
    try {
        String name = getPluginName(srcFile);
        String extension = getExtension(srcFile);
        try (FileInputStream in = new FileInputStream(srcFile)) {
            File tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
            return loadJarPlugin(name, srcFile, snapshot, tmp, description);
        }
    } catch (IOException | ClassNotFoundException e) {
        throw new InvalidPluginException("Cannot load Jar plugin " + srcFile, e);
    }
}
#end_block

#method_before
private ServerPlugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp, String pluginCanonicalWebUrl, PluginUser pluginUser, File pluginDataDir) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), PluginLoader.parentFor(type));
        ServerPlugin plugin = new ServerPlugin(name, pluginCanonicalWebUrl, pluginUser, srcJar, snapshot, new JarScanner(srcJar), pluginDataDir, pluginLoader);
        plugin.setCleanupHandle(new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private ServerPlugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp, PluginDescription description) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), PluginLoader.parentFor(type));
        ServerPlugin plugin = new ServerPlugin(name, description.canonicalUrl, description.user, srcJar, snapshot, new JarScanner(srcJar), description.dataDir, pluginLoader);
        plugin.setCleanupHandle(new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Injector getPluginInjector(File jarFile) throws IOException {
    final String pluginName = Objects.firstNonNull(JarPluginProvider.getGerritJarPluginName(jarFile), PluginLoader.nameOf(jarFile));
    return initInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
        }
    });
}
#method_after
private Injector getPluginInjector(final File jarFile) throws IOException {
    final String pluginName = Objects.firstNonNull(JarPluginProvider.getJarPluginName(jarFile), PluginLoader.nameOf(jarFile));
    return initInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
        }
    });
}
#end_block

#method_before
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    change.revision(revision);
    setWebLinks(change, revision, revInfo);
}
#method_after
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(change, revision, revInfo);
}
#end_block

#method_before
private void setWebLinks(ChangeInfo change, String revision, RevisionInfo revInfo) {
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        addWebLink(gw.toRevision(change.project(), revision), gw.getLinkName());
    }
    JsArray<WebLinkInfo> links = revInfo.web_links();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            addWebLink(link.linkUrl(), link.linkName());
        }
    }
}
#method_after
private void setWebLinks(ChangeInfo change, String revision, RevisionInfo revInfo) {
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        addWebLink(gw.toRevision(change.project(), revision), gw.getLinkName());
    }
    JsArray<WebLinkInfo> links = revInfo.web_links();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            addWebLink(link.link_url(), link.link_name());
        }
    }
}
#end_block

#method_before
private Map<String, LabelInfo> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(changes.parse(control(cd)), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = db.get().patchComments().draftByPatchSetAuthor(in.getId(), user.getAccountId()).iterator().hasNext() ? true : null;
    }
    out.webLinks = Lists.newArrayList();
    for (WebLinks.Link link : webLinkFactory.create().getPatchSetLinks(project, in.getRevision().get())) {
        out.webLinks.add(new RevisionInfo.WebLinkInfo(link.name, link.url));
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(changes.parse(control(cd)), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = db.get().patchComments().draftByPatchSetAuthor(in.getId(), user.getAccountId()).iterator().hasNext() ? true : null;
    }
    if (has(WEB_LINKS)) {
        out.webLinks = Lists.newArrayList();
        for (WebLinks.Link link : webLinks.get().getPatchSetLinks(project, in.getRevision().get())) {
            out.webLinks.add(new RevisionInfo.WebLinkInfo(link.name, link.url));
        }
    }
    return out;
}
#end_block

#method_before
public Iterable<Link> getPatchSetLinks(final String project, final String commit) {
    ArrayList<Link> links = new ArrayList<Link>();
    for (PatchSetWebLink webLink : patchSetLinks) {
        links.add(new Link(webLink.getLinkName(), webLink.getPatchSetUrl(project, commit)));
    }
    return links;
}
#method_after
public Iterable<Link> getPatchSetLinks(final String project, final String commit) {
    List<Link> links = Lists.newArrayList();
    for (PatchSetWebLink webLink : patchSetLinks) {
        links.add(new Link(webLink.getLinkName(), webLink.getPatchSetUrl(project, commit)));
    }
    return links;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(WebLinks.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
public void setPatchSetId(PatchSet.Id psId) {
    checkArgument(psId == null || psId.getParentKey().equals(getChange().getKey()));
    this.psId = psId;
}
#method_after
public void setPatchSetId(PatchSet.Id psId) {
    checkArgument(psId == null || psId.getParentKey().equals(getChange().getId()));
    this.psId = psId;
}
#end_block

#method_before
public void putComment(PatchLineComment comment) {
    commentsToAdd.add(comment);
}
#method_after
public void putComment(PatchLineComment comment) {
    checkArgument(psId != null, "setPatchSetId must be called before putComment");
    checkArgument(getCommentPsId(comment).equals(psId), "Comment on %s doesn't match previous patch set %s", getCommentPsId(comment), psId);
    checkArgument(comment.getRevId() != null);
    if (comment.getSide() == 0) {
        commentsForBase.add(comment);
    } else {
        commentsForPs.add(comment);
    }
}
#end_block

#method_before
private void storeCommentsInNotes(RevCommit c) throws OrmException, IOException {
    if (commentsToAdd.isEmpty()) {
        return;
    }
    // assume you can only add comments to one patchset at a time
    PatchSet.Id psId = commentsToAdd.get(0).getKey().getParentKey().getParentKey();
    ChangeNotes notes = ctl.getNotes();
    LinkedListMultimap<PatchSet.Id, PatchLineComment> allComments = LinkedListMultimap.create(notes.getPublishedComments());
    List<PatchLineComment> commentsOnSamePs = allComments.get(psId);
    // add all comments and re-sort list
    commentsOnSamePs.addAll(commentsToAdd);
    commentsOnSamePs = ChangeNotes.COMMENT_ORDERING.sortedCopy(commentsOnSamePs);
    String noteContents = PatchLineCommentsUtil.buildNote(accountCache, commentsOnSamePs);
    AnyObjectId oId = c.getId();
    NoteMap noteMap = notes.getNoteMap();
    noteMap.set(oId, noteContents, this.inserter);
    this.inserter.flush();
}
#method_after
private ObjectId storeCommentsInNotes() throws OrmException, IOException {
    ChangeNotes notes = ctl.getNotes();
    NoteMap noteMap = notes.getNoteMap();
    if (noteMap == null) {
        noteMap = NoteMap.newEmptyMap();
    }
    if (commentsForPs.isEmpty() && commentsForBase.isEmpty()) {
        return null;
    }
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnBases = notes.getBaseComments();
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnPs = notes.getPatchSetComments();
    // This writes all comments for the base of this PS to the note map.
    if (!commentsForBase.isEmpty()) {
        writeCommentsToNoteMap(noteMap, allCommentsOnBases, commentsForBase);
    }
    // This write all comments for this PS to the note map.
    if (!commentsForPs.isEmpty()) {
        writeCommentsToNoteMap(noteMap, allCommentsOnPs, commentsForPs);
    }
    return noteMap.writeTree(inserter);
}
#end_block

#method_before
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        batch.write(new CommitBuilder());
        RevCommit c = batch.commit();
        storeCommentsInNotes(c);
        return c;
    } catch (OrmException e) {
        // TODO(yyonas): what to do with this exception?
        return null;
    } finally {
        batch.close();
    }
}
#method_after
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        CommitBuilder builder = new CommitBuilder();
        if (migration.write()) {
            ObjectId treeId = storeCommentsInNotes();
            if (treeId != null) {
                builder.setTreeId(treeId);
            }
        }
        batch.write(builder);
        RevCommit c = batch.commit();
        return c;
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        batch.close();
    }
}
#end_block

#method_before
private boolean isEmpty() {
    return approvals.isEmpty() && reviewers.isEmpty() && status == null && submitRecords == null && changeMessage == null;
}
#method_after
private boolean isEmpty() {
    return approvals.isEmpty() && reviewers.isEmpty() && commentsForBase.isEmpty() && commentsForPs.isEmpty() && status == null && submitRecords == null && changeMessage == null;
}
#end_block

#method_before
private void parseComments(RevCommit commit) throws IOException, ConfigInvalidException, ParseException {
    Ref sharedMeta = repo.getRef(ChangeNoteUtil.changeRefName(changeId));
    if (sharedMeta != null) {
        RevCommit sharedBaseCommit = walk.parseCommit(sharedMeta.getObjectId());
        publishedCommentNoteMap = NoteMap.read(walk.getObjectReader(), sharedBaseCommit);
    }
    Iterator<Note> notes = publishedCommentNoteMap.iterator();
    while (notes.hasNext()) {
        Note next = notes.next();
        byte[] bytes = walk.getObjectReader().open(next.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = parseNote(bytes);
        if (result == null) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        publishedComments.putAll(psId, result);
    }
}
#method_after
private void parseComments(RevCommit commit) throws IOException, ConfigInvalidException, ParseException {
    Ref sharedMeta = repo.getRef(ChangeNoteUtil.changeRefName(changeId));
    if (sharedMeta != null) {
        RevCommit sharedBaseCommit = walk.parseCommit(sharedMeta.getObjectId());
        commentNoteMap = NoteMap.read(walk.getObjectReader(), sharedBaseCommit);
    }
    Iterator<Note> notes = commentNoteMap.iterator();
    while (notes.hasNext()) {
        Note next = notes.next();
        byte[] bytes = walk.getObjectReader().open(next.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = CommentsInNotesUtil.parseNote(bytes, changeId);
        if ((result == null) || (result.isEmpty())) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        short side = result.get(0).getSide();
        if (side == 0) {
            commentsForBase.putAll(psId, result);
        } else {
            commentsForPs.putAll(psId, result);
        }
    }
}
#end_block

#method_before
private ConfigInvalidException parseException(String fmt, Object... args) {
    return new ConfigInvalidException("Change " + changeId + ": " + String.format(fmt, args));
}
#method_after
private ConfigInvalidException parseException(String fmt, Object... args) {
    return ChangeNotes.parseException(changeId, fmt, args);
}
#end_block

#method_before
public NoteMap getNoteMap() {
    return noteMap;
}
#method_after
NoteMap getNoteMap() {
    return noteMap;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        publishedComments = ImmutableListMultimap.copyOf(parser.publishedComments);
        noteMap = parser.publishedCommentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
    // TODO(yyonas): figure out how to handle this exception
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        commentsForBase = ImmutableListMultimap.copyOf(parser.commentsForBase);
        commentsForPS = ImmutableListMultimap.copyOf(parser.commentsForPs);
        noteMap = parser.commentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
        // TODO(yyonas): figure out how to handle this exception
        throw new IOException(e1);
    } finally {
        walk.release();
    }
}
#end_block

#method_before
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableListMultimap.of();
    publishedComments = ImmutableListMultimap.of();
}
#method_after
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableListMultimap.of();
    commentsForBase = ImmutableListMultimap.of();
    commentsForPS = ImmutableListMultimap.of();
}
#end_block

#method_before
public String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile)).toLowerCase();
}
#method_after
public String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile));
}
#end_block

#method_before
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        ArrayList<Plugin> plugins = new ArrayList<Plugin>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#method_after
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        List<Plugin> plugins = new ArrayList<>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#end_block

#method_before
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#method_after
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    env.onStopPlugin(plugin);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#end_block

#method_before
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : activePlugins.entrySet()) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJarPlugin(fileName) && !isJsPlugin(fileName) && !externalPluginFactory.handles(file)) {
            log.warn("Skipping non-plugin file " + fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : activePlugins.entrySet()) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJarPlugin(fileName) && !isJsPlugin(fileName) && !externalPluginFactory.handles(file)) {
            log.warn("File is not a JAR nor JS plugin and " + "no Plugin provider was found that handles it: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        name = newPlugin.getName();
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        // Pluggable plugin provider may have assigned
        name = newPlugin.getName();
        // a plugin name that could be actually
        // different from the initial
        // one assigned during scan. It is safer then
        // to reassign it.
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        File tmp;
        FileInputStream in = new FileInputStream(srcPlugin);
        String extension = getExtension(srcPlugin);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
        } finally {
            in.close();
        }
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (externalPluginFactory.handles(srcPlugin)) {
        name = externalPluginFactory.getPluginName(srcPlugin);
        return loadExternalPlugin(name, srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#method_after
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        File tmp;
        FileInputStream in = new FileInputStream(srcPlugin);
        String extension = getExtension(srcPlugin);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
        } finally {
            in.close();
        }
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (externalPluginFactory.handles(srcPlugin)) {
        return loadExternalPlugin(srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#end_block

#method_before
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new ServerPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, new JarScanner(srcJar), manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        Plugin plugin = new ServerPlugin(name, getPluginCanonicalWebUrl(name), pluginUserFactory.create(name), srcJar, snapshot, new JarScanner(srcJar), getPluginDataDir(name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private ServerPlugin loadExternalPlugin(String name, File scriptFile, FileSnapshot snapshot) {
    return externalPluginFactory.get(name, scriptFile, pluginUserFactory.create(name), snapshot);
}
#method_after
private ServerPlugin loadExternalPlugin(File scriptFile, FileSnapshot snapshot) throws InvalidPluginException {
    String name = externalPluginFactory.getPluginName(scriptFile);
    return externalPluginFactory.get(scriptFile, snapshot, new PluginDescription(pluginUserFactory.create(name), getPluginCanonicalWebUrl(name), getPluginDataDir(name)));
}
#end_block

#method_before
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name. Values are
// the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#method_after
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name initially assigned from its filename.
// Values are the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
// name are disabled.
// 
// NOTE: Bear in mind that the plugin name can be reassigned after load by the
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#end_block

#method_before
public static String getGerritJarPluginName(File srcFile) throws IOException {
    JarFile jarFile = new JarFile(srcFile);
    try {
        return jarFile.getManifest().getMainAttributes().getValue("Gerrit-PluginName");
    } finally {
        jarFile.close();
    }
}
#method_after
public static String getGerritJarPluginName(File srcFile) throws IOException {
    try (JarFile jarFile = new JarFile(srcFile)) {
        return jarFile.getManifest().getMainAttributes().getValue("Gerrit-PluginName");
    }
}
#end_block

#method_before
public Collection<InitStep> getInitSteps() {
    List<File> jars = scanJarsInPluginsDirectory();
    ArrayList<InitStep> pluginsInitSteps = new ArrayList<InitStep>();
    for (File jar : jars) {
        InitStep init = loadInitStep(jar);
        if (init != null) {
            pluginsInitSteps.add(init);
        }
    }
    return pluginsInitSteps;
}
#method_after
public Collection<InitStep> getInitSteps() {
    List<File> jars = scanJarsInPluginsDirectory();
    ArrayList<InitStep> pluginsInitSteps = new ArrayList<>();
    for (File jar : jars) {
        InitStep init = loadInitStep(jar);
        if (init != null) {
            pluginsInitSteps.add(init);
        }
    }
    return pluginsInitSteps;
}
#end_block

#method_before
private Manifest getPluginManifest(PluginScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#method_after
private Manifest getPluginManifest(PluginContentScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#end_block

#method_before
@Override
public ServerPlugin get(String name, File srcFile, PluginUser pluginUser, FileSnapshot snapshot) {
    return providerOf(srcFile).get(name, srcFile, pluginUser, snapshot);
}
#method_after
@Override
public ServerPlugin get(File srcFile, FileSnapshot snapshot, PluginDescription pluginDescription) throws InvalidPluginException {
    return providerOf(srcFile).get(srcFile, snapshot, pluginDescription);
}
#end_block

#method_before
@Override
public boolean handles(File srcFile) {
    for (ServerPluginProvider scriptingFactory : serverPluginProviders) {
        if (scriptingFactory.handles(srcFile)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean handles(File srcFile) {
    List<ServerPluginProvider> providers = providersForHandlingPlugin(srcFile);
    switch(providers.size()) {
        case 1:
            return true;
        case 0:
            return false;
        default:
            throw new MultipleProvidersForPluginException(srcFile, providers);
    }
}
#end_block

#method_before
private ServerPluginProvider providerOf(File srcFile) {
    for (ServerPluginProvider provider : serverPluginProviders) {
        if (provider.handles(srcFile)) {
            return provider;
        }
    }
    throw new IllegalArgumentException(srcFile.getAbsolutePath() + " is not a supported Gerrit plugin format");
}
#method_after
private ServerPluginProvider providerOf(File srcFile) {
    List<ServerPluginProvider> providers = providersForHandlingPlugin(srcFile);
    switch(providers.size()) {
        case 1:
            return providers.get(0);
        case 0:
            throw new IllegalArgumentException("No ServerPluginProvider found/loaded to handle plugin file " + srcFile.getAbsolutePath());
        default:
            throw new MultipleProvidersForPluginException(srcFile, providers);
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPreUploadHook(uploadValidatorsFactory.create(project, repo));
    try {
        up.upload(in, out, err);
    } catch (UploadValidationException e) {
    // UploadValidationException is used by the UploadValidationListener to
    // stop the uploadPack. We do not want this exception to go beyond this
    // point otherwise it would print a stacktrace in the logs and return an
    // internal server error to the client.
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    List<PreUploadHook> allPreUploadHooks = Lists.newArrayList(preUploadHooks);
    allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString()));
    up.setPreUploadHook(PreUploadHookChain.newChain(allPreUploadHooks));
    try {
        up.upload(in, out, err);
    } catch (UploadValidationException e) {
        // internal server error to the client.
        if (!e.isOutput()) {
            up.sendMessage(e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
public UploadPack create(HttpServletRequest req, Repository repo) {
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    return up;
}
#method_after
@Override
public UploadPack create(HttpServletRequest req, Repository repo) {
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(preUploadHooks)));
    return up;
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    if (!pc.canRunUploadPack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    }
    up.setPreUploadHook(uploadValidatorsFactory.create(pc.getProject(), repo));
    if (!pc.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, pc, db.get(), true));
    }
    next.doFilter(request, response);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    if (!pc.canRunUploadPack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    }
    // We use getRemoteHost() here instead of getRemoteAddr() because REMOTE_ADDR
    // may have been overridden by a proxy server -- we'll try to avoid this.
    UploadValidators uploadValidators = uploadValidatorsFactory.create(pc.getProject(), repo, request.getRemoteHost());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(up.getPreUploadHook(), uploadValidators)));
    if (!pc.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, pc, db.get(), true));
    }
    next.doFilter(request, response);
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    rp.getAdvertiseRefsHook().advertiseRefs(rp);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser().isIdentifiedUser())) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        cache.invalidate(cacheKey);
    } else {
        Set<ObjectId> ids = cache.getIfPresent(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.invalidate(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<ObjectId>(rp.getAdvertisedObjects())));
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    rp.getAdvertiseRefsHook().advertiseRefs(rp);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser().isIdentifiedUser())) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        cache.invalidate(cacheKey);
    } else {
        Set<ObjectId> ids = cache.getIfPresent(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.invalidate(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<>(rp.getAdvertisedObjects())));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public void onSendPack(UploadPack up, Collection<? extends ObjectId> wants, Collection<? extends ObjectId> haves) throws ServiceMayNotContinueException {
    for (UploadValidationListener validator : uploadValidationListeners) {
        validator.onPreUpload(repository, project, wants, haves);
    }
}
#method_after
@Override
public void onSendPack(UploadPack up, Collection<? extends ObjectId> wants, Collection<? extends ObjectId> haves) throws ServiceMayNotContinueException {
    for (UploadValidationListener validator : uploadValidationListeners) {
        try {
            validator.onPreUpload(repository, project, remoteHost, up, wants, haves);
        } catch (ValidationException e) {
            throw new UploadValidationException(e.getMessage());
        }
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    org.h2.Driver.load();
    db = DriverManager.getConnection("jdbc:h2:mem:DialectH2Test");
    executor = new JdbcExecutor(db);
    dialect = new DialectH2().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.h2.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
}
#method_after
@Before
public void setUp() throws Exception {
    org.h2.Driver.load();
    db = DriverManager.getConnection("jdbc:h2:mem:DialectH2Test");
    executor = new JdbcExecutor(db);
    dialect = new DialectH2().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.h2.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
public void tearDown() {
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    try {
        Class.forName(ORACLE_DRIVER);
    } catch (Exception e) {
        assumeNoException(e);
    }
    // Oracle instance name
    final String sid = "xe";
    // Oracle schema=user name=database
    final String user = "gwtorm";
    final String pass = "gwtorm";
    db = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:" + sid, user, pass);
    executor = new JdbcExecutor(db);
    dialect = new DialectOracle().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", ORACLE_DRIVER);
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
}
#method_after
@Before
public void setUp() throws Exception {
    try {
        Class.forName(ORACLE_DRIVER);
    } catch (Exception e) {
        assumeNoException(e);
    }
    // Oracle instance name
    final String sid = "xe";
    // Oracle schema=user name=database
    final String user = "gwtorm";
    final String pass = "gwtorm";
    db = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:" + sid, user, pass);
    executor = new JdbcExecutor(db);
    dialect = new DialectOracle().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", ORACLE_DRIVER);
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
public void tearDown() {
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Class.forName(org.postgresql.Driver.class.getName());
    final String database = "gwtorm";
    final String user = "gwtorm";
    final String pass = "gwtorm";
    try {
        db = DriverManager.getConnection("jdbc:postgresql:" + database, user, pass);
    } catch (Throwable t) {
        assumeNoException(t);
    }
    executor = new JdbcExecutor(db);
    dialect = new DialectPostgreSQL().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.postgresql.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
}
#method_after
@Before
public void setUp() throws Exception {
    Class.forName(org.postgresql.Driver.class.getName());
    final String database = "gwtorm";
    final String user = "gwtorm";
    final String pass = "gwtorm";
    try {
        db = DriverManager.getConnection("jdbc:postgresql:" + database, user, pass);
    } catch (Throwable t) {
        assumeNoException(t);
    }
    executor = new JdbcExecutor(db);
    dialect = new DialectPostgreSQL().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.postgresql.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
public void tearDown() {
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    try {
        RestModifyView<FileResource, Reviewed.Input> view;
        if (reviewed) {
            view = putReviewed;
        } else {
            view = deleteReviewed;
        }
        view.apply(files.parse(revision, IdString.fromDecoded(path)), new Reviewed.Input());
    } catch (Exception e) {
        throw new RestApiException("Cannot update reviewed flag", e);
    }
}
#method_after
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    try {
        RestModifyView<FileResource, Reviewed.Input> view;
        if (reviewed) {
            view = putReviewed;
        } else {
            view = deleteReviewed;
        }
        view.apply(files.get().parse(revision, IdString.fromDecoded(path)), new Reviewed.Input());
    } catch (Exception e) {
        throw new RestApiException("Cannot update reviewed flag", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Set<String> reviewed() throws RestApiException {
    try {
        return ImmutableSet.copyOf((Iterable<String>) listFiles.setReviewed(true).apply(revision).value());
    } catch (OrmException e) {
        throw new RestApiException("Cannot list reviewed files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Set<String> reviewed() throws RestApiException {
    try {
        return ImmutableSet.copyOf((Iterable<String>) listFiles.get().setReviewed(true).apply(revision).value());
    } catch (OrmException e) {
        throw new RestApiException("Cannot list reviewed files", e);
    }
}
#end_block

#method_before
private void sendAutoIndex(PluginContentScanner scanner, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<PluginEntry> cmds = Lists.newArrayList();
    List<PluginEntry> servlets = Lists.newArrayList();
    List<PluginEntry> restApis = Lists.newArrayList();
    List<PluginEntry> docs = Lists.newArrayList();
    PluginEntry about = null;
    Enumeration<PluginEntry> entries = scanner.entries();
    while (entries.hasMoreElements()) {
        PluginEntry entry = entries.nextElement();
        String name = entry.getName();
        Optional<Long> size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && size.isPresent() && 0 < size.get() && size.get() <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<PluginEntry>() {

        @Override
        public int compare(PluginEntry a, PluginEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<PluginEntry>() {

        @Override
        public int compare(PluginEntry a, PluginEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, scanner.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(scanner.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(scanner, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(scanner, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(scanner, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(scanner, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#method_after
private void sendAutoIndex(PluginContentScanner scanner, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<PluginEntry> cmds = Lists.newArrayList();
    List<PluginEntry> servlets = Lists.newArrayList();
    List<PluginEntry> restApis = Lists.newArrayList();
    List<PluginEntry> docs = Lists.newArrayList();
    PluginEntry about = null;
    Enumeration<PluginEntry> entries = scanner.entries();
    while (entries.hasMoreElements()) {
        PluginEntry entry = entries.nextElement();
        String name = entry.getName();
        Optional<Long> size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && size.isPresent() && 0 < size.get() && size.get() <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, PluginEntry.COMPARATOR_BY_NAME);
    Collections.sort(docs, PluginEntry.COMPARATOR_BY_NAME);
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, scanner.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(scanner.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(scanner, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(scanner, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(scanner, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(scanner, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#end_block

#method_before
private void sendMarkdownAsHtml(String md, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws UnsupportedEncodingException, IOException {
    Map<String, String> macros = Maps.newHashMap();
    macros.put("PLUGIN", pluginName);
    macros.put("SSH_HOST", sshHost);
    macros.put("SSH_PORT", "" + sshPort);
    String url = webUrl.get();
    if (Strings.isNullOrEmpty(url)) {
        url = "http://review.example.com/";
    }
    macros.put("URL", url);
    Matcher m = Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(md);
    StringBuffer sb = new StringBuffer();
    while (m.find()) {
        String key = m.group(2);
        String val = macros.get(key);
        if (m.group(1) != null) {
            m.appendReplacement(sb, "@" + key + "@");
        } else if (val != null) {
            m.appendReplacement(sb, val);
        } else {
            m.appendReplacement(sb, "@" + key + "@");
        }
    }
    m.appendTail(sb);
    byte[] html = new MarkdownFormatter().markdownToDocHtml(sb.toString(), "UTF-8");
    resourceCache.put(cacheKey, new SmallResource(html).setContentType("text/html").setCharacterEncoding("UTF-8").setLastModified(lastModifiedTime));
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(html.length);
    res.getOutputStream().write(html);
}
#method_after
private void sendMarkdownAsHtml(String md, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws UnsupportedEncodingException, IOException {
    Map<String, String> macros = Maps.newHashMap();
    macros.put("PLUGIN", pluginName);
    macros.put("SSH_HOST", sshHost);
    macros.put("SSH_PORT", "" + sshPort);
    String url = webUrl.get();
    if (Strings.isNullOrEmpty(url)) {
        url = "http://review.example.com/";
    }
    macros.put("URL", url);
    Matcher m = Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(md);
    StringBuffer sb = new StringBuffer();
    while (m.find()) {
        String key = m.group(2);
        String val = macros.get(key);
        if (m.group(1) != null) {
            m.appendReplacement(sb, "@" + key + "@");
        } else if (val != null) {
            m.appendReplacement(sb, val);
        } else {
            m.appendReplacement(sb, "@" + key + "@");
        }
    }
    m.appendTail(sb);
    byte[] html = new MarkdownFormatter().markdownToDocHtml(sb.toString(), "UTF-8");
    resourceCache.put(cacheKey, new SmallResource(html).setContentType("text/html").setCharacterEncoding("UTF-8").setLastModified(lastModifiedTime));
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(html.length);
    res.setDateHeader("Last-Modified", lastModifiedTime);
    res.getOutputStream().write(html);
}
#end_block

#method_before
@Override
public synchronized void schedule(final Branch.NameKey branch) {
    MergeEntry e = active.get(branch);
    if (e == null) {
        e = new MergeEntry(branch);
        active.put(branch, e);
        e.needMerge = true;
        scheduleJob(e);
    }
}
#method_after
@Override
public synchronized void schedule(final Branch.NameKey branch) {
    MergeEntry e = active.get(branch);
    if (e == null) {
        e = new MergeEntry(branch);
        active.put(branch, e);
        e.needMerge = true;
        scheduleJob(e);
    } else {
        e.needMerge = true;
    }
}
#end_block

#method_before
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (messageIsForChange()) {
        update.commit();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    if (!messageIsForChange()) {
        if (changeMessage != null) {
            Change otherChange = db.changes().get(changeMessage.getPatchSetId().getParentKey());
            ChangeControl otherControl = refControl.getProjectControl().controlFor(otherChange);
            ChangeUpdate updateForOtherChange = updateFactory.create(otherControl, change.getLastUpdatedOn());
            cmUtil.addChangeMessage(db, updateForOtherChange, changeMessage);
            updateForOtherChange.commit();
        }
    }
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    return change;
}
#method_after
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (messageIsForChange()) {
        update.commit();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    return change;
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO atomic update was not propagated
        update = updateFactory.create(control);
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    ChangeInfo result = json.format(change);
    f.checkedGet();
    return result;
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO(yyonas): atomic update was not propagated
        update = updateFactory.create(control);
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    ChangeInfo result = json.format(change);
    f.checkedGet();
    return result;
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException, NoSuchChangeException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(ctl, patchSet.getCreatedOn());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet);
        }
        db.commit();
        if (messageIsForChange()) {
            update.commit();
        }
        if (!messageIsForChange()) {
            if (changeMessage != null) {
                Change otherChange = db.changes().get(changeMessage.getPatchSetId().getParentKey());
                ChangeControl otherControl = ctlFactory.controlFor(otherChange, user);
                ChangeUpdate updateForOtherChange = updateFactory.create(otherControl, updatedChange.getLastUpdatedOn());
                cmUtil.addChangeMessage(db, updateForOtherChange, changeMessage);
                updateForOtherChange.commit();
            }
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(updatedChange).reindex().runAsync();
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException, NoSuchChangeException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(ctl, patchSet.getCreatedOn());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet);
        }
        db.commit();
        if (messageIsForChange()) {
            update.commit();
        }
        if (!messageIsForChange()) {
            commitMessageNotForChange(updatedChange);
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(updatedChange).reindex().runAsync();
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO atomic update was not propagated
        update = updateFactory.create(control, change.getLastUpdatedOn());
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO(yyonas): atomic update was not propagated
        update = updateFactory.create(control, change.getLastUpdatedOn());
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#end_block

#method_before
public static List<ChangeMessage> sortChangeMessages(Iterable<ChangeMessage> changeMessage) {
    return ChangeNotes.MESSAGE_BY_TIME.sortedCopy(changeMessage);
}
#method_after
private static List<ChangeMessage> sortChangeMessages(Iterable<ChangeMessage> changeMessage) {
    return ChangeNotes.MESSAGE_BY_TIME.sortedCopy(changeMessage);
}
#end_block

#method_before
public List<ChangeMessage> byChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    List<ChangeMessage> changeMessages;
    if (!migration.readChangeMessages()) {
        ImmutableListMultimap.Builder<PatchSet.Id, ChangeMessage> result = ImmutableListMultimap.builder();
        for (ChangeMessage cm : db.changeMessages().byChange(notes.getChangeId())) {
            result.put(cm.getPatchSetId(), cm);
        }
        changeMessages = sortChangeMessages(result.build().values());
    } else {
        changeMessages = sortChangeMessages(notes.load().getChangeMessages().values());
    }
    return changeMessages;
}
#method_after
public List<ChangeMessage> byChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChangeMessages()) {
        return sortChangeMessages(db.changeMessages().byChange(notes.getChangeId()));
    } else {
        return sortChangeMessages(notes.load().getChangeMessages().values());
    }
}
#end_block

#method_before
public ChangeMessage getConflictMessage(RevisionResource rsrc) throws OrmException {
    List<ChangeMessage> cms = cmUtil.byPatchSet(dbProvider.get(), rsrc.getNotes(), rsrc.getPatchSet().getId());
    return Iterables.getFirst(Iterables.filter(Lists.reverse(cms), new Predicate<ChangeMessage>() {

        @Override
        public boolean apply(ChangeMessage input) {
            return input.getAuthor() == null;
        }
    }), null);
}
#method_after
public ChangeMessage getConflictMessage(RevisionResource rsrc) throws OrmException {
    return FluentIterable.from(cmUtil.byPatchSet(dbProvider.get(), rsrc.getNotes(), rsrc.getPatchSet().getId())).filter(new Predicate<ChangeMessage>() {

        @Override
        public boolean apply(ChangeMessage input) {
            return input.getAuthor() == null;
        }
    }).last().orNull();
}
#end_block

#method_before
private boolean isChangeReviewed(Account.Id self, ChangeData cd, List<ChangeMessage> msgs) throws OrmException {
    // Sort messages to keep the most recent ones at the beginning.
    Collections.sort(msgs, new Comparator<ChangeMessage>() {

        @Override
        public int compare(ChangeMessage a, ChangeMessage b) {
            return b.getWrittenOn().compareTo(a.getWrittenOn());
        }
    });
    Account.Id changeOwnerId = cd.change().getOwner();
    for (ChangeMessage cm : msgs) {
        if (self.equals(cm.getAuthor())) {
            return true;
        } else if (changeOwnerId.equals(cm.getAuthor())) {
            return false;
        }
    }
    return false;
}
#method_after
private boolean isChangeReviewed(Account.Id self, ChangeData cd, List<ChangeMessage> msgs) throws OrmException {
    // Sort messages to keep the most recent ones at the beginning.
    msgs = ChangeNotes.MESSAGE_BY_TIME.sortedCopy(msgs);
    Account.Id changeOwnerId = cd.change().getOwner();
    for (ChangeMessage cm : msgs) {
        if (self.equals(cm.getAuthor())) {
            return true;
        } else if (changeOwnerId.equals(cm.getAuthor())) {
            return false;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to " + newTopicName;
        } else if (newTopicName.isEmpty()) {
            summary = "Topic " + oldTopicName + " removed";
        } else {
            summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), change.currentPatchSetId());
        cmsg.setMessage(summary);
        ChangeUpdate update;
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            // TODO atomic update was not propagated
            update = updateFactory.create(control);
            cmUtil.addChangeMessage(db, update, cmsg);
            db.commit();
        } finally {
            db.rollback();
        }
        update.commit();
        CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
        indexFuture.checkedGet();
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.<String>none() : Response.ok(newTopicName);
}
#method_after
@Override
public Response<String> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to " + newTopicName;
        } else if (newTopicName.isEmpty()) {
            summary = "Topic " + oldTopicName + " removed";
        } else {
            summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), change.currentPatchSetId());
        cmsg.setMessage(summary);
        ChangeUpdate update;
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            // TODO(yyonas): atomic update was not propagated
            update = updateFactory.create(control);
            cmUtil.addChangeMessage(db, update, cmsg);
            db.commit();
        } finally {
            db.rollback();
        }
        update.commit();
        CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
        indexFuture.checkedGet();
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.<String>none() : Response.ok(newTopicName);
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException, NoSuchChangeException {
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged);
        ChangeControl control = changeControlFactory.controlFor(c, identifiedUserFactory.create(submitter.getAccountId()));
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // I didn't see how this function was going to do anything different
        // if I did what was below or put it in the function and kept the lines in
        // there...I commented out the method below because ATM, it's not used.
        // addMergedMessage(submitter, msg);
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
    update.commit();
}
#method_after
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException, NoSuchChangeException {
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged);
        ChangeControl control = commit.getControl();
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // TODO(yyonas): we need to be able to change the author of the message
        // is not the person for whom the change was made. addMergedMessage
        // did this in the past.
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
    update.commit();
}
#end_block

#method_before
// private void addMergedMessage(PatchSetApproval submitter, ChangeMessage msg)
// throws OrmException {
// if (msg != null) {
// if (submitter != null && msg.getAuthor() == null) {
// msg.setAuthor(submitter.getAccountId());
// }
// db.changeMessages().insert(Collections.singleton(msg));
// }
// }
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(changeControl(c));
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(changeControl(c));
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void sendMergeFail(ChangeNotes notes, final ChangeMessage msg, boolean makeNew) throws NoSuchChangeException, IOException {
    PatchSetApproval submitter = null;
    try {
        submitter = approvalsUtil.getSubmitter(db, notes, notes.getChange().currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg, notes);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    final Change c = notes.getChange();
    Change change = null;
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            ChangeControl control = changeControl(change);
            // TODO: atomic change is not propagated.
            update = updateFactory.create(control, c.getLastUpdatedOn());
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (update != null) {
        update.commit();
    }
    CheckedFuture<?, IOException> indexFuture;
    if (change != null) {
        indexFuture = indexer.indexAsync(change.getId());
    } else {
        indexFuture = null;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
    if (indexFuture != null) {
        try {
            indexFuture.checkedGet();
        } catch (IOException e) {
            log.error("Failed to index new change message", e);
        }
    }
}
#method_after
private void sendMergeFail(ChangeNotes notes, final ChangeMessage msg, boolean makeNew) throws NoSuchChangeException, IOException {
    PatchSetApproval submitter = null;
    try {
        submitter = approvalsUtil.getSubmitter(db, notes, notes.getChange().currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg, notes);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    final Change c = notes.getChange();
    Change change = null;
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            ChangeControl control = changeControl(change);
            // TODO(yyonas): atomic change is not propagated.
            update = updateFactory.create(control, c.getLastUpdatedOn());
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (update != null) {
        update.commit();
    }
    CheckedFuture<?, IOException> indexFuture;
    if (change != null) {
        indexFuture = indexer.indexAsync(change.getId());
    } else {
        indexFuture = null;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
    if (indexFuture != null) {
        try {
            indexFuture.checkedGet();
        } catch (IOException e) {
            log.error("Failed to index new change message", e);
        }
    }
}
#end_block

#method_before
private void abandonOneChange(Change change) throws OrmException, NoSuchChangeException, IOException {
    db.changes().beginTransaction(change.getId());
    ChangeControl control = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner()));
    ChangeUpdate update = updateFactory.create(control, change.getCreatedOn());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    return change;
                }
                return null;
            }
        });
        if (change != null) {
            ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), null, change.getLastUpdatedOn(), change.currentPatchSetId());
            msg.setMessage("Project was deleted.");
            // TODO atomic change is not propagated.
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
            indexer.index(db, change);
        }
    } finally {
        db.rollback();
    }
    update.commit();
}
#method_after
private void abandonOneChange(Change change) throws OrmException, NoSuchChangeException, IOException {
    db.changes().beginTransaction(change.getId());
    // TODO(dborowitz): support InternalUser in ChangeUpdate
    ChangeControl control = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner()));
    ChangeUpdate update = updateFactory.create(control);
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    return change;
                }
                return null;
            }
        });
        if (change != null) {
            ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), null, change.getLastUpdatedOn(), change.currentPatchSetId());
            msg.setMessage("Project was deleted.");
            // TODO(yyonas): atomic change is not propagated.
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
            indexer.index(db, change);
        }
    } finally {
        db.rollback();
    }
    update.commit();
}
#end_block

#method_before
@Override
public void run() {
    try {
        rc.processCommands(commands, progress);
    } catch (NoSuchChangeException e) {
        // TODO(yyonas): Auto-generated catch block
        e.printStackTrace();
    }
}
#method_after
@Override
public void run() {
    rc.processCommands(commands, progress);
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) throws NoSuchChangeException {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c) || isConfig(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c) || isConfig(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c) || isConfig(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            try {
                switch(c.getType()) {
                    case CREATE:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case // otherwise known as a fast-forward
                    UPDATE:
                        tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case UPDATE_NONFASTFORWARD:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case DELETE:
                        break;
                }
                if (isConfig(c)) {
                    projectCache.evict(project);
                    ProjectState ps = projectCache.get(project.getNameKey());
                    // 
                    repoManager.setProjectDescription(// 
                    project.getNameKey(), ps.getProject().getDescription());
                }
                if (!MagicBranch.isMagicBranch(c.getRefName())) {
                    // We only fire gitRefUpdated for direct refs updates.
                    // Events for change refs are fired when they are created.
                    // 
                    gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
                }
            } catch (NoSuchChangeException e) {
                c.setResult(REJECTED_OTHER_REASON, "No such change: " + e.getMessage());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, NoSuchChangeException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        cmUtil.addChangeMessage(db, update, msg);
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        cmUtil.addChangeMessage(db, update, msg);
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException, NoSuchChangeException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result) throws OrmException, IOException, NoSuchChangeException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        ChangeControl control = ctlFactory.controlFor(change, currentUser);
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
public String getAbbreviation() {
    return abbreviation;
}
#method_after
private static String getAbbreviation(String name) {
    StringBuilder abbr = new StringBuilder();
    for (int i = 0; i < name.length(); i++) {
        char c = name.charAt(i);
        if (c >= 'A' && c <= 'Z') {
            abbr.append(c);
        }
    }
    if (abbr.length() == 0) {
        abbr.append(Character.toUpperCase(name.charAt(0)));
    }
    return abbr.toString();
}
#end_block

#method_before
private CodeReviewCommit writeCherryPickCommit(final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final PatchSetApproval submitAudit = args.mergeUtil.getSubmitter(n.change.currentPatchSetId());
    PersonIdent cherryPickCommitterIdent;
    if (submitAudit != null) {
        cherryPickCommitterIdent = args.identifiedUserFactory.create(submitAudit.getAccountId()).newCommitterIdent(submitAudit.getGranted(), args.myIdent.getTimeZone());
    } else {
        cherryPickCommitterIdent = args.myIdent;
    }
    final String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(n);
    final CodeReviewCommit newCommit = (CodeReviewCommit) args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, mergeTip, n, cherryPickCommitterIdent, cherryPickCmtMsg, args.rw);
    if (newCommit == null) {
        return null;
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(args.repo, n.change.currentPatchSetId());
    final PatchSet ps = new PatchSet(id);
    ps.setCreatedOn(TimeUtil.nowTs());
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(newCommit.getId().getName()));
    n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
    final List<PatchSetApproval> approvals = Lists.newArrayList();
    for (PatchSetApproval a : args.mergeUtil.getApprovalsForCommit(n)) {
        approvals.add(new PatchSetApproval(ps.getId(), a));
    }
    args.db.changes().beginTransaction(n.change.getId());
    try {
        insertAncestors(args.db, ps.getId(), newCommit);
        args.db.patchSets().insert(Collections.singleton(ps));
        args.db.changes().update(Collections.singletonList(n.change));
        args.db.patchSetApprovals().insert(approvals);
        args.db.commit();
    } finally {
        args.db.rollback();
    }
    final RefUpdate ru = args.repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(args.rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(n.change.getProject(), ru);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#method_after
private CodeReviewCommit writeCherryPickCommit(final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final PatchSetApproval submitAudit = args.mergeUtil.getSubmitter(n.change.currentPatchSetId());
    PersonIdent cherryPickCommitterIdent;
    if (submitAudit != null) {
        cherryPickCommitterIdent = args.identifiedUserFactory.create(submitAudit.getAccountId()).newCommitterIdent(submitAudit.getGranted(), args.myIdent.getTimeZone());
    } else {
        cherryPickCommitterIdent = args.myIdent;
    }
    final String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(n);
    final CodeReviewCommit newCommit = (CodeReviewCommit) args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, mergeTip, n, cherryPickCommitterIdent, cherryPickCmtMsg, args.rw);
    if (newCommit == null) {
        return null;
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(args.repo, n.change.currentPatchSetId());
    final PatchSet ps = new PatchSet(id);
    ps.setCreatedOn(TimeUtil.nowTs());
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(newCommit.getId().getName()));
    final RefUpdate ru;
    args.db.changes().beginTransaction(n.change.getId());
    try {
        insertAncestors(args.db, ps.getId(), newCommit);
        args.db.patchSets().insert(Collections.singleton(ps));
        n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
        args.db.changes().update(Collections.singletonList(n.change));
        final List<PatchSetApproval> approvals = Lists.newArrayList();
        for (PatchSetApproval a : args.mergeUtil.getApprovalsForCommit(n)) {
            approvals.add(new PatchSetApproval(ps.getId(), a));
        }
        args.db.patchSetApprovals().insert(approvals);
        ru = args.repo.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(newCommit);
        ru.disableRefLog();
        if (ru.update(args.rw) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
        }
        args.db.commit();
    } finally {
        args.db.rollback();
    }
    gitRefUpdated.fire(n.change.getProject(), ru);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#end_block

#method_before
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + PLUGINS_PREFIX;
    authorizedBase = Strings.nullToEmpty(path) + AUTHORIZED_PREFIX;
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#method_after
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    wrapper = new ContextMapper(config.getServletContext().getContextPath());
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#end_block

#method_before
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter filter;
        try {
            filter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, base + name);
            filter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                filter.destroy();
            }
        });
        return filter;
    }
    return null;
}
#method_after
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter filter;
        try {
            filter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, wrapper.getFullPath(name));
            filter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                filter.destroy();
            }
        });
        return filter;
    }
    return null;
}
#end_block

#method_before
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    WrappedRequest wr = new WrappedRequest(req, (isAuthorizedCall(req) ? authorizedBase : base) + name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#method_after
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    HttpServletRequest wr = wrapper.create(req, name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#end_block

#method_before
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    if (uri.length() <= ctx.length()) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = uri.substring(ctx.length() + 1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        if (holder.plugin.getApiType() == ApiType.JS) {
            sendJsPlugin(holder.plugin, key, req, res);
        } else {
            JarFile jar = new JarFile(holder.plugin.getSrcFile());
            try {
                JarEntry entry = jar.getJarEntry(file);
                if (exists(entry)) {
                    sendResource(jar, entry, key, res);
                } else {
                    resourceCache.put(key, Resource.NOT_FOUND);
                    Resource.NOT_FOUND.send(req, res);
                }
            } finally {
                jar.close();
            }
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix) && holder.plugin.getSrcFile().getName().endsWith(".jar")) {
        JarFile jar = new JarFile(holder.plugin.getSrcFile());
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String pathInfo = req.getPathInfo();
    if (pathInfo.length() < 1) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = pathInfo.substring(1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    String uri = req.getRequestURI();
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = jarFileOf(holder.plugin);
        if (jar != null) {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        } else {
            sendJsPlugin(holder.plugin, key, req, res);
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = jarFileOf(holder.plugin);
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res, holder.plugin.getSrcFile().lastModified());
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> servlets = Lists.newArrayList();
    List<JarEntry> restApis = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    JarEntry about = null;
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(jar.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(jar, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(jar, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(jar, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(jar, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res);
}
#method_after
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> servlets = Lists.newArrayList();
    List<JarEntry> restApis = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    JarEntry about = null;
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(jar.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(jar, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(jar, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(jar, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(jar, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#end_block

#method_before
private void sendMarkdownAsHtml(JarFile jar, JarEntry entry, String pluginName, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] rawmd = readWholeEntry(jar, entry);
    String encoding = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        encoding = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    String txtmd = RawParseUtils.decode(Charset.forName(encoding != null ? encoding : "UTF-8"), rawmd);
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    sendMarkdownAsHtml(txtmd, pluginName, key, res);
}
#method_after
private void sendMarkdownAsHtml(String md, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws UnsupportedEncodingException, IOException {
    Map<String, String> macros = Maps.newHashMap();
    macros.put("PLUGIN", pluginName);
    macros.put("SSH_HOST", sshHost);
    macros.put("SSH_PORT", "" + sshPort);
    String url = webUrl.get();
    if (Strings.isNullOrEmpty(url)) {
        url = "http://review.example.com/";
    }
    macros.put("URL", url);
    Matcher m = Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(md);
    StringBuffer sb = new StringBuffer();
    while (m.find()) {
        String key = m.group(2);
        String val = macros.get(key);
        if (m.group(1) != null) {
            m.appendReplacement(sb, "@" + key + "@");
        } else if (val != null) {
            m.appendReplacement(sb, val);
        } else {
            m.appendReplacement(sb, "@" + key + "@");
        }
    }
    m.appendTail(sb);
    byte[] html = new MarkdownFormatter().markdownToDocHtml(sb.toString(), "UTF-8");
    resourceCache.put(cacheKey, new SmallResource(html).setContentType("text/html").setCharacterEncoding("UTF-8").setLastModified(lastModifiedTime));
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(html.length);
    res.getOutputStream().write(html);
}
#end_block

#method_before
private void sendMarkdownAsHtml(JarFile jar, JarEntry entry, String pluginName, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] rawmd = readWholeEntry(jar, entry);
    String encoding = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        encoding = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    String txtmd = RawParseUtils.decode(Charset.forName(encoding != null ? encoding : "UTF-8"), rawmd);
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    sendMarkdownAsHtml(txtmd, pluginName, key, res);
}
#method_after
private void sendMarkdownAsHtml(JarFile jar, JarEntry entry, String pluginName, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] rawmd = readWholeEntry(jar, entry);
    String encoding = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        encoding = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    String txtmd = RawParseUtils.decode(Charset.forName(encoding != null ? encoding : "UTF-8"), rawmd);
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    sendMarkdownAsHtml(txtmd, pluginName, key, res, time);
}
#end_block

#method_before
private static String getPrefix(Plugin plugin, String attr, String def) {
    File srcFile = plugin.getSrcFile();
    if (srcFile == null || !srcFile.getName().endsWith(".jar")) {
        return def;
    }
    try {
        JarFile jarFile = new JarFile(plugin.getSrcFile());
        try {
            String prefix = jarFile.getManifest().getMainAttributes().getValue(attr);
            if (prefix != null) {
                return CharMatcher.is('/').trimFrom(prefix) + "/";
            } else {
                return def;
            }
        } finally {
            jarFile.close();
        }
    } catch (IOException e) {
        log.warn(String.format("Error getting %s for plugin %s, using default", attr, plugin.getName()), e);
        return null;
    }
}
#method_after
private static String getPrefix(Plugin plugin, String attr, String def) {
    JarFile jarFile = jarFileOf(plugin);
    if (jarFile == null) {
        return def;
    }
    try {
        String prefix = jarFile.getManifest().getMainAttributes().getValue(attr);
        if (prefix != null) {
            return CharMatcher.is('/').trimFrom(prefix) + "/";
        } else {
            return def;
        }
    } catch (IOException e) {
        log.warn(String.format("Error getting %s for plugin %s, using default", attr, plugin.getName()), e);
        return null;
    }
}
#end_block

#method_before
public static String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile)).toLowerCase();
}
#method_after
public static String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile));
}
#end_block

#method_before
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        ArrayList<Plugin> plugins = new ArrayList<Plugin>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#method_after
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        List<Plugin> plugins = new ArrayList<>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#end_block

#method_before
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#method_after
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    env.onStopPlugin(plugin);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#end_block

#method_before
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new ServerPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, new JarScanner(srcJar), manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new ServerPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, new JarFile(srcJar), new JarScanner(srcJar), new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Manifest getPluginManifest(PluginScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#method_after
private Manifest getPluginManifest(PluginContentScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#end_block

#method_before
@Test
public void changeMessageOnePatchSet() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("Just a little code change.\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Just a little code change.\n", changeMessages.get(0).getMessage());
    assertEquals(changeOwner.getAccount().getId(), changeMessages.get(0).getAuthor());
    assertEquals(ps1, changeMessages.get(0).getPatchSetId());
}
#method_after
@Test
public void changeMessageOnePatchSet() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("Just a little code change.\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.keySet().size());
    ChangeMessage cm = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("Just a little code change.\n", cm.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm.getAuthor());
    assertEquals(ps1, cm.getPatchSetId());
}
#end_block

#method_before
@Test
public void changeMessagesMultiplePatchSets() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the first PS.");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    incrementPatchSet(c);
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("This is the change message for the second PS.");
    update.commit();
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(2, changeMessages.size());
    assertEquals("This is the change message for the second PS.", changeMessages.get(0).getMessage());
    assertEquals(changeOwner.getAccount().getId(), changeMessages.get(0).getAuthor());
    assertEquals(ps2, changeMessages.get(0).getPatchSetId());
    assertEquals("This is the change message for the first PS.", changeMessages.get(1).getMessage());
    assertEquals(changeOwner.getAccount().getId(), changeMessages.get(1).getAuthor());
    assertEquals(ps1, changeMessages.get(1).getPatchSetId());
}
#method_after
@Test
public void changeMessagesMultiplePatchSets() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the first PS.");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    incrementPatchSet(c);
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("This is the change message for the second PS.");
    update.commit();
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(2, changeMessages.keySet().size());
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("This is the change message for the first PS.", cm1.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm1.getAuthor());
    ChangeMessage cm2 = Iterables.getOnlyElement(changeMessages.get(ps2));
    assertEquals(ps1, cm1.getPatchSetId());
    assertEquals("This is the change message for the second PS.", cm2.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm2.getAuthor());
    assertEquals(ps2, cm2.getPatchSetId());
}
#end_block

#method_before
@Test
public void noChangeMessage() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Patch-set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(0, changeMessages.size());
}
#method_after
@Test
public void noChangeMessage() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Patch-set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(0, changeMessages.keySet().size());
}
#end_block

#method_before
@Test
public void changeMessageWithTrailingDoubleNewline() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing trailing double newline\n" + "\n");
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing trailing double newline\n" + "\n" + "\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Testing trailing double newline\n" + "\n", changeMessages.get(0).getMessage());
}
#method_after
@Test
public void changeMessageWithTrailingDoubleNewline() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing trailing double newline\n" + "\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing trailing double newline\n" + "\n" + "\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.keySet().size());
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("Testing trailing double newline\n" + "\n", cm1.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm1.getAuthor());
}
#end_block

#method_before
@Test
public void changeMessageWithMultipleParagraphs() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3");
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3", changeMessages.get(0).getMessage());
}
#method_after
@Test
public void changeMessageWithMultipleParagraphs() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.keySet().size());
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3", cm1.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm1.getAuthor());
}
#end_block

#method_before
private void parseChangeMessage(PatchSet.Id psId, Account.Id accountId, RevCommit commit) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMessageString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, new Timestamp(commit.getCommitterIdent().getWhen().getTime()), psId);
    changeMessage.setMessage(changeMessageString);
    changeMessages.add(changeMessage);
}
#method_after
private void parseChangeMessage(PatchSet.Id psId, Account.Id accountId, RevCommit commit) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, new Timestamp(commit.getCommitterIdent().getWhen().getTime()), psId);
    changeMessage.setMessage(changeMsgString);
    changeMessages.put(psId, changeMessage);
}
#end_block

#method_before
public ImmutableList<ChangeMessage> getChangeMessages() {
    return changeMessages;
}
#method_after
public ImmutableListMultimap<PatchSet.Id, ChangeMessage> getChangeMessages() {
    return changeMessages;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change.getId(), rev, walk);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
        changeMessages = ImmutableList.copyOf(parser.changeMessages);
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change.getId(), rev, walk);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        ImmutableListMultimap.Builder<PatchSet.Id, ChangeMessage> cms = ImmutableListMultimap.builder();
        for (Map.Entry<PatchSet.Id, ChangeMessage> e : parser.changeMessages.entries()) {
            cms.put(e.getKey(), e.getValue());
        }
        this.changeMessages = cms.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } finally {
        walk.release();
    }
}
#end_block

#method_before
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableList.of();
}
#method_after
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableListMultimap.of();
}
#end_block

#method_before
private void parseChangeMessage(RevCommit commit) {
    final byte[] raw = commit.getRawBuffer();
    final int size = raw.length;
    final Charset enc = RawParseUtils.parseEncoding(raw);
    final int headerStart = RawParseUtils.commitMessage(raw, 0);
    if (headerStart < 0)
        return;
    int headerEnd = RawParseUtils.endOfParagraph(raw, headerStart);
    if (headerEnd == size)
        return;
    int changeMsgStart = headerEnd + 2;
    // 2 is for the \n\n that will be between the subject line and the
    // message we want
    int changeMsgEnd = RawParseUtils.endOfParagraph(raw, changeMsgStart);
    if (changeMsgEnd == size)
        return;
    String str = RawParseUtils.decode(enc, raw, changeMsgStart, changeMsgEnd);
    changeMessages.add(str);
}
#method_after
private void parseChangeMessage(RevCommit commit) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMessage = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    changeMessages.add(changeMessage);
}
#end_block

#method_before
@Test
public void changeMessageOnePatchSet() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("Just a little code change.\nTesting new line");
    update.commit();
    ChangeNotes notes = newNotes(c);
    List<String> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Just a little code change.\nTesting new line", changeMessages.get(0));
}
#method_after
@Test
public void changeMessageOnePatchSet() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("Just a little code change.\n");
    update.commit();
    ChangeNotes notes = newNotes(c);
    List<String> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Just a little code change.\n", changeMessages.get(0));
}
#end_block

#method_before
@Test
public void changeMessagesMultiplePatchSets() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the first PS.");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    incrementPatchSet(c);
    update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the second PS.");
    update.commit();
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    List<String> changeMessages = notes.getChangeMessages();
    assertEquals(2, changeMessages.size());
    assertEquals("This is the change message for the second PS.", changeMessages.get(0));
    assertEquals("This is the change message for the first PS.", changeMessages.get(1));
}
#method_after
@Test
public void changeMessagesMultiplePatchSets() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the first PS.");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    incrementPatchSet(c);
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("This is the change message for the second PS.");
    update.commit();
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    List<String> changeMessages = notes.getChangeMessages();
    assertEquals(2, changeMessages.size());
    assertEquals("This is the change message for the second PS.", changeMessages.get(0));
    assertEquals("This is the change message for the first PS.", changeMessages.get(1));
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    return new UiAction.Description().setLabel(label).setTitle(String.format(tooltip, resource.getPatchSet().getPatchSetId(), resource.getChange().getDest().getShortName())).setVisible(!resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit());
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
    return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(!resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit());
}
#end_block

#method_before
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    canSubmit = false;
    if (hasUser) {
        canSubmit = actions.containsKey("submit");
        if (canSubmit) {
            ActionInfo actionInfo = actions.get("submit");
            submit.setTitle(actionInfo.title());
            submit.setText(actionInfo.label());
        }
        a2b(actions, "/", deleteRevision);
        a2b(actions, "cherrypick", cherrypick);
        a2b(actions, "publish", publish);
        a2b(actions, "rebase", rebase);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, revInfo, actions.get(id)));
        }
    }
}
#method_after
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    canSubmit = false;
    if (hasUser) {
        canSubmit = actions.containsKey("submit");
        if (canSubmit) {
            ActionInfo action = actions.get("submit");
            submit.setTitle(action.title());
            submit.setHTML(new SafeHtmlBuilder().openDiv().append(action.label()).closeDiv());
        }
        a2b(actions, "/", deleteRevision);
        a2b(actions, "cherrypick", cherrypick);
        a2b(actions, "publish", publish);
        a2b(actions, "rebase", rebase);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, revInfo, actions.get(id)));
        }
    }
}
#end_block

#method_before
private void printMemoryCoreCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (!cache.name.contains(".") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#method_after
private void printMemoryCoreCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (!cache.name.contains("-") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#end_block

#method_before
private void printMemoryPluginCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (cache.name.contains(".") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#method_after
private void printMemoryPluginCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (cache.name.contains("-") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#end_block

#method_before
private void printCache(CacheInfo cache) {
    stdout.print(String.format("%1s %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", CacheType.DISK.equals(cache.type) ? "D" : "", cache.name, nullToEmpty(cache.entries.mem), nullToEmpty(cache.entries.disk), Strings.nullToEmpty(cache.entries.space), Strings.nullToEmpty(cache.averageGet), formatAsProcent(cache.hitRatio.mem), formatAsProcent(cache.hitRatio.disk)));
}
#method_after
private void printCache(CacheInfo cache) {
    stdout.print(String.format("%1s %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", CacheType.DISK.equals(cache.type) ? "D" : "", cache.name, nullToEmpty(cache.entries.mem), nullToEmpty(cache.entries.disk), Strings.nullToEmpty(cache.entries.space), Strings.nullToEmpty(cache.averageGet), formatAsPercent(cache.hitRatio.mem), formatAsPercent(cache.hitRatio.disk)));
}
#end_block

#method_before
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (Map.Entry<String, Cache<?, ?>> entry : getCaches().entrySet()) {
        cacheInfos.put(entry.getKey(), new CacheInfo(entry.getValue()));
    }
    return cacheInfos;
}
#method_after
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) {
        cacheInfos.put(cacheNameOf(e.getPluginName(), e.getExportName()), new CacheInfo(e.getProvider().get()));
    }
    return cacheInfos;
}
#end_block

#method_before
private static String cacheNameOf(String plugin, String name) {
    if ("gerrit".equals(plugin)) {
        return name;
    } else {
        return plugin + "." + name;
    }
}
#method_after
private static String cacheNameOf(String plugin, String name) {
    if ("gerrit".equals(plugin)) {
        return name;
    } else {
        return plugin + "-" + name;
    }
}
#end_block

#method_before
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#method_after
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s";
    }
    return String.format("%4.1f%s", ns, suffix).trim();
}
#end_block

#method_before
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix);
}
#method_after
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix).trim();
}
#end_block

#method_before
void setVisibleA(boolean show) {
    visibleA = show;
    if (show) {
        removeStyleName(style.hideA());
    } else {
        addStyleName(style.hideA());
    }
}
#method_after
void setVisibleA(boolean show) {
    visibleA = show;
    if (show) {
        removeStyleName(style.hideA());
        // match B's viewport
        parent.syncScroll(DisplaySide.B);
    } else {
        addStyleName(style.hideA());
    }
}
#end_block

#method_before
void set(JsArray<RevisionInfo> list, DiffInfo info) {
    patchSetSelectBoxA.setUpPatchSetNav(list, info.meta_a());
    patchSetSelectBoxB.setUpPatchSetNav(list, info.meta_b());
    JsArrayString hdr = info.diff_header();
    if (hdr != null) {
        StringBuilder b = new StringBuilder();
        for (int i = 1; i < hdr.length(); i++) {
            String s = hdr.get(i);
            if (s.startsWith("diff --git ") || s.startsWith("index ") || s.startsWith("+++ ") || s.startsWith("--- ")) {
                continue;
            }
            b.append(s).append('\n');
        }
        String hdrTxt = b.toString().trim();
        header = !hdrTxt.isEmpty();
        diffHeaderText.setInnerText(hdrTxt);
        UIObject.setVisible(diffHeaderRow, header);
    } else {
        header = false;
        UIObject.setVisible(diffHeaderRow, false);
    }
    if (info.change_type() == ChangeType.ADDED) {
        // TODO(davido): Add user preference to control it,
        // as not all users would probably like this per default
        setVisibleA(false);
    }
}
#method_after
void set(DiffPreferences prefs, JsArray<RevisionInfo> list, DiffInfo info) {
    this.changeType = info.change_type();
    patchSetSelectBoxA.setUpPatchSetNav(list, info.meta_a());
    patchSetSelectBoxB.setUpPatchSetNav(list, info.meta_b());
    JsArrayString hdr = info.diff_header();
    if (hdr != null) {
        StringBuilder b = new StringBuilder();
        for (int i = 1; i < hdr.length(); i++) {
            String s = hdr.get(i);
            if (s.startsWith("diff --git ") || s.startsWith("index ") || s.startsWith("+++ ") || s.startsWith("--- ")) {
                continue;
            }
            b.append(s).append('\n');
        }
        String hdrTxt = b.toString().trim();
        header = !hdrTxt.isEmpty();
        diffHeaderText.setInnerText(hdrTxt);
        UIObject.setVisible(diffHeaderRow, header);
    } else {
        header = false;
        UIObject.setVisible(diffHeaderRow, false);
    }
    setHideEmptyPane(prefs.hideEmptyPane());
}
#end_block

#method_before
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + PLUGINS_PREFIX;
    authorizedBase = Strings.nullToEmpty(path) + AUTHORIZED_PREFIX;
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#method_after
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    wrapper = new ContextMapper(config.getServletContext().getContextPath());
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#end_block

#method_before
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter filter;
        try {
            filter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, base + name);
            filter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                filter.destroy();
            }
        });
        return filter;
    }
    return null;
}
#method_after
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter filter;
        try {
            filter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, wrapper.getFullPath(name));
            filter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                filter.destroy();
            }
        });
        return filter;
    }
    return null;
}
#end_block

#method_before
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    WrappedRequest wr = new WrappedRequest(req, (isAuthorizedCall(req) ? authorizedBase : base) + name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#method_after
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    HttpServletRequest wr = wrapper.create(req, name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#end_block

#method_before
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    if (uri.length() <= ctx.length()) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = uri.substring(ctx.length() + 1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        if (jar != null) {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        } else {
            sendJsPlugin(holder.plugin, key, req, res);
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String pathInfo = req.getPathInfo();
    if (pathInfo.length() < 1) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = pathInfo.substring(1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    String uri = req.getRequestURI();
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        if (jar != null) {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        } else {
            sendJsPlugin(holder.plugin, key, req, res);
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> data;
        // Allow the user to select a logView variant with the "pretty" param.
        List<String> pretty_values = view.getParameters().get(PRETTY_PARAM);
        if (pretty_values.isEmpty()) {
            data = new LogSoyData(req, view).toSoyData(paginator, null, df);
            GitilesConfig.putVariant(getAccess(req).getConfig(), "logEntry", "logEntryVariant", data);
        } else {
            data = new LogSoyData(req, view, true).toSoyData(paginator, null, df);
            String variant = pretty_values.get(0);
            data.put("logPrettyVariant", pretty_values.get(0));
        }
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        renderHtml(req, res, "gitiles.logDetail", data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitilesAccess access = getAccess(req);
        Config config = access.getConfig();
        DateFormatter df = new DateFormatter(access, Format.DEFAULT);
        // Allow the user to select a logView variant with the "pretty" param.
        String pretty = Iterables.getFirst(view.getParameters().get(PRETTY_PARAM), "default");
        Map<String, Object> data = new LogSoyData(req, view, config.getBoolean("logFormat", pretty, "verbose", false)).toSoyData(paginator, null, df);
        String variant = config.getString("logFormat", pretty, "variant");
        data.put("logEntryPretty", pretty);
        data.put("logEntryVariant", Objects.firstNonNull(variant, pretty));
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        renderHtml(req, res, "gitiles.logDetail", data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(new CommitJsonData().setRevWalk(paginator.getWalk()).toJsonData(req, c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        DateFormatter df = new DateFormatter(getAccess(req), Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(new CommitJsonData().setRevWalk(paginator.getWalk()).toJsonData(req, c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
private static RevWalk newWalk(Repository repo, GitilesView view) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    if (!Strings.isNullOrEmpty(view.getPathPart())) {
        walk.setTreeFilter(AndTreeFilter.create(PathFilter.create(view.getPathPart()), TreeFilter.ANY_DIFF));
    }
    return walk;
}
#method_after
private static RevWalk newWalk(Repository repo, GitilesView view) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    if (!Strings.isNullOrEmpty(view.getPathPart())) {
        walk.setRewriteParents(false);
        walk.setTreeFilter(AndTreeFilter.create(PathFilterGroup.createFromStrings(view.getPathPart()), TreeFilter.ANY_DIFF));
    }
    return walk;
}
#end_block

#method_before
public Map<String, Object> toSoyData(Paginator paginator, @Nullable String revision, GitDateFormatter df) throws IOException {
    Map<String, Object> data = Maps.newHashMapWithExpectedSize(3);
    List<Map<String, Object>> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
    for (RevCommit c : paginator) {
        if (verbose) {
            entries.add(new CommitSoyData().setRevWalk(paginator.getWalk()).toSoyData(req, c, VERBOSE_FIELDS, df));
        } else {
            entries.add(new CommitSoyData().toSoyData(req, c, FIELDS, df));
        }
    }
    data.put("entries", entries);
    ObjectId next = paginator.getNextStart();
    // TODO(mmoss): These urls don't include the n or pretty params.
    if (next != null) {
        data.put("nextUrl", copyAndCanonicalize(view, revision).replaceParam(LogServlet.START_PARAM, next.name()).toUrl());
    }
    ObjectId prev = paginator.getPreviousStart();
    if (prev != null) {
        GitilesView.Builder prevView = copyAndCanonicalize(view, revision);
        if (!prevView.getRevision().getId().equals(prev)) {
            prevView.replaceParam(LogServlet.START_PARAM, prev.name());
        }
        data.put("previousUrl", prevView.toUrl());
    }
    return data;
}
#method_after
public Map<String, Object> toSoyData(RevWalk walk, int limit, @Nullable String revision, @Nullable ObjectId start, DateFormatter df) throws IOException {
    return toSoyData(new Paginator(walk, limit, start), revision, df);
}
#end_block

#method_before
public void doAction(IdentifiedUser user, GitHubLogin hubLogin, HttpServletRequest req, HttpServletResponse resp, ControllerErrors errors) throws ServletException, IOException {
    try {
        setAccountIdentity(user, req);
        setAccoutPublicKeys(user, hubLogin, req);
        resp.getWriter().println("Created account.");
    } catch (IOException e) {
        resp.getWriter().println("Account creation failed: " + e.getCause());
        throw e;
    }
}
#method_after
public void doAction(IdentifiedUser user, GitHubLogin hubLogin, HttpServletRequest req, HttpServletResponse resp, ControllerErrors errors) throws ServletException, IOException {
    try {
        setAccountIdentity(user, req);
        setAccoutPublicKeys(user, hubLogin, req);
        log.info("Created account '" + user.getUserName() + "'");
    } catch (IOException e) {
        log.error("Account '" + user.getUserName() + "' creation failed", e);
        throw e;
    }
}
#end_block

#method_before
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String sid, String auth) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long now = now();
    final long refreshCookieAt = now + refresh;
    final long expiresAt = now + sessionMaxAgeMillis;
    if (sid == null) {
        sid = newUniqueToken(who);
    }
    if (auth == null) {
        auth = newUniqueToken(who);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, expiresAt, sid, auth);
    self.get().put(key.token, val);
    return val;
}
#method_after
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String sid, String auth) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long now = nowMs();
    final long refreshCookieAt = now + refresh;
    final long expiresAt = now + sessionMaxAgeMillis;
    if (sid == null) {
        sid = newUniqueToken(who);
    }
    if (auth == null) {
        auth = newUniqueToken(who);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, expiresAt, sid, auth);
    self.put(key.token, val);
    return val;
}
#end_block

#method_before
Val get(final Key key) {
    Val val = self.get().getIfPresent(key.token);
    if (val != null && val.expiresAt <= now()) {
        self.get().invalidate(key.token);
        return null;
    }
    return val;
}
#method_after
Val get(final Key key) {
    Val val = self.getIfPresent(key.token);
    if (val != null && val.expiresAt <= nowMs()) {
        self.invalidate(key.token);
        return null;
    }
    return val;
}
#end_block

#method_before
void destroy(final Key key) {
    self.get().invalidate(key.token);
}
#method_after
void destroy(final Key key) {
    self.invalidate(key.token);
}
#end_block

#method_before
boolean needsCookieRefresh() {
    return refreshCookieAt <= now();
}
#method_after
boolean needsCookieRefresh() {
    return refreshCookieAt <= nowMs();
}
#end_block

#method_before
private void checkComments(RevisionResource revision, Map<String, List<Comment>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<Comment>>> mapItr = in.entrySet().iterator();
    List<String> filePaths = changeDataFactory.create(db.get(), revision.getChange()).filePaths(revision.getPatchSet());
    while (mapItr.hasNext()) {
        Map.Entry<String, List<Comment>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in patch set %s", path, change.currentPatchSetId()));
        }
        List<Comment> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<Comment> listItr = list.iterator();
        while (listItr.hasNext()) {
            Comment c = listItr.next();
            if (c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.emptyToNull(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#method_after
private void checkComments(RevisionResource revision, Map<String, List<Comment>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<Comment>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getChange()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<Comment>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, change.currentPatchSetId()));
        }
        List<Comment> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<Comment> listItr = list.iterator();
        while (listItr.hasNext()) {
            Comment c = listItr.next();
            if (c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.emptyToNull(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#end_block

#method_before
public void setCurrentFilePaths(List<String> filePaths) throws OrmException {
    PatchSet ps = currentPatchSet();
    if (ps != null) {
        files.put(Integer.valueOf(ps.getPatchSetId()), ImmutableList.copyOf(filePaths));
    }
}
#method_after
public void setCurrentFilePaths(List<String> filePaths) throws OrmException {
    PatchSet ps = currentPatchSet();
    if (ps != null) {
        files.put(ps.getPatchSetId(), ImmutableList.copyOf(filePaths));
    }
}
#end_block

#method_before
public List<String> filePaths(PatchSet ps) throws OrmException {
    if (!files.containsKey(Integer.valueOf(ps.getPatchSetId()))) {
        Change c = change();
        if (c == null) {
            return null;
        }
        PatchList p;
        try {
            p = patchListCache.get(c, ps);
        } catch (PatchListNotAvailableException e) {
            List<String> emptyFileList = Collections.emptyList();
            files.put(Integer.valueOf(ps.getPatchSetId()), emptyFileList);
            return emptyFileList;
        }
        List<String> r = new ArrayList<String>(p.getPatches().size());
        for (PatchListEntry e : p.getPatches()) {
            if (Patch.COMMIT_MSG.equals(e.getNewName())) {
                continue;
            }
            switch(e.getChangeType()) {
                case ADDED:
                case MODIFIED:
                case DELETED:
                case COPIED:
                case REWRITE:
                    r.add(e.getNewName());
                    break;
                case RENAMED:
                    r.add(e.getOldName());
                    r.add(e.getNewName());
                    break;
            }
        }
        Collections.sort(r);
        files.put(Integer.valueOf(ps.getPatchSetId()), Collections.unmodifiableList(r));
    }
    return files.get(Integer.valueOf(ps.getPatchSetId()));
}
#method_after
public List<String> filePaths(PatchSet ps) throws OrmException {
    if (!files.containsKey(ps.getPatchSetId())) {
        Change c = change();
        if (c == null) {
            return null;
        }
        PatchList p;
        try {
            p = patchListCache.get(c, ps);
        } catch (PatchListNotAvailableException e) {
            List<String> emptyFileList = Collections.emptyList();
            files.put(ps.getPatchSetId(), emptyFileList);
            return emptyFileList;
        }
        List<String> r = new ArrayList<String>(p.getPatches().size());
        for (PatchListEntry e : p.getPatches()) {
            if (Patch.COMMIT_MSG.equals(e.getNewName())) {
                continue;
            }
            switch(e.getChangeType()) {
                case ADDED:
                case MODIFIED:
                case DELETED:
                case COPIED:
                case REWRITE:
                    r.add(e.getNewName());
                    break;
                case RENAMED:
                    r.add(e.getOldName());
                    r.add(e.getNewName());
                    break;
            }
        }
        Collections.sort(r);
        files.put(ps.getPatchSetId(), Collections.unmodifiableList(r));
    }
    return files.get(ps.getPatchSetId());
}
#end_block

#method_before
@Test
public void test() throws Exception {
    test(5);
}
#method_after
@Test
// we know it works now, so let's not clone a project 500 times ;-)
@Ignore
public void test() throws Exception {
    test(5);
}
#end_block

#method_before
@UiHandler("addme")
void onAddMe(ClickEvent e) {
    String reviewer = Gerrit.getUserAccountInfo().name();
    if (!reviewer.isEmpty()) {
        addReviewer(reviewer, false);
    }
}
#method_after
@UiHandler("addme")
void onAddMe(ClickEvent e) {
    String accountId = String.valueOf(Gerrit.getUserAccountInfo()._account_id());
    addReviewer(accountId, false);
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        final LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, m);
        AccountApi.self().view("preferences").get(new AsyncCallback<Preferences>() {

            @Override
            public void onSuccess(Preferences prefs) {
                for (TopMenuItem item : Natives.asList(prefs.my())) {
                    addExtensionLink(myBar, item);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar() {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            if (event.getScreen() instanceof ProjectScreen && currentMenu == null) {
                menuLeft.selectTab(menuLeft.getWidgetIndex(this));
            }
        }
    };
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    addProjectLink(projectsBar, C.menuProjectsInfo(), ProjectScreen.INFO);
    addProjectLink(projectsBar, C.menuProjectsBranches(), ProjectScreen.BRANCH);
    addProjectLink(projectsBar, C.menuProjectsAccess(), ProjectScreen.ACCESS);
    final LinkMenuItem dashboardsMenuItem = addProjectLink(projectsBar, C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar existingBar = menuBars.get(menu.getName());
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(menu.getName(), bar);
                    menuLeft.add(bar, menu.getName());
                }
            }
        }
    });
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        final LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, m);
        AccountApi.self().view("preferences").get(new AsyncCallback<Preferences>() {

            @Override
            public void onSuccess(Preferences prefs) {
                for (TopMenuItem item : Natives.asList(prefs.my())) {
                    addExtensionLink(myBar, item);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar existingBar = menuBars.get(menu.getName());
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(menu.getName(), bar);
                    menuLeft.add(bar, menu.getName());
                }
            }
        }
    });
}
#end_block

#method_before
public void onScreenLoad(ScreenLoadEvent event) {
    if (event.getScreen().getToken().equals(getTargetHistoryToken())) {
        Gerrit.currentMenu = null;
        addStyleName(Gerrit.RESOURCES.css().activeRow());
    } else {
        removeStyleName(Gerrit.RESOURCES.css().activeRow());
    }
}
#method_after
public void onScreenLoad(ScreenLoadEvent event) {
    if (match(event.getScreen().getToken())) {
        Gerrit.selectMenu(bar);
        addStyleName(Gerrit.RESOURCES.css().activeRow());
    } else {
        removeStyleName(Gerrit.RESOURCES.css().activeRow());
    }
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    boolean admin;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            admin = getCurrentUser().getCapabilities().canAdministrateServer();
            break;
        default:
            owner = false;
            admin = false;
    }
    if (object instanceof RevCommit) {
        return admin || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
protected ProjectAccess updateProjectConfig(ProjectConfig config, MetaDataUpdate md) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    hooks.doRefUpdatedHook(new Branch.NameKey(config.getProject().getNameKey(), GitRepositoryManager.REF_CONFIG), commit.getParent(0).getId(), commit.getId(), user.getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#method_after
@Override
protected ProjectAccess updateProjectConfig(ProjectConfig config, MetaDataUpdate md) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    hooks.doRefUpdatedHook(new Branch.NameKey(config.getProject().getNameKey(), GitRepositoryManager.REF_CONFIG), base, commit.getId(), user.getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#end_block

#method_before
@Override
protected ProjectSubmitType getSubmitType() {
    return ProjectSubmitType.MERGE_ALWAYS;
}
#method_after
@Override
protected SubmitType getSubmitType() {
    return SubmitType.MERGE_ALWAYS;
}
#end_block

#method_before
private void loadProject(ResultSet rs, Project project) throws SQLException, OrmException {
    project.setDescription(rs.getString("description"));
    project.setUseContributorAgreements(asInheritableBoolean(rs, "use_contributor_agreements"));
    switch(rs.getString("submit_type").charAt(0)) {
        case 'F':
            project.setSubmitType(ProjectSubmitType.FAST_FORWARD_ONLY);
            break;
        case 'M':
            project.setSubmitType(ProjectSubmitType.MERGE_IF_NECESSARY);
            break;
        case 'A':
            project.setSubmitType(ProjectSubmitType.MERGE_ALWAYS);
            break;
        case 'C':
            project.setSubmitType(ProjectSubmitType.CHERRY_PICK);
            break;
        default:
            throw new OrmException("Unsupported submit_type=" + rs.getString("submit_type") + " on project " + project.getName());
    }
    project.setUseSignedOffBy(asInheritableBoolean(rs, "use_signed_off_by"));
    project.setRequireChangeID(asInheritableBoolean(rs, "require_change_id"));
    project.setUseContentMerge(asInheritableBoolean(rs, "use_content_merge"));
    project.setParentName(rs.getString("parent_name"));
}
#method_after
private void loadProject(ResultSet rs, Project project) throws SQLException, OrmException {
    project.setDescription(rs.getString("description"));
    project.setUseContributorAgreements(asInheritableBoolean(rs, "use_contributor_agreements"));
    switch(rs.getString("submit_type").charAt(0)) {
        case 'F':
            project.setSubmitType(SubmitType.FAST_FORWARD_ONLY);
            break;
        case 'M':
            project.setSubmitType(SubmitType.MERGE_IF_NECESSARY);
            break;
        case 'A':
            project.setSubmitType(SubmitType.MERGE_ALWAYS);
            break;
        case 'C':
            project.setSubmitType(SubmitType.CHERRY_PICK);
            break;
        default:
            throw new OrmException("Unsupported submit_type=" + rs.getString("submit_type") + " on project " + project.getName());
    }
    project.setUseSignedOffBy(asInheritableBoolean(rs, "use_signed_off_by"));
    project.setRequireChangeID(asInheritableBoolean(rs, "require_change_id"));
    project.setUseContentMerge(asInheritableBoolean(rs, "use_content_merge"));
    project.setParentName(rs.getString("parent_name"));
}
#end_block

#method_before
public boolean canWrite() {
    return getProjectControl().getProject().getState().equals(ProjectStatus.ACTIVE);
}
#method_after
public boolean canWrite() {
    return getProjectControl().getProject().getState().equals(ProjectState.ACTIVE);
}
#end_block

#method_before
public boolean canRead() {
    return getProjectControl().getProject().getState().equals(ProjectStatus.READ_ONLY) || canWrite();
}
#method_after
public boolean canRead() {
    return getProjectControl().getProject().getState().equals(ProjectState.READ_ONLY) || canWrite();
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return getCurrentUser().getCapabilities().canAdministrateServer() || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && projectControl.canReadCommit(rw, (RevCommit) object));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return getCurrentUser().getCapabilities().canAdministrateServer() || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS, ListChangesOption.WEB_LINKS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    String email = info.owner().email() != null ? info.owner().email() : name;
    ownerText.setInnerText(name);
    ownerText.setTitle(email);
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    ownerLink.setText(name);
    ownerLink.setTitle(info.owner().email() != null ? info.owner().email() : name);
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._account_id()), Change.Status.NEW));
}
#end_block

#method_before
private void renderSubmitType(String action) {
    try {
        ProjectSubmitType type = ProjectSubmitType.valueOf(action);
        submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type));
    } catch (IllegalArgumentException e) {
        submitActionText.setInnerText(action);
    }
}
#method_after
private void renderSubmitType(String action) {
    try {
        SubmitType type = SubmitType.valueOf(action);
        submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type));
    } catch (IllegalArgumentException e) {
        submitActionText.setInnerText(action);
    }
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    ChangeControl control = StoredValues.CHANGE_CONTROL.get(engine);
    ProjectSubmitType submitType = control.getProject().getSubmitType();
    if (!a1.unify(term[submitType.ordinal()], engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    ChangeControl control = StoredValues.CHANGE_CONTROL.get(engine);
    SubmitType submitType = control.getProject().getSubmitType();
    if (!a1.unify(term[submitType.ordinal()], engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
protected ProjectSubmitType getSubmitType() {
    return ProjectSubmitType.MERGE_IF_NECESSARY;
}
#method_after
@Override
protected SubmitType getSubmitType() {
    return SubmitType.MERGE_IF_NECESSARY;
}
#end_block

#method_before
public static String toLongString(final ProjectStatus type) {
    if (type == null) {
        return "";
    }
    switch(type) {
        case ACTIVE:
            return C.projectState_ACTIVE();
        case READ_ONLY:
            return C.projectState_READ_ONLY();
        case HIDDEN:
            return C.projectState_HIDDEN();
        default:
            return type.name();
    }
}
#method_after
public static String toLongString(final SubmitType type) {
    if (type == null) {
        return "";
    }
    switch(type) {
        case FAST_FORWARD_ONLY:
            return C.projectSubmitType_FAST_FORWARD_ONLY();
        case MERGE_IF_NECESSARY:
            return C.projectSubmitType_MERGE_IF_NECESSARY();
        case REBASE_IF_NECESSARY:
            return C.projectSubmitType_REBASE_IF_NECESSARY();
        case MERGE_ALWAYS:
            return C.projectSubmitType_MERGE_ALWAYS();
        case CHERRY_PICK:
            return C.projectSubmitType_CHERRY_PICK();
        default:
            return type.name();
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    project = new Project.NameKey("p");
    db = reviewDbProvider.open();
}
#method_after
@Before
public void setUp() throws Exception {
    project = new Project.NameKey("p2");
}
#end_block

#method_before
private void setSubmitType(ProjectSubmitType submitType) throws IOException {
    PutConfig.Input in = new PutConfig.Input();
    in.submitType = submitType;
    in.useContentMerge = InheritableBoolean.FALSE;
    RestResponse r = adminSession.put("/projects/" + project.get() + "/config", in);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    r.consume();
}
#method_after
private void setSubmitType(SubmitType submitType) throws IOException {
    PutConfig.Input in = new PutConfig.Input();
    in.submitType = submitType;
    in.useContentMerge = InheritableBoolean.FALSE;
    RestResponse r = adminSession.put("/projects/" + project.get() + "/config", in);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    r.consume();
}
#end_block

#method_before
@Test
public void testCreateProjectWithProperties() throws IOException {
    final String newProjectName = "newProject";
    ProjectInput in = new ProjectInput();
    in.description = "Test description";
    in.submitType = ProjectSubmitType.CHERRY_PICK;
    in.useContributorAgreements = InheritableBoolean.TRUE;
    in.useSignedOffBy = InheritableBoolean.TRUE;
    in.useContentMerge = InheritableBoolean.TRUE;
    in.requireChangeId = InheritableBoolean.TRUE;
    RestResponse r = adminSession.put("/projects/" + newProjectName, in);
    ProjectInfo p = newGson().fromJson(r.getReader(), ProjectInfo.class);
    assertEquals(newProjectName, p.name);
    Project project = projectCache.get(new Project.NameKey(newProjectName)).getProject();
    assertProjectInfo(project, p);
    assertEquals(in.description, project.getDescription());
    assertEquals(in.submitType, project.getSubmitType());
    assertEquals(in.useContributorAgreements, project.getUseContributorAgreements());
    assertEquals(in.useSignedOffBy, project.getUseSignedOffBy());
    assertEquals(in.useContentMerge, project.getUseContentMerge());
    assertEquals(in.requireChangeId, project.getRequireChangeID());
}
#method_after
@Test
public void testCreateProjectWithProperties() throws IOException {
    final String newProjectName = "newProject";
    ProjectInput in = new ProjectInput();
    in.description = "Test description";
    in.submitType = SubmitType.CHERRY_PICK;
    in.useContributorAgreements = InheritableBoolean.TRUE;
    in.useSignedOffBy = InheritableBoolean.TRUE;
    in.useContentMerge = InheritableBoolean.TRUE;
    in.requireChangeId = InheritableBoolean.TRUE;
    RestResponse r = adminSession.put("/projects/" + newProjectName, in);
    ProjectInfo p = newGson().fromJson(r.getReader(), ProjectInfo.class);
    assertEquals(newProjectName, p.name);
    Project project = projectCache.get(new Project.NameKey(newProjectName)).getProject();
    assertProjectInfo(project, p);
    assertEquals(in.description, project.getDescription());
    assertEquals(in.submitType, project.getSubmitType());
    assertEquals(in.useContributorAgreements, project.getUseContributorAgreements());
    assertEquals(in.useSignedOffBy, project.getUseSignedOffBy());
    assertEquals(in.useContentMerge, project.getUseContentMerge());
    assertEquals(in.requireChangeId, project.getRequireChangeID());
}
#end_block

#method_before
@Test
public void testCreateProjectWithoutCapability_Forbidden() throws OrmException, JSchException, IOException {
    TestAccount user = accounts.create("user", "user@example.com", "User");
    RestResponse r = new RestSession(server, user).put("/projects/newProject");
    assertEquals(HttpStatus.SC_FORBIDDEN, r.getStatusCode());
}
#method_after
@Test
public void testCreateProjectWithoutCapability_Forbidden() throws OrmException, JSchException, IOException {
    RestResponse r = userSession.put("/projects/newProject");
    assertEquals(HttpStatus.SC_FORBIDDEN, r.getStatusCode());
}
#end_block

#method_before
public ProjectStatus getState() {
    return control.getProject().getState();
}
#method_after
public ProjectState getState() {
    return control.getProject().getState();
}
#end_block

#method_before
public final ProjectStatus state() {
    return ProjectStatus.valueOf(getStringState());
}
#method_after
public final ProjectState state() {
    return ProjectState.valueOf(getStringState());
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    RestApi call = ChangeApi.detail(patchSetId.getParentKey().get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS));
    call.get(group.add(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            detail = result;
        }
    }));
    ChangeApi.revision(patchSetId).view("submit_type").get(group.add(new GerritCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            submitTypeRecord = SubmitTypeRecord.OK(ProjectSubmitType.valueOf(result.asString()));
        }

        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.revision(patchSetId.getParentKey().get(), "" + patchSetId.get()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            drafts = result;
        }

        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.revision(patchSetId).view("review").get(group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            result.init();
            change = result;
            preDisplay(result);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    RestApi call = ChangeApi.detail(patchSetId.getParentKey().get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS));
    call.get(group.add(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            detail = result;
        }
    }));
    ChangeApi.revision(patchSetId).view("submit_type").get(group.add(new GerritCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            submitTypeRecord = SubmitTypeRecord.OK(SubmitType.valueOf(result.asString()));
        }

        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.revision(patchSetId.getParentKey().get(), "" + patchSetId.get()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            drafts = result;
        }

        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.revision(patchSetId).view("review").get(group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            result.init();
            change = result;
            preDisplay(result);
        }
    }));
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, ResourceNotFoundException, IOException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == ProjectSubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(new ProjectResource(projectControl), in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, ResourceNotFoundException, IOException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(new ProjectResource(projectControl), in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#end_block

#method_before
public final ProjectSubmitType submit_type() {
    return ProjectSubmitType.valueOf(submit_typeRaw());
}
#method_after
public final SubmitType submit_type() {
    return SubmitType.valueOf(submit_typeRaw());
}
#end_block

#method_before
public final ProjectStatus state() {
    if (stateRaw() == null) {
        return ProjectStatus.ACTIVE;
    }
    return ProjectStatus.valueOf(stateRaw());
}
#method_after
public final ProjectState state() {
    if (stateRaw() == null) {
        return ProjectState.ACTIVE;
    }
    return ProjectState.valueOf(stateRaw());
}
#end_block

#method_before
final List<FindReplace> commentlinks() {
    JsArray<CommentLinkInfo> cls = commentlinks0().values();
    List<FindReplace> commentLinks = new ArrayList<>(cls.length());
    for (int i = 0; i < cls.length(); i++) {
        CommentLinkInfo cl = cls.get(i);
        if (!cl.enabled()) {
            continue;
        }
        if (cl.link() != null) {
            commentLinks.add(new LinkFindReplace(cl.match(), cl.link()));
        } else {
            commentLinks.add(new RawFindReplace(cl.match(), cl.html()));
        }
    }
    return commentLinks;
}
#method_after
final List<FindReplace> commentlinks() {
    JsArray<CommentLinkInfo> cls = commentlinks0().values();
    List<FindReplace> commentLinks = new ArrayList<>(cls.length());
    for (int i = 0; i < cls.length(); i++) {
        CommentLinkInfo cl = cls.get(i);
        if (!cl.enabled()) {
            continue;
        }
        if (cl.link() != null) {
            commentLinks.add(new LinkFindReplace(cl.match(), cl.link()));
        } else {
            try {
                FindReplace fr = new RawFindReplace(cl.match(), cl.html());
                commentLinks.add(fr);
            } catch (RuntimeException e) {
                int index = e.getMessage().indexOf("at Object");
                new ErrorDialog("Invalid commentlink configuration: " + (index == -1 ? e.getMessage() : e.getMessage().substring(0, index))).center();
            }
        }
    }
    return commentLinks;
}
#end_block

#method_before
@Override
protected ProjectSubmitType getSubmitType() {
    return ProjectSubmitType.CHERRY_PICK;
}
#method_after
@Override
protected SubmitType getSubmitType() {
    return SubmitType.CHERRY_PICK;
}
#end_block

#method_before
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, String>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, String> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                if (Strings.emptyToNull(v.getValue()) != null) {
                    if (!v.getValue().equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(v.getValue());
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(v.getValue());
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(v.getValue());
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(v.getValue())) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", v.getValue(), v.getKey()));
                                    }
                                case STRING:
                                    cfg.setString(v.getKey(), v.getValue());
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
@Test
public void filterOutMoreThanOnePageOfResults() throws Exception {
    TestRepository<InMemoryRepository> repo = createProject("repo");
    Change change = newChange(repo, null, null, userId.get(), null).insert();
    int user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId().get();
    for (int i = 0; i < 5; i++) {
        newChange(repo, null, null, user2, null).insert();
    }
    assertResultEquals(change, queryOne("status:new ownerin:Administrators"));
    assertResultEquals(change, queryOne("status:new ownerin:Administrators limit:2"));
}
#method_after
@Test
public void filterOutMoreThanOnePageOfResults() throws Exception {
    TestRepository<InMemoryRepository> repo = createProject("repo");
    Change change = newChange(repo, null, null, userId.get(), null).insert();
    int user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId().get();
    for (int i = 0; i < 5; i++) {
        newChange(repo, null, null, user2, null).insert();
    }
    // assertResultEquals(change, queryOne("status:new ownerin:Administrators"));
    assertResultEquals(change, queryOne("status:new ownerin:Administrators limit:2"));
}
#end_block

#method_before
private static long lastUpdatedMs(Change c) {
    return c.getLastUpdatedOn().getTime();
}
#method_after
protected static long lastUpdatedMs(Change c) {
    return c.getLastUpdatedOn().getTime();
}
#end_block

#method_before
public static void setConfig(Project.NameKey name, String description, com.google.gerrit.extensions.common.InheritableBoolean useContributorAgreements, com.google.gerrit.extensions.common.InheritableBoolean useContentMerge, com.google.gerrit.extensions.common.InheritableBoolean useSignedOffBy, com.google.gerrit.extensions.common.InheritableBoolean requireChangeId, String maxObjectSizeLimit, com.google.gerrit.extensions.common.ProjectSubmitType submitType, com.google.gerrit.extensions.common.ProjectStatus state, Map<String, Map<String, String>> pluginConfigValues, AsyncCallback<ConfigInfo> cb) {
    ConfigInput in = ConfigInput.create();
    in.setDescription(description);
    in.setUseContributorAgreements(useContributorAgreements);
    in.setUseContentMerge(useContentMerge);
    in.setUseSignedOffBy(useSignedOffBy);
    in.setRequireChangeId(requireChangeId);
    in.setMaxObjectSizeLimit(maxObjectSizeLimit);
    in.setSubmitType(submitType);
    in.setState(state);
    in.setPluginConfigValues(pluginConfigValues);
    project(name).view("config").put(in, cb);
}
#method_after
public static void setConfig(Project.NameKey name, String description, InheritableBoolean useContributorAgreements, InheritableBoolean useContentMerge, InheritableBoolean useSignedOffBy, InheritableBoolean requireChangeId, String maxObjectSizeLimit, SubmitType submitType, ProjectState state, Map<String, Map<String, ConfigParameterValue>> pluginConfigValues, AsyncCallback<ConfigInfo> cb) {
    ConfigInput in = ConfigInput.create();
    in.setDescription(description);
    in.setUseContributorAgreements(useContributorAgreements);
    in.setUseContentMerge(useContentMerge);
    in.setUseSignedOffBy(useSignedOffBy);
    in.setRequireChangeId(requireChangeId);
    in.setMaxObjectSizeLimit(maxObjectSizeLimit);
    in.setSubmitType(submitType);
    in.setState(state);
    in.setPluginConfigValues(pluginConfigValues);
    project(name).view("config").put(in, cb);
}
#end_block

#method_before
final void setUseContributorAgreements(com.google.gerrit.extensions.common.InheritableBoolean v) {
    setUseContributorAgreementsRaw(v.name());
}
#method_after
final void setUseContributorAgreements(InheritableBoolean v) {
    setUseContributorAgreementsRaw(v.name());
}
#end_block

#method_before
final void setUseContentMerge(com.google.gerrit.extensions.common.InheritableBoolean v) {
    setUseContentMergeRaw(v.name());
}
#method_after
final void setUseContentMerge(InheritableBoolean v) {
    setUseContentMergeRaw(v.name());
}
#end_block

#method_before
final void setUseSignedOffBy(com.google.gerrit.extensions.common.InheritableBoolean v) {
    setUseSignedOffByRaw(v.name());
}
#method_after
final void setUseSignedOffBy(InheritableBoolean v) {
    setUseSignedOffByRaw(v.name());
}
#end_block

#method_before
final void setRequireChangeId(com.google.gerrit.extensions.common.InheritableBoolean v) {
    setRequireChangeIdRaw(v.name());
}
#method_after
final void setRequireChangeId(InheritableBoolean v) {
    setRequireChangeIdRaw(v.name());
}
#end_block

#method_before
final void setSubmitType(com.google.gerrit.extensions.common.ProjectSubmitType t) {
    setSubmitTypeRaw(t.name());
}
#method_after
final void setSubmitType(SubmitType t) {
    setSubmitTypeRaw(t.name());
}
#end_block

#method_before
final void setState(com.google.gerrit.extensions.common.ProjectStatus s) {
    setStateRaw(s.name());
}
#method_after
final void setState(ProjectState s) {
    setStateRaw(s.name());
}
#end_block

#method_before
final void setPluginConfigValues(Map<String, Map<String, String>> pluginConfigValues) {
    if (!pluginConfigValues.isEmpty()) {
        NativeMap<StringMap> configValues = NativeMap.create().cast();
        for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
            StringMap values = StringMap.create();
            configValues.put(e.getKey(), values);
            for (Entry<String, String> e2 : e.getValue().entrySet()) {
                values.put(e2.getKey(), e2.getValue());
            }
        }
        setPluginConfigValuesRaw(configValues);
    }
}
#method_after
final void setPluginConfigValues(Map<String, Map<String, ConfigParameterValue>> pluginConfigValues) {
    if (!pluginConfigValues.isEmpty()) {
        NativeMap<ConfigParameterValueMap> configValues = NativeMap.create().cast();
        for (Entry<String, Map<String, ConfigParameterValue>> e : pluginConfigValues.entrySet()) {
            ConfigParameterValueMap values = ConfigParameterValueMap.create();
            configValues.put(e.getKey(), values);
            for (Entry<String, ConfigParameterValue> e2 : e.getValue().entrySet()) {
                values.put(e2.getKey(), e2.getValue());
            }
        }
        setPluginConfigValuesRaw(configValues);
    }
}
#end_block

#method_before
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    submitType = new ListBox();
    for (final com.google.gerrit.extensions.common.ProjectSubmitType type : com.google.gerrit.extensions.common.ProjectSubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    state = new ListBox();
    for (final com.google.gerrit.extensions.common.ProjectStatus stateValue : com.google.gerrit.extensions.common.ProjectStatus.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#method_after
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    submitType = new ListBox();
    for (final SubmitType type : SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    state = new ListBox();
    for (final ProjectState stateValue : ProjectState.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#end_block

#method_before
private static ListBox newInheritedBooleanBox() {
    ListBox box = new ListBox();
    for (com.google.gerrit.extensions.common.InheritableBoolean b : com.google.gerrit.extensions.common.InheritableBoolean.values()) {
        box.addItem(b.name(), b.name());
    }
    return box;
}
#method_after
private static ListBox newInheritedBooleanBox() {
    ListBox box = new ListBox();
    for (InheritableBoolean b : InheritableBoolean.values()) {
        box.addItem(b.name(), b.name());
    }
    return box;
}
#end_block

#method_before
private void setEnabledForUseContentMerge() {
    if (com.google.gerrit.extensions.common.ProjectSubmitType.FAST_FORWARD_ONLY.equals(com.google.gerrit.extensions.common.ProjectSubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())))) {
        contentMerge.setEnabled(false);
        InheritedBooleanInfo b = InheritedBooleanInfo.create();
        b.setConfiguredValue(com.google.gerrit.extensions.common.InheritableBoolean.FALSE);
        setBool(contentMerge, b);
    } else {
        contentMerge.setEnabled(submitType.isEnabled());
    }
}
#method_after
private void setEnabledForUseContentMerge() {
    if (SubmitType.FAST_FORWARD_ONLY.equals(SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())))) {
        contentMerge.setEnabled(false);
        InheritedBooleanInfo b = InheritedBooleanInfo.create();
        b.setConfiguredValue(InheritableBoolean.FALSE);
        setBool(contentMerge, b);
    } else {
        contentMerge.setEnabled(submitType.isEnabled());
    }
}
#end_block

#method_before
private void setSubmitType(final com.google.gerrit.extensions.common.ProjectSubmitType newSubmitType) {
    int index = -1;
    if (submitType != null) {
        for (int i = 0; i < submitType.getItemCount(); i++) {
            if (newSubmitType.name().equals(submitType.getValue(i))) {
                index = i;
                break;
            }
        }
        submitType.setSelectedIndex(index);
        setEnabledForUseContentMerge();
    }
}
#method_after
private void setSubmitType(final SubmitType newSubmitType) {
    int index = -1;
    if (submitType != null) {
        for (int i = 0; i < submitType.getItemCount(); i++) {
            if (newSubmitType.name().equals(submitType.getValue(i))) {
                index = i;
                break;
            }
        }
        submitType.setSelectedIndex(index);
        setEnabledForUseContentMerge();
    }
}
#end_block

#method_before
private void setState(final com.google.gerrit.extensions.common.ProjectStatus newState) {
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                state.setSelectedIndex(i);
                break;
            }
        }
    }
}
#method_after
private void setState(final ProjectState newState) {
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                state.setSelectedIndex(i);
                break;
            }
        }
    }
}
#end_block

#method_before
private void setBool(ListBox box, InheritedBooleanInfo inheritedBoolean) {
    int inheritedIndex = -1;
    for (int i = 0; i < box.getItemCount(); i++) {
        if (box.getValue(i).startsWith(com.google.gerrit.extensions.common.InheritableBoolean.INHERIT.name())) {
            inheritedIndex = i;
        }
        if (box.getValue(i).startsWith(inheritedBoolean.configured_value().name())) {
            box.setSelectedIndex(i);
        }
    }
    if (inheritedIndex >= 0) {
        if (getProjectKey().equals(Gerrit.getConfig().getWildProject())) {
            if (box.getSelectedIndex() == inheritedIndex) {
                for (int i = 0; i < box.getItemCount(); i++) {
                    if (box.getValue(i).equals(com.google.gerrit.extensions.common.InheritableBoolean.FALSE.name())) {
                        box.setSelectedIndex(i);
                        break;
                    }
                }
            }
            box.removeItem(inheritedIndex);
        } else {
            box.setItemText(inheritedIndex, com.google.gerrit.extensions.common.InheritableBoolean.INHERIT.name() + " (" + inheritedBoolean.inherited_value() + ")");
        }
    }
}
#method_after
private void setBool(ListBox box, InheritedBooleanInfo inheritedBoolean) {
    int inheritedIndex = -1;
    for (int i = 0; i < box.getItemCount(); i++) {
        if (box.getValue(i).startsWith(InheritableBoolean.INHERIT.name())) {
            inheritedIndex = i;
        }
        if (box.getValue(i).startsWith(inheritedBoolean.configured_value().name())) {
            box.setSelectedIndex(i);
        }
    }
    if (inheritedIndex >= 0) {
        if (getProjectKey().equals(Gerrit.getConfig().getWildProject())) {
            if (box.getSelectedIndex() == inheritedIndex) {
                for (int i = 0; i < box.getItemCount(); i++) {
                    if (box.getValue(i).equals(InheritableBoolean.FALSE.name())) {
                        box.setSelectedIndex(i);
                        break;
                    }
                }
            }
            box.removeItem(inheritedIndex);
        } else {
            box.setItemText(inheritedIndex, InheritableBoolean.INHERIT.name() + " (" + inheritedBoolean.inherited_value() + ")");
        }
    }
}
#end_block

#method_before
private static com.google.gerrit.extensions.common.InheritableBoolean getBool(ListBox box) {
    int i = box.getSelectedIndex();
    if (i >= 0) {
        final String selectedValue = box.getValue(i);
        if (selectedValue.startsWith(com.google.gerrit.extensions.common.InheritableBoolean.INHERIT.name())) {
            return com.google.gerrit.extensions.common.InheritableBoolean.INHERIT;
        }
        return com.google.gerrit.extensions.common.InheritableBoolean.valueOf(selectedValue);
    }
    return com.google.gerrit.extensions.common.InheritableBoolean.INHERIT;
}
#method_after
private static InheritableBoolean getBool(ListBox box) {
    int i = box.getSelectedIndex();
    if (i >= 0) {
        final String selectedValue = box.getValue(i);
        if (selectedValue.startsWith(InheritableBoolean.INHERIT.name())) {
            return InheritableBoolean.INHERIT;
        }
        return InheritableBoolean.valueOf(selectedValue);
    }
    return InheritableBoolean.INHERIT;
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param, false);
            } else if ("INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param, true);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else if ("LIST".equals(param.type()) && param.permittedValues() != null) {
                w = renderListBox(g, param);
            } else {
                continue;
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            switch(param.type()) {
                case "STRING":
                case "INT":
                case "LONG":
                    w = renderTextBox(g, param);
                    break;
                case "BOOLEAN":
                    w = renderCheckBox(g, param);
                    break;
                case "LIST":
                    w = renderListBox(g, param);
                    break;
                case "ARRAY":
                    w = renderTextArea(g, param);
                    break;
                default:
                    throw new UnsupportedOperationException("unsupported widget type");
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#end_block

#method_before
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param, boolean numbersOnly) {
    NpTextBox textBox = numbersOnly ? new NpIntTextBox() : new NpTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        addWidget(g, p, param);
    } else {
        textBox.setValue(param.value());
        addWidget(g, textBox, param);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#method_after
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextBox textBox = param.type().equals("STRING") ? new NpTextBox() : new NpIntTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        addWidget(g, p, param);
    } else {
        textBox.setValue(param.value());
        addWidget(g, textBox, param);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#end_block

#method_before
private ListBox renderListBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    ListBox listBox = new ListBox();
    if (param.inheritable()) {
        listBox.addItem(Util.M.pluginProjectInheritedListValue(param.inheritedValue()));
        if (param.configuredValue() == null) {
            listBox.setSelectedIndex(0);
        }
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.configuredValue())) {
                listBox.setSelectedIndex(i + 1);
            }
        }
    } else {
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.value())) {
                listBox.setSelectedIndex(i);
            }
        }
    }
    if (param.editable()) {
        saveEnabler.listenTo(listBox);
        addWidget(g, listBox, param);
    } else {
        listBox.setEnabled(false);
        if (param.inheritable() && listBox.getSelectedIndex() != 0) {
            // the inherited value is not selected,
            // since the listBox is disabled the inherited value cannot be
            // seen and we have to display it explicitly
            Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
            inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
            HorizontalPanel p = new HorizontalPanel();
            p.add(listBox);
            p.add(inheritedLabel);
            addWidget(g, p, param);
        } else {
            addWidget(g, listBox, param);
        }
    }
    return listBox;
}
#method_after
private ListBox renderListBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    if (param.permittedValues() == null) {
        return null;
    }
    ListBox listBox = new ListBox();
    if (param.inheritable()) {
        listBox.addItem(Util.M.pluginProjectInheritedListValue(param.inheritedValue()));
        if (param.configuredValue() == null) {
            listBox.setSelectedIndex(0);
        }
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.configuredValue())) {
                listBox.setSelectedIndex(i + 1);
            }
        }
    } else {
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.value())) {
                listBox.setSelectedIndex(i);
            }
        }
    }
    if (param.editable()) {
        saveEnabler.listenTo(listBox);
        addWidget(g, listBox, param);
    } else {
        listBox.setEnabled(false);
        if (param.inheritable() && listBox.getSelectedIndex() != 0) {
            // the inherited value is not selected,
            // since the listBox is disabled the inherited value cannot be
            // seen and we have to display it explicitly
            Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
            inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
            HorizontalPanel p = new HorizontalPanel();
            p.add(listBox);
            p.add(inheritedLabel);
            addWidget(g, p, param);
        } else {
            addWidget(g, listBox, param);
        }
    }
    return listBox;
}
#end_block

#method_before
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), com.google.gerrit.extensions.common.ProjectSubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), com.google.gerrit.extensions.common.ProjectStatus.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), value);
            }
        }
    }
    return pluginConfigValues;
}
#method_after
private Map<String, Map<String, ConfigParameterValue>> getPluginConfigValues() {
    Map<String, Map<String, ConfigParameterValue>> pluginConfigValues = new HashMap<>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, ConfigParameterValue> values = new HashMap<>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ConfigParameterValue.create().value(((TextBox) widget).getValue().trim()));
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), ConfigParameterValue.create().value(Boolean.toString(((CheckBox) widget).getValue())));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), ConfigParameterValue.create().value(value));
            } else if (widget instanceof NpTextArea) {
                String text = ((NpTextArea) widget).getText().trim();
                values.put(e2.getKey(), ConfigParameterValue.create().values(text.split("\n")));
            } else {
                throw new UnsupportedOperationException("unsupported widget type");
            }
        }
    }
    return pluginConfigValues;
}
#end_block

#method_before
@Override
public void populateDownloadCommandLinks() {
    if (!urls.isEmpty()) {
        if (allowedCommands.contains(DownloadCommand.CHECKOUT) || allowedCommands.contains(DownloadCommand.DEFAULT_DOWNLOADS)) {
            commands.add(cmdLinkfactory.new CloneCommandLink());
        }
    }
}
#method_after
@Override
public void populateDownloadCommandLinks() {
    if (!urls.isEmpty()) {
        if (allowedCommands.contains(DownloadCommand.CHECKOUT) || allowedCommands.contains(DownloadCommand.DEFAULT_DOWNLOADS)) {
            commands.add(cmdLinkfactory.new CloneCommandLink());
            if (Gerrit.getConfig().getSshdAddress() != null && hasUserName()) {
                commands.add(cmdLinkfactory.new CloneWithCommitMsgHookCommandLink(getProjectKey()));
            }
        }
    }
}
#end_block

#method_before
@Override
public void onValueChange(final ValueChangeEvent<ChangeDetail> event) {
    if (isAttached() && isLastValueChangeHandler()) {
        // Until this screen is fully migrated to the new API, these calls must
        // happen sequentially after the ChangeDetail lookup, because we can't
        // start an async get at the source of every call that might trigger a
        // value change.
        CallbackGroup cbs1 = new CallbackGroup();
        final CallbackGroup cbs2 = new CallbackGroup();
        final PatchSet.Id psId = event.getValue().getCurrentPatchSet().getId();
        final Map<String, Patch> patches = new HashMap<String, Patch>();
        String revId = event.getValue().getCurrentPatchSetDetail().getInfo().getRevId();
        if (event.getValue().getChange().getStatus().isOpen()) {
            ChangeApi.revision(changeId.get(), "current").view("submit_type").get(cbs1.add(new GerritCallback<NativeString>() {

                @Override
                public void onSuccess(NativeString result) {
                    event.getValue().setSubmitTypeRecord(SubmitTypeRecord.OK(ProjectSubmitType.valueOf(result.asString())));
                }

                public void onFailure(Throwable caught) {
                }
            }));
        }
        if (Gerrit.isSignedIn()) {
            ChangeApi.revision(changeId.get(), "" + psId.get()).view("related").get(cbs1.add(new AsyncCallback<RelatedChanges.RelatedInfo>() {

                @Override
                public void onSuccess(RelatedChanges.RelatedInfo info) {
                    if (info.changes() != null) {
                        dependsOn(info);
                        neededBy(info);
                    }
                }

                private void dependsOn(RelatedChanges.RelatedInfo info) {
                    ChangeAndCommit self = null;
                    Map<String, ChangeAndCommit> m = new HashMap<String, ChangeAndCommit>();
                    for (int i = 0; i < info.changes().length(); i++) {
                        ChangeAndCommit c = info.changes().get(i);
                        if (changeId.equals(c.legacy_id())) {
                            self = c;
                        }
                        if (c.commit() != null && c.commit().commit() != null) {
                            m.put(c.commit().commit(), c);
                        }
                    }
                    if (self != null && self.commit() != null && self.commit().parents() != null) {
                        List<ChangeInfo> d = new ArrayList<ChangeInfo>();
                        for (CommitInfo p : Natives.asList(self.commit().parents())) {
                            ChangeAndCommit pc = m.get(p.commit());
                            if (pc != null && pc.has_change_number()) {
                                ChangeInfo i = new ChangeInfo();
                                load(pc, i);
                                d.add(i);
                            }
                        }
                        event.getValue().setDependsOn(d);
                    }
                }

                private void neededBy(RelatedChanges.RelatedInfo info) {
                    Set<String> mine = new HashSet<String>();
                    for (PatchSet ps : event.getValue().getPatchSets()) {
                        mine.add(ps.getRevision().get());
                    }
                    List<ChangeInfo> n = new ArrayList<ChangeInfo>();
                    for (int i = 0; i < info.changes().length(); i++) {
                        ChangeAndCommit c = info.changes().get(i);
                        if (c.has_change_number() && c.commit() != null && c.commit().parents() != null) {
                            for (int j = 0; j < c.commit().parents().length(); j++) {
                                CommitInfo p = c.commit().parents().get(j);
                                if (mine.contains(p.commit())) {
                                    ChangeInfo u = new ChangeInfo();
                                    load(c, u);
                                    n.add(u);
                                    break;
                                }
                            }
                        }
                    }
                    event.getValue().setNeededBy(n);
                }

                private void load(final ChangeAndCommit pc, final ChangeInfo i) {
                    RestApi call = ChangeApi.change(pc.legacy_id().get());
                    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.CURRENT_REVISION));
                    call.get(cbs2.add(new AsyncCallback<com.google.gerrit.client.changes.ChangeInfo>() {

                        public void onFailure(Throwable caught) {
                        }

                        public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) {
                            i.set(ChangeDetailCache.toChange(result), pc.patch_set_id());
                            i.setStarred(result.starred());
                            event.getValue().getAccounts().merge(ChangeDetailCache.users(result));
                        }
                    }));
                }

                public void onFailure(Throwable caught) {
                }
            }));
            ChangeApi.revision(changeId.get(), revId).view("files").addParameterTrue("reviewed").get(cbs1.add(new AsyncCallback<JsArrayString>() {

                @Override
                public void onSuccess(JsArrayString result) {
                    for (int i = 0; i < result.length(); i++) {
                        String path = result.get(i);
                        Patch p = patches.get(path);
                        if (p == null) {
                            p = new Patch(new Patch.Key(psId, path));
                            patches.put(path, p);
                        }
                        p.setReviewedByCurrentUser(true);
                    }
                }

                public void onFailure(Throwable caught) {
                }
            }));
            final Set<PatchSet.Id> withDrafts = new HashSet<PatchSet.Id>();
            event.getValue().setPatchSetsWithDraftComments(withDrafts);
            for (PatchSet ps : event.getValue().getPatchSets()) {
                if (!ps.getId().equals(psId)) {
                    final PatchSet.Id id = ps.getId();
                    ChangeApi.revision(changeId.get(), "" + id.get()).view("drafts").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

                        @Override
                        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                            if (!result.isEmpty()) {
                                withDrafts.add(id);
                            }
                        }

                        public void onFailure(Throwable caught) {
                        }
                    }));
                }
            }
            ChangeApi.revision(changeId.get(), "" + psId.get()).view("drafts").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

                @Override
                public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                    for (String path : result.keySet()) {
                        Patch p = patches.get(path);
                        if (p == null) {
                            p = new Patch(new Patch.Key(psId, path));
                            patches.put(path, p);
                        }
                        p.setDraftCount(result.get(path).length());
                    }
                    if (!result.isEmpty()) {
                        withDrafts.add(psId);
                    }
                }

                public void onFailure(Throwable caught) {
                }
            }));
        }
        ChangeApi.revision(changeId.get(), revId).view("comments").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                for (String path : result.keySet()) {
                    Patch p = patches.get(path);
                    if (p == null) {
                        p = new Patch(new Patch.Key(psId, path));
                        patches.put(path, p);
                    }
                    p.setCommentCount(result.get(path).length());
                }
            }

            public void onFailure(Throwable caught) {
            }
        }));
        DiffApi.list(changeId.get(), null, revId, new AsyncCallback<NativeMap<FileInfo>>() {

            @Override
            public void onSuccess(NativeMap<FileInfo> result) {
                JsArray<FileInfo> fileInfos = result.values();
                FileInfo.sortFileInfoByPath(fileInfos);
                List<Patch> list = new ArrayList<Patch>(fileInfos.length());
                for (FileInfo f : Natives.asList(fileInfos)) {
                    Patch p = patches.get(f.path());
                    if (p == null) {
                        p = new Patch(new Patch.Key(psId, f.path()));
                        patches.put(f.path(), p);
                    }
                    p.setInsertions(f.lines_inserted());
                    p.setDeletions(f.lines_deleted());
                    p.setPatchType(f.binary() ? PatchType.BINARY : PatchType.UNIFIED);
                    if (f.status() == null) {
                        p.setChangeType(ChangeType.MODIFIED);
                    } else {
                        p.setChangeType(ChangeType.forCode(f.status().charAt(0)));
                    }
                    list.add(p);
                }
                event.getValue().getCurrentPatchSetDetail().setPatches(list);
            }

            public void onFailure(Throwable caught) {
            }
        });
        ConfigInfoCache.get(event.getValue().getChange().getProject(), cbs1.add(new GerritCallback<ConfigInfoCache.Entry>() {

            @Override
            public void onSuccess(ConfigInfoCache.Entry result) {
                commentLinkProcessor = result.getCommentLinkProcessor();
                setTheme(result.getTheme());
            }

            @Override
            public void onFailure(Throwable caught) {
            // Handled by last callback's onFailure.
            }
        }));
        ChangeApi.detail(changeId.get(), cbs1.addFinal(new GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() {

            @Override
            public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) {
                changeInfo = result;
                cbs2.addFinal(new AsyncCallback<Void>() {

                    @Override
                    public void onSuccess(Void result) {
                        display(event.getValue());
                    }

                    public void onFailure(Throwable caught) {
                    }
                }).onSuccess(null);
            }
        }));
    }
}
#method_after
@Override
public void onValueChange(final ValueChangeEvent<ChangeDetail> event) {
    if (isAttached() && isLastValueChangeHandler()) {
        // Until this screen is fully migrated to the new API, these calls must
        // happen sequentially after the ChangeDetail lookup, because we can't
        // start an async get at the source of every call that might trigger a
        // value change.
        CallbackGroup cbs1 = new CallbackGroup();
        final CallbackGroup cbs2 = new CallbackGroup();
        final PatchSet.Id psId = event.getValue().getCurrentPatchSet().getId();
        final Map<String, Patch> patches = new HashMap<String, Patch>();
        String revId = event.getValue().getCurrentPatchSetDetail().getInfo().getRevId();
        if (event.getValue().getChange().getStatus().isOpen()) {
            ChangeApi.revision(changeId.get(), "current").view("submit_type").get(cbs1.add(new GerritCallback<NativeString>() {

                @Override
                public void onSuccess(NativeString result) {
                    event.getValue().setSubmitTypeRecord(SubmitTypeRecord.OK(SubmitType.valueOf(result.asString())));
                }

                public void onFailure(Throwable caught) {
                }
            }));
        }
        if (Gerrit.isSignedIn()) {
            ChangeApi.revision(changeId.get(), "" + psId.get()).view("related").get(cbs1.add(new AsyncCallback<RelatedChanges.RelatedInfo>() {

                @Override
                public void onSuccess(RelatedChanges.RelatedInfo info) {
                    if (info.changes() != null) {
                        dependsOn(info);
                        neededBy(info);
                    }
                }

                private void dependsOn(RelatedChanges.RelatedInfo info) {
                    ChangeAndCommit self = null;
                    Map<String, ChangeAndCommit> m = new HashMap<String, ChangeAndCommit>();
                    for (int i = 0; i < info.changes().length(); i++) {
                        ChangeAndCommit c = info.changes().get(i);
                        if (changeId.equals(c.legacy_id())) {
                            self = c;
                        }
                        if (c.commit() != null && c.commit().commit() != null) {
                            m.put(c.commit().commit(), c);
                        }
                    }
                    if (self != null && self.commit() != null && self.commit().parents() != null) {
                        List<ChangeInfo> d = new ArrayList<ChangeInfo>();
                        for (CommitInfo p : Natives.asList(self.commit().parents())) {
                            ChangeAndCommit pc = m.get(p.commit());
                            if (pc != null && pc.has_change_number()) {
                                ChangeInfo i = new ChangeInfo();
                                load(pc, i);
                                d.add(i);
                            }
                        }
                        event.getValue().setDependsOn(d);
                    }
                }

                private void neededBy(RelatedChanges.RelatedInfo info) {
                    Set<String> mine = new HashSet<String>();
                    for (PatchSet ps : event.getValue().getPatchSets()) {
                        mine.add(ps.getRevision().get());
                    }
                    List<ChangeInfo> n = new ArrayList<ChangeInfo>();
                    for (int i = 0; i < info.changes().length(); i++) {
                        ChangeAndCommit c = info.changes().get(i);
                        if (c.has_change_number() && c.commit() != null && c.commit().parents() != null) {
                            for (int j = 0; j < c.commit().parents().length(); j++) {
                                CommitInfo p = c.commit().parents().get(j);
                                if (mine.contains(p.commit())) {
                                    ChangeInfo u = new ChangeInfo();
                                    load(c, u);
                                    n.add(u);
                                    break;
                                }
                            }
                        }
                    }
                    event.getValue().setNeededBy(n);
                }

                private void load(final ChangeAndCommit pc, final ChangeInfo i) {
                    RestApi call = ChangeApi.change(pc.legacy_id().get());
                    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.CURRENT_REVISION));
                    call.get(cbs2.add(new AsyncCallback<com.google.gerrit.client.changes.ChangeInfo>() {

                        public void onFailure(Throwable caught) {
                        }

                        public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) {
                            i.set(ChangeDetailCache.toChange(result), pc.patch_set_id());
                            i.setStarred(result.starred());
                            event.getValue().getAccounts().merge(ChangeDetailCache.users(result));
                        }
                    }));
                }

                public void onFailure(Throwable caught) {
                }
            }));
            ChangeApi.revision(changeId.get(), revId).view("files").addParameterTrue("reviewed").get(cbs1.add(new AsyncCallback<JsArrayString>() {

                @Override
                public void onSuccess(JsArrayString result) {
                    for (int i = 0; i < result.length(); i++) {
                        String path = result.get(i);
                        Patch p = patches.get(path);
                        if (p == null) {
                            p = new Patch(new Patch.Key(psId, path));
                            patches.put(path, p);
                        }
                        p.setReviewedByCurrentUser(true);
                    }
                }

                public void onFailure(Throwable caught) {
                }
            }));
            final Set<PatchSet.Id> withDrafts = new HashSet<PatchSet.Id>();
            event.getValue().setPatchSetsWithDraftComments(withDrafts);
            for (PatchSet ps : event.getValue().getPatchSets()) {
                if (!ps.getId().equals(psId)) {
                    final PatchSet.Id id = ps.getId();
                    ChangeApi.revision(changeId.get(), "" + id.get()).view("drafts").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

                        @Override
                        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                            if (!result.isEmpty()) {
                                withDrafts.add(id);
                            }
                        }

                        public void onFailure(Throwable caught) {
                        }
                    }));
                }
            }
            ChangeApi.revision(changeId.get(), "" + psId.get()).view("drafts").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

                @Override
                public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                    for (String path : result.keySet()) {
                        Patch p = patches.get(path);
                        if (p == null) {
                            p = new Patch(new Patch.Key(psId, path));
                            patches.put(path, p);
                        }
                        p.setDraftCount(result.get(path).length());
                    }
                    if (!result.isEmpty()) {
                        withDrafts.add(psId);
                    }
                }

                public void onFailure(Throwable caught) {
                }
            }));
        }
        ChangeApi.revision(changeId.get(), revId).view("comments").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                for (String path : result.keySet()) {
                    Patch p = patches.get(path);
                    if (p == null) {
                        p = new Patch(new Patch.Key(psId, path));
                        patches.put(path, p);
                    }
                    p.setCommentCount(result.get(path).length());
                }
            }

            public void onFailure(Throwable caught) {
            }
        }));
        DiffApi.list(changeId.get(), null, revId, new AsyncCallback<NativeMap<FileInfo>>() {

            @Override
            public void onSuccess(NativeMap<FileInfo> result) {
                JsArray<FileInfo> fileInfos = result.values();
                FileInfo.sortFileInfoByPath(fileInfos);
                List<Patch> list = new ArrayList<Patch>(fileInfos.length());
                for (FileInfo f : Natives.asList(fileInfos)) {
                    Patch p = patches.get(f.path());
                    if (p == null) {
                        p = new Patch(new Patch.Key(psId, f.path()));
                        patches.put(f.path(), p);
                    }
                    p.setInsertions(f.lines_inserted());
                    p.setDeletions(f.lines_deleted());
                    p.setPatchType(f.binary() ? PatchType.BINARY : PatchType.UNIFIED);
                    if (f.status() == null) {
                        p.setChangeType(ChangeType.MODIFIED);
                    } else {
                        p.setChangeType(ChangeType.forCode(f.status().charAt(0)));
                    }
                    list.add(p);
                }
                event.getValue().getCurrentPatchSetDetail().setPatches(list);
            }

            public void onFailure(Throwable caught) {
            }
        });
        ConfigInfoCache.get(event.getValue().getChange().getProject(), cbs1.add(new GerritCallback<ConfigInfoCache.Entry>() {

            @Override
            public void onSuccess(ConfigInfoCache.Entry result) {
                commentLinkProcessor = result.getCommentLinkProcessor();
                setTheme(result.getTheme());
            }

            @Override
            public void onFailure(Throwable caught) {
            // Handled by last callback's onFailure.
            }
        }));
        ChangeApi.detail(changeId.get(), cbs1.addFinal(new GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() {

            @Override
            public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) {
                changeInfo = result;
                cbs2.addFinal(new AsyncCallback<Void>() {

                    @Override
                    public void onSuccess(Void result) {
                        display(event.getValue());
                    }

                    public void onFailure(Throwable caught) {
                    }
                }).onSuccess(null);
            }
        }));
    }
}
#end_block

#method_before
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(Objects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("repository", "*", "defaultSubmitType", ProjectSubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#method_after
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(Objects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("repository", "*", "defaultSubmitType", SubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#end_block

#method_before
private boolean isHidden() {
    return getProject().getState().equals(ProjectStatus.HIDDEN);
}
#method_after
private boolean isHidden() {
    return getProject().getState().equals(com.google.gerrit.extensions.api.projects.ProjectState.HIDDEN);
}
#end_block

#method_before
@Override
protected ProjectSubmitType getSubmitType() {
    return ProjectSubmitType.REBASE_IF_NECESSARY;
}
#method_after
@Override
protected SubmitType getSubmitType() {
    return SubmitType.REBASE_IF_NECESSARY;
}
#end_block

#method_before
private boolean refresh(Change change, PatchSet ps, ProjectSubmitType type, Repository git, Map<String, Ref> refs, Ref ref) throws IOException, OrmException {
    RevWalk rw = new RevWalk(git) {

        @Override
        protected CodeReviewCommit createCommit(AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    try {
        ObjectId id;
        try {
            id = ObjectId.fromString(ps.getRevision().get());
        } catch (IllegalArgumentException e) {
            log.error(String.format("Invalid revision on patch set %d of %d", ps.getId().get(), change.getId().get()));
            return false;
        }
        RevFlag canMerge = rw.newFlag("CAN_MERGE");
        CodeReviewCommit rev = parse(rw, id);
        rev.add(canMerge);
        boolean mergeable;
        if (ref == null || ref.getObjectId() == null) {
            // Assume yes on new branch.
            mergeable = true;
        } else {
            CodeReviewCommit tip = parse(rw, ref.getObjectId());
            Set<RevCommit> accepted = alreadyAccepted(rw, refs.values());
            accepted.add(tip);
            accepted.addAll(Arrays.asList(rev.getParents()));
            mergeable = submitStrategyFactory.create(type, db.get(), git, rw, null, /*inserter*/
            canMerge, accepted, change.getDest()).dryRun(tip, rev);
        }
        Change c = db.get().changes().get(change.getId());
        if (c != null) {
            c.setMergeable(mergeable);
            c.setLastSha1MergeTested(toRevId(ref));
            db.get().changes().update(Collections.singleton(c));
            indexer.index(db.get(), c);
        }
        return mergeable;
    } catch (MergeException | IOException | NoSuchProjectException e) {
        log.error(String.format("Cannot merge test change %d", change.getId().get()), e);
        return false;
    } finally {
        rw.release();
    }
}
#method_after
private boolean refresh(Change change, final PatchSet ps, SubmitType type, Repository git, Map<String, Ref> refs, final Ref ref) throws IOException, OrmException {
    RevWalk rw = new RevWalk(git) {

        @Override
        protected CodeReviewCommit createCommit(AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    try {
        ObjectId id;
        try {
            id = ObjectId.fromString(ps.getRevision().get());
        } catch (IllegalArgumentException e) {
            log.error(String.format("Invalid revision on patch set %d of %d", ps.getId().get(), change.getId().get()));
            return false;
        }
        RevFlag canMerge = rw.newFlag("CAN_MERGE");
        CodeReviewCommit rev = parse(rw, id);
        rev.add(canMerge);
        final boolean mergeable;
        if (ref == null || ref.getObjectId() == null) {
            // Assume yes on new branch.
            mergeable = true;
        } else {
            CodeReviewCommit tip = parse(rw, ref.getObjectId());
            Set<RevCommit> accepted = alreadyAccepted(rw, refs.values());
            accepted.add(tip);
            accepted.addAll(Arrays.asList(rev.getParents()));
            mergeable = submitStrategyFactory.create(type, db.get(), git, rw, null, /*inserter*/
            canMerge, accepted, change.getDest()).dryRun(tip, rev);
        }
        Change c = db.get().changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                if (c.getStatus().isOpen() && ps.getId().equals(c.currentPatchSetId())) {
                    c.setMergeable(mergeable);
                    c.setLastSha1MergeTested(toRevId(ref));
                    return c;
                } else {
                    return null;
                }
            }
        });
        if (c != null) {
            indexer.index(db.get(), c);
        }
        return mergeable;
    } catch (MergeException | IOException | NoSuchProjectException e) {
        log.error(String.format("Cannot merge test change %d", change.getId().get()), e);
        return false;
    } finally {
        rw.release();
    }
}
#end_block

#method_before
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = args.changeDataFactory.create(db.get(), c).currentFilePaths();
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(args, c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(filePredicates));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                ProjectSubmitType submitType = getSubmitType(otherChange, object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try {
                    Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    try {
                        RevWalk rw = new RevWalk(repo) {

                            @Override
                            protected RevCommit createCommit(AnyObjectId id) {
                                return new CodeReviewCommit(id);
                            }
                        };
                        try {
                            RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                            CodeReviewCommit commit = (CodeReviewCommit) rw.parseCommit(changeDataCache.getTestAgainst());
                            SubmitStrategy strategy = args.submitStrategyFactory.create(submitType, db.get(), repo, rw, null, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest());
                            CodeReviewCommit otherCommit = (CodeReviewCommit) rw.parseCommit(other);
                            otherCommit.add(canMergeFlag);
                            conflicts = !strategy.dryRun(commit, otherCommit);
                            args.conflictsCache.put(conflictsKey, conflicts);
                            return conflicts;
                        } catch (MergeException e) {
                            throw new IllegalStateException(e);
                        } catch (NoSuchProjectException e) {
                            throw new IllegalStateException(e);
                        } finally {
                            rw.release();
                        }
                    } finally {
                        repo.close();
                    }
                } catch (IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private ProjectSubmitType getSubmitType(Change change, ChangeData cd) throws OrmException {
                try {
                    final SubmitTypeRecord r = args.changeControlGenericFactory.controlFor(change, args.userFactory.create(change.getOwner())).getSubmitTypeRecord(db.get(), cd.currentPatchSet(), cd);
                    if (r.status != SubmitTypeRecord.Status.OK) {
                        return null;
                    }
                    return r.type;
                } catch (NoSuchChangeException e) {
                    return null;
                }
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws MergeException {
                Set<RevCommit> alreadyAccepted = Sets.newHashSet();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (ObjectId id : changeDataCache.getAlreadyAccepted(repo)) {
                        try {
                            alreadyAccepted.add(rw.parseCommit(id));
                        } catch (IncorrectObjectTypeException iote) {
                        // Not a commit? Skip over it.
                        }
                    }
                } catch (IOException e) {
                    throw new MergeException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#method_after
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = args.changeDataFactory.create(db.get(), c).currentFilePaths();
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(args, c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(filePredicates));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(otherChange, object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try {
                    Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    try {
                        RevWalk rw = new RevWalk(repo) {

                            @Override
                            protected RevCommit createCommit(AnyObjectId id) {
                                return new CodeReviewCommit(id);
                            }
                        };
                        try {
                            RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                            CodeReviewCommit commit = (CodeReviewCommit) rw.parseCommit(changeDataCache.getTestAgainst());
                            SubmitStrategy strategy = args.submitStrategyFactory.create(submitType, db.get(), repo, rw, null, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest());
                            CodeReviewCommit otherCommit = (CodeReviewCommit) rw.parseCommit(other);
                            otherCommit.add(canMergeFlag);
                            conflicts = !strategy.dryRun(commit, otherCommit);
                            args.conflictsCache.put(conflictsKey, conflicts);
                            return conflicts;
                        } catch (MergeException e) {
                            throw new IllegalStateException(e);
                        } catch (NoSuchProjectException e) {
                            throw new IllegalStateException(e);
                        } finally {
                            rw.release();
                        }
                    } finally {
                        repo.close();
                    }
                } catch (IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(Change change, ChangeData cd) throws OrmException {
                try {
                    final SubmitTypeRecord r = args.changeControlGenericFactory.controlFor(change, args.userFactory.create(change.getOwner())).getSubmitTypeRecord(db.get(), cd.currentPatchSet(), cd);
                    if (r.status != SubmitTypeRecord.Status.OK) {
                        return null;
                    }
                    return r.type;
                } catch (NoSuchChangeException e) {
                    return null;
                }
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws MergeException {
                Set<RevCommit> alreadyAccepted = Sets.newHashSet();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (ObjectId id : changeDataCache.getAlreadyAccepted(repo)) {
                        try {
                            alreadyAccepted.add(rw.parseCommit(id));
                        } catch (IncorrectObjectTypeException iote) {
                        // Not a commit? Skip over it.
                        }
                    }
                } catch (IOException e) {
                    throw new MergeException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadPluginSections(rc);
    maxObjectSizeLimit = rc.getLong(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, 0);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#end_block

#method_before
public ProjectSubmitType getSubmitType() {
    return submitType;
}
#method_after
public SubmitType getSubmitType() {
    return submitType;
}
#end_block

#method_before
public void setSubmitType(final ProjectSubmitType type) {
    submitType = type;
}
#method_after
public void setSubmitType(final SubmitType type) {
    submitType = type;
}
#end_block

#method_before
public ProjectStatus getState() {
    return state;
}
#method_after
public ProjectState getState() {
    return state;
}
#end_block

#method_before
public void setState(final ProjectStatus newState) {
    state = newState;
}
#method_after
public void setState(final ProjectState newState) {
    state = newState;
}
#end_block

#method_before
public ChangeControl forUser(final CurrentUser who) {
    return new ChangeControl(approvalsUtil, changeDataFactory, getRefControl().forUser(who), notes);
}
#method_after
public ChangeControl forUser(final CurrentUser who) {
    if (getCurrentUser().equals(who)) {
        return this;
    }
    return new ChangeControl(approvalsUtil, changeDataFactory, getRefControl().forUser(who), notes);
}
#end_block

#method_before
public SubmitTypeRecord getSubmitTypeRecord(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd) {
    cd = changeData(db, cd);
    try {
        if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
        if (patchSet.isDraft() && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
    } catch (OrmException err) {
        return logTypeRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(db, patchSet, getProjectControl(), this, getChange(), cd, false, "locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results");
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        return logTypeRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return typeRuleError("Project submit rule has no solution");
    }
    Term typeTerm = results.get(0);
    if (!typeTerm.isSymbol()) {
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " did not return a symbol.");
        return typeRuleError("Project submit rule has invalid solution");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(ProjectSubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return logInvalidType(evaluator.getSubmitRule(), typeName);
    }
}
#method_after
public SubmitTypeRecord getSubmitTypeRecord(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd) {
    cd = changeData(db, cd);
    try {
        if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
        if (patchSet.isDraft() && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
    } catch (OrmException err) {
        return logTypeRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(db, patchSet, getProjectControl(), this, getChange(), cd, false, "locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results");
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        return logTypeRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return typeRuleError("Project submit rule has no solution");
    }
    Term typeTerm = results.get(0);
    if (!typeTerm.isSymbol()) {
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " did not return a symbol.");
        return typeRuleError("Project submit rule has invalid solution");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return logInvalidType(evaluator.getSubmitRule(), typeName);
    }
}
#end_block

#method_before
@Override
public ProjectSubmitType apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = Objects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(db, rsrc.getPatchSet(), rsrc.getControl().getProjectControl(), rsrc.getControl(), rsrc.getChange(), changeDataFactory.create(db, rsrc.getChange()), false, "locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", input.filters == Filters.SKIP, input.rule != null ? new ByteArrayInputStream(input.rule.getBytes(UTF_8)) : null);
    List<Term> results;
    try {
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        throw new BadRequestException(String.format("rule failed with exception: %s", e.getMessage()));
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solution", evaluator.getSubmitRule()));
    }
    Term type = results.get(0);
    if (!type.isSymbol()) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
    String typeName = ((SymbolTerm) type).name();
    try {
        return ProjectSubmitType.valueOf(typeName.toUpperCase());
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
}
#method_after
@Override
public SubmitType apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = Objects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(db, rsrc.getPatchSet(), rsrc.getControl().getProjectControl(), rsrc.getControl(), rsrc.getChange(), changeDataFactory.create(db, rsrc.getChange()), false, "locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", input.filters == Filters.SKIP, input.rule != null ? new ByteArrayInputStream(input.rule.getBytes(UTF_8)) : null);
    List<Term> results;
    try {
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        throw new BadRequestException(String.format("rule failed with exception: %s", e.getMessage()));
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solution", evaluator.getSubmitRule()));
    }
    Term type = results.get(0);
    if (!type.isSymbol()) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
    String typeName = ((SymbolTerm) type).name();
    try {
        return SubmitType.valueOf(typeName.toUpperCase());
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
}
#end_block

#method_before
@Override
public ProjectSubmitType apply(RevisionResource resource) throws AuthException, BadRequestException {
    return test.apply(resource, null);
}
#method_after
@Override
public SubmitType apply(RevisionResource resource) throws AuthException, BadRequestException {
    return test.apply(resource, null);
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    try {
        if (!suggestParent) {
            if (projectName == null) {
                throw new UnloggedFailure(1, "fatal: Project name is required.");
            }
            ProjectInput input = new ProjectInput();
            input.name = projectName;
            if (ownerIds != null) {
                input.owners = Lists.transform(ownerIds, new Function<AccountGroup.UUID, String>() {

                    @Override
                    public String apply(AccountGroup.UUID uuid) {
                        return uuid.get();
                    }
                });
            }
            if (newParent != null) {
                input.parent = newParent.getProject().getName();
            }
            input.permissionsOnly = permissionsOnly;
            input.description = projectDescription;
            input.submitType = submitType;
            input.useContributorAgreements = contributorAgreements;
            input.useSignedOffBy = signedOffBy;
            input.useContentMerge = contentMerge;
            input.requireChangeId = requireChangeID;
            input.branches = branch;
            input.createEmptyCommit = createEmptyCommit;
            input.maxObjectSizeLimit = maxObjectSizeLimit;
            if (pluginConfigValues != null) {
                input.pluginConfigValues = parsePluginConfigValues(pluginConfigValues);
            }
            gApi.projects().create(input);
        } else {
            List<Project.NameKey> parentCandidates = suggestParentCandidatesFactory.create().getNameKeys();
            for (Project.NameKey parent : parentCandidates) {
                stdout.print(parent + "\n");
            }
        }
    } catch (RestApiException | OrmException | NoSuchProjectException err) {
        throw new UnloggedFailure(1, "fatal: " + err.getMessage(), err);
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    try {
        if (!suggestParent) {
            if (projectName == null) {
                throw new UnloggedFailure(1, "fatal: Project name is required.");
            }
            ProjectInput input = new ProjectInput();
            input.name = projectName;
            if (ownerIds != null) {
                input.owners = Lists.transform(ownerIds, new Function<AccountGroup.UUID, String>() {

                    @Override
                    public String apply(AccountGroup.UUID uuid) {
                        return uuid.get();
                    }
                });
            }
            if (newParent != null) {
                input.parent = newParent.getProject().getName();
            }
            input.permissionsOnly = permissionsOnly;
            input.description = projectDescription;
            input.submitType = submitType;
            input.useContributorAgreements = contributorAgreements;
            input.useSignedOffBy = signedOffBy;
            input.useContentMerge = contentMerge;
            input.requireChangeId = requireChangeID;
            input.branches = branch;
            input.createEmptyCommit = createEmptyCommit;
            input.maxObjectSizeLimit = maxObjectSizeLimit;
            if (pluginConfigValues != null) {
                input.pluginConfigValues = parsePluginConfigValues(pluginConfigValues);
            }
            createProjectFactory.get().create(projectName).apply(TopLevelResource.INSTANCE, input);
        } else {
            List<Project.NameKey> parentCandidates = suggestParentCandidatesFactory.create().getNameKeys();
            for (Project.NameKey parent : parentCandidates) {
                stdout.print(parent + "\n");
            }
        }
    } catch (RestApiException | ProjectCreationFailedException | IOException | NoSuchProjectException | OrmException err) {
        throw new UnloggedFailure(1, "fatal: " + err.getMessage(), err);
    }
}
#end_block

#method_before
private Map<String, Map<String, String>> parsePluginConfigValues(List<String> pluginConfigValues) throws UnloggedFailure {
    Map<String, Map<String, String>> m = new HashMap<>();
    for (String pluginConfigValue : pluginConfigValues) {
        String[] s = pluginConfigValue.split("=");
        String[] s2 = s[0].split("\\.");
        if (s.length != 2 || s2.length != 2) {
            throw new UnloggedFailure(1, "Invalid plugin config value '" + pluginConfigValue + "', expected format '<plugin-name>.<parameter-name>=<value>'");
        }
        String value = s[1];
        String pluginName = s2[0];
        String paramName = s2[1];
        Map<String, String> l = m.get(pluginName);
        if (l == null) {
            l = new HashMap<>();
            m.put(pluginName, l);
        }
        l.put(paramName, value);
    }
    return m;
}
#method_after
@VisibleForTesting
Map<String, Map<String, ConfigValue>> parsePluginConfigValues(List<String> pluginConfigValues) throws UnloggedFailure {
    Map<String, Map<String, ConfigValue>> m = new HashMap<>();
    for (String pluginConfigValue : pluginConfigValues) {
        String[] s = pluginConfigValue.split("=");
        String[] s2 = s[0].split("\\.");
        if (s.length != 2 || s2.length != 2) {
            throw new UnloggedFailure(1, "Invalid plugin config value '" + pluginConfigValue + "', expected format '<plugin-name>.<parameter-name>=<value>'" + " or '<plugin-name>.<parameter-name>=<value1,value2,...>'");
        }
        ConfigValue value = new ConfigValue();
        String v = s[1];
        if (v.contains(",")) {
            value.values = Lists.newArrayList(Splitter.on(",").split(v));
        } else {
            value.value = v;
        }
        String pluginName = s2[0];
        String paramName = s2[1];
        Map<String, ConfigValue> l = m.get(pluginName);
        if (l == null) {
            l = new HashMap<>();
            m.put(pluginName, l);
        }
        l.put(paramName, value);
    }
    return m;
}
#end_block

#method_before
private Map<String, Map<String, ConfigParameterInfo>> getPluginConfig(ProjectState project, DynamicMap<ProjectConfigEntry> pluginConfigEntries, PluginConfigFactory cfgFactory, AllProjectsNameProvider allProjects) {
    TreeMap<String, Map<String, ConfigParameterInfo>> pluginConfig = new TreeMap<>();
    for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
        ProjectConfigEntry configEntry = e.getProvider().get();
        PluginConfig cfg = cfgFactory.getFromProjectConfig(project, e.getPluginName());
        String configuredValue = cfg.getString(e.getExportName());
        ConfigParameterInfo p = new ConfigParameterInfo();
        p.displayName = configEntry.getDisplayName();
        p.description = configEntry.getDescription();
        p.warning = configEntry.getWarning(project);
        p.type = configEntry.getType();
        p.permittedValues = configEntry.getPermittedValues();
        p.editable = configEntry.isEditable(project) ? true : null;
        if (configEntry.isInheritable() && !allProjects.get().equals(project.getProject().getNameKey())) {
            PluginConfig cfgWithInheritance = cfgFactory.getFromProjectConfigWithInheritance(project, e.getPluginName());
            p.inheritable = true;
            p.value = cfgWithInheritance.getString(e.getExportName(), configEntry.getDefaultValue());
            p.configuredValue = configuredValue;
            p.inheritedValue = getInheritedValue(project, cfgFactory, e);
        } else {
            p.value = configuredValue != null ? configuredValue : configEntry.getDefaultValue();
        }
        Map<String, ConfigParameterInfo> pc = pluginConfig.get(e.getPluginName());
        if (pc == null) {
            pc = new TreeMap<>();
            pluginConfig.put(e.getPluginName(), pc);
        }
        pc.put(e.getExportName(), p);
    }
    return !pluginConfig.isEmpty() ? pluginConfig : null;
}
#method_after
private Map<String, Map<String, ConfigParameterInfo>> getPluginConfig(ProjectState project, DynamicMap<ProjectConfigEntry> pluginConfigEntries, PluginConfigFactory cfgFactory, AllProjectsNameProvider allProjects) {
    TreeMap<String, Map<String, ConfigParameterInfo>> pluginConfig = new TreeMap<>();
    for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
        ProjectConfigEntry configEntry = e.getProvider().get();
        PluginConfig cfg = cfgFactory.getFromProjectConfig(project, e.getPluginName());
        String configuredValue = cfg.getString(e.getExportName());
        ConfigParameterInfo p = new ConfigParameterInfo();
        p.displayName = configEntry.getDisplayName();
        p.description = configEntry.getDescription();
        p.warning = configEntry.getWarning(project);
        p.type = configEntry.getType();
        p.permittedValues = configEntry.getPermittedValues();
        p.editable = configEntry.isEditable(project) ? true : null;
        if (configEntry.isInheritable() && !allProjects.get().equals(project.getProject().getNameKey())) {
            PluginConfig cfgWithInheritance = cfgFactory.getFromProjectConfigWithInheritance(project, e.getPluginName());
            p.inheritable = true;
            p.value = cfgWithInheritance.getString(e.getExportName(), configEntry.getDefaultValue());
            p.configuredValue = configuredValue;
            p.inheritedValue = getInheritedValue(project, cfgFactory, e);
        } else {
            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                p.values = Arrays.asList(cfg.getStringList(e.getExportName()));
            } else {
                p.value = configuredValue != null ? configuredValue : configEntry.getDefaultValue();
            }
        }
        Map<String, ConfigParameterInfo> pc = pluginConfig.get(e.getPluginName());
        if (pc == null) {
            pc = new TreeMap<>();
            pluginConfig.put(e.getPluginName(), pc);
        }
        pc.put(e.getExportName(), p);
    }
    return !pluginConfig.isEmpty() ? pluginConfig : null;
}
#end_block

#method_before
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        RefUpdate branchUpdate = openBranch();
        boolean reopen = false;
        final ListMultimap<ProjectSubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<ProjectSubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            final Set<ProjectSubmitType> submitTypes = new HashSet<ProjectSubmitType>(toMerge.keySet());
            for (final ProjectSubmitType submitType : submitTypes) {
                if (reopen) {
                    branchUpdate = openBranch();
                }
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                updateBranch(strategy, branchUpdate);
                reopen = true;
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.statusCode = null;
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        updateChangeStatus(toUpdate);
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.notes, message(commit.getChange(), capable.getMessage()), false);
            }
        }
    } catch (NoSuchProjectException noProject) {
        log.warn(String.format("Project %s no longer exists, abandoning open changes", destBranch.getParentKey().get()));
        abandonAllOpenChanges();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        RefUpdate branchUpdate = openBranch();
        boolean reopen = false;
        final ListMultimap<SubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<SubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            final Set<SubmitType> submitTypes = new HashSet<SubmitType>(toMerge.keySet());
            for (final SubmitType submitType : submitTypes) {
                if (reopen) {
                    branchUpdate = openBranch();
                }
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                RefUpdate update = updateBranch(strategy, branchUpdate);
                reopen = true;
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                if (update != null) {
                    fireRefUpdated(update);
                }
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.setStatusCode(null);
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        updateChangeStatus(toUpdate);
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.notes(), message(commit.change(), capable.getMessage()), false);
            }
        }
    } catch (NoSuchProjectException noProject) {
        log.warn(String.format("Project %s no longer exists, abandoning open changes", destBranch.getParentKey().get()));
        abandonAllOpenChanges();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
private boolean containsMissingCommits(final ListMultimap<ProjectSubmitType, CodeReviewCommit> map, final CodeReviewCommit commit) {
    if (!isSubmitForMissingCommitsStillPossible(commit)) {
        return false;
    }
    for (final CodeReviewCommit missingCommit : commit.missing) {
        if (!map.containsValue(missingCommit)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean containsMissingCommits(final ListMultimap<SubmitType, CodeReviewCommit> map, final CodeReviewCommit commit) {
    if (!isSubmitForMissingCommitsStillPossible(commit)) {
        return false;
    }
    for (final CodeReviewCommit missingCommit : commit.missing) {
        if (!map.containsValue(missingCommit)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isSubmitForMissingCommitsStillPossible(final CodeReviewCommit commit) {
    if (commit.missing == null || commit.missing.isEmpty()) {
        return false;
    }
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // 
            return false;
        }
        if (!missingCommit.getChange().currentPatchSetId().equals(missingCommit.patchsetId)) {
            // 
            return false;
        }
    }
    return true;
}
#method_after
private boolean isSubmitForMissingCommitsStillPossible(final CodeReviewCommit commit) {
    if (commit.missing == null || commit.missing.isEmpty()) {
        return false;
    }
    for (CodeReviewCommit missingCommit : commit.missing) {
        try {
            loadChangeInfo(missingCommit);
        } catch (NoSuchChangeException | OrmException e) {
            log.error("Cannot check if missing commits can be submitted", e);
            return false;
        }
        if (missingCommit.getPatchsetId() == null) {
            // 
            return false;
        }
        if (!missingCommit.change().currentPatchSetId().equals(missingCommit.getPatchsetId())) {
            // 
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private SubmitStrategy createStrategy(final ProjectSubmitType submitType) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch);
}
#method_after
private SubmitStrategy createStrategy(final SubmitType submitType) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch);
}
#end_block

#method_before
private ListMultimap<ProjectSubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<ProjectSubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new MergeException(e.getMessage(), e);
    }
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            toUpdate.add(chg);
            continue;
        }
        commit.notes = notesFactory.create(chg);
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMerged(chg, null);
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final ProjectSubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            toUpdate.add(chg);
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new MergeException(e.getMessage(), e);
    }
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            toUpdate.add(chg);
            continue;
        }
        try {
            commit.setControl(changeControlFactory.controlFor(chg, identifiedUserFactory.create(chg.getOwner())));
        } catch (NoSuchChangeException e) {
            throw new MergeException("Failed to validate changes", e);
        }
        commit.setPatchsetId(ps.getId());
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.setStatusCode(CommitMergeStatus.ALREADY_MERGED);
                    try {
                        setMerged(chg, null);
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        SubmitType submitType = getSubmitType(commit.getControl(), ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            toUpdate.add(chg);
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private ProjectSubmitType getSubmitType(final Change change, final PatchSet ps) {
    try {
        final SubmitTypeRecord r = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner())).getSubmitTypeRecord(db, ps);
        if (r.status != SubmitTypeRecord.Status.OK) {
            log.error("Failed to get submit type for " + change.getKey());
            return null;
        }
        return r.type;
    } catch (NoSuchChangeException e) {
        log.error("Failed to get submit type for " + change.getKey(), e);
        return null;
    }
}
#method_after
private SubmitType getSubmitType(ChangeControl ctl, PatchSet ps) {
    SubmitTypeRecord r = ctl.getSubmitTypeRecord(db, ps);
    if (r.status != SubmitTypeRecord.Status.OK) {
        log.error("Failed to get submit type for " + ctl.getChange().getKey());
        return null;
    }
    return r.type;
}
#end_block

#method_before
private void updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if ((branchTip == null && mergeTip == null) || branchTip == mergeTip) {
        // nothing to do
        return;
    }
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getProject().getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject.getProject());
                        destProject = projectCache.get(destProject.getProject().getNameKey());
                        repoManager.setProjectDescription(destProject.getProject().getNameKey(), destProject.getProject().getDescription());
                    }
                    gitRefUpdated.fire(destBranch.getParentKey(), branchUpdate);
                    Account account = null;
                    PatchSetApproval submitter = approvalsUtil.getSubmitter(db, mergeTip.notes, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    String msg;
                    if (strategy.retryOnLockFailure()) {
                        mergeQueue.recheckAfter(destBranch, LOCK_FAILURE_RETRY_DELAY, MILLISECONDS);
                        msg = "will retry";
                    } else {
                        msg = "will not retry";
                    }
                    throw new IOException(branchUpdate.getResult().name() + ", " + msg);
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private RefUpdate updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if (branchTip == mergeTip || mergeTip == null) {
        // nothing to do
        return null;
    }
    if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
            cfg.load(repo, mergeTip);
        } catch (Exception e) {
            throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getProject().getName(), e);
        }
    }
    branchUpdate.setRefLogIdent(refLogIdent);
    branchUpdate.setForceUpdate(false);
    branchUpdate.setNewObjectId(mergeTip);
    branchUpdate.setRefLogMessage("merged", true);
    try {
        switch(branchUpdate.update(rw)) {
            case NEW:
            case FAST_FORWARD:
                if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                    tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                }
                if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
                    projectCache.evict(destProject.getProject());
                    destProject = projectCache.get(destProject.getProject().getNameKey());
                    repoManager.setProjectDescription(destProject.getProject().getNameKey(), destProject.getProject().getDescription());
                }
                return branchUpdate;
            case LOCK_FAILURE:
                String msg;
                if (strategy.retryOnLockFailure()) {
                    mergeQueue.recheckAfter(destBranch, LOCK_FAILURE_RETRY_DELAY, MILLISECONDS);
                    msg = "will retry";
                } else {
                    msg = "will not retry";
                }
                throw new IOException(branchUpdate.getResult().name() + ", " + msg);
            default:
                throw new IOException(branchUpdate.getResult().name());
        }
    } catch (IOException e) {
        throw new MergeException("Cannot update " + branchUpdate.getName(), e);
    }
}
#end_block

#method_before
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(commit, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        } catch (IOException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
    }
}
#method_after
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(commit, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        } catch (IOException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
    }
}
#end_block

#method_before
private Capable isSubmitStillPossible(final CodeReviewCommit commit) {
    final Capable capable;
    final Change c = commit.getChange();
    final boolean submitStillPossible = isSubmitForMissingCommitsStillPossible(commit);
    final long now = TimeUtil.nowMs();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
        capable = Capable.OK;
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change could not be merged because of a missing dependency.");
        m.append("\n");
        m.append("\n");
        m.append("The following changes must also be submitted:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            m.append("* ");
            m.append(missingCommit.getChange().getKey().get());
            m.append("\n");
        }
        capable = new Capable(m.toString());
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.getChange().getKey().abbreviate());
                if (missingCommit.patchsetId.get() != missingCommit.getChange().currentPatchSetId().get()) {
                    m.append(", however the current patch set is ");
                    m.append(missingCommit.getChange().currentPatchSetId().get());
                }
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        capable = new Capable(m.toString());
    }
    return capable;
}
#method_after
private Capable isSubmitStillPossible(final CodeReviewCommit commit) {
    final Capable capable;
    final Change c = commit.change();
    final boolean submitStillPossible = isSubmitForMissingCommitsStillPossible(commit);
    final long now = TimeUtil.nowMs();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
        capable = Capable.OK;
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change could not be merged because of a missing dependency.");
        m.append("\n");
        m.append("\n");
        m.append("The following changes must also be submitted:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            m.append("* ");
            m.append(missingCommit.change().getKey().get());
            m.append("\n");
        }
        capable = new Capable(m.toString());
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.getPatchsetId() != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.getPatchsetId().get());
                m.append(" of ");
                m.append(missingCommit.change().getKey().abbreviate());
                if (missingCommit.getPatchsetId().get() != missingCommit.change().currentPatchSetId().get()) {
                    m.append(", however the current patch set is ");
                    m.append(missingCommit.change().currentPatchSetId().get());
                }
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        capable = new Capable(m.toString());
    }
    return capable;
}
#end_block

#method_before
private void loadChangeInfo(final CodeReviewCommit commit) {
    if (commit.notes == null) {
        try {
            List<PatchSet> matches = db.patchSets().byRevision(new RevId(commit.name())).toList();
            if (matches.size() == 1) {
                final PatchSet ps = matches.get(0);
                commit.patchsetId = ps.getId();
                commit.notes = notesFactory.create(db.changes().get(ps.getId().getParentKey()));
            }
        } catch (OrmException e) {
        }
    }
}
#method_after
private void loadChangeInfo(final CodeReviewCommit commit) throws NoSuchChangeException, OrmException {
    if (commit.getControl() == null) {
        List<PatchSet> matches = db.patchSets().byRevision(new RevId(commit.name())).toList();
        if (matches.size() == 1) {
            PatchSet ps = matches.get(0);
            commit.setPatchsetId(ps.getId());
            commit.setControl(changeControl(db.changes().get(ps.getId().getParentKey())));
        }
    }
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.getChange().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
}
#method_after
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
}
#end_block

#method_before
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                final ChangeControl control = changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner()));
                final MergedSender cm = mergedSenderFactory.create(control);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(changeControl(c));
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void setNew(CodeReviewCommit c, ChangeMessage msg) {
    sendMergeFail(c.notes, msg, true);
}
#method_after
private void setNew(CodeReviewCommit c, ChangeMessage msg) {
    sendMergeFail(c.notes(), msg, true);
}
#end_block

#method_before
public ProjectSubmitType getSubmitType() {
    return submitType;
}
#method_after
public SubmitType getSubmitType() {
    return submitType;
}
#end_block

#method_before
@Override
protected ProjectSubmitType getSubmitType() {
    return ProjectSubmitType.FAST_FORWARD_ONLY;
}
#method_after
@Override
protected SubmitType getSubmitType() {
    return SubmitType.FAST_FORWARD_ONLY;
}
#end_block

#method_before
public static SubmitTypeRecord OK(ProjectSubmitType type) {
    SubmitTypeRecord r = new SubmitTypeRecord();
    r.status = Status.OK;
    r.type = type;
    return r;
}
#method_after
public static SubmitTypeRecord OK(SubmitType type) {
    SubmitTypeRecord r = new SubmitTypeRecord();
    r.status = Status.OK;
    r.type = type;
    return r;
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> data = new LogSoyData(req, view).toSoyData(paginator, null, df);
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        renderHtml(req, res, template_name, data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> data = new LogSoyData(req, view).toSoyData(paginator, null, df);
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        GitilesConfig.putVariant(getAccess(req).getConfig(), "logEntry", "logEntryVariant", data);
        renderHtml(req, res, "gitiles.logDetail", data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(CommitJsonData.toJsonData(c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(new CommitJsonData().setRevWalk(paginator.getWalk()).toJsonData(req, c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
boolean set(ChangeInfo info, boolean current) {
    List<String> names = new ArrayList<String>(info.labels());
    Collections.sort(names);
    boolean canSubmit = info.status().isOpen();
    resize(names.size(), 2);
    for (int row = 0; row < names.size(); row++) {
        String name = names.get(row);
        LabelInfo label = info.label(name);
        setText(row, 0, name);
        if (label.all() != null) {
            setWidget(row, 1, renderUsers(label));
        }
        getCellFormatter().setStyleName(row, 0, style.labelName());
        getCellFormatter().addStyleName(row, 0, getStyleForLabel(label));
        if (canSubmit && info.status() == Change.Status.NEW) {
            switch(label.status()) {
                case NEED:
                    if (current) {
                        statusText.setInnerText("Needs " + name);
                    }
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (current) {
                        statusText.setInnerText("Not " + name);
                    }
                    canSubmit = false;
                    break;
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#method_after
boolean set(ChangeInfo info, boolean current) {
    List<String> names = new ArrayList<>(info.labels());
    Collections.sort(names);
    boolean canSubmit = info.status().isOpen();
    resize(names.size(), 2);
    for (int row = 0; row < names.size(); row++) {
        String name = names.get(row);
        LabelInfo label = info.label(name);
        setText(row, 0, name);
        if (label.all() != null) {
            setWidget(row, 1, renderUsers(label));
        }
        getCellFormatter().setStyleName(row, 0, style.labelName());
        getCellFormatter().addStyleName(row, 0, getStyleForLabel(label));
        if (canSubmit && info.status() == Change.Status.NEW) {
            switch(label.status()) {
                case NEED:
                    if (current) {
                        statusText.setInnerText("Needs " + name);
                    }
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (current) {
                        statusText.setInnerText("Not " + name);
                    }
                    canSubmit = false;
                    break;
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#end_block

#method_before
private Widget renderUsers(LabelInfo label) {
    Map<Integer, List<ApprovalInfo>> m = new HashMap<Integer, List<ApprovalInfo>>(4);
    int approved = 0, rejected = 0;
    for (ApprovalInfo ai : Natives.asList(label.all())) {
        if (ai.value() != 0) {
            List<ApprovalInfo> l = m.get(Integer.valueOf(ai.value()));
            if (l == null) {
                l = new ArrayList<ApprovalInfo>(label.all().length());
                m.put(Integer.valueOf(ai.value()), l);
            }
            l.add(ai);
            if (isRejected(label, ai)) {
                rejected = ai.value();
            } else if (isApproved(label, ai)) {
                approved = ai.value();
            }
        }
    }
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    for (Integer v : sort(m.keySet(), approved, rejected)) {
        if (!html.isEmpty()) {
            html.br();
        }
        String val = LabelValue.formatValue(v.shortValue());
        html.openSpan();
        html.setAttribute("title", label.value_text(val));
        if (v.intValue() == approved) {
            html.setStyleName(style.label_ok());
        } else if (v.intValue() == rejected) {
            html.setStyleName(style.label_reject());
        }
        html.append(val).append(" ");
        html.append(formatUserList(style, m.get(v), Collections.<Integer>emptySet(), null));
        html.closeSpan();
    }
    return html.toBlockWidget();
}
#method_after
private Widget renderUsers(LabelInfo label) {
    Map<Integer, List<ApprovalInfo>> m = new HashMap<>(4);
    int approved = 0, rejected = 0;
    for (ApprovalInfo ai : Natives.asList(label.all())) {
        if (ai.value() != 0) {
            List<ApprovalInfo> l = m.get(Integer.valueOf(ai.value()));
            if (l == null) {
                l = new ArrayList<>(label.all().length());
                m.put(Integer.valueOf(ai.value()), l);
            }
            l.add(ai);
            if (isRejected(label, ai)) {
                rejected = ai.value();
            } else if (isApproved(label, ai)) {
                approved = ai.value();
            }
        }
    }
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    for (Integer v : sort(m.keySet(), approved, rejected)) {
        if (!html.isEmpty()) {
            html.br();
        }
        String val = LabelValue.formatValue(v.shortValue());
        html.openSpan();
        html.setAttribute("title", label.value_text(val));
        if (v.intValue() == approved) {
            html.setStyleName(style.label_ok());
        } else if (v.intValue() == rejected) {
            html.setStyleName(style.label_reject());
        }
        html.append(val).append(" ");
        html.append(formatUserList(style, m.get(v), Collections.<Integer>emptySet(), null));
        html.closeSpan();
    }
    return html.toBlockWidget();
}
#end_block

#method_before
private static List<Integer> sort(Set<Integer> keySet, int a, int b) {
    List<Integer> r = new ArrayList<Integer>(keySet);
    Collections.sort(r);
    if (keySet.contains(a)) {
        r.remove(Integer.valueOf(a));
        r.add(0, a);
    } else if (keySet.contains(b)) {
        r.remove(Integer.valueOf(b));
        r.add(0, b);
    }
    return r;
}
#method_after
private static List<Integer> sort(Set<Integer> keySet, int a, int b) {
    List<Integer> r = new ArrayList<>(keySet);
    Collections.sort(r);
    if (keySet.contains(a)) {
        r.remove(Integer.valueOf(a));
        r.add(0, a);
    } else if (keySet.contains(b)) {
        r.remove(Integer.valueOf(b));
        r.add(0, b);
    }
    return r;
}
#end_block

#method_before
static SafeHtml formatUserList(ChangeScreen2.Style style, Collection<? extends AccountInfo> in, Set<Integer> removable, Map<Integer, ApprovalDetail> votable) {
    List<AccountInfo> users = new ArrayList<AccountInfo>(in);
    Collections.sort(users, new Comparator<AccountInfo>() {

        @Override
        public int compare(AccountInfo a, AccountInfo b) {
            String as = name(a);
            String bs = name(b);
            if (as.isEmpty()) {
                return 1;
            } else if (bs.isEmpty()) {
                return -1;
            }
            return as.compareTo(bs);
        }

        private String name(AccountInfo a) {
            if (a.name() != null) {
                return a.name();
            } else if (a.email() != null) {
                return a.email();
            }
            return "";
        }
    });
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<? extends AccountInfo> itr = users.iterator();
    while (itr.hasNext()) {
        AccountInfo ai = itr.next();
        AvatarInfo img = ai.avatar(AvatarInfo.DEFAULT_SIZE);
        String name;
        if (ai.name() != null) {
            name = ai.name();
        } else if (ai.email() != null) {
            name = ai.email();
        } else {
            name = Integer.toString(ai._account_id());
        }
        String nonVotableCategories = "";
        if (votable != null) {
            Set<String> nonVotable = votable.get(ai._account_id()).nonVotable();
            if (!nonVotable.isEmpty()) {
                StringBuilder sb = new StringBuilder("Non votable: ");
                for (Iterator<String> it = nonVotable.iterator(); it.hasNext(); ) {
                    sb.append(it.next());
                    if (it.hasNext()) {
                        sb.append(", ");
                    }
                }
                nonVotableCategories = sb.toString();
            }
        }
        html.openSpan().setAttribute("role", "listitem").setAttribute(DATA_ID, ai._account_id()).setAttribute("title", nonVotableCategories).setStyleName(style.label_user());
        if (img != null) {
            html.openElement("img").setStyleName(style.avatar()).setAttribute("src", img.url());
            if (img.width() > 0) {
                html.setAttribute("width", img.width());
            }
            if (img.height() > 0) {
                html.setAttribute("height", img.height());
            }
            html.closeSelf();
        }
        html.append(name);
        if (removable.contains(ai._account_id())) {
            html.openElement("button").setAttribute("title", Util.M.removeReviewer(name)).setAttribute("onclick", REMOVE + "(event)").append(new ImageResourceRenderer().render(Resources.I.remove_reviewer())).closeElement("button");
        }
        html.closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#method_after
static SafeHtml formatUserList(ChangeScreen2.Style style, Collection<? extends AccountInfo> in, Set<Integer> removable, Map<Integer, VotableInfo> votable) {
    List<AccountInfo> users = new ArrayList<>(in);
    Collections.sort(users, new Comparator<AccountInfo>() {

        @Override
        public int compare(AccountInfo a, AccountInfo b) {
            String as = name(a);
            String bs = name(b);
            if (as.isEmpty()) {
                return 1;
            } else if (bs.isEmpty()) {
                return -1;
            }
            return as.compareTo(bs);
        }

        private String name(AccountInfo a) {
            if (a.name() != null) {
                return a.name();
            } else if (a.email() != null) {
                return a.email();
            }
            return "";
        }
    });
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<? extends AccountInfo> itr = users.iterator();
    while (itr.hasNext()) {
        AccountInfo ai = itr.next();
        AvatarInfo img = ai.avatar(AvatarInfo.DEFAULT_SIZE);
        String name;
        if (ai.name() != null) {
            name = ai.name();
        } else if (ai.email() != null) {
            name = ai.email();
        } else {
            name = Integer.toString(ai._account_id());
        }
        String votableCategories = "";
        if (votable != null) {
            Set<String> s = votable.get(ai._account_id()).votableLabels();
            if (!s.isEmpty()) {
                StringBuilder sb = new StringBuilder(Util.C.votable());
                sb.append(" ");
                for (Iterator<String> it = s.iterator(); it.hasNext(); ) {
                    sb.append(it.next());
                    if (it.hasNext()) {
                        sb.append(", ");
                    }
                }
                votableCategories = sb.toString();
            }
        }
        html.openSpan().setAttribute("role", "listitem").setAttribute(DATA_ID, ai._account_id()).setAttribute("title", getTitle(ai, votableCategories)).setStyleName(style.label_user());
        if (img != null) {
            html.openElement("img").setStyleName(style.avatar()).setAttribute("src", img.url());
            if (img.width() > 0) {
                html.setAttribute("width", img.width());
            }
            if (img.height() > 0) {
                html.setAttribute("height", img.height());
            }
            html.closeSelf();
        }
        html.append(name);
        if (removable.contains(ai._account_id())) {
            html.openElement("button").setAttribute("title", Util.M.removeReviewer(name)).setAttribute("onclick", REMOVE + "(event)").append(new ImageResourceRenderer().render(Resources.I.remove_reviewer())).closeElement("button");
        }
        html.closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#end_block

#method_before
void init(ChangeScreen2.Style style, Element reviewersText) {
    this.style = style;
    this.reviewersText = reviewersText;
}
#method_after
void init(ChangeScreen2.Style style, Element ccText) {
    this.style = style;
    this.ccText = ccText;
}
#end_block

#method_before
private void display(ChangeInfo info) {
    Map<Integer, AccountInfo> r = new HashMap<Integer, AccountInfo>();
    Map<Integer, AccountInfo> cc = new HashMap<Integer, AccountInfo>();
    for (LabelInfo label : Natives.asList(info.all_labels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._account_id(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    r.remove(info.owner()._account_id());
    cc.remove(info.owner()._account_id());
    Set<Integer> removable = new HashSet<Integer>();
    if (info.removable_reviewers() != null) {
        for (AccountInfo a : Natives.asList(info.removable_reviewers())) {
            removable.add(a._account_id());
        }
    }
    Map<Integer, ApprovalDetail> votable = votable(info);
    SafeHtml rHtml = Labels.formatUserList(style, r.values(), removable, votable);
    SafeHtml ccHtml = Labels.formatUserList(style, cc.values(), removable, votable);
    reviewersText.setInnerSafeHtml(rHtml);
    ccText.setInnerSafeHtml(ccHtml);
}
#method_after
private void display(ChangeInfo info) {
    Map<Integer, AccountInfo> r = new HashMap<>();
    Map<Integer, AccountInfo> cc = new HashMap<>();
    for (LabelInfo label : Natives.asList(info.all_labels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._account_id(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    r.remove(info.owner()._account_id());
    cc.remove(info.owner()._account_id());
    Set<Integer> removable = new HashSet<>();
    if (info.removable_reviewers() != null) {
        for (AccountInfo a : Natives.asList(info.removable_reviewers())) {
            removable.add(a._account_id());
        }
    }
    Map<Integer, VotableInfo> votable = votable(info);
    SafeHtml rHtml = Labels.formatUserList(style, r.values(), removable, votable);
    SafeHtml ccHtml = Labels.formatUserList(style, cc.values(), removable, votable);
    reviewersText.setInnerSafeHtml(rHtml);
    ccText.setInnerSafeHtml(ccHtml);
}
#end_block

#method_before
private static Map<Integer, ApprovalDetail> votable(ChangeInfo change) {
    Map<Integer, ApprovalDetail> d = new HashMap<Integer, ApprovalDetail>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._account_id();
                ApprovalDetail ad = d.get(id);
                if (ad == null) {
                    ad = new ApprovalDetail(new Account.Id(id));
                    d.put(id, ad);
                }
                if (ai.has_value()) {
                    ad.votable(name);
                }
                ad.value(name, ai.has_value() ? ai.value() : 0);
            }
        }
    }
    return d;
}
#method_after
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._account_id();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.has_value()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#end_block

#method_before
final List<FindReplace> commentlinks() {
    JsArray<CommentLinkInfo> cls = commentlinks0().values();
    List<FindReplace> commentLinks = new ArrayList<FindReplace>(cls.length());
    for (int i = 0; i < cls.length(); i++) {
        CommentLinkInfo cl = cls.get(i);
        if (!cl.enabled()) {
            continue;
        }
        if (cl.link() != null) {
            commentLinks.add(new LinkFindReplace(cl.match(), cl.link()));
        } else {
            try {
                FindReplace fr = new RawFindReplace(cl.match(), cl.html());
                commentLinks.add(fr);
            } catch (RuntimeException e) {
                new ErrorDialog(e.getMessage()).center();
            }
        }
    }
    return commentLinks;
}
#method_after
final List<FindReplace> commentlinks() {
    JsArray<CommentLinkInfo> cls = commentlinks0().values();
    List<FindReplace> commentLinks = new ArrayList<FindReplace>(cls.length());
    for (int i = 0; i < cls.length(); i++) {
        CommentLinkInfo cl = cls.get(i);
        if (!cl.enabled()) {
            continue;
        }
        if (cl.link() != null) {
            commentLinks.add(new LinkFindReplace(cl.match(), cl.link()));
        } else {
            try {
                FindReplace fr = new RawFindReplace(cl.match(), cl.html());
                commentLinks.add(fr);
            } catch (RuntimeException e) {
                int index = e.getMessage().indexOf("at Object");
                new ErrorDialog("Invalid commentlink configuration: " + (index == -1 ? e.getMessage() : e.getMessage().substring(0, index))).center();
            }
        }
    }
    return commentLinks;
}
#end_block

#method_before
private void insertPatch() {
    String id = revision.substring(0, 7);
    Anchor patchBase64 = new Anchor(id + ".diff.base64");
    patchBase64.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("download").url());
    Anchor patchZip = new Anchor(id + ".diff.zip");
    patchZip.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("zip").url());
    patchZip = new Anchor(id + ".tar.gz");
    patchZip.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("archive").url());
    HorizontalPanel p = new HorizontalPanel();
    p.add(patchBase64);
    InlineLabel spacer = new InlineLabel("|");
    spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
    p.add(spacer);
    p.add(patchZip);
    insertCommand("Patch-File", p);
}
#method_after
private void insertPatch() {
    String id = revision.substring(0, 7);
    Anchor patchBase64 = new Anchor(id + ".diff.base64");
    patchBase64.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("download").url());
    Anchor patchZip = new Anchor(id + ".diff.zip");
    patchZip.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("zip").url());
    HorizontalPanel p = new HorizontalPanel();
    p.add(patchBase64);
    InlineLabel spacer = new InlineLabel("|");
    spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
    p.add(spacer);
    p.add(patchZip);
    insertCommand("Patch-File", p);
}
#end_block

#method_before
private void insertArchive() {
    String id = revision.substring(0, 7);
    Anchor archive = new Anchor(id + ".tar.gz");
    archive.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("archive").url());
    HorizontalPanel p = new HorizontalPanel();
    p.add(archive);
    insertCommand("Archive", p);
}
#method_after
private void insertArchive() {
    List<Anchor> formats = new ArrayList<>(ARCHIVE.length);
    for (String f : ARCHIVE) {
        Anchor archive = new Anchor(f);
        archive.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("archive").addParameter("format", f).url());
        formats.add(archive);
    }
    HorizontalPanel p = new HorizontalPanel();
    Iterator<Anchor> it = formats.iterator();
    while (it.hasNext()) {
        Anchor a = it.next();
        p.add(a);
        if (it.hasNext()) {
            InlineLabel spacer = new InlineLabel("|");
            spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
            p.add(spacer);
        }
    }
    insertCommand("Archive", p);
}
#end_block

#method_before
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long refreshCookieAt = now() + refresh;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, xsrfToken);
    self.put(key, val);
    return val;
}
#method_after
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long now = now();
    final long refreshCookieAt = now + refresh;
    final long expiresAt = now + sessionMaxAgeMillis;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, xsrfToken, expiresAt);
    self.put(key.token, val);
    return val;
}
#end_block

#method_before
Val get(final Key key) {
    return self.getIfPresent(key.token);
}
#method_after
Val get(final Key key) {
    Val val = self.getIfPresent(key.token);
    if (val != null && val.expiresAt <= now()) {
        self.invalidate(key.token);
        return null;
    }
    return val;
}
#end_block

#method_before
private void writeObject(final ObjectOutputStream out) throws IOException {
    writeVarInt32(out, 1);
    writeVarInt32(out, accountId.get());
    writeVarInt32(out, 2);
    writeFixInt64(out, refreshCookieAt);
    writeVarInt32(out, 3);
    writeVarInt32(out, persistentCookie ? 1 : 0);
    if (externalId != null) {
        writeVarInt32(out, 4);
        writeString(out, externalId.get());
    }
    writeVarInt32(out, 5);
    writeString(out, xsrfToken);
    writeVarInt32(out, 0);
}
#method_after
private void writeObject(final ObjectOutputStream out) throws IOException {
    writeVarInt32(out, 1);
    writeVarInt32(out, accountId.get());
    writeVarInt32(out, 2);
    writeFixInt64(out, refreshCookieAt);
    writeVarInt32(out, 3);
    writeVarInt32(out, persistentCookie ? 1 : 0);
    if (externalId != null) {
        writeVarInt32(out, 4);
        writeString(out, externalId.get());
    }
    writeVarInt32(out, 5);
    writeString(out, xsrfToken);
    writeVarInt32(out, 6);
    writeFixInt64(out, expiresAt);
    writeVarInt32(out, 0);
}
#end_block

#method_before
private void readObject(final ObjectInputStream in) throws IOException {
    PARSE: for (; ; ) {
        final int tag = readVarInt32(in);
        switch(tag) {
            case 0:
                break PARSE;
            case 1:
                accountId = new Account.Id(readVarInt32(in));
                continue;
            case 2:
                refreshCookieAt = readFixInt64(in);
                continue;
            case 3:
                persistentCookie = readVarInt32(in) != 0;
                continue;
            case 4:
                externalId = new AccountExternalId.Key(readString(in));
                continue;
            case 5:
                xsrfToken = readString(in);
                continue;
            default:
                throw new IOException("Unknown tag found in object: " + tag);
        }
    }
}
#method_after
private void readObject(final ObjectInputStream in) throws IOException {
    PARSE: for (; ; ) {
        final int tag = readVarInt32(in);
        switch(tag) {
            case 0:
                break PARSE;
            case 1:
                accountId = new Account.Id(readVarInt32(in));
                continue;
            case 2:
                refreshCookieAt = readFixInt64(in);
                continue;
            case 3:
                persistentCookie = readVarInt32(in) != 0;
                continue;
            case 4:
                externalId = new AccountExternalId.Key(readString(in));
                continue;
            case 5:
                xsrfToken = readString(in);
                continue;
            case 6:
                expiresAt = readFixInt64(in);
                continue;
            default:
                throw new IOException("Unknown tag found in object: " + tag);
        }
    }
    if (expiresAt == 0) {
        expiresAt = refreshCookieAt + TimeUnit.HOURS.toMillis(2);
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InMemoryCacheModule());
    modules.add(new H2BackedPersistentCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PushReplication.Module());
    modules.add(new PluginModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(new MasterNodeStartup());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(new MasterNodeStartup());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sshInjector.getInstance(WebModule.class));
    modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(RequestContextFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sshInjector.getInstance(WebModule.class));
    modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(FILE_NAME, PatchListKey.class, PatchList.class).memoryLimit(// very large items, cache only a few
            128).populateWith(PatchListLoader.class);
            persist(INTRA_NAME, IntraLineDiffKey.class, IntraLineDiff.class).memoryLimit(// very large items, cache only a few
            128).populateWith(IntraLineLoader.class);
            bind(PatchListCacheImpl.class);
            bind(PatchListCache.class).to(PatchListCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(FILE_NAME, PatchListKey.class, PatchList.class).maximumWeight(10 << 20).loader(PatchListLoader.class).weigher(PatchListWeigher.class);
            persist(INTRA_NAME, IntraLineDiffKey.class, IntraLineDiff.class).maximumWeight(10 << 20).loader(IntraLineLoader.class).weigher(IntraLineWeigher.class);
            bind(PatchListCacheImpl.class);
            bind(PatchListCache.class).to(PatchListCacheImpl.class);
        }
    };
}
#end_block

#method_before
public PatchList get(PatchListKey key) {
    try {
        return fileCache.get(key);
    } catch (ExecutionException e) {
        PatchListLoader.log.warn("Error computing " + key, e);
        // TODO Handle PatchList errors in callers.
        return null;
    }
}
#method_after
@Override
public PatchList get(PatchListKey key) throws PatchListNotAvailableException {
    try {
        return fileCache.get(key);
    } catch (ExecutionException e) {
        PatchListLoader.log.warn("Error computing " + key, e);
        throw new PatchListNotAvailableException(e.getCause());
    }
}
#end_block

#method_before
public PatchList get(final Change change, final PatchSet patchSet) {
    final Project.NameKey projectKey = change.getProject();
    final ObjectId a = null;
    final ObjectId b = ObjectId.fromString(patchSet.getRevision().get());
    final Whitespace ws = Whitespace.IGNORE_NONE;
    return get(new PatchListKey(projectKey, a, b, ws));
}
#method_after
@Override
public PatchList get(final Change change, final PatchSet patchSet) throws PatchListNotAvailableException {
    final Project.NameKey projectKey = change.getProject();
    final ObjectId a = null;
    final ObjectId b = ObjectId.fromString(patchSet.getRevision().get());
    final Whitespace ws = Whitespace.IGNORE_NONE;
    return get(new PatchListKey(projectKey, a, b, ws));
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).populateWith(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).loader(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Inject
void setPersistentCacheFactory(@Nullable PersistentCacheFactory factory) {
    this.store = factory;
}
#method_after
@Inject(optional = true)
void setPersistentCacheFactory(@Nullable PersistentCacheFactory factory) {
    this.persistentCacheFactory = factory;
}
#end_block

#method_before
CacheBinding<K, V> persist(boolean p) {
    persist = p;
    return this;
}
#method_after
CacheBinding<K, V> persist(boolean p) {
    Preconditions.checkState(!frozen, "binding frozen, cannot be modified");
    persist = p;
    return this;
}
#end_block

#method_before
@Override
public Cache<K, V> get() {
    CacheBuilder<K, V> builder = newCacheBuilder();
    builder.maximumSize(maxSize);
    if (0 < maxAge) {
        builder.expireAfterWrite(maxAge, TimeUnit.SECONDS);
    }
    if (loader != null) {
        CacheLoader<K, V> ldr = loader.get();
        if (persist && store != null) {
            return store.build(name, keyType, valType, builder, ldr);
        }
        return builder.build(ldr);
    } else if (persist && store != null) {
        return store.build(name, keyType, valType, builder);
    } else {
        return builder.build();
    }
}
#method_after
@Override
public Cache<K, V> get() {
    frozen = true;
    if (loader != null) {
        CacheLoader<K, V> ldr = loader.get();
        if (persist && persistentCacheFactory != null) {
            return persistentCacheFactory.build(this, ldr);
        }
        return memoryCacheFactory.build(this, ldr);
    } else if (persist && persistentCacheFactory != null) {
        return persistentCacheFactory.build(this);
    } else {
        return memoryCacheFactory.build(this);
    }
}
#end_block

#method_before
protected <K, V> CacheBinding<K, V> cache(String name, TypeLiteral<K> keyType, TypeLiteral<V> valType) {
    Type type = Types.newParameterizedType(Cache.class, keyType.getType(), valType.getType());
    @SuppressWarnings("unchecked")
    Key<Cache<K, V>> key = (Key<Cache<K, V>>) Key.get(type, Names.named(name));
    CacheProvider<K, V> m = new CacheProvider<K, V>(name, keyType, valType, this);
    bind(key).toProvider(m).in(Scopes.SINGLETON);
    bind(ANY_CACHE).annotatedWith(Exports.named(name)).to(key);
    return m.memoryLimit(1024);
}
#method_after
protected <K, V> CacheBinding<K, V> cache(String name, TypeLiteral<K> keyType, TypeLiteral<V> valType) {
    Type type = Types.newParameterizedType(Cache.class, keyType.getType(), valType.getType());
    @SuppressWarnings("unchecked")
    Key<Cache<K, V>> key = (Key<Cache<K, V>>) Key.get(type, Names.named(name));
    CacheProvider<K, V> m = new CacheProvider<K, V>(this, name, keyType, valType);
    bind(key).toProvider(m).in(Scopes.SINGLETON);
    bind(ANY_CACHE).annotatedWith(Exports.named(name)).to(key);
    return m.maximumWeight(1024);
}
#end_block

#method_before
<K, V> Provider<CacheLoader<K, V>> bindCacheLoader(CacheProvider<K, V> m, Class<? extends CacheLoader<K, V>> impl) {
    Type type = Types.newParameterizedType(Cache.class, m.keyType.getType(), m.valType.getType());
    Type loadingType = Types.newParameterizedType(LoadingCache.class, m.keyType.getType(), m.valType.getType());
    Type loaderType = Types.newParameterizedType(CacheLoader.class, m.keyType.getType(), m.valType.getType());
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> key = (Key<LoadingCache<K, V>>) Key.get(type, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> loadingKey = (Key<LoadingCache<K, V>>) Key.get(loadingType, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<CacheLoader<K, V>> loaderKey = (Key<CacheLoader<K, V>>) Key.get(loaderType, Names.named(m.name));
    bind(loaderKey).to(impl).in(Scopes.SINGLETON);
    bind(loadingKey).to(key);
    return getProvider(loaderKey);
}
#method_after
<K, V> Provider<CacheLoader<K, V>> bindCacheLoader(CacheProvider<K, V> m, Class<? extends CacheLoader<K, V>> impl) {
    Type type = Types.newParameterizedType(Cache.class, m.keyType().getType(), m.valueType().getType());
    Type loadingType = Types.newParameterizedType(LoadingCache.class, m.keyType().getType(), m.valueType().getType());
    Type loaderType = Types.newParameterizedType(CacheLoader.class, m.keyType().getType(), m.valueType().getType());
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> key = (Key<LoadingCache<K, V>>) Key.get(type, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> loadingKey = (Key<LoadingCache<K, V>>) Key.get(loadingType, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<CacheLoader<K, V>> loaderKey = (Key<CacheLoader<K, V>>) Key.get(loaderType, Names.named(m.name));
    bind(loaderKey).to(impl).in(Scopes.SINGLETON);
    bind(loadingKey).to(key);
    return getProvider(loaderKey);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(WebSessionManager.CACHE_NAME, String.class, Val.class).memoryLimit(// reasonable default for many sites
            1024).maxAge(MAX_AGE_MINUTES, // expire sessions if they are inactive
            MINUTES);
            bind(WebSessionManager.class);
            bind(WebSession.class).to(CacheBasedWebSession.class).in(RequestScoped.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(WebSessionManager.CACHE_NAME, String.class, Val.class).maximumWeight(// reasonable default for many sites
            1024).expireAfterWrite(MAX_AGE_MINUTES, // expire sessions if they are inactive
            MINUTES);
            bind(WebSessionManager.class);
            bind(WebSession.class).to(CacheBasedWebSession.class).in(RequestScoped.class);
        }
    };
}
#end_block

#method_before
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, "");
}
#method_after
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, "", 0);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, ProjectState.class).populateWith(Loader.class);
            cache(CACHE_LIST, ListKey.class, new TypeLiteral<SortedSet<Project.NameKey>>() {
            }).memoryLimit(1).populateWith(Lister.class);
            bind(ProjectCacheImpl.class);
            bind(ProjectCache.class).to(ProjectCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, ProjectState.class).loader(Loader.class);
            cache(CACHE_LIST, ListKey.class, new TypeLiteral<SortedSet<Project.NameKey>>() {
            }).maximumWeight(1).loader(Lister.class);
            bind(ProjectCacheImpl.class);
            bind(ProjectCache.class).to(ProjectCacheImpl.class);
        }
    };
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYINCLUDE_NAME, AccountGroup.UUID.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
            }).populateWith(ByIncludeLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYINCLUDE_NAME, AccountGroup.UUID.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
            }).loader(ByIncludeLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
protected void run() {
    nw = columns - 50;
    Date now = new Date();
    stdout.format("%-25s %-20s      now  %16s\n", "Gerrit Code Review", Version.getVersion() != null ? Version.getVersion() : "", new SimpleDateFormat("HH:mm:ss   zzz").format(now));
    stdout.format("%-25s %-20s   uptime %16s\n", "", "", uptime(now.getTime() - serverStarted));
    stdout.print('\n');
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%-21s|  %-5s |%-9s|\n", // 
    "", // 
    "Name", // 
    "Entries", // 
    "AvgGet", // 
    "Hit Ratio"));
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%6s %6s %7s|  %-5s  |%-4s %-4s|\n", // 
    "", // 
    "", // 
    "Mem", // 
    "Disk", // 
    "Space", // 
    "", // 
    "Mem", // 
    "Disk"));
    stdout.print("--");
    for (int i = 0; i < nw; i++) {
        stdout.print('-');
    }
    stdout.print("+---------------------+---------+---------+\n");
    Map<String, H2BackedCache<?, ?>> disks = Maps.newTreeMap();
    printMemoryCaches(disks, sortedCoreCaches());
    printMemoryCaches(disks, sortedPluginCaches());
    for (Map.Entry<String, H2BackedCache<?, ?>> entry : disks.entrySet()) {
        H2BackedCache<?, ?> cache = entry.getValue();
        CacheStats stat = cache.stats();
        H2BackedCache.DiskStats disk = cache.diskStats();
        stdout.print(String.format("D %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), count(disk.size()), bytes(disk.space()), duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), percent(disk.hitCount(), disk.requestCount())));
    }
    stdout.print('\n');
    if (gc) {
        System.gc();
        System.runFinalization();
        System.gc();
    }
    sshSummary();
    taskSummary();
    memSummary();
    if (showJVM) {
        jvmSummary();
    }
    stdout.flush();
}
#method_after
@Override
protected void run() {
    nw = columns - 50;
    Date now = new Date();
    stdout.format("%-25s %-20s      now  %16s\n", "Gerrit Code Review", Version.getVersion() != null ? Version.getVersion() : "", new SimpleDateFormat("HH:mm:ss   zzz").format(now));
    stdout.format("%-25s %-20s   uptime %16s\n", "", "", uptime(now.getTime() - serverStarted));
    stdout.print('\n');
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%-21s|  %-5s |%-9s|\n", // 
    "", // 
    "Name", // 
    "Entries", // 
    "AvgGet", // 
    "Hit Ratio"));
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%6s %6s %7s|  %-5s  |%-4s %-4s|\n", // 
    "", // 
    "", // 
    "Mem", // 
    "Disk", // 
    "Space", // 
    "", // 
    "Mem", // 
    "Disk"));
    stdout.print("--");
    for (int i = 0; i < nw; i++) {
        stdout.print('-');
    }
    stdout.print("+---------------------+---------+---------+\n");
    Map<String, H2CacheImpl<?, ?>> disks = Maps.newTreeMap();
    printMemoryCaches(disks, sortedCoreCaches());
    printMemoryCaches(disks, sortedPluginCaches());
    for (Map.Entry<String, H2CacheImpl<?, ?>> entry : disks.entrySet()) {
        H2CacheImpl<?, ?> cache = entry.getValue();
        CacheStats stat = cache.stats();
        H2CacheImpl.DiskStats disk = cache.diskStats();
        stdout.print(String.format("D %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), count(disk.size()), bytes(disk.space()), duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), percent(disk.hitCount(), disk.requestCount())));
    }
    stdout.print('\n');
    if (gc) {
        System.gc();
        System.runFinalization();
        System.gc();
    }
    sshSummary();
    taskSummary();
    memSummary();
    if (showJVM) {
        jvmSummary();
    }
    stdout.flush();
}
#end_block

#method_before
private void printMemoryCaches(Map<String, H2BackedCache<?, ?>> disks, Map<String, Cache<?, ?>> caches) {
    for (Map.Entry<String, Cache<?, ?>> entry : caches.entrySet()) {
        Cache<?, ?> cache = entry.getValue();
        if (cache instanceof H2BackedCache) {
            disks.put(entry.getKey(), (H2BackedCache<?, ?>) cache);
            continue;
        }
        CacheStats stat = cache.stats();
        stdout.print(String.format("  %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), "", "", duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), ""));
    }
}
#method_after
private void printMemoryCaches(Map<String, H2CacheImpl<?, ?>> disks, Map<String, Cache<?, ?>> caches) {
    for (Map.Entry<String, Cache<?, ?>> entry : caches.entrySet()) {
        Cache<?, ?> cache = entry.getValue();
        if (cache instanceof H2CacheImpl) {
            disks.put(entry.getKey(), (H2CacheImpl<?, ?>) cache);
            continue;
        }
        CacheStats stat = cache.stats();
        stdout.print(String.format("  %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), "", "", duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), ""));
    }
}
#end_block

#method_before
private String duration(double ns) {
    if (Math.abs(ns) < 0.01) {
        return "";
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#method_after
private String duration(double ns) {
    if (ns < 0.5) {
        return "";
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Set<Account.Id>>() {
            }).populateWith(Loader.class);
            bind(AccountByEmailCacheImpl.class);
            bind(AccountByEmailCache.class).to(AccountByEmailCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Set<Account.Id>>() {
            }).loader(Loader.class);
            bind(AccountByEmailCacheImpl.class);
            bind(AccountByEmailCache.class).to(AccountByEmailCacheImpl.class);
        }
    };
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, Account.Id.class, AccountState.class).populateWith(ByIdLoader.class);
            cache(BYUSER_NAME, String.class, new TypeLiteral<Optional<Account.Id>>() {
            }).populateWith(ByNameLoader.class);
            bind(AccountCacheImpl.class);
            bind(AccountCache.class).to(AccountCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, Account.Id.class, AccountState.class).loader(ByIdLoader.class);
            cache(BYUSER_NAME, String.class, new TypeLiteral<Optional<Account.Id>>() {
            }).loader(ByNameLoader.class);
            bind(AccountCacheImpl.class);
            bind(AccountCache.class).to(AccountCacheImpl.class);
        }
    };
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).populateWith(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).populateWith(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).populateWith(ByUUIDLoader.class);
            cache(BYEXT_NAME, String.class, new TypeLiteral<Collection<AccountGroup>>() {
            }).populateWith(ByExternalNameLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByUUIDLoader.class);
            cache(BYEXT_NAME, String.class, new TypeLiteral<Collection<AccountGroup>>() {
            }).loader(ByExternalNameLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InMemoryCacheModule());
    modules.add(new H2BackedPersistentCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PushReplication.Module());
    modules.add(new PluginModule());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
        modules.add(new ProjectQoSFilter.Module());
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(RequestContextFilter.module());
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
        modules.add(new ProjectQoSFilter.Module());
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).maxAge(1, HOURS).populateWith(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).populateWith(LdapRealm.UserLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
}
#method_after
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).loader(LdapRealm.UserLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    if (threads <= 0) {
        threads = 1;
    }
    dbInjector = createDbInjector(MULTI_USER);
    gitInjector = dbInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            install(SchemaVersionCheck.module());
            bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(Scopes.SINGLETON);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class).in(Scopes.SINGLETON);
            install(AccountCacheImpl.module());
            install(GroupCacheImpl.module());
            install(new InMemoryCacheModule());
            install(new H2BackedPersistentCacheFactory.Module());
            install(new FactoryModule() {

                @Override
                protected void configure() {
                    factory(CreateCodeReviewNotes.Factory.class);
                }
            });
            install(new LifecycleModule() {

                @Override
                protected void configure() {
                    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
                }
            });
        }
    });
    manager.add(dbInjector, gitInjector);
    manager.start();
    gitInjector.injectMembers(this);
    List<Change> allChangeList = allChanges();
    monitor.beginTask("Scanning changes", allChangeList.size());
    changes = cluster(allChangeList);
    allChangeList = null;
    monitor.startWorkers(threads);
    for (int tid = 0; tid < threads; tid++) {
        new Worker().start();
    }
    monitor.waitForCompletion();
    monitor.endTask();
    manager.stop();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    if (threads <= 0) {
        threads = 1;
    }
    dbInjector = createDbInjector(MULTI_USER);
    gitInjector = dbInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            install(SchemaVersionCheck.module());
            bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(Scopes.SINGLETON);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class).in(Scopes.SINGLETON);
            install(AccountCacheImpl.module());
            install(GroupCacheImpl.module());
            install(new DefaultCacheFactory.Module());
            install(new FactoryModule() {

                @Override
                protected void configure() {
                    factory(CreateCodeReviewNotes.Factory.class);
                }
            });
            install(new LifecycleModule() {

                @Override
                protected void configure() {
                    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
                }
            });
        }
    });
    manager.add(dbInjector, gitInjector);
    manager.start();
    gitInjector.injectMembers(this);
    List<Change> allChangeList = allChanges();
    monitor.beginTask("Scanning changes", allChangeList.size());
    changes = cluster(allChangeList);
    allChangeList = null;
    monitor.startWorkers(threads);
    for (int tid = 0; tid < threads; tid++) {
        new Worker().start();
    }
    monitor.waitForCompletion();
    monitor.endTask();
    manager.stop();
    return 0;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Resolver.class);
    bind(UploadFactory.class);
    bind(UploadFilter.class);
    bind(ReceiveFactory.class);
    bind(ReceiveFilter.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(ID_CACHE, AdvertisedObjectsCacheKey.class, new TypeLiteral<Set<ObjectId>>() {
            }).memoryLimit(4096).maxAge(10, TimeUnit.MINUTES);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Resolver.class);
    bind(UploadFactory.class);
    bind(UploadFilter.class);
    bind(ReceiveFactory.class);
    bind(ReceiveFilter.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(ID_CACHE, AdvertisedObjectsCacheKey.class, new TypeLiteral<Set<ObjectId>>() {
            }).maximumWeight(4096).expireAfterWrite(10, TimeUnit.MINUTES);
        }
    });
}
#end_block

#method_before
private void setLabelScores(LabelType type, LabelInfo label, short score, Account.Id accountId) throws OrmException {
    if (label.approved != null || label.rejected != null) {
        return;
    }
    if (type.getMin() == null || type.getMax() == null) {
        // Can't set score for unknown or misconfigured type.
        return;
    }
    if (score != 0) {
        if (score == type.getMin().getValue()) {
            if (type.getFunctionName().equalsIgnoreCase("NoBlock")) {
                label.disliked = accountLoader.get(accountId);
            } else {
                label.rejected = accountLoader.get(accountId);
            }
        } else if (score == type.getMax().getValue()) {
            label.approved = accountLoader.get(accountId);
        } else if (score < 0) {
            label.disliked = accountLoader.get(accountId);
            label.value = score;
        } else if (score > 0 && label.disliked == null) {
            label.recommended = accountLoader.get(accountId);
            label.value = score;
        }
    }
    return;
}
#method_after
private void setLabelScores(LabelType type, LabelInfo label, short score, Account.Id accountId) throws OrmException {
    if (label.approved != null || label.rejected != null) {
        return;
    }
    if (type.getMin() == null || type.getMax() == null) {
        // Can't set score for unknown or misconfigured type.
        return;
    }
    if (score < 0) {
        label.disliked = accountLoader.get(accountId);
        label.value = score;
    } else if (score > 0 && label.disliked == null) {
        label.recommended = accountLoader.get(accountId);
        label.value = score;
    }
}
#end_block

#method_before
@Override
protected boolean beforeInit(SiteInit init) throws Exception {
    ErrorLogFile.errorOnlyConsole();
    if (!skipPlugins) {
        final List<PluginData> plugins = InitPlugins.listPluginsAndRemoveTempFiles(init.site, distroLocator);
        ConsoleUI ui = ConsoleUI.getInstance(false);
        verifyInstallPluginList(ui, plugins);
        if (listPlugins) {
            if (!plugins.isEmpty()) {
                ui.message("Available plugins:\n");
                for (PluginData plugin : plugins) {
                    ui.message(" * %s version %s\n", plugin.name, plugin.version);
                }
            } else {
                ui.message("No plugins found.\n");
            }
            return true;
        }
    }
    return false;
}
#method_after
@Override
protected boolean beforeInit(SiteInit init) throws Exception {
    ErrorLogFile.errorOnlyConsole();
    if (!skipPlugins) {
        final List<PluginData> plugins = InitPlugins.listPluginsAndRemoveTempFiles(init.site, pluginsDistribution);
        ConsoleUI ui = ConsoleUI.getInstance(false);
        verifyInstallPluginList(ui, plugins);
        if (listPlugins) {
            if (!plugins.isEmpty()) {
                ui.message("Available plugins:\n");
                for (PluginData plugin : plugins) {
                    ui.message(" * %s version %s\n", plugin.name, plugin.version);
                }
            } else {
                ui.message("No plugins found.\n");
            }
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public void init() {
    try {
        if (sitePath != null) {
            File site = new File(sitePath);
            LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
            new BaseInit(site, false, distroLocator, pluginsToInstall).run();
            return;
        }
        Connection conn = connectToDb();
        try {
            File site = getSiteFromReviewDb(conn);
            if (site == null && initPath != null) {
                site = new File(initPath);
            }
            if (site != null) {
                LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
                new BaseInit(site, new ReviewDbDataSourceProvider(), false, distroLocator, pluginsToInstall).run();
            }
        } finally {
            conn.close();
        }
    } catch (Exception e) {
        LOG.error("Site init failed", e);
        throw new RuntimeException(e);
    }
}
#method_after
public void init() {
    try {
        if (sitePath != null) {
            File site = new File(sitePath);
            LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
            new BaseInit(site, false, true, pluginsDistribution, pluginsToInstall).run();
            return;
        }
        Connection conn = connectToDb();
        try {
            File site = getSiteFromReviewDb(conn);
            if (site == null && initPath != null) {
                site = new File(initPath);
            }
            if (site != null) {
                LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
                new BaseInit(site, new ReviewDbDataSourceProvider(), false, false, pluginsDistribution, pluginsToInstall).run();
            }
        } finally {
            conn.close();
        }
    } catch (Exception e) {
        LOG.error("Site init failed", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
protected List<String> getInstallPlugins() {
    File root;
    try {
        root = distroLocator.locate();
    } catch (FileNotFoundException e) {
        log.warn("Couldn't open folder containing plugins." + " No plugin will be installed");
        return null;
    }
    ArrayList<String> result = Lists.newArrayList();
    File plugins = new File(root, InitPlugins.PLUGIN_DIR);
    for (File p : plugins.listFiles()) {
        String pluginJarName = p.getName();
        String pluginName = pluginJarName.substring(0, pluginJarName.length() - InitPlugins.JAR.length());
        if (pluginsToInstall == null || pluginsToInstall.contains(pluginName)) {
            result.add(pluginName);
        }
    }
    return result;
}
#method_after
protected List<String> getInstallPlugins() {
    try {
        if (pluginsToInstall != null && pluginsToInstall.isEmpty()) {
            return Collections.emptyList();
        }
        List<String> names = pluginsDistribution.listPluginNames();
        if (pluginsToInstall != null) {
            for (Iterator<String> i = names.iterator(); i.hasNext(); ) {
                String n = i.next();
                if (!pluginsToInstall.contains(n)) {
                    i.remove();
                }
            }
        }
        return names;
    } catch (FileNotFoundException e) {
        log.warn("Couldn't find distribution archive location." + " No plugin will be installed");
        return null;
    }
}
#end_block

#method_before
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<Module>();
    m.add(new InitModule(standalone));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = Objects.firstNonNull(getInstallPlugins(), Lists.<String>newArrayList());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(GerritDistributionLocator.class).toInstance(distroLocator);
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#method_after
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<Module>();
    m.add(new InitModule(standalone, initDb));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = Objects.firstNonNull(getInstallPlugins(), Lists.<String>newArrayList());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(PluginsDistribution.class).toInstance(pluginsDistribution);
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#end_block

#method_before
private synchronized void init() {
    if (manager == null) {
        final String path = System.getProperty("gerrit.site_path");
        if (path != null) {
            sitePath = new File(path);
        }
        if (System.getProperty("gerrit.init") != null) {
            List<String> pluginsToInstall;
            String installPlugins = System.getProperty("gerrit.install_plugins");
            if (installPlugins == null) {
                pluginsToInstall = null;
            } else {
                pluginsToInstall = Splitter.on(",").trimResults().omitEmptyStrings().splitToList(installPlugins);
            }
            new SiteInitializer(path, System.getProperty("gerrit.init_path"), new WebAppLocator(servletContext), pluginsToInstall).init();
        }
        try {
            dbInjector = createDbInjector();
        } catch (CreationException ce) {
            final Message first = ce.getErrorMessages().iterator().next();
            final StringBuilder buf = new StringBuilder();
            buf.append(first.getMessage());
            Throwable why = first.getCause();
            while (why != null) {
                buf.append("\n  caused by ");
                buf.append(why.toString());
                why = why.getCause();
            }
            if (first.getCause() != null) {
                buf.append("\n");
                buf.append("\nResolve above errors before continuing.");
                buf.append("\nComplete stack trace follows:");
            }
            log.error(buf.toString(), first.getCause());
            throw new CreationException(Collections.singleton(first));
        }
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        if (!sshdOff()) {
            sshInjector = createSshInjector();
        }
        webInjector = createWebInjector();
        PluginGuiceEnvironment env = sysInjector.getInstance(PluginGuiceEnvironment.class);
        env.setCfgInjector(cfgInjector);
        if (sshInjector != null) {
            env.setSshInjector(sshInjector);
        }
        env.setHttpInjector(webInjector);
        // Push the Provider<HttpServletRequest> down into the canonical
        // URL provider. Its optional for that provider, but since we can
        // supply one we should do so, in case the administrator has not
        // setup the canonical URL in the configuration file.
        // 
        // Note we have to do this manually as Guice failed to do the
        // injection here because the HTTP environment is not visible
        // to the core server modules.
        // 
        sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
        filter = webInjector.getInstance(GuiceFilter.class);
        manager = new LifecycleManager();
        manager.add(dbInjector);
        manager.add(cfgInjector);
        manager.add(sysInjector);
        if (sshInjector != null) {
            manager.add(sshInjector);
        }
        manager.add(webInjector);
    }
}
#method_after
private synchronized void init() {
    if (manager == null) {
        final String path = System.getProperty("gerrit.site_path");
        if (path != null) {
            sitePath = new File(path);
        }
        if (System.getProperty("gerrit.init") != null) {
            List<String> pluginsToInstall;
            String installPlugins = System.getProperty("gerrit.install_plugins");
            if (installPlugins == null) {
                pluginsToInstall = null;
            } else {
                pluginsToInstall = Splitter.on(",").trimResults().omitEmptyStrings().splitToList(installPlugins);
            }
            new SiteInitializer(path, System.getProperty("gerrit.init_path"), new UnzippedDistribution(servletContext), pluginsToInstall).init();
        }
        try {
            dbInjector = createDbInjector();
        } catch (CreationException ce) {
            final Message first = ce.getErrorMessages().iterator().next();
            final StringBuilder buf = new StringBuilder();
            buf.append(first.getMessage());
            Throwable why = first.getCause();
            while (why != null) {
                buf.append("\n  caused by ");
                buf.append(why.toString());
                why = why.getCause();
            }
            if (first.getCause() != null) {
                buf.append("\n");
                buf.append("\nResolve above errors before continuing.");
                buf.append("\nComplete stack trace follows:");
            }
            log.error(buf.toString(), first.getCause());
            throw new CreationException(Collections.singleton(first));
        }
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        if (!sshdOff()) {
            sshInjector = createSshInjector();
        }
        webInjector = createWebInjector();
        PluginGuiceEnvironment env = sysInjector.getInstance(PluginGuiceEnvironment.class);
        env.setCfgInjector(cfgInjector);
        if (sshInjector != null) {
            env.setSshInjector(sshInjector);
        }
        env.setHttpInjector(webInjector);
        // Push the Provider<HttpServletRequest> down into the canonical
        // URL provider. Its optional for that provider, but since we can
        // supply one we should do so, in case the administrator has not
        // setup the canonical URL in the configuration file.
        // 
        // Note we have to do this manually as Guice failed to do the
        // injection here because the HTTP environment is not visible
        // to the core server modules.
        // 
        sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
        filter = webInjector.getInstance(GuiceFilter.class);
        manager = new LifecycleManager();
        manager.add(dbInjector);
        manager.add(cfgInjector);
        manager.add(sysInjector);
        if (sshInjector != null) {
            manager.add(sshInjector);
        }
        manager.add(webInjector);
    }
}
#end_block

#method_before
private static List<PluginData> listPlugins(SitePaths site, boolean deleteTempPluginFile, GerritDistributionLocator distroLocator) throws IOException {
    final File myWar = distroLocator.locate();
    final List<PluginData> result = Lists.newArrayList();
    try {
        if (myWar.isFile()) {
            final ZipFile zf = new ZipFile(myWar);
            try {
                final Enumeration<? extends ZipEntry> e = zf.entries();
                while (e.hasMoreElements()) {
                    final ZipEntry ze = e.nextElement();
                    if (ze.isDirectory()) {
                        continue;
                    }
                    if (ze.getName().startsWith(PLUGIN_DIR) && ze.getName().endsWith(JAR)) {
                        final String pluginJarName = new File(ze.getName()).getName();
                        final String pluginName = pluginJarName.substring(0, pluginJarName.length() - JAR.length());
                        final InputStream in = zf.getInputStream(ze);
                        final File tmpPlugin = PluginLoader.storeInTemp(pluginName, in, site);
                        final String pluginVersion = getVersion(tmpPlugin);
                        if (deleteTempPluginFile) {
                            tmpPlugin.delete();
                        }
                        result.add(new PluginData(pluginName, pluginVersion, tmpPlugin));
                    }
                }
            } finally {
                zf.close();
            }
        } else {
            File pluginDir = new File(myWar, PLUGIN_DIR);
            for (File p : pluginDir.listFiles()) {
                String pluginJarName = p.getName();
                String pluginName = pluginJarName.substring(0, pluginJarName.length() - JAR.length());
                File tmpPlugin;
                InputStream in = new FileInputStream(p);
                try {
                    tmpPlugin = PluginLoader.storeInTemp(pluginName, in, site);
                } finally {
                    in.close();
                }
                String pluginVersion = getVersion(tmpPlugin);
                if (deleteTempPluginFile) {
                    tmpPlugin.delete();
                }
                result.add(new PluginData(pluginName, pluginVersion, tmpPlugin));
            }
        }
    } catch (IOException e) {
        throw new IOException("Failure during plugin installation", e);
    }
    return result;
}
#method_after
public static List<PluginData> listPlugins(SitePaths site, PluginsDistribution pluginsDistribution) throws IOException {
    return listPlugins(site, false, pluginsDistribution);
}
#end_block

#method_before
public static List<PluginData> listPluginsAndRemoveTempFiles(SitePaths site, GerritDistributionLocator distroLocator) throws IOException {
    return listPlugins(site, true, distroLocator);
}
#method_after
public static List<PluginData> listPluginsAndRemoveTempFiles(SitePaths site, PluginsDistribution pluginsDistribution) throws IOException {
    return listPlugins(site, true, pluginsDistribution);
}
#end_block

#method_before
private void installPlugins() throws IOException {
    List<PluginData> plugins = listPlugins(site, distroLocator);
    for (PluginData plugin : plugins) {
        String pluginName = plugin.name;
        try {
            final File tmpPlugin = plugin.pluginFile;
            if (!(initFlags.installPlugins.contains(pluginName) || ui.yesno(false, "Install plugin %s version %s", pluginName, plugin.version))) {
                tmpPlugin.delete();
                continue;
            }
            final File p = new File(site.plugins_dir, plugin.name + ".jar");
            if (p.exists()) {
                final String installedPluginVersion = getVersion(p);
                if (!ui.yesno(false, "version %s is already installed, overwrite it", installedPluginVersion)) {
                    tmpPlugin.delete();
                    continue;
                }
                if (!p.delete()) {
                    throw new IOException("Failed to delete plugin " + pluginName + ": " + p.getAbsolutePath());
                }
            }
            if (!tmpPlugin.renameTo(p)) {
                throw new IOException("Failed to install plugin " + pluginName + ": " + tmpPlugin.getAbsolutePath() + " -> " + p.getAbsolutePath());
            }
        } finally {
            if (plugin.pluginFile.exists()) {
                plugin.pluginFile.delete();
            }
        }
    }
    if (plugins.isEmpty()) {
        ui.message("No plugins found.");
    }
}
#method_after
private void installPlugins() throws IOException {
    List<PluginData> plugins = listPlugins(site, pluginsDistribution);
    for (PluginData plugin : plugins) {
        String pluginName = plugin.name;
        try {
            final File tmpPlugin = plugin.pluginFile;
            if (!(initFlags.installPlugins.contains(pluginName) || ui.yesno(false, "Install plugin %s version %s", pluginName, plugin.version))) {
                tmpPlugin.delete();
                continue;
            }
            final File p = new File(site.plugins_dir, plugin.name + ".jar");
            if (p.exists()) {
                final String installedPluginVersion = getVersion(p);
                if (!ui.yesno(false, "version %s is already installed, overwrite it", installedPluginVersion)) {
                    tmpPlugin.delete();
                    continue;
                }
                if (!p.delete()) {
                    throw new IOException("Failed to delete plugin " + pluginName + ": " + p.getAbsolutePath());
                }
            }
            if (!tmpPlugin.renameTo(p)) {
                throw new IOException("Failed to install plugin " + pluginName + ": " + tmpPlugin.getAbsolutePath() + " -> " + p.getAbsolutePath());
            }
        } finally {
            if (plugin.pluginFile.exists()) {
                plugin.pluginFile.delete();
            }
        }
    }
    if (plugins.isEmpty()) {
        ui.message("No plugins found.");
    }
}
#end_block

#method_before
@Override
protected boolean beforeInit(SiteInit init) throws Exception {
    ErrorLogFile.errorOnlyConsole();
    if (!skipPlugins) {
        final List<PluginData> plugins = InitPlugins.listPluginsAndRemoveTempFiles(init.site, distroLocator);
        ConsoleUI ui = ConsoleUI.getInstance(false);
        verifyInstallPluginList(ui, plugins);
        if (listPlugins) {
            if (!plugins.isEmpty()) {
                ui.message("Available plugins:\n");
                for (PluginData plugin : plugins) {
                    ui.message(" * %s version %s\n", plugin.name, plugin.version);
                }
            } else {
                ui.message("No plugins found.\n");
            }
            return true;
        }
    }
    return false;
}
#method_after
@Override
protected boolean beforeInit(SiteInit init) throws Exception {
    ErrorLogFile.errorOnlyConsole();
    if (!skipPlugins) {
        final List<PluginData> plugins = InitPlugins.listPluginsAndRemoveTempFiles(init.site, pluginsDistribution);
        ConsoleUI ui = ConsoleUI.getInstance(false);
        verifyInstallPluginList(ui, plugins);
        if (listPlugins) {
            if (!plugins.isEmpty()) {
                ui.message("Available plugins:\n");
                for (PluginData plugin : plugins) {
                    ui.message(" * %s version %s\n", plugin.name, plugin.version);
                }
            } else {
                ui.message("No plugins found.\n");
            }
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(SitePaths.class);
    bind(InitFlags.class);
    bind(Libraries.class);
    bind(LibraryDownloader.class);
    factory(Section.Factory.class);
    // Steps are executed in the order listed here.
    // 
    step().to(UpgradeFrom2_0_x.class);
    step().to(InitGitManager.class);
    if (standalone) {
        step().to(InitDatabase.class);
    }
    step().to(InitIndex.class);
    step().to(InitAuth.class);
    step().to(InitLabels.class);
    step().to(InitSendEmail.class);
    if (standalone) {
        step().to(InitContainer.class);
    }
    step().to(InitSshd.class);
    step().to(InitHttpd.class);
    step().to(InitCache.class);
    step().to(InitPlugins.class);
}
#method_after
@Override
protected void configure() {
    bind(SitePaths.class);
    bind(InitFlags.class);
    bind(Libraries.class);
    bind(LibraryDownloader.class);
    factory(Section.Factory.class);
    // Steps are executed in the order listed here.
    // 
    step().to(UpgradeFrom2_0_x.class);
    step().to(InitGitManager.class);
    if (initDb) {
        step().to(InitDatabase.class);
    }
    step().to(InitIndex.class);
    step().to(InitAuth.class);
    step().to(InitLabels.class);
    step().to(InitSendEmail.class);
    if (standalone) {
        step().to(InitContainer.class);
    }
    step().to(InitSshd.class);
    step().to(InitHttpd.class);
    step().to(InitCache.class);
    step().to(InitPlugins.class);
}
#end_block

#method_before
public void init() {
    try {
        if (sitePath != null) {
            File site = new File(sitePath);
            LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
            new BaseInit(site, false, distroLocator).run();
            return;
        }
        Connection conn = connectToDb();
        try {
            File site = getSiteFromReviewDb(conn);
            if (site == null && initPath != null) {
                site = new File(initPath);
            }
            if (site != null) {
                LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
                new BaseInit(site, new ReviewDbDataSourceProvider(), false, distroLocator).run();
            }
        } finally {
            conn.close();
        }
    } catch (Exception e) {
        LOG.error("Site init failed", e);
        throw new RuntimeException(e);
    }
}
#method_after
public void init() {
    try {
        if (sitePath != null) {
            File site = new File(sitePath);
            LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
            new BaseInit(site, false, true, pluginsDistribution).run();
            return;
        }
        Connection conn = connectToDb();
        try {
            File site = getSiteFromReviewDb(conn);
            if (site == null && initPath != null) {
                site = new File(initPath);
            }
            if (site != null) {
                LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
                new BaseInit(site, new ReviewDbDataSourceProvider(), false, false, pluginsDistribution).run();
            }
        } finally {
            conn.close();
        }
    } catch (Exception e) {
        LOG.error("Site init failed", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
protected List<String> getInstallPlugins() {
    File root;
    try {
        root = distroLocator.locate();
    } catch (FileNotFoundException e) {
        log.warn("Couldn't open folder containing plugins." + " No plugin will be installed");
        return null;
    }
    ArrayList<String> result = Lists.newArrayList();
    File plugins = new File(root, InitPlugins.PLUGIN_DIR);
    for (File p : plugins.listFiles()) {
        String pluginJarName = p.getName();
        String pluginName = pluginJarName.substring(0, pluginJarName.length() - InitPlugins.JAR.length());
        result.add(pluginName);
    }
    return result;
}
#method_after
protected List<String> getInstallPlugins() {
    try {
        return pluginsDistribution.listPluginNames();
    } catch (FileNotFoundException e) {
        log.warn("Couldn't find distribution archive location." + " No plugin will be installed");
        return null;
    }
}
#end_block

#method_before
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<Module>();
    m.add(new InitModule(standalone));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = Objects.firstNonNull(getInstallPlugins(), Lists.<String>newArrayList());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(GerritDistributionLocator.class).toInstance(distroLocator);
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#method_after
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<Module>();
    m.add(new InitModule(standalone, initDb));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = Objects.firstNonNull(getInstallPlugins(), Lists.<String>newArrayList());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(PluginsDistribution.class).toInstance(pluginsDistribution);
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#end_block

#method_before
private synchronized void init() {
    if (manager == null) {
        final String path = System.getProperty("gerrit.site_path");
        if (path != null) {
            sitePath = new File(path);
        }
        if (System.getProperty("gerrit.init") != null) {
            new SiteInitializer(path, System.getProperty("gerrit.init_path"), new WebAppLocator(servletContext)).init();
        }
        try {
            dbInjector = createDbInjector();
        } catch (CreationException ce) {
            final Message first = ce.getErrorMessages().iterator().next();
            final StringBuilder buf = new StringBuilder();
            buf.append(first.getMessage());
            Throwable why = first.getCause();
            while (why != null) {
                buf.append("\n  caused by ");
                buf.append(why.toString());
                why = why.getCause();
            }
            if (first.getCause() != null) {
                buf.append("\n");
                buf.append("\nResolve above errors before continuing.");
                buf.append("\nComplete stack trace follows:");
            }
            log.error(buf.toString(), first.getCause());
            throw new CreationException(Collections.singleton(first));
        }
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        if (!sshdOff()) {
            sshInjector = createSshInjector();
        }
        webInjector = createWebInjector();
        PluginGuiceEnvironment env = sysInjector.getInstance(PluginGuiceEnvironment.class);
        env.setCfgInjector(cfgInjector);
        if (sshInjector != null) {
            env.setSshInjector(sshInjector);
        }
        env.setHttpInjector(webInjector);
        // Push the Provider<HttpServletRequest> down into the canonical
        // URL provider. Its optional for that provider, but since we can
        // supply one we should do so, in case the administrator has not
        // setup the canonical URL in the configuration file.
        // 
        // Note we have to do this manually as Guice failed to do the
        // injection here because the HTTP environment is not visible
        // to the core server modules.
        // 
        sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
        filter = webInjector.getInstance(GuiceFilter.class);
        manager = new LifecycleManager();
        manager.add(dbInjector);
        manager.add(cfgInjector);
        manager.add(sysInjector);
        if (sshInjector != null) {
            manager.add(sshInjector);
        }
        manager.add(webInjector);
    }
}
#method_after
private synchronized void init() {
    if (manager == null) {
        final String path = System.getProperty("gerrit.site_path");
        if (path != null) {
            sitePath = new File(path);
        }
        if (System.getProperty("gerrit.init") != null) {
            new SiteInitializer(path, System.getProperty("gerrit.init_path"), new UnzippedDistribution(servletContext)).init();
        }
        try {
            dbInjector = createDbInjector();
        } catch (CreationException ce) {
            final Message first = ce.getErrorMessages().iterator().next();
            final StringBuilder buf = new StringBuilder();
            buf.append(first.getMessage());
            Throwable why = first.getCause();
            while (why != null) {
                buf.append("\n  caused by ");
                buf.append(why.toString());
                why = why.getCause();
            }
            if (first.getCause() != null) {
                buf.append("\n");
                buf.append("\nResolve above errors before continuing.");
                buf.append("\nComplete stack trace follows:");
            }
            log.error(buf.toString(), first.getCause());
            throw new CreationException(Collections.singleton(first));
        }
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        if (!sshdOff()) {
            sshInjector = createSshInjector();
        }
        webInjector = createWebInjector();
        PluginGuiceEnvironment env = sysInjector.getInstance(PluginGuiceEnvironment.class);
        env.setCfgInjector(cfgInjector);
        if (sshInjector != null) {
            env.setSshInjector(sshInjector);
        }
        env.setHttpInjector(webInjector);
        // Push the Provider<HttpServletRequest> down into the canonical
        // URL provider. Its optional for that provider, but since we can
        // supply one we should do so, in case the administrator has not
        // setup the canonical URL in the configuration file.
        // 
        // Note we have to do this manually as Guice failed to do the
        // injection here because the HTTP environment is not visible
        // to the core server modules.
        // 
        sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
        filter = webInjector.getInstance(GuiceFilter.class);
        manager = new LifecycleManager();
        manager.add(dbInjector);
        manager.add(cfgInjector);
        manager.add(sysInjector);
        if (sshInjector != null) {
            manager.add(sshInjector);
        }
        manager.add(webInjector);
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadPluginSections(rc);
    loadGitChecks(rc);
    maxObjectSizeLimit = rc.getLong(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, 0);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
protected void command(final CommandName parent, final Class<? extends BaseCommand> clazz) {
    CommandMetaData meta = clazz.getAnnotation(CommandMetaData.class);
    if (meta == null) {
        throw new IllegalStateException("no CommandMetaData annotation found");
    }
    if (doBind(meta.mode())) {
        bind(Commands.key(parent, meta.name(), meta.description())).to(clazz);
    }
}
#method_after
protected void command(final CommandName parent, final Class<? extends BaseCommand> clazz) {
    CommandMetaData meta = clazz.getAnnotation(CommandMetaData.class);
    if (meta == null) {
        throw new IllegalStateException("no CommandMetaData annotation found");
    }
    if (meta.runsAt().isSupported(slaveMode)) {
        bind(Commands.key(parent, meta.name(), meta.description())).to(clazz);
    }
}
#end_block

#method_before
@Override
public ChangeDescription get(EnumSet<ListChangesOption> options) throws RestApiException {
    try {
        // TODO(davido): respect options in mapping
        return info2Description(changeJson.addOptions(options).format(change));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return new ChangeInfoMapper(s).map(changeJson.addOptions(s).format(change));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Test
public void get() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    String triplet = "p~master~" + r.getChangeId();
    ChangeDescription c = gApi.changes().id(triplet).get(EnumSet.noneOf(ListChangesOption.class));
    assertEquals(triplet, c.id);
    assertEquals("p", c.project);
    assertEquals("master", c.branch);
    assertEquals(ChangeStatus.NEW, c.status);
    assertEquals("test commit", c.subject);
    assertEquals(true, c.mergeable);
    assertEquals(r.getChangeId(), c.changeId);
    assertEquals(c.created, c.updated);
}
#method_after
@Test
public void get() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    String triplet = "p~master~" + r.getChangeId();
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.noneOf(ListChangesOption.class));
    assertEquals(triplet, c.id);
    assertEquals("p", c.project);
    assertEquals("master", c.branch);
    assertEquals(ChangeStatus.NEW, c.status);
    assertEquals("test commit", c.subject);
    assertEquals(true, c.mergeable);
    assertEquals(r.getChangeId(), c.changeId);
    assertEquals(c.created, c.updated);
}
#end_block

#method_before
@Test
public void revert() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).review(approve());
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).submit();
    gApi.changes().id("p~master~" + r.getChangeId()).revert();
}
#method_after
@Test
public void revert() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).submit();
    gApi.changes().id("p~master~" + r.getChangeId()).revert();
}
#end_block

#method_before
public PluginConfig getFromGerritConfig(String pluginName) {
    return new PluginConfig(pluginName, getGerritConfig());
}
#method_after
public PluginConfig getFromGerritConfig(String pluginName) {
    return getFromGerritConfig(pluginName, false);
}
#end_block

#method_before
public PluginConfig getFromGerritConfig(String pluginName) {
    return new PluginConfig(pluginName, getGerritConfig());
}
#method_after
public PluginConfig getFromGerritConfig(String pluginName, boolean refresh) {
    if (refresh && cfgSnapshot.isModified(site.gerrit_config)) {
        cfgSnapshot = FileSnapshot.save(site.gerrit_config);
        cfg = cfgProvider.get();
    }
    return new PluginConfig(pluginName, cfg);
}
#end_block

#method_before
static void call(Button b, final Change.Id id, final String revision, String project, final String commitSubject) {
    // TODO Replace ActionDialog with a nicer looking display.
    b.setEnabled(false);
    new ActionDialog(b, false, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

        {
            sendButton.setText(Util.C.buttonRevertChangeSend());
            message.setText(Util.M.revertChangeDefaultMessage(commitSubject, revision));
        }

        @Override
        public void onSend() {
            ChangeApi.revert(id.get(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    Gerrit.display(PageLinks.toChange2(id));
                    hide();
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#method_after
static void call(Button b, final Change.Id id, final String revision, String project, final String commitSubject) {
    // TODO Replace ActionDialog with a nicer looking display.
    b.setEnabled(false);
    new ActionDialog(b, false, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

        {
            sendButton.setText(Util.C.buttonRevertChangeSend());
            message.setText(Util.M.revertChangeDefaultMessage(commitSubject, revision));
        }

        @Override
        public void onSend() {
            ChangeApi.revert(id.get(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange2(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#end_block

#method_before
public static void detail(int id, AsyncCallback<ChangeInfo> cb) {
    call(id, "detail").get(cb);
}
#method_after
public static void detail(int id, AsyncCallback<ChangeInfo> cb) {
    detail(id).get(cb);
}
#end_block

#method_before
public static void detail(int id, AsyncCallback<ChangeInfo> cb) {
    call(id, "detail").get(cb);
}
#method_after
public static void detail(int id, EnumSet<ListChangesOption> options, AsyncCallback<ChangeInfo> cb) {
    RestApi call = detail(id);
    if (!options.isEmpty()) {
        ChangeList.addOptions(call, options);
    }
    call.get(cb);
}
#end_block

#method_before
private static RestApi change(int id) {
    // TODO Switch to triplet project~branch~id format in URI.
    return new RestApi("/changes/").id(String.valueOf(id));
}
#method_after
public static RestApi change(int id) {
    // TODO Switch to triplet project~branch~id format in URI.
    return new RestApi("/changes/").id(String.valueOf(id));
}
#end_block

#method_before
public final void init() {
    if (labels0() != null) {
        labels0().copyKeysIntoChildren("_name");
    }
}
#method_after
public final void init() {
    if (all_labels() != null) {
        all_labels().copyKeysIntoChildren("_name");
    }
}
#end_block

#method_before
public final Set<String> labels() {
    return labels0().keySet();
}
#method_after
public final Set<String> labels() {
    return all_labels().keySet();
}
#end_block

#method_before
static void call(Button b, final Change.Id id, final String revision, String project, final String commitMessage) {
    // TODO Replace CherryPickDialog with a nicer looking display.
    b.setEnabled(false);
    new CherryPickDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCherryPickChangeSend());
            message.setText(Util.M.cherryPickedChangeDefaultMessage(commitMessage.trim(), revision));
        }

        @Override
        public void onSend() {
            ChangeApi.cherrypick(id.get(), revision, getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    Gerrit.display(PageLinks.toChange2(id));
                    hide();
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#method_after
static void call(Button b, final Change.Id id, final String revision, String project, final String commitMessage) {
    // TODO Replace CherryPickDialog with a nicer looking display.
    b.setEnabled(false);
    new CherryPickDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCherryPickChangeSend());
            message.setText(Util.M.cherryPickedChangeDefaultMessage(commitMessage.trim(), revision));
        }

        @Override
        public void onSend() {
            ChangeApi.cherrypick(id.get(), revision, getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange2(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#end_block

#method_before
public static String toChange2(final Change.Id c) {
    return "/c2/" + c + "/";
}
#method_after
public static String toChange2(Change.Id c, String p) {
    return "/c2/" + c + "/" + p;
}
#end_block

#method_before
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchPrefix("/c2/", token)) {
        String s = skip(token);
        if (s.endsWith("/")) {
            s = s.substring(0, s.length() - 1);
        }
        Change.Id id = Change.Id.parse(s);
        Gerrit.display(token, new ChangeScreen2(id));
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#method_after
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchPrefix("/c2/", token)) {
        change2(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            loadConfigInfo(info);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    ChangeApi.detail(changeId.get(), EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_ACTIONS), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info);
        }
    });
}
#end_block

#method_before
@UiHandler("starIcon")
void onToggleStar(ClickEvent e) {
    boolean newState = !starred;
    StarredChanges.toggleStar(changeId, newState);
    renderStar(newState);
}
#method_after
@UiHandler("star")
void onToggleStar(ValueChangeEvent<Boolean> e) {
    StarredChanges.toggleStar(changeId, e.getValue());
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info) {
    CallbackGroup group = new CallbackGroup();
    DiffApi.list(changeId.get(), info.current_revision(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> files) {
            renderFiles(files);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ConfigInfoCache.get(info.project_name_key(), group.add(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    CallbackGroup group = new CallbackGroup();
    loadDiff(rev, group);
    loadCommit(rev, group);
    ConfigInfoCache.get(info.project_name_key(), group.add(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
    group.done();
    if (info.status().isOpen() && rev.name().equals(info.current_revision())) {
        loadSubmitAction(rev);
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    accountCache = new HashMap<String, AccountInfo>();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean canSubmit = renderLabels(info);
    renderStar(info.starred());
    renderOwner(info);
    renderActionTextDate(info);
    renderStandardActions(info, canSubmit);
    renderCommitInfo(info);
    renderHistory(info);
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    topicText.setInnerText(info.topic());
    idText.setInnerText(info.change_id());
    // submit_type?
    submitTypeText.setInnerText("Merge If Necessary");
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean canSubmit = labels.set(info);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision, canSubmit);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    quickApprove.set(info, revision);
    boolean hasConflict = Gerrit.getConfig().testChangeMerge() && !info.mergeable();
    setVisible(notMergeable, hasConflict);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    reply.setVisible(replyAction != null);
    if (canSubmit && !hasConflict && actions.isSubmitEnabled()) {
        statusText.setInnerText(Util.C.readyToSubmit());
    } else if (canSubmit && hasConflict) {
        statusText.setInnerText(Util.C.mergeConflict());
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // info card hover
    ownerText.setInnerText(info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName());
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    ownerText.setInnerText(info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName());
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type()) || "INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param, false);
            } else if ("INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param, true);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#end_block

#method_before
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextBox textBox = new NpTextBox();
    textBox.setValue(param.value());
    g.add(getDisplayName(param), textBox);
    saveEnabler.listenTo(textBox);
    return textBox;
}
#method_after
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param, boolean numbersOnly) {
    NpTextBox textBox = numbersOnly ? new NpIntTextBox() : new NpTextBox();
    textBox.setValue(param.value());
    g.add(getDisplayName(param), textBox);
    saveEnabler.listenTo(textBox);
    return textBox;
}
#end_block

#method_before
private CheckBox renderCheckBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    CheckBox checkBox = new CheckBox();
    checkBox.setValue(Boolean.parseBoolean(param.value()));
    g.add(getDisplayName(param), checkBox);
    saveEnabler.listenTo(checkBox);
    return checkBox;
}
#method_after
private CheckBox renderCheckBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    CheckBox checkBox = new CheckBox(getDisplayName(param));
    checkBox.setValue(Boolean.parseBoolean(param.value()));
    g.add(null, checkBox);
    saveEnabler.listenTo(checkBox);
    return checkBox;
}
#end_block

#method_before
private void setPluginConfigValues(ProjectConfig projectConfig, Map<String, List<ConfigValueInput>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, List<ConfigValueInput>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (ConfigValueInput v : e.getValue()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.name);
            if (projectConfigEntry != null) {
                if (!v.name.matches("^[a-zA-Z0-9]*[a-zA-Z0-9-]*$")) {
                    log.warn("The name of the parameter '" + v.name + "' of the plugin '" + pluginName + "' is invalid.");
                    continue;
                }
                if (v.value == null) {
                    cfg.unset(v.name);
                } else {
                    try {
                        switch(projectConfigEntry.getType()) {
                            case BOOLEAN:
                                cfg.setBoolean(v.name, Boolean.parseBoolean(v.value));
                                break;
                            case INT:
                                cfg.setInt(v.name, Integer.parseInt(v.value));
                                break;
                            case LONG:
                                cfg.setLong(v.name, Long.parseLong(v.value));
                                break;
                            case STRING:
                            case LIST:
                            default:
                                cfg.setString(v.name, v.value);
                        }
                    } catch (NumberFormatException ex) {
                        throw new BadRequestException("The value '" + v.value + "' of config paramter '" + v.name + "' of plugin '" + pluginName + "' is invalid: " + ex.getMessage());
                    }
                }
            } else {
                throw new BadRequestException("The config paramter '" + v.name + "' of plugin '" + pluginName + "' does not exist.");
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectConfig projectConfig, Map<String, Map<String, String>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, String> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                if (v.getValue() != null) {
                    cfg.setString(v.getKey(), v.getValue());
                } else {
                    cfg.unset(v.getKey());
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
final void setPluginConfigValues(Map<String, Map<String, String>> pluginConfigValues) {
    NativeMap<JsArray<ConfigValueInput>> configValues = NativeMap.create().cast();
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        JsArray<ConfigValueInput> values = JsArray.createArray().cast();
        configValues.put(e.getKey(), values);
        for (Entry<String, String> e2 : e.getValue().entrySet()) {
            ConfigValueInput i = ConfigValueInput.create();
            i.setName(e2.getKey());
            i.setValue(e2.getValue());
            values.push(i);
        }
    }
    setPluginConfigValuesRaw(configValues);
}
#method_after
final void setPluginConfigValues(Map<String, Map<String, String>> pluginConfigValues) {
    if (!pluginConfigValues.isEmpty()) {
        NativeMap<StringMap> configValues = NativeMap.create().cast();
        for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
            StringMap values = StringMap.create();
            configValues.put(e.getKey(), values);
            for (Entry<String, String> e2 : e.getValue().entrySet()) {
                values.put(e2.getKey(), e2.getValue());
            }
        }
        setPluginConfigValuesRaw(configValues);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(QueryDocumentationExecutor.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(SystemGroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
private void enableForm(boolean isOwner) {
    submitType.setEnabled(isOwner);
    state.setEnabled(isOwner);
    contentMerge.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, Widget> widgetMap : pluginConfigWidgets.values()) {
            for (Widget widget : widgetMap.values()) {
                ((FocusWidget) widget).setEnabled(isOwner);
            }
        }
    }
}
#method_after
private void enableForm(boolean isOwner) {
    submitType.setEnabled(isOwner);
    state.setEnabled(isOwner);
    contentMerge.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, FocusWidget> widgetMap : pluginConfigWidgets.values()) {
            for (FocusWidget widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, Widget>>();
    for (String pluginName : Natives.keys(info.pluginConfigParameters())) {
        Map<String, Widget> widgetMap = new HashMap<String, Widget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        for (ConfigParameterInfo param : Natives.asList(info.pluginConfigParameter(pluginName))) {
            if ("STRING".equals(param.type()) || "INT".equals(param.type()) || "LONG".equals(param.type())) {
                NpTextBox textBox = new NpTextBox();
                if (param.inheritable()) {
                    textBox.setValue(param.configuredValue());
                    Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
                    inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
                    HorizontalPanel p = new HorizontalPanel();
                    p.add(textBox);
                    p.add(inheritedLabel);
                    g.add(param.displayName() != null ? param.displayName() : param.name(), p);
                } else {
                    textBox.setValue(param.value());
                    g.add(param.displayName() != null ? param.displayName() : param.name(), textBox);
                }
                saveEnabler.listenTo(textBox);
                widgetMap.put(param.name(), textBox);
            } else if ("BOOLEAN".equals(param.type())) {
                CheckBox checkbox = new CheckBox();
                checkbox.setValue(Boolean.parseBoolean(param.value()));
                g.add(param.displayName() != null ? param.displayName() : param.name(), checkbox);
                saveEnabler.listenTo(checkbox);
                widgetMap.put(param.name(), checkbox);
            } else if ("LIST".equals(param.type())) {
                ListBox listBox = new ListBox();
                if (param.inheritable()) {
                    listBox.addItem(Util.C.inheritListValue());
                    if (param.configuredValue() == null) {
                        listBox.setSelectedIndex(0);
                    }
                    for (int i = 0; i < param.supportedValues().length(); i++) {
                        String sv = param.supportedValues().get(i);
                        listBox.addItem(sv);
                        if (sv.equals(param.configuredValue())) {
                            listBox.setSelectedIndex(i + 1);
                        }
                    }
                    Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
                    inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
                    HorizontalPanel p = new HorizontalPanel();
                    p.add(listBox);
                    p.add(inheritedLabel);
                    g.add(param.displayName() != null ? param.displayName() : param.name(), p);
                } else {
                    for (int i = 0; i < param.supportedValues().length(); i++) {
                        String sv = param.supportedValues().get(i);
                        listBox.addItem(sv);
                        if (sv.equals(param.value())) {
                            listBox.setSelectedIndex(i);
                        }
                    }
                    g.add(param.displayName() != null ? param.displayName() : param.name(), listBox);
                }
                saveEnabler.listenTo(listBox);
                widgetMap.put(param.name(), listBox);
            }
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#end_block

#method_before
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<String, Map<String, String>>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, Widget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, Widget> e2 : e.getValue().entrySet()) {
            Widget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                String value = listBox.getValue(listBox.getSelectedIndex());
                if ("INHERIT".equals(value)) {
                    value = null;
                }
                values.put(e2.getKey(), value);
            }
        }
    }
    return pluginConfigValues;
}
#method_after
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<String, Map<String, String>>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            }
        }
    }
    return pluginConfigValues;
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, Input input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.onProjectCreated(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    return Response.created(json.format(p));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, Input input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    return Response.created(json.format(p));
}
#end_block

#method_before
public void log(Request request, Response response) {
    int status = response.getStatus();
    if (status < 0) {
        // Copied from NCSARequestLog
        status = 404;
    }
    TreeLogger.Type logStatus, logHeaders;
    if (status >= 500) {
        logStatus = TreeLogger.ERROR;
        logHeaders = TreeLogger.INFO;
    } else if (status >= 400) {
        logStatus = TreeLogger.WARN;
        logHeaders = TreeLogger.INFO;
    } else {
        logStatus = TreeLogger.INFO;
        logHeaders = TreeLogger.DEBUG;
    }
    String userString = request.getRemoteUser();
    if (userString == null) {
        userString = "";
    } else {
        userString += "@";
    }
    String bytesString = "";
    if (response.getContentCount() > 0) {
        bytesString = " " + response.getContentCount() + " bytes";
    }
    if (logger.isLoggable(logStatus)) {
        TreeLogger branch = logger.branch(logStatus, String.valueOf(status) + " - " + request.getMethod() + ' ' + request.getUri() + " (" + userString + request.getRemoteHost() + ')' + bytesString);
        if (branch.isLoggable(logHeaders)) {
            // Request headers
            TreeLogger headers = branch.branch(logHeaders, "Request headers");
            @SuppressWarnings("unchecked")
            Enumeration<String> headerNames = request.getHeaderNames();
            while (headerNames.hasMoreElements()) {
                String name = headerNames.nextElement();
                @SuppressWarnings("unchecked")
                List<String> values = Collections.list(request.getHeaders(name));
                headers.log(logHeaders, name + ": " + values.get(0));
            }
            // Response headers
            headers = branch.branch(logHeaders, "Response headers");
            Collection<String> names = response.getHeaderNames();
            for (String name : names) {
                headers.log(logHeaders, name + ": " + response.getHeader(name));
            }
        }
    }
}
#method_after
public void log(Request request, Response response) {
    int status = response.getStatus();
    if (status < 0) {
        // Copied from NCSARequestLog
        status = 404;
    }
    TreeLogger.Type logStatus, logHeaders;
    if (status >= 500) {
        logStatus = TreeLogger.ERROR;
        logHeaders = TreeLogger.INFO;
    } else if (status >= 400) {
        logStatus = TreeLogger.WARN;
        logHeaders = TreeLogger.INFO;
    } else {
        logStatus = TreeLogger.INFO;
        logHeaders = TreeLogger.DEBUG;
    }
    String userString = request.getRemoteUser();
    if (userString == null) {
        userString = "";
    } else {
        userString += "@";
    }
    String bytesString = "";
    if (response.getContentCount() > 0) {
        bytesString = " " + response.getContentCount() + " bytes";
    }
    if (logger.isLoggable(logStatus)) {
        TreeLogger branch = logger.branch(logStatus, String.valueOf(status) + " - " + request.getMethod() + ' ' + request.getUri() + " (" + userString + request.getRemoteHost() + ')' + bytesString);
        if (branch.isLoggable(logHeaders)) {
            // Request headers
            TreeLogger headers = branch.branch(logHeaders, "Request headers");
            for (HttpField f : request.getHttpFields()) {
                headers.log(logHeaders, f.getName() + ": " + f.getValue());
            }
            // Response headers
            headers = branch.branch(logHeaders, "Response headers");
            for (HttpField f : response.getHttpFields()) {
                headers.log(logHeaders, f.getName() + ": " + f.getValue());
            }
        }
    }
}
#end_block

#method_before
@Override
public ServletContainer start(TreeLogger logger, int port, File warDir) throws Exception {
    TreeLogger branch = logger.branch(TreeLogger.INFO, "Starting Jetty on port " + port, null);
    checkStartParams(branch, port, warDir);
    // Setup our branch logger during startup.
    Log.setLog(new JettyTreeLogger(branch));
    // Turn off XML validation.
    System.setProperty("org.mortbay.xml.XmlParser.Validating", "false");
    AbstractConnector connector = getConnector();
    if (bindAddress != null) {
        connector.setHost(bindAddress);
    }
    connector.setPort(port);
    // Don't share ports with an existing process.
    connector.setReuseAddress(false);
    // Linux keeps the port blocked after shutdown if we don't disable this.
    connector.setSoLingerTime(0);
    Server server = new Server();
    server.addConnector(connector);
    File top;
    String root = System.getProperty("gerrit.source_root");
    if (root != null) {
        top = new File(root);
    } else {
        // Under Maven warDir is "$top/gerrit-gwtui/target/gwt-hosted-mode"
        top = warDir.getParentFile().getParentFile().getParentFile();
    }
    File app = new File(top, "gerrit-war/src/main/webapp");
    File webxml = new File(app, "WEB-INF/web.xml");
    // Jetty won't start unless this directory exists.
    if (!warDir.exists() && !warDir.mkdirs())
        logger.branch(TreeLogger.ERROR, "Cannot create " + warDir, null);
    // Create a new web app in the war directory.
    // 
    WebAppContext wac = new MyWebAppContext(warDir.getAbsolutePath(), "/");
    wac.setDescriptor(webxml.getAbsolutePath());
    RequestLogHandler logHandler = new RequestLogHandler();
    logHandler.setRequestLog(new JettyRequestLogger(logger));
    logHandler.setHandler(wac);
    server.setHandler(logHandler);
    server.start();
    server.setStopAtShutdown(true);
    // Now that we're started, log to the top level logger.
    Log.setLog(new JettyTreeLogger(logger));
    return new JettyServletContainer(logger, server, wac, connector.getLocalPort(), warDir);
}
#method_after
@Override
public ServletContainer start(TreeLogger logger, int port, File warDir) throws Exception {
    TreeLogger branch = logger.branch(TreeLogger.INFO, "Starting Jetty on port " + port, null);
    checkStartParams(branch, port, warDir);
    // Setup our branch logger during startup.
    Log.setLog(new JettyTreeLogger(branch));
    // Turn off XML validation.
    System.setProperty("org.mortbay.xml.XmlParser.Validating", "false");
    Server server = new Server();
    HttpConfiguration config = defaultConfig();
    ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(config));
    if (bindAddress != null) {
        connector.setHost(bindAddress);
    }
    connector.setPort(port);
    // Don't share ports with an existing process.
    connector.setReuseAddress(false);
    // Linux keeps the port blocked after shutdown if we don't disable this.
    connector.setSoLingerTime(0);
    server.addConnector(connector);
    File top;
    String root = System.getProperty("gerrit.source_root");
    if (root != null) {
        top = new File(root);
    } else {
        // Under Maven warDir is "$top/gerrit-gwtui/target/gwt-hosted-mode"
        top = warDir.getParentFile().getParentFile().getParentFile();
    }
    File app = new File(top, "gerrit-war/src/main/webapp");
    File webxml = new File(app, "WEB-INF/web.xml");
    // Jetty won't start unless this directory exists.
    if (!warDir.exists() && !warDir.mkdirs())
        logger.branch(TreeLogger.ERROR, "Cannot create " + warDir, null);
    // Create a new web app in the war directory.
    // 
    WebAppContext wac = new MyWebAppContext(warDir.getAbsolutePath(), "/");
    wac.setDescriptor(webxml.getAbsolutePath());
    RequestLogHandler logHandler = new RequestLogHandler();
    logHandler.setRequestLog(new JettyRequestLogger(logger));
    logHandler.setHandler(wac);
    server.setHandler(logHandler);
    server.start();
    server.setStopAtShutdown(true);
    // Now that we're started, log to the top level logger.
    Log.setLog(new JettyTreeLogger(logger));
    return new JettyServletContainer(logger, server, wac, connector.getLocalPort(), warDir);
}
#end_block

#method_before
static Config parseFromSystemProperty() throws ConfigInvalidException, IOException {
    Config cfg = new Config();
    String name = System.getProperty(CONFIG_PKG + "BaseConfig");
    if (!Strings.isNullOrEmpty(name)) {
        URL url = ConfigAnnotationParser.class.getResource(CONFIG_DIR + name);
        if (url != null) {
            cfg.fromText(Resources.toString(url, Charsets.UTF_8));
        }
    }
    return cfg;
}
#method_after
static Config parseFromSystemProperty() throws ConfigInvalidException, IOException {
    Config cfg = new Config();
    String name = System.getProperty(CONFIG_PKG + "BaseConfig");
    if (!Strings.isNullOrEmpty(name)) {
        String resource = CONFIG_DIR + name + ".config";
        URL url = checkNotNull(ConfigAnnotationParser.class.getResource(resource), "test config resource not found: %s", resource);
        cfg.fromText(Resources.toString(url, Charsets.UTF_8));
    }
    return cfg;
}
#end_block

#method_before
static Config parse(Config base, GerritConfigs annotation) {
    if (annotation == null) {
        return null;
    }
    Config cfg = new Config(base);
    for (GerritConfig c : annotation.value()) {
        parse(cfg, c);
    }
    return cfg;
}
#method_after
static Config parse(Config base, GerritConfigs annotation) {
    if (annotation == null) {
        return null;
    }
    Config cfg = new Config(base);
    for (GerritConfig c : annotation.value()) {
        parseAnnotation(cfg, c);
    }
    return cfg;
}
#end_block

#method_before
private void reloadIfNeeded() {
    if (isAutoReload() && currentConfig.getCfgPath().lastModified() > currentConfigTs) {
        try {
            ReplicationFileBasedConfig newConfig = loadConfig();
            newConfig.startup(workQueue);
            int discarded = currentConfig.shutdown();
            this.currentConfig = newConfig;
            this.currentConfigTs = currentConfig.getCfgPath().lastModified();
            LOG.info("Configuration reloaded: " + currentConfig.getDestinations().size() + " destinations, " + discarded + " replication events discarded");
        } catch (Exception e) {
            LOG.error("Cannot reload replication configuration: keeping existing settings", e);
            return;
        }
    }
}
#method_after
private void reloadIfNeeded() {
    if (isAutoReload() && currentConfig.getCfgPath().lastModified() > currentConfigTs) {
        try {
            ReplicationFileBasedConfig newConfig = loadConfig();
            newConfig.startup(workQueue);
            int discarded = currentConfig.shutdown();
            this.currentConfig = newConfig;
            this.currentConfigTs = currentConfig.getCfgPath().lastModified();
            log.info("Configuration reloaded: " + currentConfig.getDestinations().size() + " destinations, " + discarded + " replication events discarded");
        } catch (Exception e) {
            log.error("Cannot reload replication configuration: keeping existing settings", e);
            return;
        }
    }
}
#end_block

#method_before
private List<Destination> allDestinations() throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("No " + config.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Empty " + config.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        Destination destination = new Destination(injector, c, config, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations() throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("Config file " + config.getFile() + "does not exist; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Config file " + config.getFile() + " is empty; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        Destination destination = new Destination(injector, c, config, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(SecureCredentialsFactory.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
}
#method_after
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(CredentialsFactory.class).to(AutoReloadSecureCredentialsFactoryDecorator.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(change, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalsUtil.copyLabels(db, changeCtl, newPatchSet.getId());
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(change);
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(change, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet.getId());
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(change);
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(c, patchSet.getCreatedOn(), (IdentifiedUser) ctl.getCurrentUser());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            insertMessage(db);
        }
        if (copyLabels) {
            approvalsUtil.copyLabels(db, ctl, patchSet.getId());
        }
        db.commit();
        update.commit();
        if (!messageIsForChange()) {
            insertMessage(db);
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(updatedChange);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(c, patchSet.getCreatedOn(), (IdentifiedUser) ctl.getCurrentUser());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            insertMessage(db);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet.getId());
        }
        db.commit();
        update.commit();
        if (!messageIsForChange()) {
            insertMessage(db);
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(updatedChange);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#end_block

#method_before
private static PatchSetApproval copy(PatchSetApproval src, PatchSet.Id psId) {
    if (src.getKey().getParentKey().equals(psId)) {
        return src;
    }
    return new PatchSetApproval(psId, src);
}
#method_after
public void copy(ReviewDb db, ChangeControl ctl, PatchSet.Id psId) throws OrmException {
    db.patchSetApprovals().insert(getForPatchSet(db, ctl, psId));
}
#end_block

#method_before
List<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId) throws OrmException {
    ChangeData cd = changeDataFactory.create(db, ctl);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.allApprovalsMap();
        Change.Id cid = cd.change().getId();
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(psId)) {
            byUser.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        Map<Integer, PatchSet> patchSets = getPatchSets(cd);
        PatchSet currPs = patchSets.get(psId.get());
        if (currPs == null) {
            throw new OrmException("missing patch set " + psId);
        }
        Repository repo = repoManager.openRepository(project.getProject().getNameKey());
        try {
            for (int i = psId.get() - 1; i >= 1; i--) {
                PatchSet.Id prior = new PatchSet.Id(cid, i);
                PatchSet priorPs = patchSets.get(i);
                if (priorPs == null) {
                    throw new OrmException("missing patch set " + prior);
                }
                List<PatchSetApproval> priorApprovals = all.get(prior);
                if (priorApprovals.isEmpty()) {
                    continue;
                }
                ChangeKind kind = changeKindCache.getChangeKind(project, repo, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(currPs.getRevision().get()));
                for (PatchSetApproval psa : priorApprovals) {
                    if (!byUser.contains(psa.getLabel(), psa.getAccountId()) && canCopy(project, psa, kind)) {
                        byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, psId));
                    }
                }
            }
            return labelNormalizer.normalize(ctl, byUser.values());
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
private List<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId) throws OrmException {
    ChangeData cd = changeDataFactory.create(db, ctl);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.allApprovalsMap();
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(psId)) {
            byUser.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        TreeMap<Integer, PatchSet> patchSets = getPatchSets(cd);
        NavigableSet<Integer> allPsIds = patchSets.navigableKeySet();
        PatchSet currPs = patchSets.get(psId.get());
        if (currPs == null) {
            throw new OrmException("missing patch set " + psId);
        }
        Repository repo = repoManager.openRepository(project.getProject().getNameKey());
        try {
            // Walk patch sets strictly less than psId in descending order.
            for (PatchSet priorPs : patchSets.descendingMap().tailMap(psId.get(), false).values()) {
                List<PatchSetApproval> priorApprovals = all.get(priorPs.getId());
                if (priorApprovals.isEmpty()) {
                    continue;
                }
                ChangeKind kind = changeKindCache.getChangeKind(project, repo, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(currPs.getRevision().get()));
                for (PatchSetApproval psa : priorApprovals) {
                    if (!byUser.contains(psa.getLabel(), psa.getAccountId()) && canCopy(project, psa, psId, allPsIds, kind)) {
                        byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, psId));
                    }
                }
            }
            return labelNormalizer.normalize(ctl, byUser.values());
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private static Map<Integer, PatchSet> getPatchSets(ChangeData cd) throws OrmException {
    Collection<PatchSet> patchSets = cd.patches();
    Map<Integer, PatchSet> result = Maps.newHashMapWithExpectedSize(patchSets.size());
    for (PatchSet ps : patchSets) {
        result.put(ps.getId().get(), ps);
    }
    return result;
}
#method_after
private static TreeMap<Integer, PatchSet> getPatchSets(ChangeData cd) throws OrmException {
    Collection<PatchSet> patchSets = cd.patches();
    TreeMap<Integer, PatchSet> result = Maps.newTreeMap();
    for (PatchSet ps : patchSets) {
        result.put(ps.getId().get(), ps);
    }
    return result;
}
#end_block

#method_before
private static boolean canCopy(ProjectState project, PatchSetApproval psa, ChangeKind kind) throws OrmException {
    LabelType type = project.getLabelTypes().byLabel(psa.getLabelId());
    if (type == null) {
        return false;
    } else if (type.isCopyMinScore() && type.isMaxNegative(psa) || type.isCopyMaxScore() && type.isMaxPositive(psa)) {
        return true;
    }
    return (type.isCopyAllScoresOnTrivialRebase() && kind == TRIVIAL_REBASE) || (type.isCopyAllScoresIfNoCodeChange() && kind == NO_CODE_CHANGE);
}
#method_after
private static boolean canCopy(ProjectState project, PatchSetApproval psa, PatchSet.Id psId, NavigableSet<Integer> allPsIds, ChangeKind kind) throws OrmException {
    int n = psa.getKey().getParentKey().get();
    checkArgument(n != psId.get());
    LabelType type = project.getLabelTypes().byLabel(psa.getLabelId());
    if (type == null) {
        return false;
    } else if (Objects.equal(n, previous(allPsIds, psId.get())) && (type.isCopyMinScore() && type.isMaxNegative(psa) || type.isCopyMaxScore() && type.isMaxPositive(psa))) {
        // may not be psId.get() - 1).
        return true;
    }
    return (type.isCopyAllScoresOnTrivialRebase() && kind == TRIVIAL_REBASE) || (type.isCopyAllScoresIfNoCodeChange() && kind == NO_CODE_CHANGE);
}
#end_block

#method_before
@Override
protected void configure() {
    super.configure();
    install(ThreadLocalRequestContext.module());
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(QueryDocumentationExecutor.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(SystemGroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    cfgInjector = createCfgInjector();
    limitThreads();
    if (version == null) {
        version = ChangeSchemas.getLatest().getVersion();
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    index = sysInjector.getInstance(IndexCollection.class).getSearchIndex();
    index.markReady(false);
    index.deleteAll();
    int result = indexAll();
    index.markReady(true);
    sysManager.stop();
    dbManager.stop();
    return result;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    limitThreads();
    if (version == null) {
        version = ChangeSchemas.getLatest().getVersion();
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    index = sysInjector.getInstance(IndexCollection.class).getSearchIndex();
    index.markReady(false);
    index.deleteAll();
    int result = indexAll();
    index.markReady(true);
    sysManager.stop();
    dbManager.stop();
    return result;
}
#end_block

#method_before
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(version, threads, outputBase);
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(false, threads, outputBase);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    // modules.add(new LogFileCompressor.Module());
    // modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModuleBase.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(NoSshKeyCache.module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(CurrentUser.class).toProvider(new Provider<CurrentUser>() {

                @Override
                public CurrentUser get() {
                    return null;
                }
            });
            bind(IdentifiedUser.class).toProvider(new Provider<IdentifiedUser>() {

                @Override
                public IdentifiedUser get() {
                    return null;
                }
            });
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(version, threads, outputBase);
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(false, threads, outputBase);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    modules.add(new FactoryModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
            factory(ChangeData.Factory.class);
            factory(ProjectState.Factory.class);
            bind(new TypeLiteral<List<CommentLinkInfo>>() {
            }).toProvider(CommentLinkProvider.class).in(SINGLETON);
            bind(CurrentUser.class).toProvider(Providers.<CurrentUser>of(null));
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class);
            factory(IncludingGroupMembership.Factory.class);
            bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
            DynamicSet.setOf(binder(), GroupBackend.class);
            bind(InternalGroupBackend.class).in(SINGLETON);
            DynamicSet.bind(binder(), GroupBackend.class).to(SystemGroupBackend.class);
            DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
            factory(InternalUser.Factory.class);
            factory(PatchSetInserter.Factory.class);
            bind(ChangeHooks.class).to(DisabledChangeHooks.class);
            bind(ReplacePatchSetSender.Factory.class).toProvider(Providers.<ReplacePatchSetSender.Factory>of(null));
            factory(CapabilityControl.Factory.class);
            factory(MergeUtil.Factory.class);
            DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
            DynamicSet.setOf(binder(), CommitValidationListener.class);
            factory(CommitValidators.Factory.class);
        }
    });
    modules.add(AccountCacheImpl.module());
    modules.add(AccountByEmailCacheImpl.module());
    modules.add(ChangeKindCache.module());
    modules.add(GroupCacheImpl.module());
    modules.add(GroupIncludeCacheImpl.module());
    modules.add(ProjectCacheImpl.module());
    modules.add(SectionSortCache.module());
    modules.add(new AccessControlModule());
    modules.add(new GitModule());
    modules.add(new PrologModule());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @MergeabilityChecksExecutor
        public WorkQueue.Executor createMergeabilityChecksExecutor(WorkQueue queues) {
            return queues.createQueue(1, "MergeabilityChecks");
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(Event event) {
    String ref = event.getRefName();
    if (ref.startsWith(Constants.R_HEADS) || ref.equals(GitRepositoryManager.REF_CONFIG)) {
        executor.submit(new RefUpdateTask(schemaFactory, new Project.NameKey(event.getProjectName()), ref));
    }
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    String ref = event.getRefName();
    if (ref.startsWith(Constants.R_HEADS) || ref.equals(RefNames.REFS_CONFIG)) {
        executor.submit(new BranchUpdateTask(schemaFactory, new Project.NameKey(event.getProjectName()), ref));
    }
    if (ref.equals(RefNames.REFS_CONFIG)) {
        Project.NameKey p = new Project.NameKey(event.getProjectName());
        try {
            ProjectConfig oldCfg = parseConfig(p, event.getOldObjectId());
            ProjectConfig newCfg = parseConfig(p, event.getNewObjectId());
            if (recheckMerges(oldCfg, newCfg)) {
                try {
                    new ProjectUpdateTask(schemaFactory, p, true).call();
                } catch (Exception e) {
                    String msg = "Failed to update mergeability flags for project " + p.get() + " on update of " + RefNames.REFS_CONFIG;
                    log.error(msg, e);
                    Throwables.propagateIfPossible(e);
                    throw new RuntimeException(msg, e);
                }
            }
        } catch (ConfigInvalidException | IOException e) {
            String msg = "Failed to update mergeability flags for project " + p.get() + " on update of " + RefNames.REFS_CONFIG;
            log.error(msg, e);
            throw new RuntimeException(msg, e);
        }
    }
}
#end_block

#method_before
public CheckedFuture<Boolean, IOException> updateAsync(Change change) {
    return Futures.makeChecked(executor.submit(new ChangeUpdateTask(schemaFactory, change)), MAPPER);
}
#method_after
public CheckedFuture<Boolean, IOException> updateAsync(Change change) {
    return updateAsync(change, false);
}
#end_block

#method_before
public CheckedFuture<Boolean, IOException> updateAsync(Change change) {
    return Futures.makeChecked(executor.submit(new ChangeUpdateTask(schemaFactory, change)), MAPPER);
}
#method_after
private CheckedFuture<Boolean, IOException> updateAsync(Change change, boolean force) {
    return Futures.makeChecked(executor.submit(new ChangeUpdateTask(schemaFactory, change, force)), MAPPER);
}
#end_block

#method_before
public CheckedFuture<?, IOException> updateAndIndexAsync(final Change change) {
    return Futures.makeChecked(Futures.transform(updateAsync(change), new AsyncFunction<Boolean, Object>() {

        @SuppressWarnings("unchecked")
        @Override
        public ListenableFuture<Object> apply(Boolean indexUpdated) throws Exception {
            if (!indexUpdated) {
                return (ListenableFuture<Object>) indexer.indexAsync(change);
            }
            return Futures.immediateFuture(null);
        }
    }), MAPPER);
}
#method_after
public CheckedFuture<?, IOException> updateAndIndexAsync(Change change) {
    final Change.Id id = change.getId();
    return Futures.makeChecked(Futures.transform(updateAsync(change), new AsyncFunction<Boolean, Object>() {

        @SuppressWarnings("unchecked")
        @Override
        public ListenableFuture<Object> apply(Boolean indexUpdated) throws Exception {
            if (!indexUpdated) {
                return (ListenableFuture<Object>) indexer.indexAsync(id);
            }
            return Futures.immediateFuture(null);
        }
    }), MAPPER);
}
#end_block

#method_before
public boolean update(Change change) throws IOException {
    try {
        return new ChangeUpdateTask(schemaFactory, change).call();
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw MAPPER.apply(e);
    }
}
#method_after
public void update(Project.NameKey project) throws IOException {
    try {
        for (CheckedFuture<?, IOException> f : new ProjectUpdateTask(schemaFactory, project, false).call()) {
            f.checkedGet();
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw MAPPER.apply(e);
    }
}
#end_block

#method_before
@Override
public Boolean call() throws Exception {
    mergeabilityCheckQueue.updatingMergeabilityFlag(change);
    RequestContext context = new RequestContext() {

        @Override
        public CurrentUser getCurrentUser() {
            return identifiedUserFactory.create(change.getOwner());
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return new Provider<ReviewDb>() {

                @Override
                public ReviewDb get() {
                    if (reviewDb == null) {
                        try {
                            reviewDb = schemaFactory.open();
                        } catch (OrmException e) {
                            throw new ProvisionException("Cannot open ReviewDb", e);
                        }
                    }
                    return reviewDb;
                }
            };
        }
    };
    RequestContext old = tl.setContext(context);
    ReviewDb db = context.getReviewDbProvider().get();
    try {
        PatchSet ps = db.patchSets().get(change.currentPatchSetId());
        MergeableInfo info = mergeable.get().apply(new RevisionResource(new ChangeResource(changeControlFactory.controlFor(change, context.getCurrentUser())), ps));
        return change.isMergeable() != info.mergeable;
    } catch (ResourceConflictException e) {
        // change is closed
        return false;
    } finally {
        tl.setContext(old);
        if (reviewDb != null) {
            reviewDb.close();
            reviewDb = null;
        }
    }
}
#method_after
@Override
public Boolean call() throws Exception {
    mergeabilityCheckQueue.updatingMergeabilityFlag(change, force);
    RequestContext context = new RequestContext() {

        @Override
        public CurrentUser getCurrentUser() {
            return identifiedUserFactory.create(change.getOwner());
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return new Provider<ReviewDb>() {

                @Override
                public ReviewDb get() {
                    if (reviewDb == null) {
                        try {
                            reviewDb = schemaFactory.open();
                        } catch (OrmException e) {
                            throw new ProvisionException("Cannot open ReviewDb", e);
                        }
                    }
                    return reviewDb;
                }
            };
        }
    };
    RequestContext old = tl.setContext(context);
    ReviewDb db = context.getReviewDbProvider().get();
    try {
        PatchSet ps = db.patchSets().get(change.currentPatchSetId());
        Mergeable m = mergeable.get();
        m.setForce(force);
        ChangeControl control = changeControlFactory.controlFor(change.getId(), context.getCurrentUser());
        MergeableInfo info = m.apply(new RevisionResource(new ChangeResource(control), ps));
        return change.isMergeable() != info.mergeable;
    } catch (ResourceConflictException e) {
        // change is closed
        return false;
    } finally {
        tl.setContext(old);
        if (reviewDb != null) {
            reviewDb.close();
            reviewDb = null;
        }
    }
}
#end_block

#method_before
public Result indexAll(ChangeIndex index, Iterable<Project.NameKey> projects, int numProjects, int numChanges, OutputStream progressOut, OutputStream verboseOut) {
    if (progressOut == null) {
        progressOut = NullOutputStream.INSTANCE;
    }
    PrintWriter verboseWriter = verboseOut != null ? new PrintWriter(verboseOut) : null;
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", numProjects >= 0 ? numProjects : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, numChanges >= 0 ? numChanges : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = Lists.newArrayList();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        final ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(index), project, doneTask, failedTask, verboseWriter));
        futures.add(future);
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    fail(project, e);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    try {
        mpm.waitFor(Futures.transform(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
        // TODO(davido): include indexing of mergeable field in MPM above
        for (Project.NameKey project : projects) {
            List<CheckedFuture<?, IOException>> f = checker.reindexProject(project);
            for (CheckedFuture<?, IOException> checkedFuture : f) {
                checkedFuture.checkedGet();
            }
        }
    } catch (ExecutionException | IOException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#method_after
public Result indexAll(ChangeIndex index, Iterable<Project.NameKey> projects, int numProjects, int numChanges, OutputStream progressOut, OutputStream verboseOut) {
    if (progressOut == null) {
        progressOut = NullOutputStream.INSTANCE;
    }
    PrintWriter verboseWriter = verboseOut != null ? new PrintWriter(verboseOut) : null;
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", numProjects >= 0 ? numProjects : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, numChanges >= 0 ? numChanges : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = Lists.newArrayList();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        try {
            mergeabilityChecker.update(project);
        } catch (IOException e) {
            log.error("Error in mergeability checker", e);
            ok.set(false);
        }
        final ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(index), project, doneTask, failedTask, verboseWriter));
        futures.add(future);
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    fail(project, e);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    try {
        mpm.waitFor(Futures.transform(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
    } catch (ExecutionException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#end_block

#method_before
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            Repository repo = null;
            try {
                repo = repoManager.openRepository(project);
                Map<String, Ref> refs = repo.getRefDatabase().getRefs(ALL);
                for (Change c : db.get().changes().byProject(project)) {
                    Ref r = refs.get(c.currentPatchSetId().toRefName());
                    if (r != null) {
                        byId.put(r.getObjectId(), new ChangeData(c));
                    }
                }
                new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
            } catch (RepositoryNotFoundException rnfe) {
                log.error(rnfe.getMessage());
            } finally {
                if (repo != null) {
                    repo.close();
                }
            // TODO(dborowitz): Opening all repositories in a live server may be
            // wasteful; see if we can determine which ones it is safe to close
            // with RepositoryCache.close(repo).
            }
            return null;
        }
    };
}
#method_after
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            Repository repo = null;
            ReviewDb db = null;
            try {
                repo = repoManager.openRepository(project);
                Map<String, Ref> refs = repo.getRefDatabase().getRefs(ALL);
                db = schemaFactory.open();
                for (Change c : db.changes().byProject(project)) {
                    Ref r = refs.get(c.currentPatchSetId().toRefName());
                    if (r != null) {
                        byId.put(r.getObjectId(), changeDataFactory.create(db, c));
                    }
                }
                new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
            } catch (RepositoryNotFoundException rnfe) {
                log.error(rnfe.getMessage());
            } finally {
                if (db != null) {
                    db.close();
                }
                if (repo != null) {
                    repo.close();
                }
            // TODO(dborowitz): Opening all repositories in a live server may be
            // wasteful; see if we can determine which ones it is safe to close
            // with RepositoryCache.close(repo).
            }
            return null;
        }
    };
}
#end_block

#method_before
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    String sub = commit.subject();
    String msg = commit.message();
    if (msg.startsWith(sub)) {
        msg = msg.substring(sub.length());
        if (msg.length() > 0 && msg.charAt(0) == '\n') {
            msg = msg.substring(1);
        }
    }
    commitName.setText("Commit-Id: " + revision);
    commitName.setPreviewText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(msg).linkify()));
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        browserLink.setInnerText(gw.getLinkName());
        browserLink.setHref(gw.toRevision(change.project(), revision));
    } else {
        UIObject.setVisible(browserLink, false);
    }
}
#method_after
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    String sub = commit.subject();
    String msg = commit.message();
    if (msg.startsWith(sub)) {
        msg = msg.substring(sub.length());
        if (msg.length() > 0 && msg.charAt(0) == '\n') {
            msg = msg.substring(1);
        }
    }
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(msg).linkify()));
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        browserLink.setInnerText(gw.getLinkName());
        browserLink.setHref(gw.toRevision(change.project(), revision));
    } else {
        UIObject.setVisible(browserLink, false);
    }
}
#end_block

#method_before
private void postInitPlugins() throws Exception {
    for (InitStep initStep : pluginLoader.getInitSteps()) {
        if (initStep instanceof PostInitStep) {
            ((PostInitStep) initStep).postRun();
        }
    }
}
#method_after
private void postInitPlugins() throws Exception {
    for (InitStep initStep : pluginLoader.getInitSteps()) {
        initStep.postRun();
    }
}
#end_block

#method_before
public void postRun() throws Exception {
    for (InitStep step : steps) {
        if (!(step instanceof PostInitStep)) {
            continue;
        }
        if (step instanceof InitPlugins && flags.skipPlugins) {
            continue;
        }
        ((PostInitStep) step).postRun();
    }
}
#method_after
public void postRun() throws Exception {
    for (InitStep step : steps) {
        if (step instanceof InitPlugins && flags.skipPlugins) {
            continue;
        }
        step.postRun();
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    try {
        ProjectResource projectResource = new ProjectResource(project);
        CreateBranch.Input input = new CreateBranch.Input();
        input.ref = ref;
        input.revision = revision;
        createBranchFactory.create(ref).apply(projectResource, input);
    } catch (IOException e) {
        throw new RestApiException("Cannot create branch", e);
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    try {
        BranchInput in = new BranchInput();
        in.revision = revision;
        gApi.projects().name(project.getProject().getNameKey().get()).branch(name).create(in);
    } catch (RestApiException e) {
        throw new UnloggedFailure(1, "fatal: " + e.getMessage(), e);
    }
}
#end_block

#method_before
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineLabel(C.keyHelp()));
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    final String reportBugUrl = getConfig().getReportBugUrl();
    final String reportBugTitle = getConfig().getReportBugText();
    if (reportBugUrl != null) {
        Anchor a = new Anchor(reportBugTitle == null ? C.reportBug() : reportBugTitle, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
}
#method_after
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineLabel(C.keyHelp()));
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    final String reportBugText = getConfig().getReportBugText();
    Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, getConfig().getReportBugUrl());
    a.setTarget("_blank");
    a.setStyleName("");
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(a);
}
#end_block

#method_before
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    if (Strings.isNullOrEmpty(config.getReportBugText())) {
        config.setReportBugText(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#method_after
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    final String reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl");
    config.setReportBugUrl(reportBugUrl != null ? reportBugUrl : "http://code.google.com/p/gerrit/issues/list");
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#end_block

#method_before
public void setReportBugText(String u) {
    reportBugText = u;
}
#method_after
public void setReportBugText(String t) {
    reportBugText = t;
}
#end_block

#method_before
private ItsAssociationPolicy getItsAssociationPolicy() {
    return gerritConfig.getEnum("commentLink", pluginsName, "association", ItsAssociationPolicy.OPTIONAL);
}
#method_after
private ItsAssociationPolicy getItsAssociationPolicy() {
    return gerritConfig.getEnum("commentLink", pluginName, "association", ItsAssociationPolicy.OPTIONAL);
}
#end_block

#method_before
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + "/plugins/";
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#method_after
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + PLUGINS_PREFIX;
    authorizedBase = Strings.nullToEmpty(path) + AUTHORIZED_PREFIX;
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#end_block

#method_before
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    WrappedRequest wr = new WrappedRequest(req, base + name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#method_after
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    WrappedRequest wr = new WrappedRequest(req, (isAuthorizedCall(req) ? authorizedBase : base) + name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#end_block

#method_before
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    if (uri.length() <= ctx.length()) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = uri.substring(ctx.length() + 1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        if (jar == null) {
            String jsFileName = file.replaceFirst("static/", "");
            sendJsPlugin(jsFileName, key, req, res);
        } else {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    if (uri.length() <= ctx.length()) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = uri.substring(ctx.length() + 1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        if (jar != null) {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        } else {
            sendJsPlugin(holder.plugin, key, req, res);
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            if (name.substring(prefix.length()).startsWith("cmd-")) {
                cmds.add(entry);
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (!docs.isEmpty()) {
        md.append("## Documentation ##\n");
        for (JarEntry entry : docs) {
            String rsrc = entry.getName().substring(prefix.length());
            String title;
            if (rsrc.endsWith(".html")) {
                title = rsrc.substring(0, rsrc.length() - 5).replace('-', ' ');
            } else if (rsrc.endsWith(".md")) {
                title = extractTitleFromMarkdown(jar, entry);
                if (Strings.isNullOrEmpty(title)) {
                    title = rsrc.substring(0, rsrc.length() - 3).replace('-', ' ');
                }
                rsrc = rsrc.substring(0, rsrc.length() - 3) + ".html";
            } else {
                title = rsrc.replace('-', ' ');
            }
            md.append(String.format("* [%s](%s)\n", title, rsrc));
        }
        md.append("\n");
    }
    if (!cmds.isEmpty()) {
        md.append("## Commands ##\n");
        for (JarEntry entry : cmds) {
            String rsrc = entry.getName().substring(prefix.length());
            String title;
            if (rsrc.endsWith(".html")) {
                title = rsrc.substring(4, rsrc.length() - 5).replace('-', ' ');
            } else if (rsrc.endsWith(".md")) {
                title = extractTitleFromMarkdown(jar, entry);
                if (Strings.isNullOrEmpty(title)) {
                    title = rsrc.substring(4, rsrc.length() - 3).replace('-', ' ');
                }
                rsrc = rsrc.substring(0, rsrc.length() - 3) + ".html";
            } else {
                title = rsrc.substring(4).replace('-', ' ');
            }
            md.append(String.format("* [%s](%s)\n", title, rsrc));
        }
        md.append("\n");
    }
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res);
}
#method_after
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> servlets = Lists.newArrayList();
    List<JarEntry> restApis = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    JarEntry about = null;
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(jar.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(jar, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(jar, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(jar, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(jar, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res);
}
#end_block

#method_before
private void sendResource(JarFile jar, JarEntry entry, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] data = null;
    if (entry.getSize() <= SMALL_RESOURCE) {
        data = readWholeEntry(jar, entry);
    }
    String contentType = null;
    String charEnc = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        contentType = Strings.emptyToNull(atts.getValue("Content-Type"));
        charEnc = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    if (contentType == null) {
        contentType = mimeUtil.getMimeType(entry.getName(), data).toString();
        if ("application/octet-stream".equals(contentType) && entry.getName().endsWith(".js")) {
            contentType = "application/javascript";
        }
    }
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    res.setHeader("Content-Length", Long.toString(entry.getSize()));
    res.setContentType(contentType);
    if (charEnc != null) {
        res.setCharacterEncoding(charEnc);
    }
    if (data != null) {
        resourceCache.put(key, new SmallResource(data).setContentType(contentType).setCharacterEncoding(charEnc).setLastModified(time));
        res.getOutputStream().write(data);
    } else {
        InputStream in = jar.getInputStream(entry);
        writeToResponse(res, in);
    }
}
#method_after
private void sendResource(JarFile jar, JarEntry entry, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] data = null;
    if (entry.getSize() <= SMALL_RESOURCE) {
        data = readWholeEntry(jar, entry);
    }
    String contentType = null;
    String charEnc = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        contentType = Strings.emptyToNull(atts.getValue("Content-Type"));
        charEnc = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    if (contentType == null) {
        contentType = mimeUtil.getMimeType(entry.getName(), data).toString();
        if ("application/octet-stream".equals(contentType) && entry.getName().endsWith(".js")) {
            contentType = "application/javascript";
        }
    }
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    res.setHeader("Content-Length", Long.toString(entry.getSize()));
    res.setContentType(contentType);
    if (charEnc != null) {
        res.setCharacterEncoding(charEnc);
    }
    if (data != null) {
        resourceCache.put(key, new SmallResource(data).setContentType(contentType).setCharacterEncoding(charEnc).setLastModified(time));
        res.getOutputStream().write(data);
    } else {
        writeToResponse(res, jar.getInputStream(entry));
    }
}
#end_block

#method_before
private void sendJsPlugin(String jsFileName, ResourceKey key, HttpServletRequest req, HttpServletResponse res) throws IOException {
    File jsFile = new File(pluginsDir, jsFileName);
    if (jsFile.exists()) {
        res.setHeader("Content-Length", Long.toString(jsFile.length()));
        res.setContentType("application/javascript");
        writeToResponse(res, new FileInputStream(jsFile));
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void sendJsPlugin(Plugin plugin, ResourceKey key, HttpServletRequest req, HttpServletResponse res) throws IOException {
    File pluginFile = plugin.getSrcFile();
    if (req.getPathInfo().equals(getJsPluginPath(plugin)) && pluginFile.exists()) {
        res.setHeader("Content-Length", Long.toString(pluginFile.length()));
        res.setContentType("application/javascript");
        writeToResponse(res, new FileInputStream(pluginFile));
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
@Override
public String getServletPath() {
    return ((HttpServletRequest) getRequest()).getRequestURI().substring(contextPath.length());
}
#method_after
@Override
public String getServletPath() {
    return getRequestURI().substring(contextPath.length());
}
#end_block

#method_before
@Override
public void start(PluginGuiceEnvironment env) throws Exception {
    manager = new LifecycleManager();
    String fileName = getSrcFile().getName();
    httpInjector = Guice.createInjector(new StandaloneJsPluginModule(getName(), fileName));
    manager.add(httpInjector);
    manager.start();
}
#method_after
@Override
public void start(PluginGuiceEnvironment env) throws Exception {
    manager = new LifecycleManager();
    String fileName = getSrcFile().getName();
    httpInjector = Guice.createInjector(new StandaloneJsPluginModule(getName(), fileName));
    manager.start();
}
#end_block

#method_before
@Override
void stop(PluginGuiceEnvironment env) {
    if (manager != null) {
        manager.stop();
    }
}
#method_after
@Override
void stop(PluginGuiceEnvironment env) {
    if (manager != null) {
        manager.stop();
        httpInjector = null;
    }
}
#end_block

#method_before
@Override
boolean canReload() {
    return false;
}
#method_after
@Override
boolean canReload() {
    return true;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
    bind(WebUiPlugin.class).annotatedWith(UniqueAnnotations.create()).toInstance(new JavaScriptPlugin(fileName));
}
#method_after
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
    DynamicSet.bind(binder(), WebUiPlugin.class).toInstance(new JavaScriptPlugin(fileName));
}
#end_block

#method_before
public void installPluginFromStream(String name, InputStream in) throws IOException, PluginInstallException {
    if (!(name.endsWith(".jar") || name.endsWith(".js"))) {
        throw new ParserInitializationException("Can only install files with '.jar' and '.js' extension");
    }
    File jar = new File(pluginsDir, name);
    name = nameOf(jar);
    File old = new File(pluginsDir, ".last_" + name + ".zip");
    File tmp = asTemp(in, ".next_" + name, ".zip", pluginsDir);
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            log.info(String.format("Replacing plugin %s", name));
            old.delete();
            jar.renameTo(old);
        }
        new File(pluginsDir, name + ".jar.disabled").delete();
        tmp.renameTo(jar);
        try {
            runPlugin(name, jar, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", name));
            }
        } catch (PluginInstallException e) {
            jar.delete();
            throw e;
        }
        cleanInBackground();
    }
}
#method_after
public void installPluginFromStream(String originalName, InputStream in) throws IOException, PluginInstallException {
    String fileName = originalName;
    if (!(fileName.endsWith(".jar") || fileName.endsWith(".js"))) {
        fileName += ".jar";
    }
    File tmp = asTemp(in, ".next_" + fileName + "_", ".tmp", pluginsDir);
    String name = Objects.firstNonNull(getGerritPluginName(tmp), nameOf(fileName));
    if (!originalName.equals(name)) {
        log.warn(String.format("Plugin provides its own name: <%s>," + " use it instead of the input name: <%s>", name, originalName));
    }
    String fileExtension = getExtension(fileName);
    File dst = new File(pluginsDir, name + fileExtension);
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            fileName = active.getSrcFile().getName();
            log.info(String.format("Replacing plugin %s", active.getName()));
            File old = new File(pluginsDir, ".last_" + fileName);
            old.delete();
            active.getSrcFile().renameTo(old);
        }
        new File(pluginsDir, fileName + ".disabled").delete();
        tmp.renameTo(dst);
        try {
            Plugin plugin = runPlugin(name, dst, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", plugin.getName()));
            }
        } catch (PluginInstallException e) {
            dst.delete();
            throw e;
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public static File storeInTemp(String pluginName, InputStream in, SitePaths sitePaths) throws IOException {
    return asTemp(in, tempNameFor(pluginName), ".jar", sitePaths.tmp_dir);
}
#method_after
public static File storeInTemp(String pluginName, InputStream in, SitePaths sitePaths) throws IOException {
    if (!sitePaths.tmp_dir.exists()) {
        sitePaths.tmp_dir.mkdirs();
    }
    return asTemp(in, tempNameFor(pluginName), ".jar", sitePaths.tmp_dir);
}
#end_block

#method_before
public void disablePlugins(Set<String> names) {
    synchronized (this) {
        for (String name : names) {
            Plugin active = running.get(name);
            if (active == null) {
                continue;
            }
            log.info(String.format("Disabling plugin %s", name));
            File off = new File(pluginsDir, active.getName() + ".jar.disabled");
            active.getSrcFile().renameTo(off);
            unloadPlugin(active);
            try {
                FileSnapshot snapshot = FileSnapshot.save(off);
                Plugin offPlugin = loadPlugin(name, off, snapshot);
                disabled.put(name, offPlugin);
            } catch (Throwable e) {
                // This shouldn't happen, as the plugin was loaded earlier.
                log.warn(String.format("Cannot load disabled plugin %s", name), e.getCause());
            }
        }
        cleanInBackground();
    }
}
#method_after
public void disablePlugins(Set<String> names) {
    synchronized (this) {
        for (String name : names) {
            Plugin active = running.get(name);
            if (active == null) {
                continue;
            }
            log.info(String.format("Disabling plugin %s", active.getName()));
            File off = new File(active.getSrcFile() + ".disabled");
            active.getSrcFile().renameTo(off);
            unloadPlugin(active);
            try {
                FileSnapshot snapshot = FileSnapshot.save(off);
                Plugin offPlugin = loadPlugin(name, off, snapshot);
                disabled.put(name, offPlugin);
            } catch (Throwable e) {
                // This shouldn't happen, as the plugin was loaded earlier.
                log.warn(String.format("Cannot load disabled plugin %s", active.getName()), e.getCause());
            }
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public void enablePlugins(Set<String> names) throws PluginInstallException {
    synchronized (this) {
        for (String name : names) {
            Plugin off = disabled.get(name);
            if (off == null) {
                continue;
            }
            log.info(String.format("Enabling plugin %s", name));
            File on = new File(pluginsDir, off.getName() + ".jar");
            off.getSrcFile().renameTo(on);
            disabled.remove(name);
            runPlugin(name, on, null);
        }
        cleanInBackground();
    }
}
#method_after
public void enablePlugins(Set<String> names) throws PluginInstallException {
    synchronized (this) {
        for (String name : names) {
            Plugin off = disabled.get(name);
            if (off == null) {
                continue;
            }
            log.info(String.format("Enabling plugin %s", name));
            String n = off.getSrcFile().getName();
            if (n.endsWith(".disabled")) {
                n = n.substring(0, n.lastIndexOf('.'));
            }
            File on = new File(pluginsDir, n);
            off.getSrcFile().renameTo(on);
            disabled.remove(name);
            runPlugin(name, on, null);
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public synchronized void rescan() {
    List<File> plugins = scanJarsInPluginsDirectory();
    stopRemovedPlugins(plugins);
    dropRemovedDisabledPlugins(plugins);
    for (File plugin : plugins) {
        if (plugin.getName().endsWith(".disabled")) {
            continue;
        }
        String name = nameOf(plugin);
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(plugin)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(plugin)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", name));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, plugin, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s", name));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> jars = prunePlugins(pluginsDir);
    if (jars.isEmpty()) {
        return;
    }
    syncDisabledPlugins(jars);
    Map<String, File> activePlugins = filterDisabled(jars);
    for (Map.Entry<String, File> entry : activePlugins.entrySet()) {
        String name = entry.getKey();
        File jar = entry.getValue();
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, jar, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private void stopRemovedPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (File jar : jars) {
        if (!jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#method_after
private void stopRemovedPlugins(Multimap<String, File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (Map.Entry<String, Collection<File>> entry : jars.asMap().entrySet()) {
        for (File file : entry.getValue()) {
            if (!file.getName().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#end_block

#method_before
private void dropRemovedDisabledPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (File jar : jars) {
        if (jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#method_after
private void dropRemovedDisabledPlugins(Multimap<String, File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (Map.Entry<String, Collection<File>> entry : jars.asMap().entrySet()) {
        for (File file : entry.getValue()) {
            if (file.getName().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#end_block

#method_before
synchronized int processPendingCleanups() {
    Iterator<Plugin> iterator = toCleanup.iterator();
    while (iterator.hasNext()) {
        Plugin plugin = iterator.next();
        iterator.remove();
        CleanupHandle cleanupHandle = cleanupHandles.remove(plugin);
        cleanupHandle.cleanup();
    }
    return toCleanup.size();
}
#method_after
synchronized int processPendingCleanups() {
    Iterator<Plugin> iterator = toCleanup.iterator();
    while (iterator.hasNext()) {
        Plugin plugin = iterator.next();
        iterator.remove();
        CleanupHandle cleanupHandle = cleanupHandles.remove(plugin);
        if (cleanupHandle != null) {
            cleanupHandle.cleanup();
        }
    }
    return toCleanup.size();
}
#end_block

#method_before
private static String nameOf(File jar) {
    String name = jar.getName();
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#method_after
public static String nameOf(File plugin) {
    return nameOf(plugin.getName());
}
#end_block

#method_before
private static String nameOf(File jar) {
    String name = jar.getName();
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#method_after
private static String nameOf(String name) {
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#end_block

#method_before
private static String getExtension(File file) {
    String name = file.getName();
    int ext = name.lastIndexOf(".");
    return 0 < ext ? name.substring(ext, name.length()) : "";
}
#method_after
private static String getExtension(File file) {
    return getExtension(file.getName());
}
#end_block

#method_before
private static String getExtension(File file) {
    String name = file.getName();
    int ext = name.lastIndexOf(".");
    return 0 < ext ? name.substring(ext, name.length()) : "";
}
#method_after
private static String getExtension(String name) {
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(ext) : "";
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    File tmp;
    FileInputStream in = new FileInputStream(srcPlugin);
    String extension = getExtension(srcPlugin);
    try {
        tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
    } finally {
        in.close();
    }
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else {
        throw new RuntimeException("Unsupported plugin type");
    }
}
#method_after
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        File tmp;
        FileInputStream in = new FileInputStream(srcPlugin);
        String extension = getExtension(srcPlugin);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
        } finally {
            in.close();
        }
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: ", srcPlugin.getName()));
    }
}
#end_block

#method_before
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        URL[] urls = { tmp.toURI().toURL() };
        ClassLoader parentLoader = parentFor(type);
        ClassLoader pluginLoader = new URLClassLoader(urls, parentLoader);
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        Plugin plugin = new JarPlugin(name, pluginUserFactory.create(name), srcJar, snapshot, jarFile, manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new JarPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, jarFile, manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    @SuppressWarnings("unchecked")
    Class<? extends Module> clazz = (Class<? extends Module>) Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return clazz;
}
#method_after
private static Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    @SuppressWarnings("unchecked")
    Class<? extends Module> clazz = (Class<? extends Module>) Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return clazz;
}
#end_block

#method_before
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (isJarPlugin(n) || isJsPlugin(n)) && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#method_after
private static List<File> scanJarsInPluginsDirectory(File pluginsDir) {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (isJarPlugin(n) || isJsPlugin(n)) && !n.startsWith(".last_") && !n.startsWith(".next_") && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#end_block

#method_before
private boolean isJarPlugin(String name) {
    return isPlugin(name, "jar");
}
#method_after
private static boolean isJarPlugin(String name) {
    return isPlugin(name, "jar");
}
#end_block

#method_before
private boolean isJsPlugin(String name) {
    return isPlugin(name, "js");
}
#method_after
private static boolean isJsPlugin(String name) {
    return isPlugin(name, "js");
}
#end_block

#method_before
private boolean isPlugin(String fileName, String ext) {
    String fullExt = "." + ext;
    return fileName.endsWith(fullExt) || fileName.endsWith(fullExt + ".disabled");
}
#method_after
private static boolean isPlugin(String fileName, String ext) {
    String fullExt = "." + ext;
    return fileName.endsWith(fullExt) || fileName.endsWith(fullExt + ".disabled");
}
#end_block

#method_before
public <T extends TaskInfo> List<T> getTaskInfos(TaskInfo.Factory<T> factory) {
    final List<T> taskInfos = new ArrayList<T>();
    for (final Executor exe : queues) {
        for (final Task<?> task : exe.getTasks()) {
            T info = factory.getTaskInfo(task);
            taskInfos.add(info);
        }
    }
    return taskInfos;
}
#method_after
public <T> List<T> getTaskInfos(TaskInfoFactory<T> factory) {
    List<T> taskInfos = Lists.newArrayList();
    for (Executor exe : queues) {
        for (Task<?> task : exe.getTasks()) {
            taskInfos.add(factory.getTaskInfo(task));
        }
    }
    return taskInfos;
}
#end_block

#method_before
@Override
protected void run() {
    final List<QueueTaskInfo> pending = getSortedTaskInfoList();
    taskNameWidth = wide ? Integer.MAX_VALUE : columns - 8 - 12 - 8 - 4;
    stdout.print(// 
    String.format(// 
    "%-8s %-12s %-8s %s\n", "Task", "State", "", "Command"));
    stdout.print("----------------------------------------------" + "--------------------------------\n");
    int numberOfPendingTasks = 0;
    final long now = System.currentTimeMillis();
    final boolean viewAll = currentUser.getCapabilities().canViewQueue();
    for (final QueueTaskInfo taskInfo : pending) {
        final long delay = taskInfo.getDelay();
        final Task.State state = taskInfo.getTaskState();
        final String start;
        switch(state) {
            case DONE:
            case CANCELLED:
            case RUNNING:
            case READY:
                start = format(state);
                break;
            default:
                start = time(now, delay);
                break;
        }
        boolean regularUserCanSee = false;
        boolean hasCustomizedPrint = true;
        // If the user is not administrator, check if has rights to see
        // the Task
        Project.NameKey projectName = null;
        String remoteName = null;
        if (!viewAll) {
            projectName = taskInfo.getProjectNameKey();
            remoteName = taskInfo.getRemoteName();
            hasCustomizedPrint = taskInfo.hasCustomizedPrint();
            ProjectState e = null;
            if (projectName != null) {
                e = projectCache.get(projectName);
            }
            regularUserCanSee = e != null && e.controlFor(currentUser).isVisible();
            if (regularUserCanSee) {
                numberOfPendingTasks++;
            }
        }
        // Shows information about tasks depending on the user rights
        if (viewAll || (!hasCustomizedPrint && regularUserCanSee)) {
            stdout.print(String.format(// 
            "%8s %-12s %-8s %s\n", id(taskInfo.getTaskId()), start, "", taskInfo.getTaskString(taskNameWidth)));
        } else if (regularUserCanSee) {
            if (remoteName == null) {
                remoteName = projectName.get();
            } else {
                remoteName = remoteName + "/" + projectName;
            }
            stdout.print(// 
            String.format(// 
            "%8s %-12s %-8s %s\n", id(taskInfo.getTaskId()), start, "", remoteName));
        }
    }
    stdout.print("----------------------------------------------" + "--------------------------------\n");
    if (viewAll) {
        numberOfPendingTasks = pending.size();
    }
    stdout.print("  " + numberOfPendingTasks + " tasks\n");
}
#method_after
@Override
protected void run() {
    taskNameWidth = wide ? Integer.MAX_VALUE : columns - 8 - 12 - 8 - 4;
    final List<QueueTaskInfo> pending = getSortedTaskInfoList();
    stdout.print(String.format("%-8s %-12s %-8s %s\n", "Task", "State", "", "Command"));
    stdout.print("----------------------------------------------" + "--------------------------------\n");
    int numberOfPendingTasks = 0;
    final long now = System.currentTimeMillis();
    final boolean viewAll = currentUser.getCapabilities().canViewQueue();
    for (final QueueTaskInfo taskInfo : pending) {
        final long delay = taskInfo.delayMillis;
        final Task.State state = taskInfo.state;
        final String start;
        switch(state) {
            case DONE:
            case CANCELLED:
            case RUNNING:
            case READY:
                start = format(state);
                break;
            default:
                start = time(now, delay);
                break;
        }
        boolean regularUserCanSee = false;
        boolean hasCustomizedPrint = true;
        // If the user is not administrator, check if has rights to see
        // the Task
        Project.NameKey projectName = null;
        String remoteName = null;
        if (!viewAll) {
            projectName = taskInfo.getProjectNameKey();
            remoteName = taskInfo.getRemoteName();
            hasCustomizedPrint = taskInfo.hasCustomizedPrint();
            ProjectState e = null;
            if (projectName != null) {
                e = projectCache.get(projectName);
            }
            regularUserCanSee = e != null && e.controlFor(currentUser).isVisible();
            if (regularUserCanSee) {
                numberOfPendingTasks++;
            }
        }
        // Shows information about tasks depending on the user rights
        if (viewAll || (!hasCustomizedPrint && regularUserCanSee)) {
            stdout.print(String.format("%8s %-12s %-8s %s\n", id(taskInfo.getTaskId()), start, "", taskInfo.getTaskString(taskNameWidth)));
        } else if (regularUserCanSee) {
            if (remoteName == null) {
                remoteName = projectName.get();
            } else {
                remoteName = remoteName + "/" + projectName;
            }
            stdout.print(String.format("%8s %-12s %-8s %s\n", id(taskInfo.getTaskId()), start, "", remoteName));
        }
    }
    stdout.print("----------------------------------------------" + "--------------------------------\n");
    if (viewAll) {
        numberOfPendingTasks = pending.size();
    }
    stdout.print("  " + numberOfPendingTasks + " tasks\n");
}
#end_block

#method_before
private List<QueueTaskInfo> getSortedTaskInfoList() {
    final List<QueueTaskInfo> taskInfos = workQueue.getTaskInfos(new TaskInfo.Factory<QueueTaskInfo>() {

        @Override
        public QueueTaskInfo getTaskInfo(Task task) {
            return new QueueTaskInfo(task);
        }
    });
    Collections.sort(taskInfos, new Comparator<QueueTaskInfo>() {

        @Override
        public int compare(QueueTaskInfo aTaskInfo, QueueTaskInfo bTaskInfo) {
            final Task.State aState = aTaskInfo.getTaskState();
            final Task.State bState = bTaskInfo.getTaskState();
            if (aState != bState) {
                return aState.ordinal() - bState.ordinal();
            }
            final long aDelay = aTaskInfo.getDelay();
            final long bDelay = bTaskInfo.getDelay();
            if (aDelay < bDelay) {
                return -1;
            } else if (aDelay > bDelay) {
                return 1;
            }
            return aTaskInfo.getTaskString(taskNameWidth).compareTo(bTaskInfo.getTaskString(taskNameWidth));
        }
    });
    return taskInfos;
}
#method_after
private List<QueueTaskInfo> getSortedTaskInfoList() {
    final List<QueueTaskInfo> taskInfos = workQueue.getTaskInfos(new TaskInfoFactory<QueueTaskInfo>() {

        @Override
        public QueueTaskInfo getTaskInfo(Task<?> task) {
            return new QueueTaskInfo(task);
        }
    });
    Collections.sort(taskInfos, new Comparator<QueueTaskInfo>() {

        @Override
        public int compare(QueueTaskInfo a, QueueTaskInfo b) {
            if (a.state != b.state) {
                return a.state.ordinal() - b.state.ordinal();
            }
            int cmp = Long.signum(a.delayMillis - b.delayMillis);
            if (cmp != 0) {
                return cmp;
            }
            return a.getTaskString(taskNameWidth).compareTo(b.getTaskString(taskNameWidth));
        }
    });
    return taskInfos;
}
#end_block

#method_before
public String getRemoteName() {
    if (task instanceof ProjectTask) {
        return ((ProjectTask<?>) task).getRemoteName();
    } else {
        return null;
    }
}
#method_after
String getRemoteName() {
    if (task instanceof ProjectTask) {
        return ((ProjectTask<?>) task).getRemoteName();
    }
    return null;
}
#end_block

#method_before
public NameKey getProjectNameKey() {
    if (task instanceof ProjectTask<?>) {
        return ((ProjectTask<?>) task).getProjectNameKey();
    } else {
        return null;
    }
}
#method_after
Project.NameKey getProjectNameKey() {
    if (task instanceof ProjectTask<?>) {
        return ((ProjectTask<?>) task).getProjectNameKey();
    }
    return null;
}
#end_block

#method_before
public boolean hasCustomizedPrint() {
    if (task instanceof ProjectTask<?>) {
        return ((ProjectTask<?>) task).hasCustomizedPrint();
    } else {
        return false;
    }
}
#method_after
boolean hasCustomizedPrint() {
    if (task instanceof ProjectTask<?>) {
        return ((ProjectTask<?>) task).hasCustomizedPrint();
    }
    return false;
}
#end_block

#method_before
public int getTaskId() {
    return task.getTaskId();
}
#method_after
int getTaskId() {
    return task.getTaskId();
}
#end_block

#method_before
public String getTaskString(int maxLength) {
    String s = task.toString();
    if (s.length() < maxLength) {
        return s;
    } else {
        return s.substring(0, maxLength);
    }
}
#method_after
String getTaskString(int maxLength) {
    String s = task.toString();
    return s.length() < maxLength ? s : s.substring(0, maxLength);
}
#end_block

#method_before
private PatchSet parsePatchSet(final String patchIdentity) throws UnloggedFailure, OrmException {
    // 
    if (patchIdentity.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$")) {
        final RevId id = new RevId(patchIdentity);
        final ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        final Set<PatchSet> matches = new HashSet<PatchSet>();
        for (final PatchSet ps : patches) {
            final Change change = db.changes().get(ps.getId().getParentKey());
            if (inProject(change) && inBranch(change)) {
                matches.add(ps);
            }
        }
        switch(matches.size()) {
            case 1:
                return matches.iterator().next();
            case 0:
                throw error("\"" + patchIdentity + "\" no such patch set");
            default:
                throw error("\"" + patchIdentity + "\" matches multiple patch sets");
        }
    }
    // 
    if (patchIdentity.matches("^[1-9][0-9]*,[1-9][0-9]*$")) {
        final PatchSet.Id patchSetId;
        try {
            patchSetId = PatchSet.Id.parse(patchIdentity);
        } catch (IllegalArgumentException e) {
            throw error("\"" + patchIdentity + "\" is not a valid patch set");
        }
        final PatchSet patchSet = db.patchSets().get(patchSetId);
        if (patchSet == null) {
            throw error("\"" + patchIdentity + "\" no such patch set");
        }
        if (projectControl != null || branch != null) {
            final Change change = db.changes().get(patchSetId.getParentKey());
            if (projectControl != null) {
                if (!inProject(change)) {
                    throw error("change " + change.getId() + " not in project " + projectControl.getProject().getName());
                }
            }
            if (branch != null) {
                if (!inBranch(change)) {
                    throw error("change " + change.getId() + " not in branch " + change.getDest().toString());
                }
            }
        }
        return patchSet;
    }
    throw error("\"" + patchIdentity + "\" is not a valid patch set");
}
#method_after
private PatchSet parsePatchSet(final String patchIdentity) throws UnloggedFailure, OrmException {
    // 
    if (patchIdentity.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$")) {
        final RevId id = new RevId(patchIdentity);
        final ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        final Set<PatchSet> matches = new HashSet<PatchSet>();
        for (final PatchSet ps : patches) {
            final Change change = db.changes().get(ps.getId().getParentKey());
            if (inProject(change) && inBranch(change)) {
                matches.add(ps);
            }
        }
        switch(matches.size()) {
            case 1:
                return matches.iterator().next();
            case 0:
                throw error("\"" + patchIdentity + "\" no such patch set");
            default:
                throw error("\"" + patchIdentity + "\" matches multiple patch sets");
        }
    }
    // 
    if (patchIdentity.matches("^[1-9][0-9]*,[1-9][0-9]*$")) {
        final PatchSet.Id patchSetId;
        try {
            patchSetId = PatchSet.Id.parse(patchIdentity);
        } catch (IllegalArgumentException e) {
            throw error("\"" + patchIdentity + "\" is not a valid patch set");
        }
        final PatchSet patchSet = db.patchSets().get(patchSetId);
        if (patchSet == null) {
            throw error("\"" + patchIdentity + "\" no such patch set");
        }
        if (projectControl != null || branch != null) {
            final Change change = db.changes().get(patchSetId.getParentKey());
            if (!inProject(change)) {
                throw error("change " + change.getId() + " not in project " + projectControl.getProject().getName());
            }
            if (!inBranch(change)) {
                throw error("change " + change.getId() + " not in branch " + change.getDest().get());
            }
        }
        return patchSet;
    }
    throw error("\"" + patchIdentity + "\" is not a valid patch set");
}
#end_block

#method_before
private boolean inBranch(final Change change) {
    if (branch == null) {
        return true;
    }
    return change.getDest().toString().equals(branch);
}
#method_after
private boolean inBranch(final Change change) {
    if (branch == null) {
        // No --branch option, so they want every branch.
        return true;
    }
    return change.getDest().get().equals(branch);
}
#end_block

#method_before
private void save(PersonIdent ident, String msg) throws IOException {
    Repository repo = new FileRepository(path);
    try {
        inserter = repo.newObjectInserter();
        reader = repo.newObjectReader();
        try {
            RevWalk rw = new RevWalk(reader);
            try {
                RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
                newTree = readTree(srcTree);
                saveConfig(ProjectConfig.PROJECT_CONFIG, cfg);
                ObjectId res = newTree.writeTree(inserter);
                if (res.equals(srcTree)) {
                    // If there are no changes to the content, don't create the commit.
                    return;
                }
                CommitBuilder commit = new CommitBuilder();
                commit.setAuthor(ident);
                commit.setCommitter(ident);
                commit.setMessage(msg);
                commit.setTreeId(res);
                if (revision != null) {
                    commit.addParentId(revision);
                }
                ObjectId newRevision = inserter.insert(commit);
                updateRef(repo, ident, newRevision, "commit: " + msg);
                revision = newRevision;
            } finally {
                rw.release();
            }
        } finally {
            if (inserter != null) {
                inserter.release();
            }
            if (reader != null) {
                reader.release();
            }
        }
    } finally {
        repo.close();
    }
}
#method_after
private void save(PersonIdent ident, String msg) throws IOException {
    Repository repo = new FileRepository(path);
    try {
        inserter = repo.newObjectInserter();
        reader = repo.newObjectReader();
        try {
            RevWalk rw = new RevWalk(reader);
            try {
                RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
                newTree = readTree(srcTree);
                saveConfig(ProjectConfig.PROJECT_CONFIG, cfg);
                ObjectId res = newTree.writeTree(inserter);
                if (res.equals(srcTree)) {
                    // If there are no changes to the content, don't create the commit.
                    return;
                }
                CommitBuilder commit = new CommitBuilder();
                commit.setAuthor(ident);
                commit.setCommitter(ident);
                commit.setMessage(msg);
                commit.setTreeId(res);
                if (revision != null) {
                    commit.addParentId(revision);
                }
                ObjectId newRevision = inserter.insert(commit);
                updateRef(repo, ident, newRevision, "commit: " + msg);
                revision = newRevision;
            } finally {
                rw.release();
            }
        } finally {
            if (inserter != null) {
                inserter.release();
                inserter = null;
            }
            if (reader != null) {
                reader.release();
                reader = null;
            }
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(SitePaths.class);
    bind(InitFlags.class);
    bind(Libraries.class);
    bind(LibraryDownloader.class);
    factory(Section.Factory.class);
    // Steps are executed in the order listed here.
    // 
    step().to(UpgradeFrom2_0_x.class);
    step().to(InitGitManager.class);
    if (standalone) {
        step().to(InitDatabase.class);
    }
    step().to(InitAuth.class);
    step().to(InitLabels.class);
    step().to(InitSendEmail.class);
    if (standalone) {
        step().to(InitContainer.class);
    }
    step().to(InitSshd.class);
    step().to(InitHttpd.class);
    step().to(InitCache.class);
    if (standalone) {
        step().to(InitPlugins.class);
    }
}
#method_after
@Override
protected void configure() {
    bind(SitePaths.class);
    bind(InitFlags.class);
    bind(Libraries.class);
    bind(LibraryDownloader.class);
    factory(Section.Factory.class);
    // Steps are executed in the order listed here.
    // 
    step().to(UpgradeFrom2_0_x.class);
    step().to(InitGitManager.class);
    if (standalone) {
        step().to(InitDatabase.class);
    }
    step().to(InitIndex.class);
    step().to(InitAuth.class);
    step().to(InitLabels.class);
    step().to(InitSendEmail.class);
    if (standalone) {
        step().to(InitContainer.class);
    }
    step().to(InitSshd.class);
    step().to(InitHttpd.class);
    step().to(InitCache.class);
    if (standalone) {
        step().to(InitPlugins.class);
    }
}
#end_block

#method_before
@Override
public void run() throws Exception {
    ui.header("Review Labels");
    boolean enabled = ui.yesno(false, "Install Verified label");
    Config cfg = allProjectsConfig.load();
    if (enabled) {
        cfg.setString(KEY_LABEL, LABEL_VERIFIED, KEY_FUNCTION, "MaxWithBlock");
        cfg.setStringList(KEY_LABEL, LABEL_VERIFIED, KEY_VALUE, Arrays.asList(new String[] { "-1 Fails", " 0 No score", "+1 Verified" }));
        allProjectsConfig.save("Review Label Initialization");
    }
}
#method_after
@Override
public void run() throws Exception {
    Config cfg = allProjectsConfig.load();
    if (!cfg.getSubsections(KEY_LABEL).contains(LABEL_VERIFIED)) {
        ui.header("Review Labels");
        boolean enabled = ui.yesno(false, "Install Verified label");
        if (enabled) {
            cfg.setString(KEY_LABEL, LABEL_VERIFIED, KEY_FUNCTION, "MaxWithBlock");
            cfg.setStringList(KEY_LABEL, LABEL_VERIFIED, KEY_VALUE, Arrays.asList(new String[] { "-1 Fails", " 0 No score", "+1 Verified" }));
            allProjectsConfig.save("Review Label Initialization");
        }
    }
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || (canPerform(Permission.CREATE) && projectControl.canReadCommit(rw, (RevCommit) object));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#method_after
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
        case SSH_COMMAND:
            return getCurrentUser().getCapabilities().canAdministrateServer() || (isOwner() && !isForceBlocked(Permission.PUSH)) || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#end_block

#method_before
public List<PermissionRange> getLabelRanges() {
    List<PermissionRange> r = new ArrayList<PermissionRange>();
    for (Map.Entry<String, List<PermissionRule>> e : relevant.getDeclaredPermissions()) {
        if (Permission.isLabel(e.getKey())) {
            int min = 0;
            int max = 0;
            for (PermissionRule rule : e.getValue()) {
                if (projectControl.match(rule)) {
                    min = Math.min(min, rule.getMin());
                    max = Math.max(max, rule.getMax());
                }
            }
            if (min != 0 || max != 0) {
                r.add(new PermissionRange(e.getKey(), min, max));
            }
        }
    }
    return r;
}
#method_after
public List<PermissionRange> getLabelRanges(boolean isChangeOwner) {
    List<PermissionRange> r = new ArrayList<PermissionRange>();
    for (Map.Entry<String, List<PermissionRule>> e : relevant.getDeclaredPermissions()) {
        if (Permission.isLabel(e.getKey())) {
            int min = 0;
            int max = 0;
            for (PermissionRule rule : e.getValue()) {
                if (projectControl.match(rule, isChangeOwner)) {
                    min = Math.min(min, rule.getMin());
                    max = Math.max(max, rule.getMax());
                }
            }
            if (min != 0 || max != 0) {
                r.add(new PermissionRange(e.getKey(), min, max));
            }
        }
    }
    return r;
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    if (Permission.hasRange(permission)) {
        return toRange(permission, access(permission));
    }
    return null;
}
#method_after
public PermissionRange getRange(String permission) {
    return getRange(permission, false);
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    if (Permission.hasRange(permission)) {
        return toRange(permission, access(permission));
    }
    return null;
}
#method_after
public PermissionRange getRange(String permission, boolean isChangeOwner) {
    if (Permission.hasRange(permission)) {
        return toRange(permission, access(permission, isChangeOwner));
    }
    return null;
}
#end_block

#method_before
private List<PermissionRule> access(String permissionName) {
    List<PermissionRule> rules = effective.get(permissionName);
    if (rules != null) {
        return rules;
    }
    rules = relevant.getPermission(permissionName);
    if (rules.isEmpty()) {
        effective.put(permissionName, rules);
        return rules;
    }
    if (rules.size() == 1) {
        if (!projectControl.match(rules.get(0))) {
            rules = Collections.emptyList();
        }
        effective.put(permissionName, rules);
        return rules;
    }
    List<PermissionRule> mine = new ArrayList<PermissionRule>(rules.size());
    for (PermissionRule rule : rules) {
        if (projectControl.match(rule)) {
            mine.add(rule);
        }
    }
    if (mine.isEmpty()) {
        mine = Collections.emptyList();
    }
    effective.put(permissionName, mine);
    return mine;
}
#method_after
private List<PermissionRule> access(String permissionName) {
    return access(permissionName, false);
}
#end_block

#method_before
private List<PermissionRule> access(String permissionName) {
    List<PermissionRule> rules = effective.get(permissionName);
    if (rules != null) {
        return rules;
    }
    rules = relevant.getPermission(permissionName);
    if (rules.isEmpty()) {
        effective.put(permissionName, rules);
        return rules;
    }
    if (rules.size() == 1) {
        if (!projectControl.match(rules.get(0))) {
            rules = Collections.emptyList();
        }
        effective.put(permissionName, rules);
        return rules;
    }
    List<PermissionRule> mine = new ArrayList<PermissionRule>(rules.size());
    for (PermissionRule rule : rules) {
        if (projectControl.match(rule)) {
            mine.add(rule);
        }
    }
    if (mine.isEmpty()) {
        mine = Collections.emptyList();
    }
    effective.put(permissionName, mine);
    return mine;
}
#method_after
private List<PermissionRule> access(String permissionName, boolean isChangeOwner) {
    List<PermissionRule> rules = effective.get(permissionName);
    if (rules != null) {
        return rules;
    }
    rules = relevant.getPermission(permissionName);
    if (rules.isEmpty()) {
        effective.put(permissionName, rules);
        return rules;
    }
    if (rules.size() == 1) {
        if (!projectControl.match(rules.get(0), isChangeOwner)) {
            rules = Collections.emptyList();
        }
        effective.put(permissionName, rules);
        return rules;
    }
    List<PermissionRule> mine = new ArrayList<PermissionRule>(rules.size());
    for (PermissionRule rule : rules) {
        if (projectControl.match(rule, isChangeOwner)) {
            mine.add(rule);
        }
    }
    if (mine.isEmpty()) {
        mine = Collections.emptyList();
    }
    effective.put(permissionName, mine);
    return mine;
}
#end_block

#method_before
public ChangeControl validateFor(Change.Id id, CurrentUser user) throws NoSuchChangeException, OrmException {
    ChangeControl c = controlFor(id, user);
    if (!c.isVisible(db.get())) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
public ChangeControl validateFor(Change change, CurrentUser user) throws NoSuchChangeException, OrmException {
    ChangeControl c = controlFor(change, user);
    if (!c.isVisible(db.get())) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#end_block

#method_before
public LabelTypes getLabelTypes() {
    return getProjectControl().getLabelTypes();
}
#method_after
public LabelTypes getLabelTypes() {
    String destBranch = getChange().getDest().get();
    List<LabelType> all = getProjectControl().getLabelTypes().getLabelTypes();
    List<LabelType> r = Lists.newArrayListWithCapacity(all.size());
    for (LabelType l : all) {
        List<String> refs = l.getRefPatterns();
        if (refs == null) {
            r.add(l);
        } else {
            for (String refPattern : refs) {
                if (RefConfigSection.isValid(refPattern) && match(destBranch, refPattern)) {
                    r.add(l);
                    break;
                }
            }
        }
    }
    return new LabelTypes(r);
}
#end_block

#method_before
public List<PermissionRange> getLabelRanges() {
    return getRefControl().getLabelRanges();
}
#method_after
public List<PermissionRange> getLabelRanges() {
    return getRefControl().getLabelRanges(isOwner());
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    List<PermissionRule> rules = getRefControl().getRules(permission);
    if (isOwner() && rulesContainGroup(rules, AccountGroup.CHANGE_OWNERS)) {
        return getRefControl().getLabelRange(permission);
    } else {
        return getRefControl().getRange(permission);
    }
}
#method_after
public PermissionRange getRange(String permission) {
    return getRefControl().getRange(permission, isOwner());
}
#end_block

#method_before
public boolean isOwner() {
    if (getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
        return i.getAccountId().equals(change.getOwner());
    }
    return false;
}
#method_after
public boolean isOwner() {
    if (getCurrentUser().isIdentifiedUser()) {
        final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
        return i.getAccountId().equals(change.getOwner());
    }
    return false;
}
#end_block

#method_before
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
        Iterable<PatchSetApproval> results;
        if (cd != null) {
            results = cd.currentApprovals(Providers.of(db));
        } else {
            results = db.patchSetApprovals().byChange(change.getId());
        }
        for (PatchSetApproval approval : results) {
            if (user.getAccountId().equals(approval.getAccountId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getCurrentUser().isIdentifiedUser()) {
        final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
        Iterable<PatchSetApproval> results;
        if (cd != null) {
            results = cd.currentApprovals(Providers.of(db));
        } else {
            results = db.patchSetApprovals().byChange(change.getId());
        }
        for (PatchSetApproval approval : results) {
            if (user.getAccountId().equals(approval.getAccountId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
public boolean canRemoveReviewer(Account.Id reviewer, int value) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(reviewer)) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= value) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(Account.Id reviewer, int value) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser().isIdentifiedUser()) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(reviewer)) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= value) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("may".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.MAY;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            try {
                if ("ok".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.OK;
                    appliedBy(lbl, status);
                } else if ("reject".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.REJECT;
                    appliedBy(lbl, status);
                } else if ("need".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.NEED;
                } else if ("may".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.MAY;
                } else if ("impossible".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
                } else {
                    return logInvalidResult(submitRule, submitRecord);
                }
            } catch (UserTermExpected e) {
                return logInvalidResult(submitRule, submitRecord, e.getMessage());
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record);
}
#method_after
private List<SubmitRecord> logInvalidResult(Term rule, Term record, String reason) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record + (reason == null ? "" : ". Reason: " + reason));
}
#end_block

#method_before
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record);
}
#method_after
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logInvalidResult(rule, record, null);
}
#end_block

#method_before
private void appliedBy(SubmitRecord.Label label, Term status) {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        }
    }
}
#method_after
private void appliedBy(SubmitRecord.Label label, Term status) throws UserTermExpected {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        } else {
            throw new UserTermExpected(label);
        }
    }
}
#end_block

#method_before
@Test
public void systemGroupsCreated_ssh() throws JSchException, IOException {
    SshSession session = new SshSession(server, admin);
    String result = session.exec("gerrit ls-groups");
    assertTrue(result.contains("Administrators"));
    assertTrue(result.contains("Anonymous Users"));
    assertTrue(result.contains("Change Owners"));
    assertTrue(result.contains("Non-Interactive Users"));
    assertTrue(result.contains("Project Owners"));
    assertTrue(result.contains("Registered Users"));
    session.close();
}
#method_after
@Test
public void systemGroupsCreated_ssh() throws JSchException, IOException {
    SshSession session = new SshSession(server, admin);
    String result = session.exec("gerrit ls-groups");
    assertTrue(result.contains("Administrators"));
    assertTrue(result.contains("Anonymous Users"));
    assertTrue(result.contains("Change Owner"));
    assertTrue(result.contains("Non-Interactive Users"));
    assertTrue(result.contains("Project Owners"));
    assertTrue(result.contains("Registered Users"));
    session.close();
}
#end_block

#method_before
@Test
public void systemGroupsCreated_rest() throws IOException {
    RestSession session = new RestSession(server, admin);
    RestResponse r = session.get("/groups/");
    Gson gson = new Gson();
    Map<String, GroupInfo> result = gson.fromJson(r.getReader(), new TypeToken<Map<String, GroupInfo>>() {
    }.getType());
    Set<String> names = result.keySet();
    assertTrue(names.contains("Administrators"));
    assertTrue(names.contains("Anonymous Users"));
    assertTrue(names.contains("Change Owners"));
    assertTrue(names.contains("Non-Interactive Users"));
    assertTrue(names.contains("Project Owners"));
    assertTrue(names.contains("Registered Users"));
}
#method_after
@Test
public void systemGroupsCreated_rest() throws IOException {
    RestSession session = new RestSession(server, admin);
    RestResponse r = session.get("/groups/");
    Gson gson = new Gson();
    Map<String, GroupInfo> result = gson.fromJson(r.getReader(), new TypeToken<Map<String, GroupInfo>>() {
    }.getType());
    Set<String> names = result.keySet();
    assertTrue(names.contains("Administrators"));
    assertTrue(names.contains("Anonymous Users"));
    assertTrue(names.contains("Change Owner"));
    assertTrue(names.contains("Non-Interactive Users"));
    assertTrue(names.contains("Project Owners"));
    assertTrue(names.contains("Registered Users"));
}
#end_block

#method_before
@Test
public void systemGroupsCreated_internals() throws OrmException {
    ReviewDb db = reviewDbProvider.open();
    try {
        Set<String> names = Sets.newHashSet();
        for (AccountGroup g : db.accountGroups().all()) {
            names.add(g.getName());
        }
        assertTrue(names.contains("Administrators"));
        assertTrue(names.contains("Anonymous Users"));
        assertTrue(names.contains("Change Owners"));
        assertTrue(names.contains("Non-Interactive Users"));
        assertTrue(names.contains("Project Owners"));
        assertTrue(names.contains("Registered Users"));
    } finally {
        db.close();
    }
}
#method_after
@Test
public void systemGroupsCreated_internals() throws OrmException {
    ReviewDb db = reviewDbProvider.open();
    try {
        Set<String> names = Sets.newHashSet();
        for (AccountGroup g : db.accountGroups().all()) {
            names.add(g.getName());
        }
        assertTrue(names.contains("Administrators"));
        assertTrue(names.contains("Anonymous Users"));
        assertTrue(names.contains("Change Owner"));
        assertTrue(names.contains("Non-Interactive Users"));
        assertTrue(names.contains("Project Owners"));
        assertTrue(names.contains("Registered Users"));
    } finally {
        db.close();
    }
}
#end_block

#method_before
private SystemConfig initSystemConfig(final ReviewDb c) throws OrmException {
    admin = newGroup(c, "Administrators", null);
    admin.setDescription("Gerrit Site Administrators");
    admin.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(admin));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(admin)));
    anonymous = newGroup(c, "Anonymous Users", AccountGroup.ANONYMOUS_USERS);
    anonymous.setDescription("Any user, signed-in or not");
    anonymous.setOwnerGroupUUID(admin.getGroupUUID());
    anonymous.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(anonymous));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(anonymous)));
    registered = newGroup(c, "Registered Users", AccountGroup.REGISTERED_USERS);
    registered.setDescription("Any signed-in user");
    registered.setOwnerGroupUUID(admin.getGroupUUID());
    registered.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(registered));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(registered)));
    batch = newGroup(c, "Non-Interactive Users", null);
    batch.setDescription("Users who perform batch actions on Gerrit");
    batch.setOwnerGroupUUID(admin.getGroupUUID());
    batch.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(batch));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(batch)));
    owners = newGroup(c, "Project Owners", AccountGroup.PROJECT_OWNERS);
    owners.setDescription("Any owner of the project");
    owners.setOwnerGroupUUID(admin.getGroupUUID());
    owners.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(owners));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(owners)));
    changeOwners = newGroup(c, "Change Owners", AccountGroup.CHANGE_OWNERS);
    changeOwners.setDescription("The owners of a change");
    changeOwners.setOwnerGroupUUID(admin.getGroupUUID());
    changeOwners.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(changeOwners));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(changeOwners)));
    final SystemConfig s = SystemConfig.create();
    try {
        s.sitePath = site_path.getCanonicalPath();
    } catch (IOException e) {
        s.sitePath = site_path.getAbsolutePath();
    }
    c.systemConfig().insert(Collections.singleton(s));
    return s;
}
#method_after
private SystemConfig initSystemConfig(final ReviewDb c) throws OrmException {
    admin = newGroup(c, "Administrators", null);
    admin.setDescription("Gerrit Site Administrators");
    admin.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(admin));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(admin)));
    anonymous = newGroup(c, "Anonymous Users", AccountGroup.ANONYMOUS_USERS);
    anonymous.setDescription("Any user, signed-in or not");
    anonymous.setOwnerGroupUUID(admin.getGroupUUID());
    anonymous.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(anonymous));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(anonymous)));
    registered = newGroup(c, "Registered Users", AccountGroup.REGISTERED_USERS);
    registered.setDescription("Any signed-in user");
    registered.setOwnerGroupUUID(admin.getGroupUUID());
    registered.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(registered));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(registered)));
    batch = newGroup(c, "Non-Interactive Users", null);
    batch.setDescription("Users who perform batch actions on Gerrit");
    batch.setOwnerGroupUUID(admin.getGroupUUID());
    batch.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(batch));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(batch)));
    owners = newGroup(c, "Project Owners", AccountGroup.PROJECT_OWNERS);
    owners.setDescription("Any owner of the project");
    owners.setOwnerGroupUUID(admin.getGroupUUID());
    owners.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(owners));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(owners)));
    changeOwner = newGroup(c, "Change Owner", AccountGroup.CHANGE_OWNER);
    changeOwner.setDescription("The owner of a change");
    changeOwner.setOwnerGroupUUID(admin.getGroupUUID());
    changeOwner.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(changeOwner));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(changeOwner)));
    final SystemConfig s = SystemConfig.create();
    try {
        s.sitePath = site_path.getCanonicalPath();
    } catch (IOException e) {
        s.sitePath = site_path.getAbsolutePath();
    }
    c.systemConfig().insert(Collections.singleton(s));
    return s;
}
#end_block

#method_before
public void save(String pluginName, String message) throws IOException {
    Repository repo = new FileRepository(path);
    try {
        inserter = repo.newObjectInserter();
        reader = repo.newObjectReader();
        try {
            RevWalk rw = new RevWalk(reader);
            try {
                RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
                newTree = readTree(srcTree);
                saveConfig(ProjectConfig.PROJECT_CONFIG, cfg);
                ObjectId res = newTree.writeTree(inserter);
                if (res.equals(srcTree)) {
                    // If there are no changes to the content, don't create the commit.
                    return;
                }
                PersonIdent ident = new PersonIdent(pluginName, pluginName + "@gerrit");
                String msg = "Update from plugin " + pluginName + ": " + message;
                CommitBuilder commit = new CommitBuilder();
                commit.setAuthor(ident);
                commit.setCommitter(ident);
                commit.setMessage(msg);
                commit.setTreeId(res);
                if (revision != null) {
                    commit.addParentId(revision);
                }
                ObjectId newRevision = inserter.insert(commit);
                updateRef(repo, ident, newRevision, "commit: " + msg);
                revision = newRevision;
            } finally {
                rw.release();
            }
        } finally {
            if (inserter != null) {
                inserter.release();
            }
            if (reader != null) {
                reader.release();
            }
        }
    } finally {
        repo.close();
    }
}
#method_after
public void save(String pluginName, String message) throws IOException {
    Repository repo = new FileRepository(path);
    try {
        inserter = repo.newObjectInserter();
        reader = repo.newObjectReader();
        try {
            RevWalk rw = new RevWalk(reader);
            try {
                RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
                newTree = readTree(srcTree);
                saveConfig(ProjectConfig.PROJECT_CONFIG, cfg);
                ObjectId res = newTree.writeTree(inserter);
                if (res.equals(srcTree)) {
                    // If there are no changes to the content, don't create the commit.
                    return;
                }
                PersonIdent ident = new PersonIdent(pluginName, pluginName + "@gerrit");
                String msg = "Update from plugin " + pluginName + ": " + message;
                CommitBuilder commit = new CommitBuilder();
                commit.setAuthor(ident);
                commit.setCommitter(ident);
                commit.setMessage(msg);
                commit.setTreeId(res);
                if (revision != null) {
                    commit.addParentId(revision);
                }
                ObjectId newRevision = inserter.insert(commit);
                updateRef(repo, ident, newRevision, "commit: " + msg);
                revision = newRevision;
            } finally {
                rw.release();
            }
        } finally {
            if (inserter != null) {
                inserter.release();
                inserter = null;
            }
            if (reader != null) {
                reader.release();
                reader = null;
            }
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    e.stopPropagation();
    save();
}
#method_after
@UiHandler("save")
void onSave(ClickEvent e) {
    e.stopPropagation();
    save(null);
}
#end_block

#method_before
void save() {
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo original = comment;
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    enableEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            set(result);
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            super.onFailure(e);
        }
    };
    if (original.id() == null) {
        CommentApi.createDraft(psId, input, cb);
    } else {
        CommentApi.updateDraft(psId, original.id(), input, cb);
    }
    getCm().focus();
}
#method_after
void save(CallbackGroup group) {
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo original = comment;
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    enableEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            set(result);
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            parent.updateUnsaved(DraftBox.this, false);
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            super.onFailure(e);
        }
    };
    if (original.id() == null) {
        CommentApi.createDraft(psId, input, group == null ? cb : group.add(cb));
    } else {
        CommentApi.updateDraft(psId, original.id(), input, group == null ? cb : group.add(cb));
    }
    getCm().focus();
}
#end_block

#method_before
@UiHandler("editArea")
void onKeyDown(KeyDownEvent e) {
    if ((e.isControlKeyDown() || e.isMetaKeyDown()) && !e.isAltKeyDown() && !e.isShiftKeyDown()) {
        switch(e.getNativeKeyCode()) {
            case 's':
            case 'S':
                e.preventDefault();
                save();
                return;
        }
    } else if (e.getNativeKeyCode() == KeyCodes.KEY_ESCAPE && !isDirty()) {
        if (isNew()) {
            removeUI();
            return;
        } else {
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            getCm().focus();
            return;
        }
    }
    expandTimer.schedule(250);
}
#method_after
@UiHandler("editArea")
void onKeyDown(KeyDownEvent e) {
    if ((e.isControlKeyDown() || e.isMetaKeyDown()) && !e.isAltKeyDown() && !e.isShiftKeyDown()) {
        switch(e.getNativeKeyCode()) {
            case 's':
            case 'S':
                e.preventDefault();
                save(null);
                return;
        }
    } else if (e.getNativeKeyCode() == KeyCodes.KEY_ESCAPE && !isDirty()) {
        if (isNew()) {
            removeUI();
            return;
        } else {
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            getCm().focus();
            return;
        }
    }
    expandTimer.schedule(250);
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    saveAllDrafts();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    saveAllDrafts(null);
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#end_block

#method_before
void updateUnsaved(DraftBox box, boolean isEdit) {
    if (isEdit) {
        unsaved.add(box);
    } else {
        unsaved.remove(box);
    }
}
#method_after
void updateUnsaved(DraftBox box, boolean isUnsaved) {
    if (isUnsaved) {
        unsaved.add(box);
    } else {
        unsaved.remove(box);
    }
}
#end_block

#method_before
private void saveAllDrafts() {
    for (DraftBox box : unsaved) {
        box.save();
    }
    unsaved.clear();
}
#method_after
private void saveAllDrafts(CallbackGroup cb) {
    for (DraftBox box : unsaved) {
        box.save(cb);
    }
}
#end_block

#method_before
private Runnable upToChange(final boolean openReplyBox) {
    return new Runnable() {

        public void run() {
            saveAllDrafts();
            String b = base != null ? String.valueOf(base.get()) : null;
            String rev = String.valueOf(revision.get());
            Gerrit.display(PageLinks.toChange(changeId, rev), new ChangeScreen2(changeId, b, rev, openReplyBox));
        }
    };
}
#method_after
private Runnable upToChange(final boolean openReplyBox) {
    return new Runnable() {

        public void run() {
            if (unsaved.isEmpty()) {
                goUpToChange(openReplyBox);
            } else {
                CallbackGroup group = new CallbackGroup();
                saveAllDrafts(group);
                group.addFinal(new GerritCallback<Void>() {

                    @Override
                    public void onSuccess(Void result) {
                        goUpToChange(openReplyBox);
                    }
                }).onSuccess(null);
            }
        }
    };
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, null);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    });
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    CallbackGroup group = new CallbackGroup();
    loadDiff(info.revisions().get(base), rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    loadDiff(b, rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            if (Gerrit.getConfig().testChangeMerge()) {
                if (canSubmit) {
                    actions.setSubmitEnabled(!Gerrit.getConfig().testChangeDisableSubmit() || changeInfo.mergeable());
                    if (status == Change.Status.NEW) {
                        statusText.setInnerText(changeInfo.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                    }
                }
                setVisible(notMergeable, !changeInfo.mergeable());
            }
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled();
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            if (canSubmit) {
                if (status == Change.Status.NEW) {
                    statusText.setInnerText(changeInfo.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                }
            }
            setVisible(notMergeable, !changeInfo.mergeable());
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#end_block

#method_before
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    if (revision == null) {
        revision = info.current_revision();
    } else if (!info.revisions().containsKey(revision)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revision.equals(String.valueOf(r._number()))) {
                revision = r.name();
                break;
            }
        }
    }
    RevisionInfo rev = revision != null ? info.revision(revision) : null;
    if (rev != null) {
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#method_after
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.current_revision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#end_block

#method_before
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r._number() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(diffBase.getItemCount() - 1);
}
#method_after
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r._number() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#end_block

#method_before
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setTestChangeMerge(cfg.getBoolean("changeMerge", "test", false));
    config.setTestChangeDisableSubmit(cfg.getBoolean("changeMerge", "disableSubmit", true));
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setIndex(indexCollection.getSearchIndex() != null);
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#method_after
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setIndex(indexCollection.getSearchIndex() != null);
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_SUBJECT; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    for (int i = BASE_COLUMNS; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#method_after
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_SUBJECT; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_SIZE, Gerrit.RESOURCES.css().cSIZE());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    for (int i = BASE_COLUMNS; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (Gerrit.getConfig().testChangeMerge() && !c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergable());
        table.getCellFormatter().addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().notMergable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    table.setWidget(row, C_SIZE, getSizeWidget(c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (Gerrit.getConfig().testChangeMerge() && !c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
        table.getCellFormatter().addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().notMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
@Override
protected void onLoad() {
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            if (msg != null) {
                message.setText(msg.replaceAll("\\n", "\\\n" + "> "));
            }
            message.setFocus(true);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            Window.scrollTo(0, 0);
            message.setFocus(true);
        }
    });
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            String t = message.getText();
            if (t != null) {
                message.setCursorPos(t.length());
            }
            return false;
        }
    }, 0);
}
#end_block

#method_before
void onReply(String msg) {
    if (popup != null) {
        popup.hide();
        return;
    }
    if (replyBox == null) {
        replyBox = new ReplyBox(psId, revision, allLabels, permittedLabels, msg);
        allLabels = null;
        permittedLabels = null;
    }
    final PluginSafePopupPanel p = new PluginSafePopupPanel(true);
    if (style != null) {
        p.setStyleName(style.replyBox());
    } else {
        p.setStyleName(style2.replyBox());
    }
    p.addAutoHidePartner(replyButton.getElement());
    p.addCloseHandler(new CloseHandler<PopupPanel>() {

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            if (popup == p) {
                popup = null;
            }
        }
    });
    p.add(replyBox);
    p.showRelativeTo(replyButton);
    GlobalKey.dialog(p);
    popup = p;
}
#method_after
void onReply(MessageInfo msg) {
    if (popup != null) {
        popup.hide();
        return;
    }
    if (replyBox == null) {
        replyBox = new ReplyBox(psId, revision, allLabels, permittedLabels);
        allLabels = null;
        permittedLabels = null;
    }
    if (msg != null) {
        replyBox.replyTo(msg);
    }
    final PluginSafePopupPanel p = new PluginSafePopupPanel(true);
    p.setStyleName(style.replyBox());
    p.addAutoHidePartner(replyButton.getElement());
    p.addCloseHandler(new CloseHandler<PopupPanel>() {

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            if (popup == p) {
                popup = null;
            }
        }
    });
    p.add(replyBox);
    p.showRelativeTo(replyButton);
    GlobalKey.dialog(p);
    popup = p;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style, statusText);
    reviewers.init(style, reviewersText);
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            reload.reload();
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style, statusText);
    reviewers.init(style, reviewersText);
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    related.setMaxHeight(commit.getElement().getParentElement().getOffsetHeight());
    if (openReplyBox) {
        onReply();
    } else {
        String prior = Gerrit.getPriorView();
        if (prior != null && prior.startsWith("/c/")) {
            scrollToPath(prior.substring(3));
        }
    }
    startPoller();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    commit.onShowView();
    related.setMaxHeight(commit.getElement().getParentElement().getOffsetHeight());
    if (openReplyBox) {
        onReply();
    } else {
        String prior = Gerrit.getPriorView();
        if (prior != null && prior.startsWith("/c/")) {
            scrollToPath(prior.substring(3));
        }
    }
    startPoller();
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
            history.addComments(id, result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderOwner(info);
    renderActionTextDate(info);
    renderHistory(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, null, reply, null);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderCommitSubject(info);
    renderOwner(info);
    renderActionTextDate(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                reload.reload();
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isAttached()) {
        add(updateAvailable);
    }
}
#method_after
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                Gerrit.display(PageLinks.toChange(changeId));
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isAttached()) {
        add(updateAvailable);
    }
}
#end_block

#method_before
@UiHandler("reply")
void onReply(ClickEvent e) {
    onReply();
}
#method_after
@UiHandler("reply")
void onReply(ClickEvent e) {
    e.stopPropagation();
    if (Gerrit.isSignedIn()) {
        history.replyTo(info);
    } else {
        Gerrit.doSignIn(com.google.gwt.user.client.History.getToken());
    }
}
#end_block

#method_before
void setOpen(boolean open) {
    UIObject.setVisible(summary, !open);
    UIObject.setVisible(message, open);
    if (Gerrit.isSignedIn()) {
        UIObject.setVisible(buttons, open);
    }
    if (open) {
        removeStyleName(style.closed());
    } else {
        addStyleName(style.closed());
    }
}
#method_after
void setOpen(boolean open) {
    if (open && info._revisionNumber() > 0) {
        if (commentList == null) {
            history.load(info._revisionNumber());
        } else if (!commentList.isEmpty()) {
            renderComments(commentList);
            commentList = Collections.emptyList();
        }
    }
    UIObject.setVisible(summary, !open);
    UIObject.setVisible(message, open);
    comments.setVisible(open && comments.getWidgetCount() > 0);
    if (open) {
        removeStyleName(style.closed());
    } else {
        addStyleName(style.closed());
    }
}
#end_block

#method_before
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(approve()).submit();
}
#method_after
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(approve());
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit();
}
#end_block

#method_before
@Test
public void cherryPick() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).cherryPick(in).current().review(approve()).submit();
}
#method_after
@Test
public void cherryPick() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi cApi = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).cherryPick(in);
    cApi.current().review(approve());
    cApi.current().submit();
}
#end_block

#method_before
@Override
public RevisionApi review(ReviewInput in) throws RestApiException {
    try {
        review.get().apply(revision, in);
        return this;
    } catch (OrmException e) {
        throw new RestApiException("Cannot post review", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot post review", e);
    }
}
#method_after
@Override
public void review(ReviewInput in) throws RestApiException {
    try {
        review.get().apply(revision, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot post review", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot post review", e);
    }
}
#end_block

#method_before
@Override
public void rebase() throws RestApiException {
    try {
        rebase.get().apply(revision, null);
    } catch (OrmException e) {
        throw new RestApiException("Cannot rebase ps", e);
    } catch (EmailException e) {
        throw new RestApiException("Cannot rebase ps", e);
    }
}
#method_after
@Override
public ChangeApi rebase() throws RestApiException {
    try {
        return changes.id(rebase.get().apply(revision, null)._number);
    } catch (OrmException e) {
        throw new RestApiException("Cannot rebase ps", e);
    } catch (EmailException e) {
        throw new RestApiException("Cannot rebase ps", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi cherryPick(CherryPickInput in) throws RestApiException {
    try {
        return changes.id(cherryPick.get().apply(revision, in)._number);
    } catch (OrmException e) {
        throw new RestApiException("Cannot cherry pick ps", e);
    } catch (EmailException e) {
        throw new RestApiException("Cannot cherry pick ps", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot cherry pick ps", e);
    }
}
#method_after
@Override
public ChangeApi cherryPick(CherryPickInput in) throws RestApiException {
    try {
        return changes.id(cherryPick.get().apply(revision, in)._number);
    } catch (OrmException e) {
        throw new RestApiException("Cannot cherry pick", e);
    } catch (EmailException e) {
        throw new RestApiException("Cannot cherry pick", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot cherry pick", e);
    }
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, BranchInput input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new BranchInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    final Repository repo = repoManager.openRepository(rsrc.getNameKey());
    try {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo b = new BranchInfo();
            b.ref = ref;
            b.revision = revid.getName();
            b.setCanDelete(refControl.canDelete());
            return b;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    } finally {
        repo.close();
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    final Repository repo = repoManager.openRepository(rsrc.getNameKey());
    try {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo b = new BranchInfo();
            b.ref = ref;
            b.revision = revid.getName();
            b.setCanDelete(refControl.canDelete());
            return b;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Projects.class).to(ProjectsImpl.class);
    factory(ProjectApiImpl.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(Projects.class).to(ProjectsImpl.class);
    factory(BranchApiImpl.Factory.class);
    factory(ProjectApiImpl.Factory.class);
}
#end_block

#method_before
@Test
public void createBranch() throws GitAPIException, IOException, RestApiException {
    ProjectApi pApi = gApi.projects().forName(project.get());
    BranchInput in = new BranchInput();
    in.ref = "foo";
    pApi.createBranch(in);
}
#method_after
@Test
public void createBranch() throws GitAPIException, IOException, RestApiException {
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
}
#end_block

#method_before
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(getValue().isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    Element element = context.getElement().getFirstChildElement();
    while (element.getPropertyInt("value") != AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        element = element.getNextSiblingElement();
    }
    if (element.getPropertyInt("value") == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        if (enableSmallFileFeatures) {
            element.removeAttribute("disabled");
        } else {
            element.setAttribute("disabled", "disabled");
            if (AccountDiffPreference.CONTEXT_CHOICES[context.getSelectedIndex()] == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
                for (int i = 0; i < AccountDiffPreference.CONTEXT_CHOICES.length; i++) {
                    if (AccountDiffPreference.CONTEXT_CHOICES[i] == PatchScreen.LARGE_FILE_CONTEXT) {
                        context.setSelectedIndex(i);
                        break;
                    }
                }
            }
        }
    }
    toggleEnabledStatus(save.isEnabled());
}
#method_after
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(getValue().isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    NodeList<OptionElement> options = context.getElement().<SelectElement>cast().getOptions();
    // WHOLE_FILE_CONTEXT is the last option in the list.
    int lastIndex = options.getLength() - 1;
    OptionElement currOption = options.getItem(lastIndex);
    if (enableSmallFileFeatures) {
        currOption.setDisabled(false);
    } else {
        currOption.setDisabled(true);
        if (context.getSelectedIndex() == lastIndex) {
            // Select the next longest context from WHOLE_FILE_CONTEXT
            context.setSelectedIndex(lastIndex - 1);
        }
    }
    toggleEnabledStatus(save.isEnabled());
}
#end_block

#method_before
private static List<Predicate<ChangeData>> predicates(final Provider<ReviewDb> db, final PatchListCache plc, final SubmitStrategyFactory submitStrategyFactory, final ChangeControl.GenericFactory changeControlFactory, final IdentifiedUser.GenericFactory identifiedUserFactory, final GitRepositoryManager repoManager, final String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> r = Lists.newArrayList();
    for (final Change c : changes) {
        List<Predicate<ChangeData>> r2 = Lists.newArrayList();
        for (String file : (new ChangeData(c)).currentFilePaths(db, plc)) {
            r2.add(new EqualsFilePredicate(db, plc, file));
        }
        List<Predicate<ChangeData>> r3 = Lists.newArrayList();
        r3.add(not(new LegacyChangeIdPredicate(db, c.getId())));
        r3.add(or(r2));
        r3.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change(db);
                try {
                    Repository repo = repoManager.openRepository(otherChange.getProject());
                    try {
                        ObjectInserter inserter = repo.newObjectInserter();
                        try {
                            RevWalk rw = new RevWalk(repo) {

                                @Override
                                protected RevCommit createCommit(final AnyObjectId id) {
                                    return new CodeReviewCommit(id);
                                }
                            };
                            try {
                                RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                                CodeReviewCommit commit = (CodeReviewCommit) rw.parseCommit(ObjectId.fromString(new ChangeData(c).currentPatchSet(db).getRevision().get()));
                                SubmitStrategy strategy = submitStrategyFactory.create(getSubmitType(object), db.get(), repo, rw, inserter, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest());
                                CodeReviewCommit otherCommit = (CodeReviewCommit) rw.parseCommit(ObjectId.fromString(object.currentPatchSet(db).getRevision().get()));
                                otherCommit.add(canMergeFlag);
                                return !strategy.dryRun(commit, otherCommit);
                            } catch (MergeException e) {
                                throw new IllegalStateException();
                            } catch (NoSuchProjectException e) {
                                throw new IllegalStateException();
                            } finally {
                                rw.release();
                            }
                        } finally {
                            inserter.release();
                        }
                    } finally {
                        repo.close();
                    }
                } catch (IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(ChangeData cd) throws OrmException {
                try {
                    final SubmitTypeRecord r = changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())).getSubmitTypeRecord(db.get(), cd.currentPatchSet(db), cd);
                    if (r.status != SubmitTypeRecord.Status.OK) {
                        return null;
                    }
                    return r.type;
                } catch (NoSuchChangeException e) {
                    return null;
                }
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws MergeException {
                final Set<RevCommit> alreadyAccepted = new HashSet<RevCommit>();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (final Ref r : repo.getAllRefs().values()) {
                        if (r.getName().startsWith(Constants.R_HEADS) || r.getName().startsWith(Constants.R_TAGS)) {
                            try {
                                alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                            } catch (IncorrectObjectTypeException iote) {
                            // Not a commit? Skip over it.
                            }
                        }
                    }
                } catch (IOException e) {
                    throw new MergeException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        r.add(and(r3));
    }
    return r;
}
#method_after
private static List<Predicate<ChangeData>> predicates(final Provider<ReviewDb> db, final PatchListCache plc, final SubmitStrategyFactory submitStrategyFactory, final ChangeControl.GenericFactory changeControlFactory, final IdentifiedUser.GenericFactory identifiedUserFactory, final GitRepositoryManager repoManager, final ProjectCache projectCache, final ConflictsCache conflictsCache, final String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, projectCache);
        List<String> files = new ChangeData(c).currentFilePaths(db, plc);
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsFilePredicate(db, plc, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(db, c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(db, c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(db, c.getDest().get()));
        predicatesForOneChange.add(or(filePredicates));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change(db);
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(otherChange, object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet(db).getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try {
                    Repository repo = repoManager.openRepository(otherChange.getProject());
                    try {
                        RevWalk rw = new RevWalk(repo) {

                            @Override
                            protected RevCommit createCommit(AnyObjectId id) {
                                return new CodeReviewCommit(id);
                            }
                        };
                        try {
                            RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                            CodeReviewCommit commit = (CodeReviewCommit) rw.parseCommit(changeDataCache.getTestAgainst());
                            SubmitStrategy strategy = submitStrategyFactory.create(submitType, db.get(), repo, rw, null, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest());
                            CodeReviewCommit otherCommit = (CodeReviewCommit) rw.parseCommit(other);
                            otherCommit.add(canMergeFlag);
                            conflicts = !strategy.dryRun(commit, otherCommit);
                            conflictsCache.put(conflictsKey, conflicts);
                            return conflicts;
                        } catch (MergeException e) {
                            throw new IllegalStateException(e);
                        } catch (NoSuchProjectException e) {
                            throw new IllegalStateException(e);
                        } finally {
                            rw.release();
                        }
                    } finally {
                        repo.close();
                    }
                } catch (IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(Change change, ChangeData cd) throws OrmException {
                try {
                    final SubmitTypeRecord r = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner())).getSubmitTypeRecord(db.get(), cd.currentPatchSet(db), cd);
                    if (r.status != SubmitTypeRecord.Status.OK) {
                        return null;
                    }
                    return r.type;
                } catch (NoSuchChangeException e) {
                    return null;
                }
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws MergeException {
                Set<RevCommit> alreadyAccepted = Sets.newHashSet();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (ObjectId id : changeDataCache.getAlreadyAccepted(repo)) {
                        try {
                            alreadyAccepted.add(rw.parseCommit(id));
                        } catch (IncorrectObjectTypeException iote) {
                        // Not a commit? Skip over it.
                        }
                    }
                } catch (IOException e) {
                    throw new MergeException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public boolean hasLimit(Predicate<ChangeData> p) {
    return find(p, IntPredicate.class, FIELD_LIMIT) != null;
}
#method_after
@SuppressWarnings("unchecked")
public static boolean hasLimit(Predicate<ChangeData> p) {
    return find(p, IntPredicate.class, FIELD_LIMIT) != null;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public int getLimit(Predicate<ChangeData> p) {
    return ((IntPredicate<?>) find(p, IntPredicate.class, FIELD_LIMIT)).intValue();
}
#method_after
@SuppressWarnings("unchecked")
public static int getLimit(Predicate<ChangeData> p) {
    return ((IntPredicate<?>) find(p, IntPredicate.class, FIELD_LIMIT)).intValue();
}
#end_block

#method_before
public boolean hasSortKey(Predicate<ChangeData> p) {
    return find(p, SortKeyPredicate.class, "sortkey_after") != null || find(p, SortKeyPredicate.class, "sortkey_before") != null;
}
#method_after
public static boolean hasSortKey(Predicate<ChangeData> p) {
    return find(p, SortKeyPredicate.class, "sortkey_after") != null || find(p, SortKeyPredicate.class, "sortkey_before") != null;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> comment(String value) throws QueryParseException {
    if (args.index == ChangeIndex.DISABLED) {
        throw error("secondary index must be enabled for comment:" + value);
    }
    return new CommentPredicate(args.dbProvider, args.index, value);
}
#method_after
@Operator
public Predicate<ChangeData> comment(String value) throws QueryParseException {
    ChangeIndex index = requireIndex(FIELD_COMMENT, value);
    return new CommentPredicate(args.dbProvider, index, value);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> conflicts(String value) throws OrmException, QueryParseException {
    if (args.index == ChangeIndex.DISABLED) {
        throw error("secondary index must be enabled for " + FIELD_CONFLICTS + ":" + value);
    }
    return new ConflictsPredicate(args.dbProvider, args.patchListCache, args.submitStrategyFactory, args.changeControlGenericFactory, args.userFactory, args.repoManager, value, parseChange(value));
}
#method_after
@Operator
public Predicate<ChangeData> conflicts(String value) throws OrmException, QueryParseException {
    requireIndex(FIELD_CONFLICTS, value);
    return new ConflictsPredicate(args.dbProvider, args.patchListCache, args.submitStrategyFactory, args.changeControlGenericFactory, args.userFactory, args.repoManager, args.projectCache, args.conflictsCache, value, parseChange(value));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        if (allowFileRegex || args.index != ChangeIndex.DISABLED) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw error("secondary index must be enabled for file:" + file);
        }
    } else {
        if (args.index == ChangeIndex.DISABLED) {
            throw error("secondary index must be enabled for file:" + file);
        }
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        if (!allowFileRegex) {
            requireIndex(FIELD_FILE, file);
        }
        return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
    } else {
        requireIndex(FIELD_FILE, file);
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> message(String text) throws QueryParseException {
    if (args.index == ChangeIndex.DISABLED) {
        throw error("secondary index must be enabled for message:" + text);
    }
    return new MessagePredicate(args.dbProvider, args.index, text);
}
#method_after
@Operator
public Predicate<ChangeData> message(String text) throws QueryParseException {
    ChangeIndex index = args.indexes.getSearchIndex();
    if (index == null) {
        return new LegacyMessagePredicate(args.dbProvider, args.repoManager, text);
    }
    return new MessagePredicate(args.dbProvider, index, text);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser instanceof IdentifiedUser && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser, false));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id), true));
        }
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser.isIdentifiedUser() && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser, false));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id), true));
        }
    }
    return Predicate.or(p);
}
#end_block

#method_before
public Predicate<ChangeData> limit(int limit) {
    return new IntPredicate<ChangeData>(FIELD_LIMIT, limit) {

        @Override
        public boolean match(ChangeData object) {
            return true;
        }

        @Override
        public int getCost() {
            return 0;
        }
    };
}
#method_after
public Predicate<ChangeData> limit(int limit) {
    return new LimitPredicate(limit);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> sortkey_after(String sortKey) {
    return new SortKeyPredicate.After(args.dbProvider, sortKey);
}
#method_after
@Operator
public Predicate<ChangeData> sortkey_after(String sortKey) {
    return new SortKeyPredicate.After(BasicChangeRewrites.schema(args.indexes), args.dbProvider, sortKey);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> sortkey_before(String sortKey) {
    return new SortKeyPredicate.Before(args.dbProvider, sortKey);
}
#method_after
@Operator
public Predicate<ChangeData> sortkey_before(String sortKey) {
    return new SortKeyPredicate.Before(BasicChangeRewrites.schema(args.indexes), args.dbProvider, sortKey);
}
#end_block

#method_before
private List<Change> parseChange(String value) throws OrmException, QueryParseException {
    if (PAT_LEGACY_ID.matcher(value).matches()) {
        return Collections.singletonList(args.dbProvider.get().changes().get(Change.Id.parse(value)));
    } else if (PAT_CHANGE_ID.matcher(value).matches()) {
        Change.Key a = new Change.Key(parseChangeId(value));
        Change.Key b = a.max();
        List<Change> changes = args.dbProvider.get().changes().byKeyRange(a, b).toList();
        if (changes.isEmpty()) {
            throw error("Change " + value + " not found");
        }
        return changes;
    }
    throw error("Change " + value + " not found");
}
#method_after
private List<Change> parseChange(String value) throws OrmException, QueryParseException {
    if (PAT_LEGACY_ID.matcher(value).matches()) {
        return Collections.singletonList(args.dbProvider.get().changes().get(Change.Id.parse(value)));
    } else if (PAT_CHANGE_ID.matcher(value).matches()) {
        Change.Key a = new Change.Key(parseChangeId(value));
        List<Change> changes = args.dbProvider.get().changes().byKeyRange(a, a.max()).toList();
        if (changes.isEmpty()) {
            throw error("Change " + value + " not found");
        }
        return changes;
    }
    throw error("Change " + value + " not found");
}
#end_block

#method_before
private Account.Id self() {
    if (currentUser instanceof IdentifiedUser) {
        return ((IdentifiedUser) currentUser).getAccountId();
    }
    throw new IllegalArgumentException();
}
#method_after
private Account.Id self() {
    if (currentUser.isIdentifiedUser()) {
        return ((IdentifiedUser) currentUser).getAccountId();
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@NoCostComputation
@Rewrite("sortkey_before:z A=(age:*)")
public Predicate<ChangeData> r00_ageToSortKey(@Named("A") AgePredicate a) {
    String cut = ChangeUtil.sortKey(a.getCut(), Integer.MAX_VALUE);
    return and(new SortKeyPredicate.Before(dbProvider, cut), a);
}
#method_after
@SuppressWarnings("unchecked")
@NoCostComputation
@Rewrite("sortkey_before:z A=(age:*)")
public Predicate<ChangeData> r00_ageToSortKey(@Named("A") AgePredicate a) {
    String cut = ChangeUtil.sortKey(a.getCut(), Integer.MAX_VALUE);
    return and(new SortKeyPredicate.Before(schema(indexes), dbProvider, cut), a);
}
#end_block

#method_before
public void testHeadRefReplicated() throws URISyntaxException {
    reset(changeHooksMock);
    RefReplicatedEvent expectedEvent = new RefReplicatedEvent("someProject", "refs/heads/master", "someHost", RefPushResult.SUCCEEDED);
    changeHooksMock.postEvent(anyObject(Branch.NameKey.class), RefReplicatedEventEquals.eqEvent(expectedEvent));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    verify(changeHooksMock);
}
#method_after
public void testHeadRefReplicated() throws URISyntaxException {
    reset(changeHooksMock);
    RefReplicatedEvent expectedEvent = new RefReplicatedEvent("someProject", "refs/heads/master", "someHost", RefPushResult.SUCCEEDED);
    changeHooksMock.postEvent(anyObject(Branch.NameKey.class), RefReplicatedEventEquals.eqEvent(expectedEvent));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onRefReplicatedToOneNode("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    verify(changeHooksMock);
}
#end_block

#method_before
public void testChangeRefReplicated() throws URISyntaxException, OrmException {
    Change expectedChange = new Change(null, null, null, null, null);
    reset(changeAccessMock);
    expect(changeAccessMock.get(anyObject(Change.Id.class))).andReturn(expectedChange);
    replay(changeAccessMock);
    reset(changeHooksMock);
    RefReplicatedEvent expectedEvent = new RefReplicatedEvent("someProject", "refs/changes/1/1/1", "someHost", RefPushResult.FAILED);
    changeHooksMock.postEvent(eq(expectedChange), RefReplicatedEventEquals.eqEvent(expectedEvent), anyObject(ReviewDb.class));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/changes/1/1/1", new URIish("git://someHost/someProject.git"), RefPushResult.FAILED);
    verify(changeHooksMock);
}
#method_after
public void testChangeRefReplicated() throws URISyntaxException, OrmException {
    Change expectedChange = new Change(null, null, null, null, null);
    reset(changeAccessMock);
    expect(changeAccessMock.get(anyObject(Change.Id.class))).andReturn(expectedChange);
    replay(changeAccessMock);
    reset(changeHooksMock);
    RefReplicatedEvent expectedEvent = new RefReplicatedEvent("someProject", "refs/changes/1/1/1", "someHost", RefPushResult.FAILED);
    changeHooksMock.postEvent(eq(expectedChange), RefReplicatedEventEquals.eqEvent(expectedEvent), anyObject(ReviewDb.class));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onRefReplicatedToOneNode("someProject", "refs/changes/1/1/1", new URIish("git://someHost/someProject.git"), RefPushResult.FAILED);
    verify(changeHooksMock);
}
#end_block

#method_before
public void testOnAllNodesReplicated() throws URISyntaxException {
    reset(changeHooksMock);
    changeHooksMock.postEvent(anyObject(Branch.NameKey.class), anyObject(RefReplicatedEvent.class));
    expectLastCall().times(5);
    RefReplicationDoneEvent expectedDoneEvent = new RefReplicationDoneEvent("someProject", "refs/heads/master", 5);
    changeHooksMock.postEvent(anyObject(Branch.NameKey.class), RefReplicationDoneEventEquals.eqEvent(expectedDoneEvent));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    gitUpdateProcessing.onAllNodesReplicated(5);
    verify(changeHooksMock);
}
#method_after
public void testOnAllNodesReplicated() throws URISyntaxException {
    reset(changeHooksMock);
    RefReplicationDoneEvent expectedDoneEvent = new RefReplicationDoneEvent("someProject", "refs/heads/master", 5);
    changeHooksMock.postEvent(anyObject(Branch.NameKey.class), RefReplicationDoneEventEquals.eqEvent(expectedDoneEvent));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onRefReplicatedToAllNodes("someProject", "refs/heads/master", 5);
    verify(changeHooksMock);
}
#end_block

#method_before
@Override
public boolean matches(Object actual) {
    if (!(actual instanceof RefReplicatedEvent)) {
        return false;
    }
    RefReplicatedEvent actualRefReplicatedEvent = (RefReplicatedEvent) actual;
    if (!checkObjectsEquals(expected.project, actualRefReplicatedEvent.project)) {
        return false;
    }
    if (!checkObjectsEquals(expected.ref, actualRefReplicatedEvent.ref)) {
        return false;
    }
    if (!checkObjectsEquals(expected.targetNode, actualRefReplicatedEvent.targetNode)) {
        return false;
    }
    if (!checkObjectsEquals(expected.status, actualRefReplicatedEvent.status)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean matches(Object actual) {
    if (!(actual instanceof RefReplicatedEvent)) {
        return false;
    }
    RefReplicatedEvent actualRefReplicatedEvent = (RefReplicatedEvent) actual;
    if (!equals(expected.project, actualRefReplicatedEvent.project)) {
        return false;
    }
    if (!equals(expected.ref, actualRefReplicatedEvent.ref)) {
        return false;
    }
    if (!equals(expected.targetNode, actualRefReplicatedEvent.targetNode)) {
        return false;
    }
    if (!equals(expected.status, actualRefReplicatedEvent.status)) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public boolean matches(Object actual) {
    if (!(actual instanceof RefReplicationDoneEvent)) {
        return false;
    }
    RefReplicationDoneEvent actualRefReplicatedDoneEvent = (RefReplicationDoneEvent) actual;
    if (!checkObjectsEquals(expected.project, actualRefReplicatedDoneEvent.project)) {
        return false;
    }
    if (!checkObjectsEquals(expected.ref, actualRefReplicatedDoneEvent.ref)) {
        return false;
    }
    if (expected.nodesCount != actualRefReplicatedDoneEvent.nodesCount) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean matches(Object actual) {
    if (!(actual instanceof RefReplicationDoneEvent)) {
        return false;
    }
    RefReplicationDoneEvent actualRefReplicatedDoneEvent = (RefReplicationDoneEvent) actual;
    if (!equals(expected.project, actualRefReplicatedDoneEvent.project)) {
        return false;
    }
    if (!equals(expected.ref, actualRefReplicatedDoneEvent.ref)) {
        return false;
    }
    if (expected.nodesCount != actualRefReplicatedDoneEvent.nodesCount) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(ReplicationType.GIT_UPDATED, injector);
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : configs) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(new GitUpdateProcessing(changeHooks, database));
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : configs) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#end_block

#method_before
@Override
void onRefReplicatedToOneNode(String project, String ref, URIish uri, RefPushResult status) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replicate ");
    sb.append(project);
    sb.append(" to ");
    sb.append(resolveNodeName(uri));
    sb.append(", ");
    switch(status) {
        case SUCCEEDED:
            sb.append("Succeeded!");
            break;
        case FAILED:
            sb.append("FAILED!");
            hasError.compareAndSet(false, true);
            break;
        case NOT_ATTEMPTED:
            sb.append("NOT ATTEMPTED!");
            break;
        default:
            sb.append("UNKNOWN RESULT!");
            break;
    }
    writeStdOut(sb.toString());
}
#method_after
@Override
void onRefReplicatedToOneNode(String project, String ref, URIish uri, RefPushResult status) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replicate ");
    sb.append(project);
    sb.append(" ref ");
    sb.append(ref);
    sb.append(" to ");
    sb.append(resolveNodeName(uri));
    sb.append(", ");
    switch(status) {
        case SUCCEEDED:
            sb.append("Succeeded!");
            break;
        case FAILED:
            sb.append("FAILED!");
            hasError.compareAndSet(false, true);
            break;
        case NOT_ATTEMPTED:
            sb.append("NOT ATTEMPTED!");
            break;
        default:
            sb.append("UNKNOWN RESULT!");
            break;
    }
    writeStdOut(sb.toString());
}
#end_block

#method_before
@Override
void onRefReplicatedToAllNodes(String project, String ref, int nodesCount) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replication of ");
    sb.append(project);
    sb.append(" completed to ");
    sb.append(nodesCount);
    sb.append(" nodes, ");
    writeStdOut(sb.toString());
}
#method_after
@Override
void onRefReplicatedToAllNodes(String project, String ref, int nodesCount) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replication of ");
    sb.append(project);
    sb.append(" ref ");
    sb.append(ref);
    sb.append(" completed to ");
    sb.append(nodesCount);
    sb.append(" nodes, ");
    writeStdOut(sb.toString());
}
#end_block

#method_before
public void increasePushTaskCount(String project, String ref) {
    getRefReplicationInfo(project, ref).nodesToReplicateCount.incrementAndGet();
    totalPushTasksCount.incrementAndGet();
}
#method_after
public void increasePushTaskCount(String project, String ref) {
    countingLock.lock();
    try {
        getRefStatus(project, ref).nodesToReplicateCount++;
        totalPushTasksCount++;
    } finally {
        countingLock.unlock();
    }
}
#end_block

#method_before
public boolean hasPushTask() {
    return totalPushTasksCount.get() != 0;
}
#method_after
public boolean hasPushTask() {
    return totalPushTasksCount != 0;
}
#end_block

#method_before
public void notifyRefReplicated(String project, String ref, URIish uri, RefPushResult status) {
    pushResultProcessing.onRefReplicatedToOneNode(project, ref, uri, status);
    RefReplicationInfo refReplicationInfo = getRefReplicationInfo(project, ref);
    refReplicationInfo.replicatedNodesCount.incrementAndGet();
    if (allScheduled && refReplicationInfo.nodesToReplicateCount.get() == refReplicationInfo.replicatedNodesCount.get()) {
        fireOnRefReplicatedToAllNodes(project, ref);
    }
    finishedPushTasksCount.incrementAndGet();
    verifyAllPushTasksCompleted();
}
#method_after
public void notifyRefReplicated(String project, String ref, URIish uri, RefPushResult status) {
    pushResultProcessing.onRefReplicatedToOneNode(project, ref, uri, status);
    RefReplicationStatus completedRefStatus = null;
    boolean allPushTaksCompleted = false;
    countingLock.lock();
    try {
        RefReplicationStatus refStatus = getRefStatus(project, ref);
        refStatus.replicatedNodesCount++;
        finishedPushTasksCount++;
        if (allScheduled) {
            if (refStatus.allDone()) {
                completedRefStatus = statusByProjectRef.remove(project, ref);
            }
            allPushTaksCompleted = finishedPushTasksCount == totalPushTasksCount;
        }
    } finally {
        countingLock.unlock();
    }
    if (completedRefStatus != null) {
        doRefPushTasksCompleted(completedRefStatus);
    }
    if (allPushTaksCompleted) {
        doAllPushTasksCompleted();
    }
}
#end_block

#method_before
public void markAllPushTasksScheduled() {
    allScheduled = true;
    verifyAllPushTasksCompleted();
}
#method_after
public void markAllPushTasksScheduled() {
    countingLock.lock();
    try {
        allScheduled = true;
        if (finishedPushTasksCount < totalPushTasksCount) {
            return;
        }
    } finally {
        countingLock.unlock();
    }
    doAllPushTasksCompleted();
}
#end_block

#method_before
private void fireRemainingOnRefReplicatedToAllNodes() {
    // Some could be remaining if replication of a ref is completed before all tasks are scheduled
    for (SimpleEntry<String, String> projectRefKey : replicationInfoPerProjectRef.keySet()) {
        fireOnRefReplicatedToAllNodes(projectRefKey.getKey(), projectRefKey.getValue());
    }
}
#method_after
private void fireRemainingOnRefReplicatedToAllNodes() {
    for (RefReplicationStatus refStatus : statusByProjectRef.values()) {
        doRefPushTasksCompleted(refStatus);
    }
}
#end_block

#method_before
@Test
public void shouldFireOneReplicationEventWhenNothingToReplicate() {
    resetToStrict(pushResultProcessingMock);
    // expected event
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(0);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.markAllPushTasksScheduled();
    verify(pushResultProcessingMock);
}
#method_after
@Test
public void shouldFireOneReplicationEventWhenNothingToReplicate() {
    resetToDefault(pushResultProcessingMock);
    // expected event
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(0);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.markAllPushTasksScheduled();
    verify(pushResultProcessingMock);
}
#end_block

#method_before
@Test
public void shouldFireEventsForReplicationOfOneRefToOneNode() throws URISyntaxException {
    resetToStrict(pushResultProcessingMock);
    URIish uri = new URIish("git://someHost/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 1);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(1);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    verify(pushResultProcessingMock);
}
#method_after
@Test
public void shouldFireEventsForReplicationOfOneRefToOneNode() throws URISyntaxException {
    resetToDefault(pushResultProcessingMock);
    URIish uri = new URIish("git://someHost/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 1);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(1);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    verify(pushResultProcessingMock);
}
#end_block

#method_before
@Test
public void shouldFireEventsForReplicationOfOneRefToMultipleNodes() throws URISyntaxException {
    resetToStrict(pushResultProcessingMock);
    URIish uri1 = new URIish("git://someHost1/someRepo.git");
    URIish uri2 = new URIish("git://someHost2/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri2, RefPushResult.FAILED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 2);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(2);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    replicationState.notifyRefReplicated("someProject", "someRef", uri2, RefPushResult.FAILED);
    verify(pushResultProcessingMock);
}
#method_after
@Test
public void shouldFireEventsForReplicationOfOneRefToMultipleNodes() throws URISyntaxException {
    resetToDefault(pushResultProcessingMock);
    URIish uri1 = new URIish("git://someHost1/someRepo.git");
    URIish uri2 = new URIish("git://someHost2/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri2, RefPushResult.FAILED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 2);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(2);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    replicationState.notifyRefReplicated("someProject", "someRef", uri2, RefPushResult.FAILED);
    verify(pushResultProcessingMock);
}
#end_block

#method_before
@Override
protected Object getRowItemKey(final DocInfo item) {
    return item.url();
}
#method_after
@Override
protected Object getRowItemKey(DocInfo item) {
    return item.url();
}
#end_block

#method_before
@Override
protected void onOpenRow(final int row) {
    final DocInfo d = getRowItem(row);
    Gerrit.display("/" + d.url());
}
#method_after
@Override
protected void onOpenRow(int row) {
    DocInfo d = getRowItem(row);
    Window.Location.assign(d.getFullUrl());
}
#end_block

#method_before
private void insertNoneRow(final int row) {
    insertRow(row);
    table.setText(row, 0, Util.C.docTableNone());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.setColSpan(row, 0, columns);
    fmt.setStyleName(row, 0, Gerrit.RESOURCES.css().emptySection());
}
#method_after
private void insertNoneRow(int row) {
    table.insertRow(row);
    table.setText(row, 0, Util.C.docTableNone());
    FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.setStyleName(row, 0, Gerrit.RESOURCES.css().emptySection());
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().cSUBJECT());
}
#method_after
@Override
protected void applyDataRowStyle(int row) {
    super.applyDataRowStyle(row);
    CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().cSUBJECT());
}
#end_block

#method_before
private void populateDocRow(final int row, final DocInfo d) {
    String title = com.google.gerrit.client.changes.Util.cropSubject(d.title());
    table.setWidget(row, C_TITLE, new DocLink(d));
    setRowItem(row, d);
}
#method_after
private void populateDocRow(int row, DocInfo d) {
    table.setWidget(row, C_TITLE, new DocLink(d));
    setRowItem(row, d);
}
#end_block

#method_before
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/doc/", token)) {
        docSearch(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* DEPRECATED URL */
    matchPrefix("/c2/", token)) {
        changeScreen2 = true;
        change(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#method_after
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/Documentation/", token)) {
        docSearch(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* DEPRECATED URL */
    matchPrefix("/c2/", token)) {
        changeScreen2 = true;
        change(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#end_block

#method_before
private static void docSearch(final String token) {
    Gerrit.display(token, new DocScreen(skip(token)));
}
#method_after
private static void docSearch(final String token) {
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            Gerrit.display(token, new DocScreen(skip(token)));
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new DocTable() {

        {
            keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadSearch()) {

                @Override
                public void onKeyPress(final KeyPressEvent event) {
                    Gerrit.display(getToken());
                }
            });
        }
    };
    section = new DocTable.Section();
    table.addSection(section);
    table.setSavePointerId(query);
    add(table);
    setWindowTitle(Util.M.docQueryWindowTitle(query));
    setPageTitle(Util.M.docQueryPageTitle(query));
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new DocTable();
    table.setSavePointerId(query);
    add(table);
    setWindowTitle(Util.M.docQueryWindowTitle(query));
    setPageTitle(Util.M.docQueryPageTitle(query));
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    docs.query(loadCallback(), query);
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    doQuery();
}
#end_block

#method_before
protected AsyncCallback<DocList> loadCallback() {
    return new GerritCallback<DocList>() {

        @Override
        public final void onSuccess(DocList result) {
            display(result);
            DocScreen.this.display();
        }
    };
}
#method_after
private AsyncCallback<JsArray<DocInfo>> loadCallback() {
    return new GerritCallback<JsArray<DocInfo>>() {

        @Override
        public void onSuccess(JsArray<DocInfo> result) {
            displayResults(result);
            display();
        }
    };
}
#end_block

#method_before
@Override
protected Map<String, Ref> getAdvertisedRefs(Repository repository, RevWalk revWalk) throws ServiceMayNotContinueException {
    try {
        return filter(repository.getRefDatabase().getRefs(RefDatabase.ALL));
    } catch (ServiceMayNotContinueException e) {
        throw e;
    } catch (IOException e) {
        throw new ServiceMayNotContinueException().initCause(e);
    }
}
#method_after
@Override
protected Map<String, Ref> getAdvertisedRefs(Repository repository, RevWalk revWalk) throws ServiceMayNotContinueException {
    try {
        return filter(repository.getRefDatabase().getRefs(RefDatabase.ALL));
    } catch (ServiceMayNotContinueException e) {
        throw e;
    } catch (IOException e) {
        ServiceMayNotContinueException ex = new ServiceMayNotContinueException();
        ex.initCause(e);
        throw ex;
    }
}
#end_block

#method_before
@Override
public void advertiseRefs(BaseReceivePack rp) throws ServiceMayNotContinueException {
    Map<String, Ref> oldRefs = rp.getAdvertisedRefs();
    if (oldRefs == null) {
        try {
            oldRefs = rp.getRepository().getRefDatabase().getRefs(ALL);
        } catch (ServiceMayNotContinueException e) {
            throw e;
        } catch (IOException e) {
            throw new ServiceMayNotContinueException().initCause(e);
        }
    }
    Map<String, Ref> r = Maps.newHashMapWithExpectedSize(oldRefs.size());
    for (Map.Entry<String, Ref> e : oldRefs.entrySet()) {
        String name = e.getKey();
        if (!skip(name)) {
            r.put(name, e.getValue());
        }
    }
    rp.setAdvertisedRefs(r, advertiseHistory(r.values(), rp));
}
#method_after
@Override
public void advertiseRefs(BaseReceivePack rp) throws ServiceMayNotContinueException {
    Map<String, Ref> oldRefs = rp.getAdvertisedRefs();
    if (oldRefs == null) {
        try {
            oldRefs = rp.getRepository().getRefDatabase().getRefs(ALL);
        } catch (ServiceMayNotContinueException e) {
            throw e;
        } catch (IOException e) {
            ServiceMayNotContinueException ex = new ServiceMayNotContinueException();
            ex.initCause(e);
            throw ex;
        }
    }
    Map<String, Ref> r = Maps.newHashMapWithExpectedSize(oldRefs.size());
    for (Map.Entry<String, Ref> e : oldRefs.entrySet()) {
        String name = e.getKey();
        if (!skip(name)) {
            r.put(name, e.getValue());
        }
    }
    rp.setAdvertisedRefs(r, advertiseHistory(r.values(), rp));
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = new File(new File(getSitePath(), "logs"), "gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    if (slave && httpd) {
        throw die("Cannot combine --slave and --enable-httpd");
    }
    if (consoleLog) {
    } else {
        manager.add(ErrorLogFile.start(getSitePath()));
    }
    try {
        dbInjector = createDbInjector(MULTI_USER);
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        shellInjector = createShellInjector();
        manager.add(dbInjector, cfgInjector, sysInjector, shellInjector);
        if (sshd) {
            initSshd();
        }
        if (httpd) {
            initHttpd();
        }
        manager.start();
        RuntimeShutdown.add(new Runnable() {

            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    runFile.delete();
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                runFile.createNewFile();
                runFile.setReadable(true, false);
                FileOutputStream out = new FileOutputStream(runFile);
                try {
                    out.write((runId + "\n").getBytes("UTF-8"));
                } finally {
                    out.close();
                }
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (shell) {
            InteractiveShell interp = shellInjector.getInstance(InteractiveShell.class);
            interp.set("m", manager);
            interp.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#method_after
@Override
public int run() throws Exception {
    if (doInit) {
        try {
            new Init(getSitePath()).run();
        } catch (Exception e) {
            throw die("Init failed", e);
        }
    }
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = new File(new File(getSitePath(), "logs"), "gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    if (slave && httpd) {
        throw die("Cannot combine --slave and --enable-httpd");
    }
    manager.add(GarbageCollectionLogFile.start(getSitePath()));
    if (consoleLog) {
    } else {
        manager.add(ErrorLogFile.start(getSitePath()));
    }
    try {
        dbInjector = createDbInjector(MULTI_USER);
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        sysInjector.getInstance(PluginGuiceEnvironment.class).setCfgInjector(cfgInjector);
        manager.add(dbInjector, cfgInjector, sysInjector);
        if (sshd) {
            initSshd();
        }
        if (httpd) {
            initHttpd();
        }
        manager.start();
        RuntimeShutdown.add(new Runnable() {

            @Override
            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    runFile.delete();
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                runFile.createNewFile();
                runFile.setReadable(true, false);
                FileOutputStream out = new FileOutputStream(runFile);
                try {
                    out.write((runId + "\n").getBytes("UTF-8"));
                } finally {
                    out.close();
                }
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (serverStarted != null) {
            serverStarted.run();
        }
        if (inspector) {
            JythonShell shell = new JythonShell();
            shell.set("m", manager);
            shell.set("ds", dbInjector.getInstance(DataSourceProvider.class));
            shell.set("schk", dbInjector.getInstance(SchemaVersionCheck.class));
            shell.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new EhcachePoolImpl.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PushReplication.Module());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private void initSshd() {
    sshInjector = createSshInjector();
    manager.add(sshInjector);
}
#method_after
private void initSshd() {
    sshInjector = createSshInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setSshInjector(sshInjector);
    manager.add(sshInjector);
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sshd) {
        modules.add(new SshModule());
        if (slave) {
            modules.add(new SlaveCommandModule());
        } else {
            modules.add(new MasterCommandModule());
        }
    } else {
        modules.add(new NoSshModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sshd) {
        modules.add(sysInjector.getInstance(SshModule.class));
        if (slave) {
            modules.add(new SlaveCommandModule());
        } else {
            modules.add(new MasterCommandModule());
        }
    } else {
        modules.add(new NoSshModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private void initHttpd() {
    webInjector = createWebInjector();
    sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
    httpdInjector = createHttpdInjector();
    manager.add(webInjector, httpdInjector);
}
#method_after
private void initHttpd() {
    webInjector = createWebInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setHttpInjector(webInjector);
    sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
    httpdInjector = createHttpdInjector();
    manager.add(webInjector, httpdInjector);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
        modules.add(new ProjectQoSFilter.Module());
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
protected Object runMethod0(Class klazz, Object instance, String name, Class[] sig, Object[] args) throws InvocationTargetException {
    Method interpMethod;
    try {
        interpMethod = klazz.getMethod(name, sig);
        return interpMethod.invoke(instance, args);
    } catch (NoSuchMethodException e) {
        throw cannotStart(e);
    } catch (SecurityException e) {
        throw cannotStart(e);
    } catch (IllegalArgumentException e) {
        throw cannotStart(e);
    } catch (IllegalAccessException e) {
        throw cannotStart(e);
    }
}
#method_after
protected Object runMethod0(Class<?> klazz, Object instance, String name, Class<?>[] sig, Object[] args) throws InvocationTargetException {
    try {
        Method m;
        m = klazz.getMethod(name, sig);
        return m.invoke(instance, args);
    } catch (NoSuchMethodException e) {
        throw cannotStart(e);
    } catch (SecurityException e) {
        throw cannotStart(e);
    } catch (IllegalArgumentException e) {
        throw cannotStart(e);
    } catch (IllegalAccessException e) {
        throw cannotStart(e);
    }
}
#end_block

#method_before
protected Object runMethod(Class klazz, Object instance, String name, Class[] sig, Object[] args) {
    try {
        return runMethod0(klazz, instance, name, sig, args);
    } catch (InvocationTargetException e) {
        throw cannotStart(e);
    }
}
#method_after
protected Object runMethod(Class<?> klazz, Object instance, String name, Class<?>[] sig, Object[] args) {
    try {
        return runMethod0(klazz, instance, name, sig, args);
    } catch (InvocationTargetException e) {
        throw cannotStart(e);
    }
}
#end_block

#method_before
protected Object runInterpreter(String name, Class[] sig, Object[] args) {
    return runMethod(console, interp, name, sig, args);
}
#method_after
protected Object runInterpreter(String name, Class<?>[] sig, Object[] args) {
    return runMethod(console, shell, name, sig, args);
}
#end_block

#method_before
private static Class findClass(String klazzname) {
    try {
        return Class.forName(klazzname);
    } catch (ClassNotFoundException e) {
        throw noShell("Class " + klazzname + " not found", e);
    }
}
#method_after
private static Class<?> findClass(String klazzname) {
    try {
        return Class.forName(klazzname);
    } catch (ClassNotFoundException e) {
        throw noShell("Class " + klazzname + " not found", e);
    }
}
#end_block

#method_before
protected void execFile(final File parent, final String p) {
    try {
        File script = new File(parent, p);
        if (script.canExecute()) {
            runMethod0(console, interp, "execfile", new Class[] { String.class }, new Object[] { script.getAbsolutePath() });
        } else {
            log.info("User initialization file " + script.getAbsolutePath() + " is not found or not executable");
        }
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading file " + p + " : ", e);
    } catch (SecurityException e) {
        log.error("SecurityException occured while loading file " + p + " : ", e);
    }
}
#method_after
protected void execFile(final File parent, final String p) {
    try {
        File script = new File(parent, p);
        if (script.canExecute()) {
            runMethod0(console, shell, "execfile", new Class[] { String.class }, new Object[] { script.getAbsolutePath() });
        } else {
            log.info("User initialization file " + script.getAbsolutePath() + " is not found or not executable");
        }
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading file " + p + " : ", e);
    } catch (SecurityException e) {
        log.error("SecurityException occured while loading file " + p + " : ", e);
    }
}
#end_block

#method_before
protected void execStream(final InputStream in, final String p) {
    try {
        runMethod0(console, interp, "execfile", new Class[] { InputStream.class, String.class }, new Object[] { in, p });
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading " + p + " : ", e);
    }
}
#method_after
protected void execStream(final InputStream in, final String p) {
    try {
        runMethod0(console, shell, "execfile", new Class[] { InputStream.class, String.class }, new Object[] { in, p });
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading " + p + " : ", e);
    }
}
#end_block

#method_before
private static ClassLoader libClassLoader() throws IOException {
    final File path;
    try {
        path = getDistributionArchive();
    } catch (FileNotFoundException e) {
        if (NOT_ARCHIVED == e.getMessage()) {
            // 
            return GerritLauncher.class.getClassLoader();
        }
        throw e;
    }
    final ArrayList<URL> jars = new ArrayList<URL>();
    try {
        final ZipFile zf = new ZipFile(path);
        try {
            final Enumeration<? extends ZipEntry> e = zf.entries();
            while (e.hasMoreElements()) {
                final ZipEntry ze = e.nextElement();
                if (ze.isDirectory()) {
                    continue;
                }
                if (ze.getName().startsWith("WEB-INF/lib/")) {
                    final File tmp = createTempFile(safeName(ze), ".jar");
                    final FileOutputStream out = new FileOutputStream(tmp);
                    try {
                        final InputStream in = zf.getInputStream(ze);
                        try {
                            final byte[] buf = new byte[4096];
                            int n;
                            while ((n = in.read(buf, 0, buf.length)) > 0) {
                                out.write(buf, 0, n);
                            }
                        } finally {
                            in.close();
                        }
                    } finally {
                        out.close();
                    }
                    jars.add(tmp.toURI().toURL());
                }
            }
        } finally {
            zf.close();
        }
    } catch (IOException e) {
        throw new IOException("Cannot obtain libraries from " + path, e);
    }
    if (jars.isEmpty()) {
        return GerritLauncher.class.getClassLoader();
    }
    Collections.sort(jars, new Comparator<URL>() {

        public int compare(URL o1, URL o2) {
            return o1.toString().compareTo(o2.toString());
        }
    });
    return new URLClassLoader(jars.toArray(new URL[jars.size()]));
}
#method_after
private static ClassLoader libClassLoader() throws IOException {
    final File path;
    try {
        path = getDistributionArchive();
    } catch (FileNotFoundException e) {
        if (NOT_ARCHIVED == e.getMessage()) {
            // 
            return GerritLauncher.class.getClassLoader();
        }
        throw e;
    }
    final SortedMap<String, URL> jars = new TreeMap<String, URL>();
    try {
        final ZipFile zf = new ZipFile(path);
        try {
            final Enumeration<? extends ZipEntry> e = zf.entries();
            while (e.hasMoreElements()) {
                final ZipEntry ze = e.nextElement();
                if (ze.isDirectory()) {
                    continue;
                } else if (ze.getName().startsWith("WEB-INF/lib/")) {
                    extractJar(zf, ze, jars);
                } else if (ze.getName().startsWith("WEB-INF/pgm-lib/")) {
                    extractJar(zf, ze, jars);
                }
            }
        } finally {
            zf.close();
        }
    } catch (IOException e) {
        throw new IOException("Cannot obtain libraries from " + path, e);
    }
    if (jars.isEmpty()) {
        return GerritLauncher.class.getClassLoader();
    }
    // The extension API needs to be its own ClassLoader, along
    // with a few of its dependencies. Try to construct this first.
    List<URL> extapi = new ArrayList<URL>();
    move(jars, "gerrit-extension-api-", extapi);
    move(jars, "guice-", extapi);
    move(jars, "javax.inject-1.jar", extapi);
    move(jars, "aopalliance-1.0.jar", extapi);
    move(jars, "guice-servlet-", extapi);
    move(jars, "tomcat-servlet-api-", extapi);
    ClassLoader parent = ClassLoader.getSystemClassLoader();
    if (!extapi.isEmpty()) {
        parent = new URLClassLoader(extapi.toArray(new URL[extapi.size()]), parent);
    }
    return new URLClassLoader(jars.values().toArray(new URL[jars.size()]), parent);
}
#end_block

#method_before
private static File tmproot() {
    // Use $HOME/.gerritcodereview/tmp for our temporary file area.
    // 
    final File tmp = new File(getHomeDirectory(), "tmp");
    if (!tmp.exists() && !tmp.mkdirs()) {
        System.err.println("warning: cannot create " + tmp.getAbsolutePath());
        System.err.println("warning: using system temporary directory instead");
        return null;
    }
    // Try to clean up any stale empty directories. Assume any empty
    // directory that is older than 7 days is one of these dead ones
    // that we can clean up.
    // 
    final File[] tmpEntries = tmp.listFiles();
    if (tmpEntries != null) {
        final long now = System.currentTimeMillis();
        final long expired = now - MILLISECONDS.convert(7, DAYS);
        for (final File tmpEntry : tmpEntries) {
            if (tmpEntry.isDirectory() && tmpEntry.lastModified() < expired) {
                final String[] all = tmpEntry.list();
                if (all == null || all.length == 0) {
                    tmpEntry.delete();
                }
            }
        }
    }
    try {
        return tmp.getCanonicalFile();
    } catch (IOException e) {
        return tmp;
    }
}
#method_after
private static File tmproot() {
    File tmp;
    String gerritTemp = System.getenv("GERRIT_TMP");
    if (gerritTemp != null && gerritTemp.length() > 0) {
        tmp = new File(gerritTemp);
    } else {
        tmp = new File(getHomeDirectory(), "tmp");
    }
    if (!tmp.exists() && !tmp.mkdirs()) {
        System.err.println("warning: cannot create " + tmp.getAbsolutePath());
        System.err.println("warning: using system temporary directory instead");
        return null;
    }
    // Try to clean up any stale empty directories. Assume any empty
    // directory that is older than 7 days is one of these dead ones
    // that we can clean up.
    // 
    final File[] tmpEntries = tmp.listFiles();
    if (tmpEntries != null) {
        final long now = System.currentTimeMillis();
        final long expired = now - MILLISECONDS.convert(7, DAYS);
        for (final File tmpEntry : tmpEntries) {
            if (tmpEntry.isDirectory() && tmpEntry.lastModified() < expired) {
                final String[] all = tmpEntry.list();
                if (all == null || all.length == 0) {
                    tmpEntry.delete();
                }
            }
        }
    }
    try {
        return tmp.getCanonicalFile();
    } catch (IOException e) {
        return tmp;
    }
}
#end_block

#method_before
@Override
public void run() throws Exception {
    List<QueryDocumentationExecutor.DocResult> res = searcher.doQuery(q);
    for (DocResult docResult : res) {
        stdout.println(String.format("%s: %s", docResult.title, docResult.url));
    }
}
#method_after
@Override
public void run() throws Exception {
    List<QueryDocumentationExecutor.DocResult> res = searcher.doQuery(q);
    for (DocResult docResult : res) {
        stdout.println(String.format("%s:\n%s%s\n", docResult.title, url, docResult.url));
    }
}
#end_block

#method_before
public List<DocResult> doQuery(String q) throws DocQueryException {
    if (parser == null || searcher == null) {
        throw new DocQueryException("Not initialized");
    }
    try {
        Query query = parser.parse(q);
        TopDocs results = searcher.search(query, Integer.MAX_VALUE);
        ScoreDoc[] hits = results.scoreDocs;
        int totalHits = results.totalHits;
        List<DocResult> out = Lists.newArrayListWithCapacity(totalHits);
        for (int i = 0; i < totalHits; i++) {
            DocResult result = new DocResult();
            Document doc = searcher.doc(hits[i].doc);
            result.url = doc.get(Constants.URL_FIELD);
            result.title = doc.get(Constants.TITLE_FIELD);
            out.add(result);
        }
        return out;
    } catch (IOException e) {
        throw new DocQueryException(e);
    } catch (ParseException e) {
        throw new DocQueryException(e);
    }
}
#method_after
public List<DocResult> doQuery(String q) throws DocQueryException {
    if (parser == null || searcher == null) {
        throw new DocQueryException("Documentation search not available");
    }
    try {
        Query query = parser.parse(q);
        TopDocs results = searcher.search(query, Integer.MAX_VALUE);
        ScoreDoc[] hits = results.scoreDocs;
        int totalHits = results.totalHits;
        List<DocResult> out = Lists.newArrayListWithCapacity(totalHits);
        for (int i = 0; i < totalHits; i++) {
            DocResult result = new DocResult();
            Document doc = searcher.doc(hits[i].doc);
            result.url = doc.get(Constants.URL_FIELD);
            result.title = doc.get(Constants.TITLE_FIELD);
            out.add(result);
        }
        return out;
    } catch (IOException e) {
        throw new DocQueryException(e);
    } catch (ParseException e) {
        throw new DocQueryException(e);
    }
}
#end_block

#method_before
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    if (!(regions.length() == 0 || regions.length() == 1 && regions.get(0).ab() != null)) {
        header.hideNoDiff();
    }
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                mapper.appendDelete(deleteCnt);
            }
            int chunkEndA = mapper.getLineA() - 1;
            int chunkEndB = mapper.getLineB() - 1;
            if (aLength > 0) {
                addDiffChunkAndPadding(cmB, chunkEndB, chunkEndA, aLength, bLength > 0);
            }
            if (bLength > 0) {
                addDiffChunkAndPadding(cmA, chunkEndA, chunkEndB, bLength, aLength > 0);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
            if (aLength == 0) {
                diffTable.sidePanel.addGutter(cmB, origLineB, SidePanel.GutterType.INSERT);
            } else if (bLength == 0) {
                diffTable.sidePanel.addGutter(cmA, origLineA, SidePanel.GutterType.DELETE);
            } else {
                diffTable.sidePanel.addGutter(cmB, origLineB, SidePanel.GutterType.EDIT);
            }
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    if (!(regions.length() == 0 || regions.length() == 1 && regions.get(0).ab() != null)) {
        header.removeNoDiff();
    }
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                mapper.appendDelete(deleteCnt);
            }
            int chunkEndA = mapper.getLineA() - 1;
            int chunkEndB = mapper.getLineB() - 1;
            if (aLength > 0) {
                addDiffChunkAndPadding(cmB, chunkEndB, chunkEndA, aLength, bLength > 0);
            }
            if (bLength > 0) {
                addDiffChunkAndPadding(cmA, chunkEndA, chunkEndB, bLength, aLength > 0);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
            if (aLength == 0) {
                diffTable.sidePanel.addGutter(cmB, origLineB, SidePanel.GutterType.INSERT);
            } else if (bLength == 0) {
                diffTable.sidePanel.addGutter(cmA, origLineA, SidePanel.GutterType.DELETE);
            } else {
                diffTable.sidePanel.addGutter(cmB, origLineB, SidePanel.GutterType.EDIT);
            }
        }
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    bind(DocQueryProcessor.class).to(DocQueryLucene.class);
    if (uiOptions.enableDefaultUi()) {
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?docsearch/(.*)$").with(DocSearchRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
    serve("/robots.txt").with(RobotsServlet.class);
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    if (uiOptions.enableDefaultUi()) {
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    filter("/Documentation/").through(QueryDocumentationFilter.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
    serve("/robots.txt").with(RobotsServlet.class);
}
#end_block

#method_before
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(DocQueryLucene.DOC_FIELD, reader));
        doc.add(new StringField(DocQueryLucene.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(DocQueryLucene.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#method_after
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#end_block

#method_before
public Change.Id cherryPick(final PatchSet.Id patchSetId, final String message, final String destinationBranch, final RefControl refControl) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, MergeException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (destinationBranch == null || destinationBranch.length() == 0) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = db.changes().get(changeId).getProject();
    final Repository git;
    try {
        git = gitManager.openRepository(project);
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        RevWalk revWalk = new RevWalk(git);
        try {
            Ref destRef = git.getRef(destinationBranch);
            if (destRef == null) {
                throw new InvalidChangeOperationException("Branch " + destinationBranch + " does not exist.");
            }
            final RevCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
            RevCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent committerIdent = currentUser.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            RevCommit cherryPickCommit;
            ObjectInserter oi = git.newObjectInserter();
            try {
                ProjectState projectState = refControl.getProjectControl().getProjectState();
                cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, message, revWalk);
            } finally {
                oi.release();
            }
            if (cherryPickCommit == null) {
                throw new MergeException("Could not create a merge commit during the cherry pick");
            }
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(cherryPickCommit.getTree(), mergeTip, cherryPickCommit.getAuthorIdent(), myIdent, message);
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            List<Change> destChanges = db.changes().byBranchKey(new Branch.NameKey(db.changes().get(changeId).getProject(), destRef.getName()), changeKey).toList();
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " resides on the same branch. " + "Cannot create a new patch set.");
            } else if (destChanges.size() == 1) {
                // will be added as a new patch set.
                return insertPatchSet(git, revWalk, destChanges.get(0), patchSetId, cherryPickCommit, refControl);
            } else {
                // change.
                return createNewChange(git, revWalk, changeKey, project, patchSetId, destRef, cherryPickCommit, refControl);
            }
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#method_after
public Change.Id cherryPick(final PatchSet.Id patchSetId, final String message, final String destinationBranch, final RefControl refControl) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, MergeException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (destinationBranch == null || destinationBranch.length() == 0) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = db.changes().get(changeId).getProject();
    final Repository git;
    try {
        git = gitManager.openRepository(project);
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        RevWalk revWalk = new RevWalk(git);
        try {
            Ref destRef = git.getRef(destinationBranch);
            if (destRef == null) {
                throw new InvalidChangeOperationException("Branch " + destinationBranch + " does not exist.");
            }
            final RevCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
            RevCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent committerIdent = currentUser.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), myIdent, message);
            String commitMessage = ChangeIdUtil.insertId(message, computedChangeId);
            RevCommit cherryPickCommit;
            ObjectInserter oi = git.newObjectInserter();
            try {
                ProjectState projectState = refControl.getProjectControl().getProjectState();
                cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk);
            } finally {
                oi.release();
            }
            if (cherryPickCommit == null) {
                throw new MergeException("Could not create a merge commit during the cherry pick");
            }
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            List<Change> destChanges = db.changes().byBranchKey(new Branch.NameKey(db.changes().get(changeId).getProject(), destRef.getName()), changeKey).toList();
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " resides on the same branch. " + "Cannot create a new patch set.");
            } else if (destChanges.size() == 1) {
                // will be added as a new patch set.
                return insertPatchSet(git, revWalk, destChanges.get(0), patchSetId, cherryPickCommit, refControl);
            } else {
                // change.
                return createNewChange(git, revWalk, changeKey, project, patchSetId, destRef, cherryPickCommit, refControl);
            }
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
private Change.Id insertPatchSet(Repository git, RevWalk revWalk, Change change, PatchSet.Id patchSetId, RevCommit cherryPickCommit, RefControl refControl) throws InvalidChangeOperationException, IOException, OrmException, NoSuchChangeException {
    final PatchSetInserter inserter = patchSetInserterFactory.create(git, revWalk, refControl, currentUser, change, cherryPickCommit);
    final PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(patchSetId.getParentKey(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), newPatchSetId);
    cmsg.setMessage("Uploaded patch set " + newPatchSetId.get() + ".");
    inserter.setMessage(cmsg).insert();
    return change.getId();
}
#method_after
private Change.Id insertPatchSet(Repository git, RevWalk revWalk, Change change, PatchSet.Id patchSetId, RevCommit cherryPickCommit, RefControl refControl) throws InvalidChangeOperationException, IOException, OrmException, NoSuchChangeException {
    final PatchSetInserter inserter = patchSetInserterFactory.create(git, revWalk, refControl, currentUser, change, cherryPickCommit);
    final PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    inserter.setMessage("Uploaded patch set " + newPatchSetId.get() + ".").insert();
    return change.getId();
}
#end_block

#method_before
public static <R extends RestResource> Iterable<UiAction.Description> from(DynamicMap<RestView<R>> views, final R resource) {
    return Iterables.filter(Iterables.transform(views, new Function<DynamicMap.Entry<RestView<R>>, UiAction.Description>() {

        @Override
        @Nullable
        public UiAction.Description apply(DynamicMap.Entry<RestView<R>> e) {
            int d = e.getExportName().indexOf('.');
            if (d < 0) {
                return null;
            }
            RestView<R> view;
            try {
                view = e.getProvider().get();
            } catch (RuntimeException err) {
                log.error(String.format("error creating view %s.%s", e.getPluginName(), e.getExportName()), err);
                return null;
            }
            if (!(view instanceof UiAction)) {
                return null;
            }
            UiAction.Description dsc = ((UiAction<R>) view).getDescription(resource);
            if (dsc == null || dsc.isVisible()) {
                return null;
            }
            String name = e.getExportName().substring(d + 1);
            PrivateInternals_UiActionDescription.setMethod(dsc, e.getExportName().substring(0, d));
            PrivateInternals_UiActionDescription.setId(dsc, "gerrit".equals(e.getPluginName()) ? name : e.getPluginName() + '~' + name);
            return dsc;
        }
    }), Predicates.notNull());
}
#method_after
public static <R extends RestResource> Iterable<UiAction.Description> from(DynamicMap<RestView<R>> views, final R resource) {
    return Iterables.filter(Iterables.transform(views, new Function<DynamicMap.Entry<RestView<R>>, UiAction.Description>() {

        @Override
        @Nullable
        public UiAction.Description apply(DynamicMap.Entry<RestView<R>> e) {
            int d = e.getExportName().indexOf('.');
            if (d < 0) {
                return null;
            }
            RestView<R> view;
            try {
                view = e.getProvider().get();
            } catch (RuntimeException err) {
                log.error(String.format("error creating view %s.%s", e.getPluginName(), e.getExportName()), err);
                return null;
            }
            if (!(view instanceof UiAction)) {
                return null;
            }
            UiAction.Description dsc = ((UiAction<R>) view).getDescription(resource);
            if (dsc == null || !dsc.isVisible()) {
                return null;
            }
            String name = e.getExportName().substring(d + 1);
            PrivateInternals_UiActionDescription.setMethod(dsc, e.getExportName().substring(0, d));
            PrivateInternals_UiActionDescription.setId(dsc, "gerrit".equals(e.getPluginName()) ? name : e.getPluginName() + '~' + name);
            return dsc;
        }
    }), Predicates.notNull());
}
#end_block

#method_before
private void populateCommands(final PatchSetDetail detail) {
    for (final UiCommandDetail cmd : detail.getCommands()) {
        final Button b = new Button();
        b.setText(cmd.label);
        b.setEnabled(cmd.enabled);
        b.setTitle(cmd.title);
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                AsyncCallback<NativeString> cb = new AsyncCallback<NativeString>() {

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        new ErrorDialog(caught).center();
                    }

                    @Override
                    public void onSuccess(NativeString msg) {
                        b.setEnabled(true);
                        if (msg != null && !msg.asString().isEmpty()) {
                            Window.alert(msg.asString());
                        }
                    }
                };
                RestApi api = ChangeApi.revision(patchSet.getId()).view(cmd.id);
                if ("PUT".equalsIgnoreCase(cmd.method)) {
                    api.put(JavaScriptObject.createObject(), cb);
                } else if ("DELETE".equalsIgnoreCase(cmd.method)) {
                    api.delete(cb);
                } else {
                    api.post(JavaScriptObject.createObject(), cb);
                }
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateCommands(final PatchSetDetail detail) {
    for (final UiCommandDetail cmd : detail.getCommands()) {
        final Button b = new Button();
        b.setText(cmd.label);
        b.setEnabled(cmd.enabled);
        b.setTitle(cmd.title);
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                AsyncCallback<NativeString> cb = new AsyncCallback<NativeString>() {

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        new ErrorDialog(caught).center();
                    }

                    @Override
                    public void onSuccess(NativeString msg) {
                        b.setEnabled(true);
                        if (msg != null && !msg.asString().isEmpty()) {
                            Window.alert(msg.asString());
                        }
                        Gerrit.display(PageLinks.toChange(patchSet.getId()));
                    }
                };
                RestApi api = ChangeApi.revision(patchSet.getId()).view(cmd.id);
                if ("PUT".equalsIgnoreCase(cmd.method)) {
                    api.put(JavaScriptObject.createObject(), cb);
                } else if ("DELETE".equalsIgnoreCase(cmd.method)) {
                    api.delete(cb);
                } else {
                    api.post(JavaScriptObject.createObject(), cb);
                }
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(CacheDeleteHandler.class);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DELETE_PROJECT)).to(DeleteProjectCapability.class);
    bind(DatabaseDeleteHandler.class).to(SchemaVersion.guessVersion(SchemaVersion.C) < 77 ? Schema73DatabaseDeleteHandler.class : Schema77DatabaseDeleteHandler.class);
    bind(FilesystemDeleteHandler.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            delete(PROJECT_KIND).to(DeleteProject.class);
            post(PROJECT_KIND, "delete").to(DeleteProject.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(CacheDeleteHandler.class);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DELETE_PROJECT)).to(DeleteProjectCapability.class);
    bind(DatabaseDeleteHandler.class).to(registerDatabaseHandler());
    bind(FilesystemDeleteHandler.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            delete(PROJECT_KIND).to(DeleteProject.class);
            post(PROJECT_KIND, "delete").to(DeleteAction.class);
        }
    });
}
#end_block

#method_before
public void installPluginFromStream(String name, InputStream in) throws IOException, PluginInstallException {
    if (!name.endsWith(".jar")) {
        name += ".jar";
    }
    File jar = new File(pluginsDir, name);
    name = nameOf(jar);
    File old = new File(pluginsDir, ".last_" + name + ".zip");
    File tmp = asTemp(in, ".next_" + name, ".zip", pluginsDir);
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            log.info(String.format("Replacing plugin %s", name));
            old.delete();
            jar.renameTo(old);
        }
        // TODO(davido): the name-owned plugins can be renamed here,
        // do we care?
        new File(pluginsDir, name + ".jar.disabled").delete();
        tmp.renameTo(jar);
        try {
            Plugin plugin = runPlugin(name, jar, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", plugin.getName()));
            }
        } catch (PluginInstallException e) {
            jar.delete();
            throw e;
        }
        cleanInBackground();
    }
}
#method_after
public void installPluginFromStream(String originalName, InputStream in) throws IOException, PluginInstallException {
    String fileName = originalName;
    if (!fileName.endsWith(".jar")) {
        fileName += ".jar";
    }
    File tmp = asTemp(in, ".next_" + fileName + "_", ".tmp", pluginsDir);
    String name = Objects.firstNonNull(getGerritPluginName(tmp), nameOf(fileName));
    if (!originalName.equals(name)) {
        log.warn(String.format("Plugin provides its own name: <%s>," + " use it instead of the input name: <%s>", name, originalName));
    }
    File dst = new File(pluginsDir, name + ".jar");
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            fileName = active.getSrcFile().getName();
            log.info(String.format("Replacing plugin %s", active.getName()));
            File old = new File(pluginsDir, ".last_" + fileName);
            old.delete();
            active.getSrcFile().renameTo(old);
        }
        new File(pluginsDir, fileName + ".disabled").delete();
        tmp.renameTo(dst);
        try {
            Plugin plugin = runPlugin(name, dst, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", plugin.getName()));
            }
        } catch (PluginInstallException e) {
            dst.delete();
            throw e;
        }
        cleanInBackground();
    }
}
#end_block

#method_before
synchronized private void unloadPlugin(Plugin plugin) {
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
    files.remove(name);
}
#method_after
synchronized private void unloadPlugin(Plugin plugin) {
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#end_block

#method_before
public void disablePlugins(Set<String> names) {
    synchronized (this) {
        for (String name : names) {
            Plugin active = running.get(name);
            if (active == null) {
                continue;
            }
            log.info(String.format("Disabling plugin %s", name));
            File off = new File(pluginsDir, active.getName() + ".jar.disabled");
            active.getSrcFile().renameTo(off);
            unloadPlugin(active);
            try {
                FileSnapshot snapshot = FileSnapshot.save(off);
                Plugin offPlugin = loadPlugin(name, off, snapshot);
                disabled.put(name, offPlugin);
            } catch (Throwable e) {
                // This shouldn't happen, as the plugin was loaded earlier.
                log.warn(String.format("Cannot load disabled plugin %s", name), e.getCause());
            }
        }
        cleanInBackground();
    }
}
#method_after
public void disablePlugins(Set<String> names) {
    synchronized (this) {
        for (String name : names) {
            Plugin active = running.get(name);
            if (active == null) {
                continue;
            }
            log.info(String.format("Disabling plugin %s", active.getName()));
            File off = new File(active.getSrcFile() + ".disabled");
            active.getSrcFile().renameTo(off);
            unloadPlugin(active);
            try {
                FileSnapshot snapshot = FileSnapshot.save(off);
                Plugin offPlugin = loadPlugin(name, off, snapshot);
                disabled.put(name, offPlugin);
            } catch (Throwable e) {
                // This shouldn't happen, as the plugin was loaded earlier.
                log.warn(String.format("Cannot load disabled plugin %s", active.getName()), e.getCause());
            }
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public void enablePlugins(Set<String> names) throws PluginInstallException {
    synchronized (this) {
        for (String name : names) {
            Plugin off = disabled.get(name);
            if (off == null) {
                continue;
            }
            log.info(String.format("Enabling plugin %s", name));
            File on = new File(pluginsDir, off.getName() + ".jar");
            off.getSrcFile().renameTo(on);
            disabled.remove(name);
            runPlugin(name, on, null);
        }
        cleanInBackground();
    }
}
#method_after
public void enablePlugins(Set<String> names) throws PluginInstallException {
    synchronized (this) {
        for (String name : names) {
            Plugin off = disabled.get(name);
            if (off == null) {
                continue;
            }
            log.info(String.format("Enabling plugin %s", name));
            String n = off.getSrcFile().getName();
            if (n.endsWith(".disabled")) {
                n = n.substring(0, n.lastIndexOf('.'));
            }
            File on = new File(pluginsDir, n);
            off.getSrcFile().renameTo(on);
            disabled.remove(name);
            runPlugin(name, on, null);
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public synchronized void rescan() {
    List<File> jars = scanJarsInPluginsDirectory();
    stopRemovedPlugins(jars);
    dropRemovedDisabledPlugins(jars);
    for (File jar : jars) {
        if (jar.getName().endsWith(".disabled")) {
            continue;
        }
        String name = nameOf(jar);
        if (files.containsKey(name)) {
            name = files.get(name);
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", name));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, jar, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s", loadedPlugin.getName()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> jars = prunePlugins(pluginsDir);
    if (jars.isEmpty()) {
        return;
    }
    syncDisabledPlugins(jars);
    Map<String, File> activePlugins = filterDisabled(jars);
    for (String name : activePlugins.keySet()) {
        File jar = activePlugins.get(name);
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, jar, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private Plugin runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        if (!newPlugin.getName().equals(name)) {
            files.put(name, newPlugin.getName());
        }
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(newPlugin.getName(), newPlugin);
        } else {
            disabled.put(newPlugin.getName(), newPlugin);
        }
        broken.remove(newPlugin.getName());
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private void stopRemovedPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (File jar : jars) {
        if (!jar.getName().endsWith(".disabled")) {
            String name = nameOf(jar);
            unload.remove(files.containsKey(name) ? files.get(name) : name);
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#method_after
private void stopRemovedPlugins(Multimap<String, File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (Map.Entry<String, Collection<File>> entry : jars.asMap().entrySet()) {
        for (File file : entry.getValue()) {
            if (!file.getName().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#end_block

#method_before
private void dropRemovedDisabledPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (File jar : jars) {
        if (jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#method_after
private void dropRemovedDisabledPlugins(Multimap<String, File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (Map.Entry<String, Collection<File>> entry : jars.asMap().entrySet()) {
        for (File file : entry.getValue()) {
            if (file.getName().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#end_block

#method_before
private static String nameOf(File jar) {
    String name = jar.getName();
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#method_after
private static String nameOf(File jar) {
    return nameOf(jar.getName());
}
#end_block

#method_before
private static String nameOf(File jar) {
    String name = jar.getName();
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#method_after
private static String nameOf(String name) {
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcJar, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    File tmp;
    FileInputStream in = new FileInputStream(srcJar);
    try {
        tmp = asTemp(in, tempNameFor(name), ".jar", tmpDir);
    } finally {
        in.close();
    }
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String pluginName = main.getValue("Gerrit-PluginName");
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        if (!Strings.isNullOrEmpty(pluginName)) {
            name = pluginName;
        }
        URL[] urls = { tmp.toURI().toURL() };
        ClassLoader parentLoader = parentFor(type);
        ClassLoader pluginLoader = new URLClassLoader(urls, parentLoader);
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        Plugin plugin = new JarPlugin(name, pluginUserFactory.create(name), srcJar, snapshot, jarFile, manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadPlugin(String name, File srcJar, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    File tmp;
    FileInputStream in = new FileInputStream(srcJar);
    try {
        tmp = asTemp(in, tempNameFor(name), ".jar", tmpDir);
    } finally {
        in.close();
    }
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        URL[] urls = { tmp.toURI().toURL() };
        ClassLoader parentLoader = parentFor(type);
        ClassLoader pluginLoader = new URLClassLoader(urls, parentLoader);
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        Plugin plugin = new JarPlugin(name, pluginUserFactory.create(name), srcJar, snapshot, jarFile, manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    @SuppressWarnings("unchecked")
    Class<? extends Module> clazz = (Class<? extends Module>) Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return clazz;
}
#method_after
private static Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    @SuppressWarnings("unchecked")
    Class<? extends Module> clazz = (Class<? extends Module>) Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return clazz;
}
#end_block

#method_before
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (n.endsWith(".jar") || n.endsWith(".jar.disabled")) && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#method_after
private static List<File> scanJarsInPluginsDirectory(File pluginsDir) {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (n.endsWith(".jar") || n.endsWith(".jar.disabled")) && !n.startsWith(".last_") && !n.startsWith(".next_") && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (receiveEvent.commit.getParentCount() > 1 && !refControl.canUploadMerges(receiveEvent.command)) {
        throw new CommitValidationException("you are not allowed to upload merges");
    }
    return Collections.<CommitValidationMessage>emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (receiveEvent.commit.getParentCount() > 1) {
        if (MagicBranch.isForReview(receiveEvent.command.getRefName())) {
            if (!refControl.canUploadMerges()) {
                throw new CommitValidationException("you are not allowed to upload merges for review");
            }
        } else {
            if (!refControl.canPushMerges()) {
                throw new CommitValidationException("you are not allowed to push merges directly bypassing code review");
            }
        }
    }
    return Collections.<CommitValidationMessage>emptyList();
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges(cmd) && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && (MagicBranch.isForReview(cmd.getRefName()) ? ctl.canUploadMerges() : ctl.canPushMerges()) && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
public boolean canUploadMerges(ReceiveCommand c) {
    String ref = getRefName();
    if (MagicBranch.isMagicBranch(c.getRefName())) {
        ref = "refs/for/" + ref;
    }
    return projectControl.controlForRef(ref).canPerform(Permission.PUSH_MERGE) && canWrite();
}
#method_after
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && canWrite();
}
#end_block

#method_before
static PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#method_after
static public PermissionRule grant(ProjectConfig project, String permissionName, int min, int max, AccountGroup.UUID group, String ref) {
    PermissionRule rule = newRule(project, group);
    rule.setMin(min);
    rule.setMax(max);
    return grant(project, permissionName, rule, ref);
}
#end_block

#method_before
static PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#method_after
static private PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#end_block

#method_before
private ProjectState newProjectState(ProjectConfig local) {
    PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager gitMgr = null;
    ProjectControl.AssistedFactory projectControlFactory = null;
    RulesCache rulesCache = null;
    SitePaths sitePaths = null;
    List<CommentLinkInfo> commentLinks = null;
    all.put(local.getProject().getNameKey(), new ProjectState(sitePaths, projectCache, allProjectsName, projectControlFactory, envFactory, gitMgr, rulesCache, commentLinks, local));
    return all.get(local.getProject().getNameKey());
}
#method_after
private ProjectState newProjectState(ProjectConfig local) {
    add(local);
    return all.get(local.getProject().getNameKey());
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    util = new Util();
    load("gerrit", "gerrit_common_test.pl", new AbstractModule() {

        @Override
        protected void configure() {
            bind(PrologEnvironment.Args.class).toInstance(new PrologEnvironment.Args(null, null, null, null, null, null));
        }
    });
    local = new ProjectConfig(localKey);
    local.createInMemory();
    V.setRefPatterns(Arrays.asList("sameAsAccess"));
    Q.setRefPatterns(Arrays.asList("refs/heads/develop"));
    local.getLabelSections().put(V.getName(), V);
    local.getLabelSections().put(Q.getName(), Q);
    util.add(local);
    grantLabel(local, LABEL + V.getName(), -1, +1, REGISTERED, "refs/heads/*");
    grantLabel(local, LABEL + Q.getName(), -1, +1, REGISTERED, "refs/heads/master");
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    util = new Util();
    load("gerrit", "gerrit_common_test.pl", new AbstractModule() {

        @Override
        protected void configure() {
            bind(PrologEnvironment.Args.class).toInstance(new PrologEnvironment.Args(null, null, null, null, null, null));
        }
    });
    local = new ProjectConfig(localKey);
    local.createInMemory();
    Q.setRefPatterns(Arrays.asList("refs/heads/develop"));
    local.getLabelSections().put(V.getName(), V);
    local.getLabelSections().put(Q.getName(), Q);
    util.add(local);
    grant(local, LABEL + V.getName(), -1, +1, REGISTERED, "refs/heads/*");
    grant(local, LABEL + Q.getName(), -1, +1, REGISTERED, "refs/heads/master");
}
#end_block

#method_before
private void loadLabelSections(Config rc) throws IOException {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = Maps.newLinkedHashMap();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = Lists.newArrayList();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String abbr = rc.getString(LABEL, name, KEY_ABBREVIATION);
        if (abbr != null) {
            label.setAbbreviation(abbr);
        }
        String functionName = Objects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, false));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, false));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, true));
        labelSections.put(name, label);
    }
}
#method_after
private void loadLabelSections(Config rc) throws IOException {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = Maps.newLinkedHashMap();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = Lists.newArrayList();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String abbr = rc.getString(LABEL, name, KEY_ABBREVIATION);
        if (abbr != null) {
            label.setAbbreviation(abbr);
        }
        String functionName = Objects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, false));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, false));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, true));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_Branch));
        labelSections.put(name, label);
    }
}
#end_block

#method_before
private void loadPluginSections(Config rc) {
    pluginConfigs = Maps.newHashMap();
    Set<String> pluginSubsections = rc.getSubsections(PLUGIN);
    for (String plugin : pluginSubsections) {
        LinkedListMultimap<String, String> pluginConfig = LinkedListMultimap.create();
        pluginConfigs.put(plugin, pluginConfig);
        for (String name : rc.getNames(PLUGIN, plugin)) {
            pluginConfig.putAll(name, Arrays.asList(rc.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#method_after
private void loadPluginSections(Config rc) {
    pluginConfigs = Maps.newHashMap();
    for (String plugin : rc.getSubsections(PLUGIN)) {
        Config pluginConfig = new Config();
        pluginConfigs.put(plugin, pluginConfig);
        for (String name : rc.getNames(PLUGIN, plugin)) {
            pluginConfig.setStringList(PLUGIN, plugin, name, Arrays.asList(rc.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#end_block

#method_before
public LinkedListMultimap<String, String> getPluginConfig(String pluginName) {
    LinkedListMultimap<String, String> pluginConfig = pluginConfigs.get(pluginName);
    if (pluginConfig == null) {
        pluginConfig = LinkedListMultimap.create();
        pluginConfigs.put(pluginName, pluginConfig);
    }
    return pluginConfig;
}
#method_after
public PluginConfig getPluginConfig(String pluginName) {
    Config pluginConfig = pluginConfigs.get(pluginName);
    if (pluginConfig == null) {
        pluginConfig = new Config();
        pluginConfigs.put(pluginName, pluginConfig);
    }
    return new PluginConfig(pluginName, pluginConfig);
}
#end_block

#method_before
private void savePluginSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(PLUGIN));
    for (String name : existing) {
        rc.unsetSection(PLUGIN, name);
    }
    for (Entry<String, LinkedListMultimap<String, String>> e : pluginConfigs.entrySet()) {
        String plugin = e.getKey();
        LinkedListMultimap<String, String> pluginConfig = e.getValue();
        for (String name : pluginConfig.keySet()) {
            rc.setStringList(PLUGIN, plugin, name, pluginConfig.get(name));
        }
    }
}
#method_after
private void savePluginSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(PLUGIN));
    for (String name : existing) {
        rc.unsetSection(PLUGIN, name);
    }
    for (Entry<String, Config> e : pluginConfigs.entrySet()) {
        String plugin = e.getKey();
        Config pluginConfig = e.getValue();
        for (String name : pluginConfig.getNames(PLUGIN, plugin)) {
            rc.setStringList(PLUGIN, plugin, name, Arrays.asList(pluginConfig.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#end_block

#method_before
public PluginConfig get(String pluginName) {
    LinkedListMultimap<String, String> pluginConfig = LinkedListMultimap.create();
    for (String name : cfg.getNames(PLUGIN, pluginName)) {
        pluginConfig.putAll(name, Arrays.asList(cfg.getStringList(PLUGIN, pluginName, name)));
    }
    return new PluginConfig(pluginName, pluginConfig);
}
#method_after
public PluginConfig get(String pluginName) {
    return new PluginConfig(pluginName, cfg);
}
#end_block

#method_before
public String getString(String name, String defaultValue) {
    return getValue(name, Functions.<String>identity(), defaultValue);
}
#method_after
public String getString(String name) {
    return cfg.getString(PLUGIN, pluginName, name);
}
#end_block

#method_before
public String getString(String name, String defaultValue) {
    return getValue(name, Functions.<String>identity(), defaultValue);
}
#method_after
public String getString(String name, String defaultValue) {
    return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
}
#end_block

#method_before
public int getInt(String name, int defaultValue) {
    return getValue(name, new Function<String, Integer>() {

        @Override
        public Integer apply(String stringVal) {
            return Integer.parseInt(stringVal);
        }
    }, defaultValue);
}
#method_after
public int getInt(String name, int defaultValue) {
    return cfg.getInt(PLUGIN, pluginName, name, defaultValue);
}
#end_block

#method_before
public long getLong(String name, long defaultValue) {
    return getValue(name, new Function<String, Long>() {

        @Override
        public Long apply(String stringVal) {
            return Long.parseLong(stringVal);
        }
    }, defaultValue);
}
#method_after
public long getLong(String name, long defaultValue) {
    return cfg.getLong(PLUGIN, pluginName, name, defaultValue);
}
#end_block

#method_before
public boolean getBoolean(String name, boolean defaultValue) {
    return getValue(name, new Function<String, Boolean>() {

        @Override
        public Boolean apply(String stringVal) {
            return Boolean.parseBoolean(stringVal);
        }
    }, defaultValue);
}
#method_after
public boolean getBoolean(String name, boolean defaultValue) {
    return cfg.getBoolean(PLUGIN, pluginName, name, defaultValue);
}
#end_block

#method_before
static void call(Button b, final ChangeInfo info, final String revision, String project, final String commitMessage) {
    // TODO Replace CherryPickDialog with a nicer looking display.
    b.setEnabled(false);
    new CherryPickDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCherryPickChangeSend());
            if (info.status().isClosed()) {
                String cm = commitMessage.trim();
                String cmWithoutChangeId = cm.substring(0, cm.lastIndexOf("Change-Id"));
                String cmChangeId = cm.substring(cm.lastIndexOf("Change-Id"));
                message.setText(Util.M.cherryPickedChangeDefaultMessage(cmWithoutChangeId, revision, cmChangeId));
            } else {
                message.setText(commitMessage.trim());
            }
        }

        @Override
        public void onSend() {
            ChangeApi.cherrypick(info.legacy_id().get(), revision, getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange2(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#method_after
static void call(Button b, final ChangeInfo info, final String revision, String project, final String commitMessage) {
    // TODO Replace CherryPickDialog with a nicer looking display.
    b.setEnabled(false);
    new CherryPickDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCherryPickChangeSend());
            if (info.status().isClosed()) {
                message.setText(Util.M.cherryPickedChangeDefaultMessage(commitMessage.trim(), revision));
            } else {
                message.setText(commitMessage.trim());
            }
        }

        @Override
        public void onSend() {
            ChangeApi.cherrypick(info.legacy_id().get(), revision, getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange2(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                ChangeApi.submit(patchSet.getId().getParentKey().get(), patchSet.getRevision().get(), new GerritCallback<SubmitInfo>() {

                    public void onSuccess(SubmitInfo result) {
                        redisplay();
                    }

                    public void onFailure(Throwable err) {
                        if (SubmitFailureDialog.isConflict(err)) {
                            new SubmitFailureDialog(err.getMessage()).center();
                            redisplay();
                        } else {
                            b.setEnabled(true);
                            super.onFailure(err);
                        }
                    }

                    private void redisplay() {
                        Gerrit.display(PageLinks.toChange(patchSet.getId().getParentKey()), new ChangeScreen(patchSet.getId().getParentKey()));
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, true, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRevertChangeSend());
                        message.setText(Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.revert(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canCherryPick()) {
        final Button b = new Button(Util.C.buttonCherryPickChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CherryPickDialog(b, changeDetail.getChange().getProject()) {

                    {
                        sendButton.setText(Util.C.buttonCherryPickChangeSend());
                        if (changeDetail.getChange().getStatus().isClosed()) {
                            String cm = detail.getInfo().getMessage().trim();
                            String cmWithoutChangeId = cm.substring(0, cm.lastIndexOf("Change-Id"));
                            String cmChangeId = cm.substring(cm.lastIndexOf("Change-Id"));
                            message.setText(Util.M.cherryPickedChangeDefaultMessage(cmWithoutChangeId, detail.getPatchSet().getRevision().get(), cmChangeId));
                        } else {
                            message.setText(detail.getInfo().getMessage().trim());
                        }
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.cherrypick(changeDetail.getChange().getChangeId(), patchSet.getRevision().get(), getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage()) {

                    {
                        sendButton.setText(Util.C.buttonAbandonChangeSend());
                    }

                    @Override
                    public void onSend() {
                        // TODO: once the other users of ActionDialog have converted to
                        // REST APIs, we can use createCallback() rather than providing
                        // them directly.
                        ChangeApi.abandon(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRestoreChangeSend());
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.restore(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRebase()) {
        final Button b = new Button(Util.C.buttonRebaseChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.rebaseChange(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b));
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                ChangeApi.submit(patchSet.getId().getParentKey().get(), patchSet.getRevision().get(), new GerritCallback<SubmitInfo>() {

                    public void onSuccess(SubmitInfo result) {
                        redisplay();
                    }

                    public void onFailure(Throwable err) {
                        if (SubmitFailureDialog.isConflict(err)) {
                            new SubmitFailureDialog(err.getMessage()).center();
                            redisplay();
                        } else {
                            b.setEnabled(true);
                            super.onFailure(err);
                        }
                    }

                    private void redisplay() {
                        Gerrit.display(PageLinks.toChange(patchSet.getId().getParentKey()), new ChangeScreen(patchSet.getId().getParentKey()));
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, true, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRevertChangeSend());
                        message.setText(Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.revert(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canCherryPick()) {
        final Button b = new Button(Util.C.buttonCherryPickChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CherryPickDialog(b, changeDetail.getChange().getProject()) {

                    {
                        sendButton.setText(Util.C.buttonCherryPickChangeSend());
                        if (changeDetail.getChange().getStatus().isClosed()) {
                            message.setText(Util.M.cherryPickedChangeDefaultMessage(detail.getInfo().getMessage().trim(), detail.getPatchSet().getRevision().get()));
                        } else {
                            message.setText(detail.getInfo().getMessage().trim());
                        }
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.cherrypick(changeDetail.getChange().getChangeId(), patchSet.getRevision().get(), getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage()) {

                    {
                        sendButton.setText(Util.C.buttonAbandonChangeSend());
                    }

                    @Override
                    public void onSend() {
                        // TODO: once the other users of ActionDialog have converted to
                        // REST APIs, we can use createCallback() rather than providing
                        // them directly.
                        ChangeApi.abandon(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRestoreChangeSend());
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.restore(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRebase()) {
        final Button b = new Button(Util.C.buttonRebaseChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.rebaseChange(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b));
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private PersonIdent createPersonIdent() {
    return ((IdentifiedUser) currentUser).newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone());
}
#method_after
private PersonIdent createPersonIdent() {
    return identifiedUser.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone());
}
#end_block

#method_before
@Override
public String apply(ProjectResource rsrc, Input input) throws AuthException, ResourceNotFoundException, BadRequestException, UnprocessableEntityException, IOException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.ref)) {
        throw new BadRequestException("ref required");
    }
    String ref = input.ref;
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        if (repo.getRef(ref) == null) {
            throw new UnprocessableEntityException(String.format("Ref Not Found: %s", ref));
        }
        if (!repo.getRef(Constants.HEAD).getTarget().getName().equals(ref)) {
            final RefUpdate u = repo.updateRef(Constants.HEAD, true);
            u.setRefLogIdent(((IdentifiedUser) currentUser.get()).newRefLogIdent());
            RefUpdate.Result res = u.link(ref);
            switch(res) {
                case NO_CHANGE:
                case RENAMED:
                case FORCED:
                case NEW:
                    break;
                default:
                    throw new IOException("Setting HEAD failed with " + res);
            }
        }
        return ref;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#method_after
@Override
public String apply(ProjectResource rsrc, Input input) throws AuthException, ResourceNotFoundException, BadRequestException, UnprocessableEntityException, IOException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.ref)) {
        throw new BadRequestException("ref required");
    }
    String ref = input.ref;
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        if (repo.getRef(ref) == null) {
            throw new UnprocessableEntityException(String.format("Ref Not Found: %s", ref));
        }
        if (!repo.getRef(Constants.HEAD).getTarget().getName().equals(ref)) {
            final RefUpdate u = repo.updateRef(Constants.HEAD, true);
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            RefUpdate.Result res = u.link(ref);
            switch(res) {
                case NO_CHANGE:
                case RENAMED:
                case FORCED:
                case NEW:
                    break;
                default:
                    throw new IOException("Setting HEAD failed with " + res);
            }
        }
        return ref;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(CacheDeleteHandler.class);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DELETE_PROJECT)).to(DeleteProjectCapability.class);
    bind(DatabaseDeleteHandler.class).to(registerDatabaseHandler());
    bind(FilesystemDeleteHandler.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            post(PROJECT_KIND, "delete-project").to(UiDeleteAction.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(CacheDeleteHandler.class);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DELETE_PROJECT)).to(DeleteProjectCapability.class);
    bind(DatabaseDeleteHandler.class).to(registerDatabaseHandler());
    bind(FilesystemDeleteHandler.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            delete(PROJECT_KIND).to(DeleteProject.class);
            post(PROJECT_KIND, "delete").to(DeleteProject.class);
        }
    });
}
#end_block

#method_before
private Class<? extends DatabaseDeleteHandler> registerDatabaseHandler() {
    int schemaVersion = SchemaVersion.guessVersion(SchemaVersion.C);
    // Injection of version dependent database handlers
    Class<? extends DatabaseDeleteHandler> databaseDeleteHandlerClass = null;
    switch(schemaVersion) {
        case 73:
        case 74:
        case 75:
        case 76:
            databaseDeleteHandlerClass = Schema73DatabaseDeleteHandler.class;
            break;
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
            databaseDeleteHandlerClass = Schema77DatabaseDeleteHandler.class;
            break;
        default:
            throw new RuntimeException("This version of the delete-project plugin is not " + "compatible with your current schema version (Version: " + schemaVersion + "). Please update the plugin.");
    }
    assert databaseDeleteHandlerClass != null : "No database handler set";
    return databaseDeleteHandlerClass;
}
#method_after
private Class<? extends DatabaseDeleteHandler> registerDatabaseHandler() {
    int schemaVersion = SchemaVersion.guessVersion(SchemaVersion.C);
    // Injection of version dependent database handlers
    Class<? extends DatabaseDeleteHandler> databaseDeleteHandlerClass = null;
    switch(schemaVersion) {
        case 73:
        case 74:
        case 75:
        case 76:
            databaseDeleteHandlerClass = Schema73DatabaseDeleteHandler.class;
            break;
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
            databaseDeleteHandlerClass = Schema77DatabaseDeleteHandler.class;
            break;
        default:
            throw new RuntimeException("This version of the delete-project plugin is not " + "compatible with your current schema version (Version: " + schemaVersion + "). Please update the plugin.");
    }
    assert databaseDeleteHandlerClass != null : "No database handler set";
    return databaseDeleteHandlerClass;
}
#end_block

#method_before
private void initEditMessageAction() {
    NativeMap<ActionInfo> actions = changeInfo.revision(revision).actions();
    if (actions != null && actions.containsKey("message")) {
        editMessage.setVisible(true);
        editMessageAction = new EditMessageAction(changeInfo.legacy_id(), revision, changeInfo.revision(revision).commit().message(), style, editMessage, reply);
        keysAction.add(new KeyCommand(0, 'e', Util.C.keyEditMessage()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                editMessageAction.onEdit();
            }
        });
    }
}
#method_after
private void initEditMessageAction(ChangeInfo info, String revision) {
    NativeMap<ActionInfo> actions = info.revision(revision).actions();
    if (actions != null && actions.containsKey("message")) {
        editMessage.setVisible(true);
        editMessageAction = new EditMessageAction(info.legacy_id(), revision, info.revision(revision).commit().message(), style, editMessage, reply);
        keysAction.add(new KeyCommand(0, 'e', Util.C.keyEditMessage()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                editMessageAction.onEdit();
            }
        });
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    downloadPatch.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction();
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderDownload(info, revision);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void renderRevisions(ChangeInfo info) {
    if (info.revisions().size() == 1) {
        UIObject.setVisible(revisionParent, false);
        return;
    }
    JsArray<RevisionInfo> list = info.revisions().values();
    Collections.sort(Natives.asList(list), new Comparator<RevisionInfo>() {

        @Override
        public int compare(RevisionInfo a, RevisionInfo b) {
            return a._number() - b._number();
        }
    });
    int selected = -1;
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        revisionList.addItem(r._number() + ": " + r.name().substring(0, 6), "" + r._number());
        if (revision.equals(r.name())) {
            selected = i;
        }
    }
    if (0 <= selected) {
        revisionList.setSelectedIndex(selected);
    }
}
#method_after
private void renderRevisions(ChangeInfo info) {
    if (info.revisions().size() == 1) {
        UIObject.setVisible(revisionParent, false);
        return;
    }
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isReversePatchSetOrder()) {
        Collections.reverse(Natives.asList(list));
    }
    int selected = -1;
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        revisionList.addItem(r._number() + ": " + r.name().substring(0, 6), "" + r._number());
        if (revision.equals(r.name())) {
            selected = i;
        }
    }
    if (0 <= selected) {
        revisionList.setSelectedIndex(selected);
    }
}
#end_block

#method_before
@Override
public BinaryResult apply(RevisionResource rsrc) throws ResourceNotFoundException, ResourceConflictException {
    Project.NameKey project = rsrc.getControl().getProject().getNameKey();
    boolean close = true;
    try {
        final Repository repo = repoManager.openRepository(project);
        try {
            final RevWalk rw = new RevWalk(repo);
            try {
                final RevCommit commit = rw.parseCommit(ObjectId.fromString(rsrc.getPatchSet().getRevision().get()));
                RevCommit[] parents = commit.getParents();
                if (parents.length > 1) {
                    throw new ResourceConflictException("Revision has more than 1 parent.");
                } else if (parents.length == 0) {
                    throw new ResourceConflictException("Revision has no parent.");
                }
                final RevCommit base = parents[0];
                rw.parseBody(base);
                BinaryResult bin = new BinaryResult() {

                    @Override
                    public void writeTo(OutputStream out) throws IOException {
                        out.write(formatEmailHeader(commit).getBytes(UTF_8));
                        DiffFormatter fmt = new DiffFormatter(out);
                        fmt.setRepository(repo);
                        fmt.format(base.getTree(), commit.getTree());
                        fmt.flush();
                    }

                    @Override
                    public void close() throws IOException {
                        rw.release();
                        repo.close();
                    }
                }.setContentType("application/mbox").base64();
                if (download) {
                    bin.setAttachmentName(String.format("%s.diff.base64", rw.getObjectReader().abbreviate(commit, 8).name()));
                }
                close = false;
                return bin;
            } finally {
                if (close) {
                    rw.release();
                }
            }
        } finally {
            if (close) {
                repo.close();
            }
        }
    } catch (IOException e) {
        throw new ResourceNotFoundException();
    }
}
#method_after
@Override
public BinaryResult apply(RevisionResource rsrc) throws ResourceNotFoundException, ResourceConflictException {
    Project.NameKey project = rsrc.getControl().getProject().getNameKey();
    boolean close = true;
    try {
        final Repository repo = repoManager.openRepository(project);
        try {
            final RevWalk rw = new RevWalk(repo);
            try {
                final RevCommit commit = rw.parseCommit(ObjectId.fromString(rsrc.getPatchSet().getRevision().get()));
                RevCommit[] parents = commit.getParents();
                if (parents.length > 1) {
                    throw new ResourceConflictException("Revision has more than 1 parent.");
                } else if (parents.length == 0) {
                    throw new ResourceConflictException("Revision has no parent.");
                }
                final RevCommit base = parents[0];
                rw.parseBody(base);
                BinaryResult bin = new BinaryResult() {

                    @Override
                    public void writeTo(OutputStream out) throws IOException {
                        if (zip) {
                            ZipOutputStream zos = new ZipOutputStream(out);
                            ZipEntry e = new ZipEntry(fileName(rw, commit));
                            e.setTime(commit.getCommitTime() * 1000L);
                            zos.putNextEntry(e);
                            format(zos);
                            zos.closeEntry();
                            zos.finish();
                        } else {
                            format(out);
                        }
                    }

                    private void format(OutputStream out) throws IOException {
                        out.write(formatEmailHeader(commit).getBytes(UTF_8));
                        DiffFormatter fmt = new DiffFormatter(out);
                        fmt.setRepository(repo);
                        fmt.format(base.getTree(), commit.getTree());
                        fmt.flush();
                    }

                    @Override
                    public void close() throws IOException {
                        rw.release();
                        repo.close();
                    }
                };
                if (zip) {
                    bin.disableGzip().setContentType("application/zip").setAttachmentName(fileName(rw, commit) + ".zip");
                } else {
                    bin.base64().setContentType("application/mbox").setAttachmentName(download ? fileName(rw, commit) + ".base64" : null);
                }
                close = false;
                return bin;
            } finally {
                if (close) {
                    rw.release();
                }
            }
        } finally {
            if (close) {
                repo.close();
            }
        }
    } catch (IOException e) {
        throw new ResourceNotFoundException();
    }
}
#end_block

#method_before
private ViewData view(RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return new ViewData(p.get(0), view);
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return new ViewData(null, core);
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        Map.Entry<String, RestView<RestResource>> entry = Iterables.getOnlyElement(r.entrySet());
        return new ViewData(entry.getKey(), entry.getValue());
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#method_after
private ViewData view(RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return new ViewData(p.get(0), view);
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return new ViewData(null, core);
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        Map.Entry<String, RestView<RestResource>> entry = Iterables.getOnlyElement(r.entrySet());
        return new ViewData(entry.getKey(), entry.getValue());
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: %s", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#end_block

#method_before
@UiHandler("editCommitMessage")
void onEditMessage(ClickEvent e) {
    if (Gerrit.isSignedIn()) {
        editCommitMessageAction.onEdit();
    } else {
        Gerrit.doSignIn(getToken());
    }
}
#method_after
@UiHandler("editMessage")
void onEditMessage(ClickEvent e) {
    editMessageAction.onEdit();
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    initEditCommitMessageAction();
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction();
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "edit_commit_message").to(EditCommitMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#end_block

#method_before
static void invoke(ChangeInfo change, ActionInfo action, RestApi api) {
    final Change.Id id = change.legacy_id();
    AsyncCallback<JavaScriptObject> cb = new GerritCallback<JavaScriptObject>() {

        @Override
        public void onSuccess(JavaScriptObject msg) {
            if (msg instanceof NativeString) {
                NativeString str = (NativeString) msg;
                if (str != null && !str.asString().isEmpty()) {
                    Window.alert(str.asString());
                }
            }
            Gerrit.display(PageLinks.toChange2(id));
        }
    };
    if ("PUT".equalsIgnoreCase(action.method())) {
        api.put(JavaScriptObject.createObject(), cb);
    } else if ("DELETE".equalsIgnoreCase(action.method())) {
        api.delete(cb);
    } else {
        api.post(JavaScriptObject.createObject(), cb);
    }
}
#method_after
static void invoke(ChangeInfo change, ActionInfo action, RestApi api) {
    final Change.Id id = change.legacy_id();
    AsyncCallback<JavaScriptObject> cb = new GerritCallback<JavaScriptObject>() {

        @Override
        public void onSuccess(JavaScriptObject msg) {
            if (NativeString.is(msg)) {
                NativeString str = (NativeString) msg;
                if (!str.asString().isEmpty()) {
                    Window.alert(str.asString());
                }
            }
            Gerrit.display(PageLinks.toChange2(id));
        }
    };
    if ("PUT".equalsIgnoreCase(action.method())) {
        api.put(JavaScriptObject.createObject(), cb);
    } else if ("DELETE".equalsIgnoreCase(action.method())) {
        api.delete(cb);
    } else {
        api.post(JavaScriptObject.createObject(), cb);
    }
}
#end_block

#method_before
private void removeUI() {
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    clearRange();
    setRangeHighlight(false);
    Side side = comment.side();
    removeFromParent();
    if (!getCommentInfo().has_line()) {
        parent.removeFileCommentBox(this, side);
        return;
    }
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    parent.removeDraft(this, side, comment.line() - 1);
    getCm().focus();
    getSelfWidgetWrapper().getWidget().clear();
    getGutterWrapper().remove();
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            resizePaddingWidget();
        }
    });
}
#method_after
private void removeUI() {
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    clearRange();
    setRangeHighlight(false);
    removeFromParent();
    if (!getCommentInfo().has_line()) {
        parent.removeFileCommentBox(this);
        return;
    }
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    parent.removeDraft(this, comment.line() - 1);
    getCm().focus();
    getSelfWidgetWrapper().getWidget().clear();
    getGutterWrapper().remove();
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            resizePaddingWidget();
        }
    });
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    if (base != null) {
        CommentApi.comments(base, group.add(getCommentCallback(false)));
    }
    CommentApi.comments(revision, group.add(getCommentCallback(false)));
    if (Gerrit.isSignedIn()) {
        if (base != null) {
            CommentApi.drafts(base, group.add(getCommentCallback(true)));
        }
        CommentApi.drafts(revision, group.add(getCommentCallback(true)));
    } else {
        drafts = JsArray.createArray().cast();
    }
    ConfigInfoCache.get(revision.getParentKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide2.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            DiffInfo diffInfo = diff;
            diff = null;
            display(diffInfo);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    if (base != null) {
        CommentApi.comments(base, group.add(getCommentCallback(DisplaySide.A, false)));
    }
    CommentApi.comments(revision, group.add(getCommentCallback(DisplaySide.B, false)));
    if (Gerrit.isSignedIn()) {
        if (base != null) {
            CommentApi.drafts(base, group.add(getCommentCallback(DisplaySide.A, true)));
        }
        CommentApi.drafts(revision, group.add(getCommentCallback(DisplaySide.B, true)));
    }
    ConfigInfoCache.get(revision.getParentKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide2.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            DiffInfo diffInfo = diff;
            diff = null;
            display(diffInfo);
        }
    }));
}
#end_block

#method_before
private GerritCallback<NativeMap<JsArray<CommentInfo>>> getCommentCallback(final boolean toDrafts) {
    return new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            JsArray<CommentInfo> in = result.get(path);
            if (in != null) {
                addAllToCommentList(in, toDrafts);
            }
        }
    };
}
#method_after
private GerritCallback<NativeMap<JsArray<CommentInfo>>> getCommentCallback(final DisplaySide side, final boolean toDrafts) {
    return new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            JsArray<CommentInfo> in = result.get(path);
            if (in != null) {
                if (toDrafts) {
                    if (side == DisplaySide.A) {
                        draftsBase = in;
                    } else {
                        draftsRevision = in;
                    }
                } else {
                    if (side == DisplaySide.A) {
                        publishedBase = in;
                    } else {
                        publishedRevision = in;
                    }
                }
            }
        }
    };
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (publishedBase != null || publishedRevision != null) {
        publishedMap = new HashMap<String, PublishedBox>();
    }
    if (publishedBase != null) {
        renderPublished(publishedBase);
    }
    if (publishedRevision != null) {
        renderPublished(publishedRevision);
    }
    if (draftsBase != null) {
        renderDrafts(draftsBase);
    }
    if (draftsRevision != null) {
        renderDrafts(draftsRevision);
    }
    renderSkips();
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#end_block

#method_before
CommentInfo createReply(CommentInfo replyTo) {
    if (!replyTo.has_line()) {
        return CommentInfo.createFile(path, replyTo.side(), replyTo.id(), null);
    } else {
        return CommentInfo.createRange(path, replyTo.side(), replyTo.line(), replyTo.id(), null, null);
    }
}
#method_after
CommentInfo createReply(CommentInfo replyTo) {
    if (!replyTo.has_line() && replyTo.range() == null) {
        return CommentInfo.createFile(path, replyTo.side(), replyTo.id(), null);
    } else {
        return CommentInfo.createRange(path, replyTo.side(), replyTo.line(), replyTo.id(), null, replyTo.range());
    }
}
#end_block

#method_before
DraftBox addDraftBox(CommentInfo info) {
    Side side = info.side();
    CodeMirror cm = getCmFromSide(info.side());
    final DraftBox box = new DraftBox(this, cm, commentLinkProcessor, getPatchSetIdFromSide(side), info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#method_after
DraftBox addDraftBox(CommentInfo info, DisplaySide side) {
    CodeMirror cm = getCmFromSide(side);
    final DraftBox box = new DraftBox(this, cm, side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    DiffChunkInfo myChunk = getDiffChunk(mySide, line);
    DiffChunkInfo otherChunk = getDiffChunk(getSideFromCm(other), lineToPad);
    PaddingManager otherManager;
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        otherManager = linePaddingManagerMap.get(otherHandle);
    } else {
        otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
    }
    if ((myChunk == null && otherChunk == null) || (myChunk != null && otherChunk != null)) {
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (otherChunk == null) {
        box.setDiffChunkInfo(myChunk);
    }
    box.setGutterWrapper(diffTable.sidePanel.addGutter(cm, info.line() - 1, box instanceof DraftBox ? SidePanel.GutterType.DRAFT : SidePanel.GutterType.COMMENT));
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    DisplaySide side = box.getSide();
    CodeMirror cm = getCmFromSide(side);
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(side, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    DiffChunkInfo myChunk = getDiffChunk(side, line);
    DiffChunkInfo otherChunk = getDiffChunk(getSideFromCm(other), lineToPad);
    PaddingManager otherManager;
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        otherManager = linePaddingManagerMap.get(otherHandle);
    } else {
        otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
    }
    if ((myChunk == null && otherChunk == null) || (myChunk != null && otherChunk != null)) {
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (otherChunk == null) {
        box.setDiffChunkInfo(myChunk);
    }
    box.setGutterWrapper(diffTable.sidePanel.addGutter(cm, info.line() - 1, box instanceof DraftBox ? SidePanel.GutterType.DRAFT : SidePanel.GutterType.COMMENT));
    return box;
}
#end_block

#method_before
void removeDraft(DraftBox box, Side side, int line) {
    LineHandle handle = getCmFromSide(side).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (lineLastPublishedBoxMap.containsKey(handle)) {
        lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle));
    }
}
#method_after
void removeDraft(DraftBox box, int line) {
    LineHandle handle = getCmFromSide(box.getSide()).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (lineLastPublishedBoxMap.containsKey(handle)) {
        lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle));
    }
}
#end_block

#method_before
void addFileCommentBox(CommentBox box, Side side) {
    diffTable.addFileCommentBox(box, side);
}
#method_after
void addFileCommentBox(CommentBox box) {
    diffTable.addFileCommentBox(box);
}
#end_block

#method_before
void removeFileCommentBox(DraftBox box, Side side) {
    diffTable.onRemoveDraftBox(box, side);
}
#method_after
void removeFileCommentBox(DraftBox box) {
    diffTable.onRemoveDraftBox(box);
}
#end_block

#method_before
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, cm, commentLinkProcessor, getPatchSetIdFromSide(side), info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            continue;
        }
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderPublished(JsArray<CommentInfo> published) {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        DisplaySide side;
        if (info.side() == Side.PARENT) {
            if (base != null) {
                continue;
            }
            side = DisplaySide.A;
        } else {
            side = published == publishedBase ? DisplaySide.A : DisplaySide.B;
        }
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, cm, side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box);
            continue;
        }
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), commentLinkProcessor, getPatchSetIdFromSide(side), info);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            continue;
        }
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderDrafts(JsArray<CommentInfo> drafts) {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        DisplaySide side;
        if (info.side() == Side.PARENT) {
            if (base != null) {
                continue;
            }
            side = DisplaySide.A;
        } else {
            side = drafts == draftsBase ? DisplaySide.A : DisplaySide.B;
        }
        DraftBox box = new DraftBox(this, getCmFromSide(side), side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
        if (publishedBase != null || publishedRevision != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box);
            continue;
        }
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private PatchSet.Id getPatchSetIdFromSide(Side side) {
    return side == Side.PARENT && base != null ? base : revision;
}
#method_after
private PatchSet.Id getPatchSetIdFromSide(DisplaySide side) {
    return side == DisplaySide.A && base != null ? base : revision;
}
#end_block

#method_before
private CodeMirror getCmFromSide(Side side) {
    return side == Side.PARENT ? cmA : cmB;
}
#method_after
private CodeMirror getCmFromSide(DisplaySide side) {
    return side == DisplaySide.A ? cmA : cmB;
}
#end_block

#method_before
private Side getSideFromCm(CodeMirror cm) {
    return cm == cmA ? Side.PARENT : Side.REVISION;
}
#method_after
private DisplaySide getSideFromCm(CodeMirror cm) {
    return cm == cmA ? DisplaySide.A : DisplaySide.B;
}
#end_block

#method_before
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, int line, String gutter, NativeEvent clickEvent) {
            instance.setCursor(LineCharacter.create(line));
            instance.setActiveLine(instance.getLineHandle(line));
            insertNewDraft(instance).run();
        }
    };
}
#method_after
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, int line, String gutter, NativeEvent clickEvent) {
            if (!(cm.hasActiveLine() && instance.getLineNumber(cm.getActiveLine()) == line)) {
                instance.setCursor(LineCharacter.create(line));
                instance.setActiveLine(cm.getLineHandle(line));
            }
            insertNewDraft(cm).run();
        }
    };
}
#end_block

#method_before
private Runnable insertNewDraft(final CodeMirror cm) {
    if (!Gerrit.isSignedIn()) {
        return new Runnable() {

            @Override
            public void run() {
                Gerrit.doSignIn(getToken());
            }
        };
    }
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            if (box == null) {
                lineActiveBoxMap.put(handle, addDraftBox(CommentInfo.createRange(path, getSideFromCm(cm), line + 1, null, null, cm.somethingSelected() ? CommentRange.fromFromTo(cm.getSelectedRange()) : null)));
            } else if (box instanceof DraftBox) {
                ((DraftBox) box).setEdit(true);
            } else {
                ((PublishedBox) box).doReply();
            }
        }
    };
}
#method_after
private Runnable insertNewDraft(final CodeMirror cm) {
    if (!Gerrit.isSignedIn()) {
        return new Runnable() {

            @Override
            public void run() {
                Gerrit.doSignIn(getToken());
            }
        };
    }
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            FromTo fromTo = cm.getSelectedRange();
            if (cm.somethingSelected()) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line, fromTo.getTo().getLine() == line ? fromTo : null));
            } else if (box == null) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line, null));
            } else if (box instanceof DraftBox) {
                ((DraftBox) box).setEdit(true);
            } else {
                ((PublishedBox) box).doReply();
            }
        }
    };
}
#end_block

#method_before
private DiffChunkInfo getDiffChunk(Side side, int line) {
    for (DiffChunkInfo info : diffChunks) {
        if (info.getSide() == side && info.getStart() <= line && line <= info.getEnd()) {
            return info;
        }
    }
    return null;
}
#method_after
private DiffChunkInfo getDiffChunk(DisplaySide side, int line) {
    for (DiffChunkInfo info : diffChunks) {
        if (info.getSide() == side && info.getStart() <= line && line <= info.getEnd()) {
            return info;
        }
    }
    return null;
}
#end_block

#method_before
void resizePaddingOnOtherSide(Side mySide, int line) {
    CodeMirror cm = getCmFromSide(mySide);
    LineHandle handle = cm.getLineHandle(line);
    final LinePaddingWidgetWrapper otherWrapper = linePaddingOnOtherSideMap.get(handle);
    double myChunkHeight = cm.heightAtLine(line + 1) - cm.heightAtLine(line - otherWrapper.getChunkLength() + 1);
    Element otherPadding = otherWrapper.getElement();
    int otherPaddingHeight = otherPadding.getOffsetHeight();
    CodeMirror otherCm = otherCm(cm);
    int otherLine = otherWrapper.getOtherLine();
    LineHandle other = otherCm.getLineHandle(otherLine);
    if (linePaddingOnOtherSideMap.containsKey(other)) {
        LinePaddingWidgetWrapper myWrapper = linePaddingOnOtherSideMap.get(other);
        Element myPadding = linePaddingOnOtherSideMap.get(other).getElement();
        int myPaddingHeight = myPadding.getOffsetHeight();
        myChunkHeight -= myPaddingHeight;
        double otherChunkHeight = otherCm.heightAtLine(otherLine + 1) - otherCm.heightAtLine(otherLine - myWrapper.getChunkLength() + 1) - otherPaddingHeight;
        double delta = myChunkHeight - otherChunkHeight;
        if (delta > 0) {
            if (myPaddingHeight != 0) {
                setHeightInPx(myPadding, 0);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != delta) {
                setHeightInPx(otherPadding, delta);
                otherWrapper.getWidget().changed();
            }
        } else {
            if (myPaddingHeight != -delta) {
                setHeightInPx(myPadding, -delta);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != 0) {
                setHeightInPx(otherPadding, 0);
                otherWrapper.getWidget().changed();
            }
        }
    } else if (otherPaddingHeight != myChunkHeight) {
        setHeightInPx(otherPadding, myChunkHeight);
        otherWrapper.getWidget().changed();
    }
}
#method_after
void resizePaddingOnOtherSide(DisplaySide mySide, int line) {
    CodeMirror cm = getCmFromSide(mySide);
    LineHandle handle = cm.getLineHandle(line);
    final LinePaddingWidgetWrapper otherWrapper = linePaddingOnOtherSideMap.get(handle);
    double myChunkHeight = cm.heightAtLine(line + 1) - cm.heightAtLine(line - otherWrapper.getChunkLength() + 1);
    Element otherPadding = otherWrapper.getElement();
    int otherPaddingHeight = otherPadding.getOffsetHeight();
    CodeMirror otherCm = otherCm(cm);
    int otherLine = otherWrapper.getOtherLine();
    LineHandle other = otherCm.getLineHandle(otherLine);
    if (linePaddingOnOtherSideMap.containsKey(other)) {
        LinePaddingWidgetWrapper myWrapper = linePaddingOnOtherSideMap.get(other);
        Element myPadding = linePaddingOnOtherSideMap.get(other).getElement();
        int myPaddingHeight = myPadding.getOffsetHeight();
        myChunkHeight -= myPaddingHeight;
        double otherChunkHeight = otherCm.heightAtLine(otherLine + 1) - otherCm.heightAtLine(otherLine - myWrapper.getChunkLength() + 1) - otherPaddingHeight;
        double delta = myChunkHeight - otherChunkHeight;
        if (delta > 0) {
            if (myPaddingHeight != 0) {
                setHeightInPx(myPadding, 0);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != delta) {
                setHeightInPx(otherPadding, delta);
                otherWrapper.getWidget().changed();
            }
        } else {
            if (myPaddingHeight != -delta) {
                setHeightInPx(myPadding, -delta);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != 0) {
                setHeightInPx(otherPadding, 0);
                otherWrapper.getWidget().changed();
            }
        }
    } else if (otherPaddingHeight != myChunkHeight) {
        setHeightInPx(otherPadding, myChunkHeight);
        otherWrapper.getWidget().changed();
    }
}
#end_block

#method_before
private RenderLineHandler resizeLinePadding(final Side side) {
    return new RenderLineHandler() {

        @Override
        public void handle(final CodeMirror instance, final LineHandle handle, Element element) {
            if (lineActiveBoxMap.containsKey(handle)) {
                lineActiveBoxMap.get(handle).resizePaddingWidget();
            }
            if (linePaddingOnOtherSideMap.containsKey(handle)) {
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        resizePaddingOnOtherSide(side, instance.getLineNumber(handle));
                    }
                });
            }
        }
    };
}
#method_after
private RenderLineHandler resizeLinePadding(final DisplaySide side) {
    return new RenderLineHandler() {

        @Override
        public void handle(final CodeMirror instance, final LineHandle handle, Element element) {
            if (lineActiveBoxMap.containsKey(handle)) {
                lineActiveBoxMap.get(handle).resizePaddingWidget();
            }
            if (linePaddingOnOtherSideMap.containsKey(handle)) {
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        resizePaddingOnOtherSide(side, instance.getLineNumber(handle));
                    }
                });
            }
        }
    };
}
#end_block

#method_before
Side getSide() {
    return side;
}
#method_after
DisplaySide getSide() {
    return side;
}
#end_block

#method_before
public static FromTo create(LineCharacter from, LineCharacter to) {
    FromTo fromTo = createObject().cast();
    fromTo.setFrom(from);
    fromTo.setTo(to);
    return fromTo;
}
#method_after
public static FromTo create(CommentRange range) {
    return create(LineCharacter.create(range.start_line() - 1, range.start_character()), LineCharacter.create(range.end_line() - 1, range.end_character()));
}
#end_block

#method_before
DraftBox addReplyBox() {
    DraftBox box = parent.addDraftBox(parent.createReply(comment));
    registerReplyBox(box);
    return box;
}
#method_after
DraftBox addReplyBox() {
    DraftBox box = parent.addDraftBox(parent.createReply(comment), getSide());
    registerReplyBox(box);
    return box;
}
#end_block

#method_before
void doReply() {
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        DraftBox box = addReplyBox();
        if (!getCommentInfo().has_line()) {
            parent.addFileCommentBox(box, comment.side());
        }
    } else {
        openReplyBox();
    }
}
#method_after
void doReply() {
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        DraftBox box = addReplyBox();
        if (!getCommentInfo().has_line()) {
            parent.addFileCommentBox(box);
        }
    } else {
        openReplyBox();
    }
}
#end_block

#method_before
@UiHandler("done")
void onReplyDone(ClickEvent e) {
    e.stopPropagation();
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        done.setEnabled(false);
        CommentInput input = CommentInput.create(parent.createReply(comment));
        input.setMessage(PatchUtil.C.cannedReplyDone());
        CommentApi.createDraft(psId, input, new GerritCallback<CommentInfo>() {

            @Override
            public void onSuccess(CommentInfo result) {
                done.setEnabled(true);
                setOpen(false);
                DraftBox box = parent.addDraftBox(result);
                registerReplyBox(box);
                if (!getCommentInfo().has_line()) {
                    parent.addFileCommentBox(box, comment.side());
                }
            }
        });
    } else {
        openReplyBox();
        setOpen(false);
    }
}
#method_after
@UiHandler("done")
void onReplyDone(ClickEvent e) {
    e.stopPropagation();
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        done.setEnabled(false);
        CommentInput input = CommentInput.create(parent.createReply(comment));
        input.setMessage(PatchUtil.C.cannedReplyDone());
        CommentApi.createDraft(psId, input, new GerritCallback<CommentInfo>() {

            @Override
            public void onSuccess(CommentInfo result) {
                done.setEnabled(true);
                setOpen(false);
                DraftBox box = parent.addDraftBox(result, getSide());
                registerReplyBox(box);
                if (!getCommentInfo().has_line()) {
                    parent.addFileCommentBox(box);
                }
            }
        });
    } else {
        openReplyBox();
        setOpen(false);
    }
}
#end_block

#method_before
public static CommentRange create(int sl, int sc, int el, int ec) {
    CommentRange r = createObject().cast();
    r.set(sl, sc, el, ec);
    return r;
}
#method_after
public static CommentRange create(FromTo fromTo) {
    if (fromTo == null) {
        return null;
    }
    LineCharacter from = fromTo.getFrom();
    LineCharacter to = fromTo.getTo();
    return create(from.getLine() + 1, from.getCh(), to.getLine() + 1, to.getCh());
}
#end_block

#method_before
private FileCommentPanel getPanelFromSide(Side side) {
    return side == Side.PARENT ? fileCommentPanelA : fileCommentPanelB;
}
#method_after
private FileCommentPanel getPanelFromSide(DisplaySide side) {
    return side == DisplaySide.A ? fileCommentPanelA : fileCommentPanelB;
}
#end_block

#method_before
void createOrEditFileComment(Side side) {
    getPanelFromSide(side).createOrEditFileComment();
    updateFileCommentVisibility(false);
}
#method_after
void createOrEditFileComment(DisplaySide side) {
    getPanelFromSide(side).createOrEditFileComment();
    updateFileCommentVisibility(false);
}
#end_block

#method_before
void addFileCommentBox(CommentBox box, Side side) {
    getPanelFromSide(side).addFileComment(box);
}
#method_after
void addFileCommentBox(CommentBox box) {
    getPanelFromSide(box.getSide()).addFileComment(box);
}
#end_block

#method_before
void onRemoveDraftBox(DraftBox box, Side side) {
    getPanelFromSide(side).onRemoveDraftBox(box);
}
#method_after
void onRemoveDraftBox(DraftBox box) {
    getPanelFromSide(box.getSide()).onRemoveDraftBox(box);
}
#end_block

#method_before
void resizePaddingWidget() {
    if (!getCommentInfo().has_line()) {
        return;
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            assert selfWidgetWrapper != null;
            selfWidgetWrapper.getWidget().changed();
            if (diffChunkInfo != null) {
                parent.resizePaddingOnOtherSide(getCommentInfo().side(), diffChunkInfo.getEnd());
            } else {
                assert widgetManager != null;
                widgetManager.resizePaddingWidget();
            }
        }
    });
}
#method_after
void resizePaddingWidget() {
    if (!getCommentInfo().has_line()) {
        return;
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            assert selfWidgetWrapper != null;
            selfWidgetWrapper.getWidget().changed();
            if (diffChunkInfo != null) {
                parent.resizePaddingOnOtherSide(side, diffChunkInfo.getEnd());
            } else {
                assert widgetManager != null;
                widgetManager.resizePaddingWidget();
            }
        }
    });
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    if (all && projectNames.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    if (all) {
        pushAllFactory.create(urlMatch).schedule(0, TimeUnit.SECONDS);
    } else {
        for (String name : projectNames) {
            Project.NameKey key = new Project.NameKey(name);
            if (projectCache.get(key) != null) {
                replication.scheduleFullSync(key, urlMatch);
            } else {
                throw new UnloggedFailure(1, "error: '" + name + "': not a Gerrit project");
            }
        }
    }
}
#method_after
@Override
protected void run() throws Failure {
    if (all && projectNames.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    ReplicationState state = new ReplicationState(ReplicationType.COMMAND, this);
    Future<?> future = null;
    if (all) {
        future = pushAllFactory.create(urlMatch, state).schedule(0, TimeUnit.SECONDS);
    } else {
        for (String name : projectNames) {
            Project.NameKey key = new Project.NameKey(name);
            if (projectCache.get(key) != null) {
                replication.scheduleFullSync(key, urlMatch, state);
            } else {
                writeStdErrSync("error: '" + name + "': not a Gerrit project");
            }
        }
        state.markAllPushTasksScheduled();
    }
    if (wait) {
        if (future != null) {
            try {
                future.get();
            } catch (InterruptedException e) {
                wrappedLog.error("Thread was interrupted while waiting for PushAll operation to finish", e, state);
                return;
            } catch (ExecutionException e) {
                wrappedLog.error("An exception was thrown in PushAll operation", e, state);
                return;
            }
        }
        if (state.hasPushTask()) {
            try {
                state.waitForReplication();
            } catch (InterruptedException e) {
                writeStdErrSync("We are interrupted while waiting replication to complete");
            }
        } else {
            writeStdOutSync("Nothing to replicate");
        }
    }
}
#end_block

#method_before
@Test
public void testList() throws Exception {
    Map<String, CapabilityInfo> m = injector.getInstance(ListCapabilities.class).apply(new ConfigResource());
    for (String id : GlobalCapability.getAllNames()) {
        assertTrue("contains " + id, m.containsKey(id));
        assertEquals(id, m.get(id).id);
        assertNotNull(id + " has name", m.get(id).name);
    }
    String pluginCapability = "gerrit-printHello";
    assertTrue("contains " + pluginCapability, m.containsKey(pluginCapability));
}
#method_after
@Test
public void testList() throws Exception {
    Map<String, CapabilityInfo> m = injector.getInstance(ListCapabilities.class).apply(new ConfigResource());
    for (String id : GlobalCapability.getAllNames()) {
        assertTrue("contains " + id, m.containsKey(id));
        assertEquals(id, m.get(id).id);
        assertNotNull(id + " has name", m.get(id).name);
    }
    String pluginCapability = "gerrit-printHello";
    assertTrue("contains " + pluginCapability, m.containsKey(pluginCapability));
    assertEquals(pluginCapability, m.get(pluginCapability).id);
    assertEquals("Print Hello", m.get(pluginCapability).name);
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        if (Strings.isNullOrEmpty(commandName)) {
            StringWriter msg = new StringWriter();
            msg.write(usage());
            throw new UnloggedFailure(1, msg.toString());
        }
        final CommandProvider p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.getProvider().get();
        checkRequiresCapability(getName(), cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        if (Strings.isNullOrEmpty(commandName)) {
            StringWriter msg = new StringWriter();
            msg.write(usage());
            throw new UnloggedFailure(1, msg.toString());
        }
        final CommandProvider p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.getProvider().get();
        checkRequiresCapability(cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#end_block

#method_before
private void checkRequiresCapability(String baseName, Command cmd) throws UnloggedFailure {
    RequiresCapability rc = cmd.getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            // then it must be a plugin-owned capability
            if (!GlobalCapability.isCapability(rc.value())) {
                if (ctl.canPerform(String.format("%s-%s", baseName, rc.value()))) {
                    return;
                }
            }
            String msg = String.format("fatal: %s does not have \"%s\" capability.", user.getUserName(), rc.value());
            throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg);
        }
    }
}
#method_after
private void checkRequiresCapability(Command cmd) throws UnloggedFailure {
    RequiresCapability rc = cmd.getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        String capability = rc.value();
        if (cmd instanceof BaseCommand) {
            String pluginName = ((BaseCommand) cmd).getPluginName();
            if (pluginName != null && !"gerrit".equals(pluginName) && (rc.scope() == CapabilityScope.PLUGIN || rc.scope() == CapabilityScope.CONTEXT)) {
                capability = String.format("%s-%s", pluginName, rc.value());
            } else if (rc.scope() == CapabilityScope.PLUGIN) {
                log.error(String.format("Class %s uses @%s(scope=%s), but is not within a plugin", cmd.getClass().getName(), RequiresCapability.class.getSimpleName(), CapabilityScope.PLUGIN.name()));
                throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, "fatal: cannot check capability");
            }
        }
        if (!ctl.canPerform(capability) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", user.getUserName(), capability);
            throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg);
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    maxObjectSizeLimit = rc.getLong(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, 0);
}
#end_block

#method_before
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        // because it might be provided by plugin
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#method_after
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#end_block

#method_before
private static LabelValue parseLabelValue(String src) {
    List<String> parts = ImmutableList.copyOf(Splitter.on(CharMatcher.WHITESPACE).omitEmptyStrings().limit(2).split(src));
    if (parts.isEmpty()) {
        throw new IllegalArgumentException("empty value");
    }
    return new LabelValue(Shorts.checkedCast(PermissionRule.parseInt(parts.get(0))), parts.get(1));
}
#method_after
private static LabelValue parseLabelValue(String src) {
    List<String> parts = ImmutableList.copyOf(Splitter.on(CharMatcher.WHITESPACE).omitEmptyStrings().limit(2).split(src));
    if (parts.isEmpty()) {
        throw new IllegalArgumentException("empty value");
    }
    String valueText = parts.size() > 1 ? parts.get(1) : "";
    return new LabelValue(Shorts.checkedCast(PermissionRule.parseInt(parts.get(0))), valueText);
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), Project.InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), Project.InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), Project.InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), defaultStateValue);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
private void saveAccessSections(Config rc, Set<AccountGroup.UUID> keepGroups) {
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            // because it might be provided by plugin
            if (!have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = Permission.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
}
#method_after
private void saveAccessSections(Config rc, Set<AccountGroup.UUID> keepGroups) {
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (!have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = Permission.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
}
#end_block

#method_before
@Override
public Response<CommentInfo> apply(RevisionResource rsrc, Input in) throws AuthException, BadRequestException, ResourceConflictException, OrmException {
    if (Strings.isNullOrEmpty(in.path)) {
        throw new BadRequestException("path must be non-empty");
    } else if (in.message == null || in.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (in.line != null && in.line <= 0) {
        throw new BadRequestException("line must be > 0");
    }
    PatchLineComment c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), ChangeUtil.messageUUID(db.get())), in.line != null ? in.line : 0, rsrc.getAccountId(), Url.decode(in.inReplyTo));
    c.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    c.setMessage(in.message.trim());
    c.setRange(in.range);
    db.get().patchComments().insert(Collections.singleton(c));
    return Response.created(new CommentInfo(c, null));
}
#method_after
@Override
public Response<CommentInfo> apply(RevisionResource rsrc, Input in) throws AuthException, BadRequestException, ResourceConflictException, OrmException {
    if (Strings.isNullOrEmpty(in.path)) {
        throw new BadRequestException("path must be non-empty");
    } else if (in.message == null || in.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (in.line != null && in.line <= 0) {
        throw new BadRequestException("line must be > 0");
    } else if (in.line != null && in.range != null && in.line != in.range.getEndLine()) {
        throw new BadRequestException("range endLine must be on the same line as the comment");
    }
    int line = in.line != null ? in.line : in.range != null ? in.range.getEndLine() : 0;
    PatchLineComment c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), ChangeUtil.messageUUID(db.get())), line, rsrc.getAccountId(), Url.decode(in.inReplyTo));
    c.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    c.setMessage(in.message.trim());
    c.setRange(in.range);
    db.get().patchComments().insert(Collections.singleton(c));
    return Response.created(new CommentInfo(c, null));
}
#end_block

#method_before
@Override
public Object apply(DraftResource rsrc, Input in) throws AuthException, BadRequestException, ResourceConflictException, OrmException {
    PatchLineComment c = rsrc.getComment();
    if (in == null || in.message == null || in.message.trim().isEmpty()) {
        return delete.get().apply(rsrc, null);
    } else if (in.kind != null && !"gerritcodereview#comment".equals(in.kind)) {
        throw new BadRequestException("expected kind gerritcodereview#comment");
    } else if (in.id != null && !rsrc.getId().equals(in.id)) {
        throw new BadRequestException("id must match URL");
    } else if (in.line != null && in.line < 0) {
        throw new BadRequestException("line must be >= 0");
    }
    if (in.path != null && !in.path.equals(c.getKey().getParentKey().getFileName())) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        db.get().patchComments().delete(Collections.singleton(c));
        c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), c.getKey().get()), c.getLine(), rsrc.getAuthorId(), c.getParentUuid());
        db.get().patchComments().insert(Collections.singleton(update(c, in)));
    } else {
        db.get().patchComments().update(Collections.singleton(update(c, in)));
    }
    return new CommentInfo(c, null);
}
#method_after
@Override
public Object apply(DraftResource rsrc, Input in) throws AuthException, BadRequestException, ResourceConflictException, OrmException {
    PatchLineComment c = rsrc.getComment();
    if (in == null || in.message == null || in.message.trim().isEmpty()) {
        return delete.get().apply(rsrc, null);
    } else if (in.kind != null && !"gerritcodereview#comment".equals(in.kind)) {
        throw new BadRequestException("expected kind gerritcodereview#comment");
    } else if (in.id != null && !rsrc.getId().equals(in.id)) {
        throw new BadRequestException("id must match URL");
    } else if (in.line != null && in.line < 0) {
        throw new BadRequestException("line must be >= 0");
    } else if (in.line != null && in.range != null && in.line != in.range.getEndLine()) {
        throw new BadRequestException("range endLine must be on the same line as the comment");
    }
    if (in.path != null && !in.path.equals(c.getKey().getParentKey().getFileName())) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        db.get().patchComments().delete(Collections.singleton(c));
        c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), c.getKey().get()), c.getLine(), rsrc.getAuthorId(), c.getParentUuid());
        db.get().patchComments().insert(Collections.singleton(update(c, in)));
    } else {
        db.get().patchComments().update(Collections.singleton(update(c, in)));
    }
    return new CommentInfo(c, null);
}
#end_block

#method_before
private PatchLineComment update(PatchLineComment e, Input in) {
    if (in.side != null) {
        e.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    }
    if (in.line != null) {
        e.setLine(in.line);
    }
    if (in.inReplyTo != null) {
        e.setParentUuid(Url.decode(in.inReplyTo));
    }
    e.setMessage(in.message.trim());
    e.setRange(in.range);
    e.updated();
    return e;
}
#method_after
private PatchLineComment update(PatchLineComment e, Input in) {
    if (in.side != null) {
        e.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    }
    if (in.inReplyTo != null) {
        e.setParentUuid(Url.decode(in.inReplyTo));
    }
    e.setMessage(in.message.trim());
    if (in.range != null || in.line != null) {
        e.setRange(in.range);
        e.setLine(in.range != null ? in.range.getEndLine() : in.line);
    }
    e.updated();
    return e;
}
#end_block

#method_before
@Override
public PatchLineComment call() throws NoSuchChangeException, OrmException {
    if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
        throw new IllegalStateException("Comment published");
    }
    final Patch.Key patchKey = comment.getKey().getParentKey();
    final PatchSet.Id patchSetId = patchKey.getParentKey();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    db.changes().beginTransaction(changeId);
    try {
        changeControlFactory.validateFor(changeId);
        if (db.patchSets().get(patchSetId) == null) {
            throw new NoSuchChangeException(changeId);
        }
        final Account.Id me = currentUser.getAccountId();
        if (comment.getKey().get() == null) {
            if (comment.getLine() < 0) {
                throw new IllegalStateException("Comment line must be >= 0, not " + comment.getLine());
            }
            if (comment.getParentUuid() != null) {
                final PatchLineComment parent = db.patchComments().get(new PatchLineComment.Key(patchKey, comment.getParentUuid()));
                if (parent == null || parent.getSide() != comment.getSide()) {
                    throw new IllegalStateException("Parent comment must be on same side");
                }
            }
            final PatchLineComment nc = new PatchLineComment(new PatchLineComment.Key(patchKey, ChangeUtil.messageUUID(db)), comment.getLine(), me, comment.getParentUuid());
            nc.setSide(comment.getSide());
            nc.setMessage(comment.getMessage());
            nc.setRange(comment.getRange());
            db.patchComments().insert(Collections.singleton(nc));
            db.commit();
            return nc;
        } else {
            if (!me.equals(comment.getAuthor())) {
                throw new NoSuchChangeException(changeId);
            }
            comment.updated();
            db.patchComments().update(Collections.singleton(comment));
            db.commit();
            return comment;
        }
    } finally {
        db.rollback();
    }
}
#method_after
@Override
public PatchLineComment call() throws NoSuchChangeException, OrmException {
    if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
        throw new IllegalStateException("Comment published");
    }
    final Patch.Key patchKey = comment.getKey().getParentKey();
    final PatchSet.Id patchSetId = patchKey.getParentKey();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    db.changes().beginTransaction(changeId);
    try {
        changeControlFactory.validateFor(changeId);
        if (db.patchSets().get(patchSetId) == null) {
            throw new NoSuchChangeException(changeId);
        }
        final Account.Id me = currentUser.getAccountId();
        if (comment.getKey().get() == null) {
            if (comment.getLine() < 0) {
                throw new IllegalStateException("Comment line must be >= 0, not " + comment.getLine());
            }
            if (comment.getParentUuid() != null) {
                final PatchLineComment parent = db.patchComments().get(new PatchLineComment.Key(patchKey, comment.getParentUuid()));
                if (parent == null || parent.getSide() != comment.getSide()) {
                    throw new IllegalStateException("Parent comment must be on same side");
                }
            }
            if (comment.getRange() != null && comment.getLine() != comment.getRange().getEndLine()) {
                throw new IllegalStateException("Range endLine must be on the same line as the comment");
            }
            final PatchLineComment nc = new PatchLineComment(new PatchLineComment.Key(patchKey, ChangeUtil.messageUUID(db)), comment.getLine(), me, comment.getParentUuid());
            nc.setSide(comment.getSide());
            nc.setMessage(comment.getMessage());
            nc.setRange(comment.getRange());
            db.patchComments().insert(Collections.singleton(nc));
            db.commit();
            return nc;
        } else {
            if (!me.equals(comment.getAuthor())) {
                throw new NoSuchChangeException(changeId);
            }
            comment.updated();
            db.patchComments().update(Collections.singleton(comment));
            db.commit();
            return comment;
        }
    } finally {
        db.rollback();
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj instanceof CommentRange) {
        CommentRange other = (CommentRange) obj;
        return startLine == other.startLine && startCh == other.startCh && endLine == other.endLine && endCh == other.endCh;
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj instanceof CommentRange) {
        CommentRange other = (CommentRange) obj;
        return startLine == other.startLine && startCharacter == other.startCharacter && endLine == other.endLine && endCharacter == other.endCharacter;
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return "Range [startLine=" + startLine + ", startCh=" + startCh + ", endLine=" + endLine + ", endCh=" + endCh + "]";
}
#method_after
@Override
public String toString() {
    return "Range[startLine=" + startLine + ", startCharacter=" + startCharacter + ", endLine=" + endLine + ", endCharacter=" + endCharacter + "]";
}
#end_block

#method_before
public static CommentInfo createRange(String path, Side side, int line, String in_reply_to, String message, CommentRange range) {
    CommentInfo info = createFile(path, side, in_reply_to, message);
    info.setLine(line);
    info.setRange(range);
    return info;
}
#method_after
public static CommentInfo createRange(String path, Side side, int line, String in_reply_to, String message, CommentRange range) {
    CommentInfo info = createFile(path, side, in_reply_to, message);
    info.setRange(range);
    info.setLine(range == null ? line : range.end_line());
    return info;
}
#end_block

#method_before
public static CommentRange create(int sl, int sc, int el, int ec) {
    CommentRange r = createObject().cast();
    r.setStartLine(sl);
    r.setStartCh(sc);
    r.setEndLine(el);
    r.setEndCh(ec);
    return r;
}
#method_after
public static CommentRange create(int sl, int sc, int el, int ec) {
    CommentRange r = createObject().cast();
    r.set(sl, sc, el, ec);
    return r;
}
#end_block

#method_before
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create(repo);
        try {
            mergeValidators.validatePreMerge(commit, destProject, destBranch);
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMergedPatchSet(chg.getId(), ps.getId());
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
}
#method_after
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
}
#end_block

#method_before
public void validatePreMerge(CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch) throws MergeValidationException {
    List<MergeValidationListener> validators = Lists.newLinkedList();
    validators.add(new PluginMergeValidationListener(mergeValidationListeners));
    validators.add(new ProjectConfigValidator(repo, allProjectsName, db, ps, projectCache, identifiedUserFactory));
    for (MergeValidationListener validator : validators) {
        validator.onPreMerge(commit, destProject, destBranch);
    }
}
#method_after
public void validatePreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch, PatchSet.Id patchSetId) throws MergeValidationException {
    List<MergeValidationListener> validators = Lists.newLinkedList();
    validators.add(new PluginMergeValidationListener(mergeValidationListeners));
    validators.add(projectConfigValidatorFactory.create());
    for (MergeValidationListener validator : validators) {
        validator.onPreMerge(repo, commit, destProject, destBranch, patchSetId);
    }
}
#end_block

#method_before
@Override
public void onPreMerge(final CodeReviewCommit commit, final ProjectState destProject, final Branch.NameKey destBranch) throws MergeValidationException {
    if (GitRepositoryManager.REF_CONFIG.equals(destBranch.get())) {
        final Project.NameKey newParent;
        try {
            ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
            cfg.load(repo, commit);
            newParent = cfg.getProject().getParent(allProjectsName);
        } catch (Exception e) {
            throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION);
        }
        final Project.NameKey oldParent = destProject.getProject().getParent(allProjectsName);
        if (oldParent == null) {
            // update of the 'All-Projects' project
            if (newParent != null) {
                throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT);
            }
        } else {
            if (!oldParent.equals(newParent)) {
                final PatchSetApproval psa = getSubmitter(db, ps.getId());
                if (psa == null) {
                    throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
                }
                final IdentifiedUser submitter = identifiedUserFactory.create(psa.getAccountId());
                if (!submitter.getCapabilities().canAdministrateServer()) {
                    throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
                }
                if (projectCache.get(newParent) == null) {
                    throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND);
                }
            }
        }
    }
}
#method_after
@Override
public void onPreMerge(final Repository repo, final CodeReviewCommit commit, final ProjectState destProject, final Branch.NameKey destBranch, final PatchSet.Id patchSetId) throws MergeValidationException {
    if (GitRepositoryManager.REF_CONFIG.equals(destBranch.get())) {
        final Project.NameKey newParent;
        try {
            ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
            cfg.load(repo, commit);
            newParent = cfg.getProject().getParent(allProjectsName);
        } catch (Exception e) {
            throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION);
        }
        final Project.NameKey oldParent = destProject.getProject().getParent(allProjectsName);
        if (oldParent == null) {
            // update of the 'All-Projects' project
            if (newParent != null) {
                throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT);
            }
        } else {
            if (!oldParent.equals(newParent)) {
                final PatchSetApproval psa = getSubmitter(db, patchSetId);
                if (psa == null) {
                    throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
                }
                final IdentifiedUser submitter = identifiedUserFactory.create(psa.getAccountId());
                if (!submitter.getCapabilities().canAdministrateServer()) {
                    throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
                }
                if (projectCache.get(newParent) == null) {
                    throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void onPreMerge(CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch) throws MergeValidationException {
    for (MergeValidationListener validator : mergeValidationListeners) {
        validator.onPreMerge(commit, destProject, destBranch);
    }
}
#method_after
@Override
public void onPreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch, PatchSet.Id patchSetId) throws MergeValidationException {
    for (MergeValidationListener validator : mergeValidationListeners) {
        validator.onPreMerge(repo, commit, destProject, destBranch, patchSetId);
    }
}
#end_block

#method_before
public ChangeAttribute asChangeAttribute(final Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().toString();
    a.subject = change.getSubject();
    try {
        ChangeData cd = new ChangeData(change);
        a.commitMessage = cd.commitMessage(repoManager, db);
    } catch (OrmException e) {
    } catch (IOException e) {
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.status = change.getStatus();
    return a;
}
#method_after
public ChangeAttribute asChangeAttribute(final Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().toString();
    a.subject = change.getSubject();
    try {
        a.commitMessage = new ChangeData(change).commitMessage(repoManager, db);
    } catch (Exception e) {
        log.error("Error while getting full commit message for" + " change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.status = change.getStatus();
    return a;
}
#end_block

#method_before
void createOrEditFileComment() {
    if (boxes.isEmpty()) {
        CommentInfo info = CommentInfo.create(path, side, null, null, null);
        addFileComment(host.addDraftBox(info, false));
    } else {
        CommentBox box = boxes.get(boxes.size() - 1);
        if (box.isDraft()) {
            ((DraftBox) box).setEdit(true);
        } else {
            addFileComment(((PublishedBox) box).addReplyBox("", false));
        }
    }
}
#method_after
void createOrEditFileComment() {
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
        return;
    }
    if (boxes.isEmpty()) {
        CommentInfo info = CommentInfo.createFile(path, side, null, null);
        addFileComment(parent.addDraftBox(info));
    } else {
        CommentBox box = boxes.get(boxes.size() - 1);
        if (box instanceof DraftBox) {
            ((DraftBox) box).setEdit(true);
        } else {
            addFileComment(((PublishedBox) box).addReplyBox());
        }
    }
}
#end_block

#method_before
void addFileComment(CommentBox box) {
    boxes.add(box);
    table.updateVisibility(false);
    ((HTMLPanel) getWidget()).add(box);
    box.registerDiffTable(table);
}
#method_after
void addFileComment(CommentBox box) {
    boxes.add(box);
    body.add(box);
    table.updateFileCommentVisibility(false);
}
#end_block

#method_before
void onRemoveDraftBox(DraftBox box) {
    boxes.remove(box);
    table.updateVisibility(false);
}
#method_after
void onRemoveDraftBox(DraftBox box) {
    boxes.remove(box);
    table.updateFileCommentVisibility(false);
}
#end_block

#method_before
void createOrEditFileComment(Side side) {
    getPanelFromSide(side).createOrEditFileComment();
    patchSelectBoxA.toggleVisible(true);
}
#method_after
void createOrEditFileComment(Side side) {
    getPanelFromSide(side).createOrEditFileComment();
    updateFileCommentVisibility(false);
}
#end_block

#method_before
private void expandText() {
    double cols = editArea.getCharacterWidth();
    int rows = 2;
    for (String line : editArea.getText().split("\n")) {
        rows += Math.ceil((1.0 + line.length()) / cols);
    }
    rows = Math.max(INITIAL_LINES, Math.min(rows, MAX_LINES));
    if (editArea.getVisibleLines() != rows) {
        editArea.setVisibleLines(rows);
    }
    resizePaddingWidget();
}
#method_after
private void expandText() {
    double cols = editArea.getCharacterWidth();
    int rows = 2;
    for (String line : editArea.getValue().split("\n")) {
        rows += Math.ceil((1.0 + line.length()) / cols);
    }
    rows = Math.max(INITIAL_LINES, Math.min(rows, MAX_LINES));
    if (editArea.getVisibleLines() != rows) {
        editArea.setVisibleLines(rows);
    }
    resizePaddingWidget();
}
#end_block

#method_before
void setEdit(boolean edit) {
    if (edit) {
        setOpen(true);
        removeStyleName(draftStyle.view());
        addStyleName(draftStyle.edit());
        editArea.setText(getOriginal().message());
        expandText();
        editArea.setReadOnly(false);
        editArea.setFocus(true);
        disableClickFocusHandler();
    } else {
        expandTimer.cancel();
        editArea.setReadOnly(true);
        removeStyleName(draftStyle.edit());
        addStyleName(draftStyle.view());
        enableClickFocusHandler();
    }
    resizePaddingWidget();
}
#method_after
void setEdit(boolean edit) {
    UIObject.setVisible(summary, false);
    UIObject.setVisible(p_view, !edit);
    UIObject.setVisible(p_edit, edit);
    if (edit) {
        final String msg = comment.message() != null ? comment.message().trim() : "";
        editArea.setValue(msg);
        editArea.setFocus(true);
        cancel.setVisible(!isNew());
        expandText();
        if (msg.length() > 0) {
            Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

                @Override
                public boolean execute() {
                    editArea.setCursorPos(msg.length());
                    return false;
                }
            }, 0);
        }
    } else {
        expandTimer.cancel();
    }
    resizePaddingWidget();
}
#end_block

#method_before
private void removeUI() {
    setEdit(false);
    expandTimer.cancel();
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    removeFromParent();
    getCm().focus();
    if (isFileComment()) {
        getDiffTable().onRemoveDraftBox(this, getSide());
        return;
    }
    CommentInfo info = getOriginal();
    getDiffView().removeDraft(this, getSide(), info.line() - 1);
    getSelfWidget().clear();
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    manager.resizePaddingWidget();
}
#method_after
private void removeUI() {
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    Side side = comment.side();
    removeFromParent();
    if (!getCommentInfo().has_line()) {
        parent.removeFileCommentBox(this, side);
        return;
    }
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    parent.removeDraft(this, side, comment.line() - 1);
    cm.focus();
    getSelfWidgetWrapper().getWidget().clear();
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            resizePaddingWidget();
        }
    });
}
#end_block

#method_before
@UiHandler("edit")
void onEdit(ClickEvent e) {
    setEdit(true);
}
#method_after
@UiHandler("edit")
void onEdit(ClickEvent e) {
    e.stopPropagation();
    setEdit(true);
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    setEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setMessageText(message);
            setDate(result.updated());
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
    getCm().focus();
}
#method_after
@UiHandler("save")
void onSave(ClickEvent e) {
    e.stopPropagation();
    onSave();
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    setEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setMessageText(message);
            setDate(result.updated());
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
    getCm().focus();
}
#method_after
private void onSave() {
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo original = comment;
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    enableEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            set(result);
            if (result.message().length() < 70) {
                UIObject.setVisible(p_edit, false);
                setOpen(false);
            } else {
                setEdit(false);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            super.onFailure(e);
        }
    };
    if (original.id() == null) {
        CommentApi.createDraft(psId, input, cb);
    } else {
        CommentApi.updateDraft(psId, original.id(), input, cb);
    }
    cm.focus();
}
#end_block

#method_before
@UiHandler("cancel")
void onCancel(ClickEvent e) {
    setEdit(false);
    getCm().focus();
}
#method_after
@UiHandler("cancel")
void onCancel(ClickEvent e) {
    e.stopPropagation();
    if (isNew() && !isDirty()) {
        removeUI();
    } else {
        setEdit(false);
        cm.focus();
    }
}
#end_block

#method_before
@UiHandler("discard")
void onDiscard(ClickEvent e) {
    if (isNew) {
        removeUI();
    } else {
        setEdit(false);
        CommentApi.deleteDraft(getPatchSetId(), getOriginal().id(), new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                removeUI();
            }
        });
    }
}
#method_after
@UiHandler({ "discard1", "discard2" })
void onDiscard(ClickEvent e) {
    e.stopPropagation();
    if (isNew()) {
        removeUI();
    } else {
        setEdit(false);
        CommentApi.deleteDraft(psId, comment.id(), new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                removeUI();
            }
        });
    }
}
#end_block

#method_before
DraftBox addReplyBox(String initMessage, boolean doSave) {
    DraftBox box = getDiffView().addReply(getOriginal(), initMessage, doSave);
    registerReplyBox(box);
    return box;
}
#method_after
DraftBox addReplyBox() {
    DraftBox box = parent.addDraftBox(parent.createReply(comment));
    registerReplyBox(box);
    return box;
}
#end_block

#method_before
@UiHandler("reply")
void onReply(ClickEvent e) {
    checkAndAddReply("", false);
}
#method_after
@UiHandler("reply")
void onReply(ClickEvent e) {
    e.stopPropagation();
    doReply();
}
#end_block

#method_before
@UiHandler("replyDone")
void onReplyDone(ClickEvent e) {
    checkAndAddReply(PatchUtil.C.cannedReplyDone(), true);
}
#method_after
@UiHandler("done")
void onReplyDone(ClickEvent e) {
    e.stopPropagation();
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        done.setEnabled(false);
        CommentInput input = CommentInput.create(parent.createReply(comment));
        input.setMessage(PatchUtil.C.cannedReplyDone());
        CommentApi.createDraft(psId, input, new GerritCallback<CommentInfo>() {

            @Override
            public void onSuccess(CommentInfo result) {
                done.setEnabled(true);
                setOpen(false);
                DraftBox box = parent.addDraftBox(result);
                registerReplyBox(box);
                if (!getCommentInfo().has_line()) {
                    parent.addFileCommentBox(box, comment.side());
                }
            }
        });
    } else {
        openReplyBox();
        setOpen(false);
    }
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            if (cmA != null) {
                cmA.setOption("viewportMargin", 10);
            }
            if (cmB != null) {
                cmB.setOption("viewportMargin", 10);
            }
        }
    });
    resizeBoxPaddings();
    (cmB != null ? cmB : cmA).focus();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    handlers.add(UserAgent.addDialogVisibleHandler(new DialogVisibleHandler() {

        @Override
        public void onDialogVisible(DialogVisibleEvent event) {
            diffTable.getElement().getStyle().setVisibility(event.isVisible() ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE);
        }
    }));
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            if (cmA != null) {
                cmA.setOption("viewportMargin", 10);
            }
            if (cmB != null) {
                cmB.setOption("viewportMargin", 10);
            }
            resizeCodeMirror();
        }
    });
    (cmB != null ? cmB : cmA).focus();
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#end_block

#method_before
private void removeKeyHandlerRegs() {
    for (HandlerRegistration h : keyHandlers) {
        h.removeHandler();
    }
    keyHandlers.clear();
}
#method_after
private void removeKeyHandlerRegs() {
    for (HandlerRegistration h : handlers) {
        h.removeHandler();
    }
    handlers.clear();
}
#end_block

#method_before
private void registerCmEvents(CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("scroll", doScroll(cm));
    cm.on("renderLine", resizeEmptyLine(getSideFromCm(cm)));
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)));
    cm.addKeyMap(KeyMap.create().on("'k'", moveCursorDown(cm, -1)));
    cm.addKeyMap(KeyMap.create().on("'u'", upToChange()));
    cm.addKeyMap(KeyMap.create().on("'o'", toggleOpenBox(cm)));
    cm.addKeyMap(KeyMap.create().on("Enter", toggleOpenBox(cm)));
    CodeMirror.defineVimEx("up", "u", upToChange());
    CodeMirror.defineVimEx("mark", "m", toggleReviewed());
    if (Gerrit.isSignedIn()) {
        cm.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cm)));
    }
    /**
     * TODO: Work on a better way for customizing keybindings and remove
     * temporary navigation hacks.
     */
    for (String s : new String[] { "C", "J", "K", "O", "R", "U", "Ctrl-C", "Enter" }) {
        CodeMirror.disableUnwantedKey("vim", s);
    }
}
#method_after
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeEmptyLine(getSideFromCm(cm)));
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)));
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', PatchUtil.C.upToChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange().run();
        }
    });
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new KeyCommand(0, 'm', PatchUtil.C.toggleReviewed()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            toggleReviewed().run();
        }
    });
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    keyHandlers.add(GlobalKey.add(this, keysNavigation));
    keyHandlers.add(GlobalKey.add(this, keysAction));
    keyHandlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        keyHandlers.add(GlobalKey.add(this, keysComment));
    }
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', PatchUtil.C.upToChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange().run();
        }
    });
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            toggleReviewed().run();
        }
    });
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    handlers.add(GlobalKey.add(this, keysNavigation));
    handlers.add(GlobalKey.add(this, keysAction));
    handlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        handlers.add(GlobalKey.add(this, keysComment));
    }
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingWidgetMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    lineElementMap = new HashMap<LineHandle, Element>();
    render(diffInfo);
    allBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
            resizeBoxPaddings();
        }
    });
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    allBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
            resizeBoxPaddings();
        }
    });
}
#end_block

#method_before
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("lineWrapping", true).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "vim").set("value", contents).setInfinity("viewportMargin");
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#method_after
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("lineWrapping", true).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "vim").set("value", contents).setInfinity("viewportMargin");
    int h = Gerrit.getHeaderFooterHeight() + 18;
    CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - h);
    return cm;
}
#end_block

#method_before
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), mapper.getLineB(), insertCnt, false);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), mapper.getLineA(), deleteCnt, false);
                mapper.appendDelete(deleteCnt);
            }
            insertEmptyLines(cmA, mapper.getLineA(), origLineB, commonCnt, true);
            insertEmptyLines(cmB, mapper.getLineB(), origLineA, commonCnt, true);
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                mapper.appendDelete(deleteCnt);
            }
            int chunkEndA = mapper.getLineA() - 1;
            int chunkEndB = mapper.getLineB() - 1;
            if (bLength > 0) {
                addDiffChunkAndPadding(cmA, chunkEndA, chunkEndB, bLength);
            }
            if (aLength > 0) {
                addDiffChunkAndPadding(cmB, chunkEndB, chunkEndA, aLength);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#end_block

#method_before
private DraftBox addNewDraft(CodeMirror cm, int line) {
    Side side = getSideFromCm(cm);
    CommentInfo info = CommentInfo.create(path, side, line + 1, null, null);
    return addDraftBox(info, false);
}
#method_after
private DraftBox addNewDraft(CodeMirror cm, int line) {
    return addDraftBox(CommentInfo.createLine(path, getSideFromCm(cm), line + 1, null, null));
}
#end_block

#method_before
DraftBox addDraftBox(CommentInfo info, boolean doSave) {
    CodeMirror cm = getCmFromSide(info.side());
    DraftBox box = new DraftBox(this, cm, revision, info, commentLinkProcessor, true, doSave);
    if (!doSave) {
        box.setEdit(true);
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#method_after
DraftBox addDraftBox(CommentInfo info) {
    CodeMirror cm = getCmFromSide(info.side());
    DraftBox box = new DraftBox(this, cm, commentLinkProcessor, revision, info);
    if (info.id() == null) {
        box.setOpen(true);
        box.setEdit(true);
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 28, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 28, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidget(boxWidget);
    allBoxes.add(box);
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (getDiffChunk(getSideFromCm(other), lineToPad) == null) {
        box.setDiffChunkInfo(getDiffChunk(mySide, line));
    }
    allBoxes.add(box);
    return box;
}
#end_block

#method_before
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, cm, revision, info, commentLinkProcessor);
        box.setOpen(false);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        publishedMap.put(info.id(), box);
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, commentLinkProcessor, revision, info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), revision, info, commentLinkProcessor, false, false);
        box.setOpen(false);
        box.setEdit(false);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), commentLinkProcessor, revision, info);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderSkips() {
    if (context == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        return;
    }
    /**
     * TODO: This is not optimal, but shouldn't bee too costly in most cases.
     * Maybe rewrite after done keeping track of diff chunk positions.
     */
    for (CommentBox box : lineActiveBoxMap.values()) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < -context || deltaAfter < -context) {
                // Size guaranteed to be greater than 1
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, before);
                checkAndAddSkip(temp, skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                checkAndAddSkip(temp, skip);
            }
        }
        if (temp.isEmpty()) {
            return;
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#method_after
private void renderSkips() {
    if (context == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        return;
    }
    /**
     * TODO: This is not optimal, but shouldn't bee too costly in most cases.
     * Maybe rewrite after done keeping track of diff chunk positions.
     */
    for (CommentBox box : lineActiveBoxMap.values()) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getCommentInfo();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < -context || deltaAfter < -context) {
                // Size guaranteed to be greater than 1
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, before);
                checkAndAddSkip(temp, skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                checkAndAddSkip(temp, skip);
            }
        }
        if (temp.isEmpty()) {
            return;
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#end_block

#method_before
private Runnable doScroll(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            // Hack to prevent feedback loop, Chrome seems fine but Firefox chokes.
            if (cm.isScrollSetByOther()) {
                return;
            }
            other.scrollToY(cm.getScrollInfo().getTop());
            other.setScrollSetByOther(true);
            Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

                @Override
                public boolean execute() {
                    other.setScrollSetByOther(false);
                    return false;
                }
            }, 0);
        }
    };
}
#method_after
private Runnable doScroll(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            // Hack to prevent feedback loop, Chrome seems fine but Firefox chokes.
            if (cm.getScrollSetAt() + 50 > System.currentTimeMillis()) {
                return;
            }
            ScrollInfo si = cm.getScrollInfo();
            if (si.getTop() == 0 && !Gerrit.isHeaderVisible()) {
                Gerrit.setHeaderVisible(true);
                diffTable.updateFileCommentVisibility(false);
                resizeCodeMirror();
            } else if (si.getTop() > 0.5 * si.getClientHeight() && Gerrit.isHeaderVisible()) {
                Gerrit.setHeaderVisible(false);
                diffTable.updateFileCommentVisibility(true);
                resizeCodeMirror();
            }
            /**
             * Since CM doesn't always take the height of line widgets into
             * account when calculating scrollInfo when scrolling too fast
             * (e.g. throw-scrolling), simply setting scrollTop to be the same
             * doesn't guarantee alignment, but should work in most cases. See the
             * hack in fixScroll();
             */
            other.scrollToY(si.getTop());
            other.setScrollSetAt(System.currentTimeMillis());
            (cm == cmA ? scrollTimerA : scrollTimerB).schedule(50);
        }
    };
}
#end_block

#method_before
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            int line = cm.getLineNumber(handle);
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(line, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(line, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), line);
            int oLine = info.getLine();
            if (info.isAligned()) {
                other.setActiveLine(other.getLineHandle(oLine));
                other.addLineClass(oLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#method_after
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                LineHandle activeLine = cm.getActiveLine();
                cm.removeLineClass(activeLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(activeLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                LineHandle otherActiveLine = other.getActiveLine();
                other.removeLineClass(otherActiveLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(otherActiveLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(handle, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(handle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), cm.getLineNumber(handle));
            int oLine = info.getLine();
            LineHandle oLineHandle = other.getLineHandle(oLine);
            if (info.isAligned()) {
                other.setActiveLine(oLineHandle);
                other.addLineClass(oLineHandle, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLineHandle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#end_block

#method_before
private Runnable insertNewDraft(final CodeMirror cm) {
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            if (box == null) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line));
            } else if (box.isDraft()) {
                ((DraftBox) box).setEdit(true);
            } else {
                ((PublishedBox) box).onReply(null);
            }
        }
    };
}
#method_after
private Runnable insertNewDraft(final CodeMirror cm) {
    if (!Gerrit.isSignedIn()) {
        return new Runnable() {

            @Override
            public void run() {
                Gerrit.doSignIn(getToken());
            }
        };
    }
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            if (box == null) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line));
            } else if (box instanceof DraftBox) {
                ((DraftBox) box).setEdit(true);
            } else {
                ((PublishedBox) box).doReply();
            }
        }
    };
}
#end_block

#method_before
private Runnable toggleReviewed() {
    return new Runnable() {

        public void run() {
            reviewedTop.setReviewed(!reviewedTop.isReviewed());
        }
    };
}
#method_after
private Runnable toggleReviewed() {
    return new Runnable() {

        public void run() {
            reviewed.setReviewed(!reviewed.isReviewed());
        }
    };
}
#end_block

#method_before
private RenderLineHandler resizeEmptyLine(final Side side) {
    return new RenderLineHandler() {

        @Override
        public void handle(final CodeMirror instance, final LineHandle handle, final Element element) {
            if (linePaddingWidgetMap.containsKey(handle)) {
                /**
                 * This needs to be deferred because CM fires "renderLine" **before**
                 * the line is actually added to the DOM.
                 */
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        LinePaddingWidgetWrapper otherWrapper = linePaddingWidgetMap.get(handle);
                        int myLineHeight = element.getOffsetHeight();
                        Element otherPadding = otherWrapper.getElement();
                        if (!otherWrapper.isCommon() && myLineHeight > 0) {
                            setHeightInPx(otherPadding, myLineHeight);
                        } else {
                            /**
                             * We have to pay the cost of keeping track of the actual DOM
                             * elements ourselves, because CM doesn't provide an interface
                             * to query for them, and the only place we can ever have legit
                             * access to the line element is in this event handler.
                             */
                            lineElementMap.put(handle, element);
                            if (myLineHeight == 0) {
                                return;
                            }
                            // The lines are always aligned since they are in a common region.
                            int otherLine = mapper.lineOnOther(side, instance.getLineNumber(handle)).getLine();
                            LineHandle other = otherCm(instance).getLineHandle(otherLine);
                            LinePaddingWidgetWrapper myWrapper = linePaddingWidgetMap.get(other);
                            if (lineElementMap.containsKey(other)) {
                                Element otherElement = lineElementMap.get(other);
                                int otherLineHeight = otherElement.getOffsetHeight();
                                if (otherLineHeight == 0) {
                                    return;
                                }
                                Element myPadding = myWrapper.getElement();
                                int delta = myLineHeight - otherLineHeight;
                                if (delta >= 0) {
                                    setHeightInPx(otherPadding, delta);
                                    setHeightInPx(myPadding, 0);
                                } else {
                                    setHeightInPx(otherPadding, 0);
                                    setHeightInPx(myPadding, -delta);
                                }
                                myWrapper.getWidget().changed();
                                otherWrapper.getWidget().changed();
                            }
                        }
                    }
                });
            }
        }
    };
}
#method_after
private RenderLineHandler resizeEmptyLine(final Side side) {
    return new RenderLineHandler() {

        @Override
        public void handle(final CodeMirror instance, final LineHandle handle, Element element) {
            if (linePaddingOnOtherSideMap.containsKey(handle)) {
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        resizePaddingOnOtherSide(side, instance.getLineNumber(handle));
                    }
                });
            }
        }
    };
}
#end_block

#method_before
void resizePaddingWidget() {
    if (fileComment) {
        cm.refresh();
        return;
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        public void execute() {
            if (selfWidget == null || widgetManager == null) {
                throw new IllegalStateException("resizePaddingWidget() called before setting up widgets");
            }
            selfWidget.changed();
            widgetManager.resizePaddingWidget();
        }
    });
}
#method_after
void resizePaddingWidget() {
    if (!getCommentInfo().has_line()) {
        return;
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            assert selfWidgetWrapper != null;
            selfWidgetWrapper.getWidget().changed();
            if (diffChunkInfo != null) {
                parent.resizePaddingOnOtherSide(getCommentInfo().side(), diffChunkInfo.getEnd());
            } else {
                assert widgetManager != null;
                widgetManager.resizePaddingWidget();
            }
        }
    });
}
#end_block

#method_before
void setOpen(boolean open) {
    if (open) {
        removeStyleName(res.style().close());
        addStyleName(res.style().open());
    } else {
        removeStyleName(res.style().open());
        addStyleName(res.style().close());
    }
    resizePaddingWidget();
}
#method_after
void setOpen(boolean open) {
    resizePaddingWidget();
}
#end_block

#method_before
private void addReviewers(ChangeResource rsrc, PostResult result, Set<IdentifiedUser> reviewers) throws OrmException, EmailException {
    if (reviewers.isEmpty()) {
        result.reviewers = ImmutableList.of();
        return;
    }
    ReviewDb db = dbProvider.get();
    PatchSet.Id psid = rsrc.getChange().currentPatchSetId();
    Set<Account.Id> existing = Sets.newHashSet();
    for (PatchSetApproval psa : db.patchSetApprovals().byPatchSet(psid)) {
        existing.add(psa.getAccountId());
    }
    result.reviewers = Lists.newArrayListWithCapacity(reviewers.size());
    List<PatchSetApproval> toInsert = Lists.newArrayListWithCapacity(reviewers.size());
    for (IdentifiedUser user : reviewers) {
        Account.Id id = user.getAccountId();
        if (existing.contains(id)) {
            continue;
        }
        ChangeControl control = rsrc.getControl().forUser(user);
        PatchSetApproval psa = dummyApproval(control, psid, id);
        result.reviewers.add(json.format(new ReviewerInfo(id), control, ImmutableList.of(psa)));
        toInsert.add(psa);
    }
    if (toInsert.isEmpty()) {
        return;
    }
    db.changes().beginTransaction(rsrc.getChange().getId());
    try {
        // Empty update of Change to bump rowVersion, changing its ETag.
        Change c = db.changes().get(rsrc.getChange().getId());
        if (c != null) {
            db.changes().update(Collections.singleton(c));
        }
        db.patchSetApprovals().insert(toInsert);
        db.commit();
    } finally {
        db.rollback();
    }
    accountLoaderFactory.create(true).fill(result.reviewers);
    postAdd(rsrc.getChange(), result);
}
#method_after
private void addReviewers(ChangeResource rsrc, PostResult result, Set<IdentifiedUser> reviewers) throws OrmException, EmailException {
    if (reviewers.isEmpty()) {
        result.reviewers = ImmutableList.of();
        return;
    }
    ReviewDb db = dbProvider.get();
    PatchSet.Id psid = rsrc.getChange().currentPatchSetId();
    Set<Account.Id> existing = Sets.newHashSet();
    for (PatchSetApproval psa : db.patchSetApprovals().byPatchSet(psid)) {
        existing.add(psa.getAccountId());
    }
    result.reviewers = Lists.newArrayListWithCapacity(reviewers.size());
    List<PatchSetApproval> toInsert = Lists.newArrayListWithCapacity(reviewers.size());
    for (IdentifiedUser user : reviewers) {
        Account.Id id = user.getAccountId();
        if (existing.contains(id)) {
            continue;
        }
        ChangeControl control = rsrc.getControl().forUser(user);
        PatchSetApproval psa = dummyApproval(control, psid, id);
        result.reviewers.add(json.format(new ReviewerInfo(id), control, ImmutableList.of(psa)));
        toInsert.add(psa);
    }
    if (toInsert.isEmpty()) {
        return;
    }
    db.changes().beginTransaction(rsrc.getChange().getId());
    try {
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getChange().getId(), db);
        db.patchSetApprovals().insert(toInsert);
        db.commit();
    } finally {
        db.rollback();
    }
    accountLoaderFactory.create(true).fill(result.reviewers);
    postAdd(rsrc.getChange(), result);
}
#end_block

#method_before
@Override
public Object apply(ReviewerResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException {
    ChangeControl control = rsrc.getControl();
    Change.Id changeId = rsrc.getChange().getId();
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(changeId);
    try {
        List<PatchSetApproval> del = Lists.newArrayList();
        for (PatchSetApproval a : approvals(db, rsrc)) {
            if (control.canRemoveReviewer(a)) {
                del.add(a);
            } else {
                throw new AuthException("delete not permitted");
            }
        }
        if (del.isEmpty()) {
            throw new ResourceNotFoundException();
        }
        // Empty update of Change to bump rowVersion, changing its ETag.
        Change c = db.changes().get(rsrc.getChange().getId());
        if (c != null) {
            db.changes().update(Collections.singleton(c));
        }
        db.patchSetApprovals().delete(del);
        db.commit();
    } finally {
        db.rollback();
    }
    return Response.none();
}
#method_after
@Override
public Object apply(ReviewerResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException {
    ChangeControl control = rsrc.getControl();
    Change.Id changeId = rsrc.getChange().getId();
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(changeId);
    try {
        List<PatchSetApproval> del = Lists.newArrayList();
        for (PatchSetApproval a : approvals(db, rsrc)) {
            if (control.canRemoveReviewer(a)) {
                del.add(a);
            } else {
                throw new AuthException("delete not permitted");
            }
        }
        if (del.isEmpty()) {
            throw new ResourceNotFoundException();
        }
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getChange().getId(), db);
        db.patchSetApprovals().delete(del);
        db.commit();
    } finally {
        db.rollback();
    }
    return Response.none();
}
#end_block

#method_before
private void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_ACTIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_ACTIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
@Override
protected void onUnload() {
    if (availableUpdate != null) {
        availableUpdate.hide(true);
        availableUpdate = null;
    }
    if (poller != null) {
        poller.cancel();
        poller = null;
    }
    for (HandlerRegistration h : keys) {
        h.removeHandler();
    }
    keys.clear();
    super.onUnload();
}
#method_after
@Override
protected void onUnload() {
    if (updateAvailable != null) {
        updateAvailable.hide(true);
        updateAvailable = null;
    }
    if (updateCheck != null) {
        updateCheck.cancel();
        updateCheck = null;
    }
    for (HandlerRegistration h : handlers) {
        h.removeHandler();
    }
    handlers.clear();
    super.onUnload();
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keys.add(GlobalKey.add(this, keysNavigation));
    keys.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    handlers.add(GlobalKey.add(this, keysNavigation));
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#end_block

#method_before
private void loadMergeable(final boolean canSubmit) {
    if (Gerrit.getConfig().testChangeMerge()) {
        ChangeApi.revision(changeId.get(), revision).view("mergeable").get(new AsyncCallback<MergeableInfo>() {

            @Override
            public void onSuccess(MergeableInfo result) {
                if (canSubmit) {
                    actions.setSubmitEnabled(result.mergeable());
                    statusText.setInnerText(result.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                }
                setVisible(notMergeable, !result.mergeable());
                renderSubmitType(result.submit_type());
            }

            @Override
            public void onFailure(Throwable caught) {
                loadSubmitType(canSubmit);
            }
        });
    } else {
        loadSubmitType(canSubmit);
    }
}
#method_after
private void loadMergeable(final Change.Status status, final boolean canSubmit) {
    if (Gerrit.getConfig().testChangeMerge()) {
        ChangeApi.revision(changeId.get(), revision).view("mergeable").get(new AsyncCallback<MergeableInfo>() {

            @Override
            public void onSuccess(MergeableInfo result) {
                if (canSubmit) {
                    actions.setSubmitEnabled(result.mergeable());
                    if (status == Change.Status.NEW) {
                        statusText.setInnerText(result.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                    }
                }
                setVisible(notMergeable, !result.mergeable());
                renderSubmitType(result.submit_type());
            }

            @Override
            public void onFailure(Throwable caught) {
                loadSubmitType(status, canSubmit);
            }
        });
    } else {
        loadSubmitType(status, canSubmit);
    }
}
#end_block

#method_before
private void loadSubmitType(final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        statusText.setInnerText(Util.C.readyToSubmit());
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(canSubmit);
    }
    reply.setVisible(replyAction != null);
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    reply.setVisible(replyAction != null);
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void showUpdates(ChangeInfo newInfo) {
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (availableUpdate == null) {
        availableUpdate = new UpdatedBar() {

            @Override
            void onShow() {
                // TODO Avoid RPC and use newInfo.
                reload.reload();
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
        availableUpdate.addCloseHandler(new CloseHandler<PopupPanel>() {

            @Override
            public void onClose(CloseEvent<PopupPanel> event) {
                availableUpdate = null;
            }
        });
    }
    availableUpdate.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!availableUpdate.isShowing()) {
        availableUpdate.popup();
    }
}
#method_after
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                reload.reload();
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
        updateAvailable.addCloseHandler(new CloseHandler<PopupPanel>() {

            @Override
            public void onClose(CloseEvent<PopupPanel> event) {
                updateAvailable = null;
            }
        });
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isShowing()) {
        updateAvailable.popup();
    }
}
#end_block

#method_before
private void startPoller() {
    poller = new Timer() {

        private int delay = REFRESH_POLL_PERIOD;

        @Override
        public void run() {
            if (!isAttached()) {
                // onUnload() should have removed this.
                return;
            } else if (!UserActivityMonitor.isActive()) {
                cancel();
                delay = REFRESH_IDLE_PERIOD;
                scheduleRepeating(delay);
            }
            loadChangeInfo(false, new AsyncCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo info) {
                    if (isAttached() && !info.updated().equals(lastDisplayedUpdate)) {
                        showUpdates(info);
                    }
                }

                @Override
                public void onFailure(Throwable caught) {
                    // but place an upper bound on the delay.
                    if (isAttached()) {
                        cancel();
                        delay = (int) Math.max(delay * (1.5 + Math.random()), REFRESH_MAX_PERIOD);
                        scheduleRepeating(delay);
                    }
                }
            });
        }
    };
    poller.scheduleRepeating(REFRESH_POLL_PERIOD);
}
#method_after
private void startPoller() {
    if (Gerrit.isSignedIn() && 0 < Gerrit.getConfig().getChangeUpdateDelay()) {
        updateCheck = new UpdateCheckTimer(this);
        updateCheck.schedule();
        handlers.add(UserActivityMonitor.addValueChangeHandler(updateCheck));
    }
}
#end_block

#method_before
public static RootPanel getBottomMenu() {
    return gBottomMenu;
}
#method_after
public static RootPanel getBottomMenu() {
    return bottomMenu;
}
#end_block

#method_before
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            lastViewToken = History.getToken();
            String token = view.getToken();
            if (!token.equals(lastViewToken)) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    saveDefaultTheme();
    loadPlugins(hpd, token);
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            lastViewToken = History.getToken();
            String token = view.getToken();
            if (!token.equals(lastViewToken)) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(topMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    saveDefaultTheme();
    loadPlugins(hpd, token);
}
#end_block

#method_before
public static boolean isActive() {
    return impl.recent || impl.active;
}
#method_after
public static boolean isActive() {
    return impl.active || impl.recent;
}
#end_block

#method_before
@Override
public void onKeyPress(KeyPressEvent event) {
    active = true;
}
#method_after
@Override
public void onKeyPress(KeyPressEvent event) {
    recent = true;
}
#end_block

#method_before
@Override
public void onValueChange(ValueChangeEvent<String> event) {
    active = true;
}
#method_after
@Override
public void onValueChange(ValueChangeEvent<String> event) {
    recent = true;
}
#end_block

#method_before
@Override
public boolean execute() {
    long now = System.currentTimeMillis();
    if (active) {
        recent = true;
        active = false;
        last = now;
    } else if ((now - last) > TIMEOUT) {
        recent = false;
    }
    return true;
}
#method_after
@Override
public boolean execute() {
    long now = System.currentTimeMillis();
    if (recent) {
        if (!active) {
            ValueChangeEvent.fire(this, active);
        }
        recent = false;
        active = true;
        last = now;
    } else if (active && (now - last) > TIMEOUT) {
        active = false;
        ValueChangeEvent.fire(this, false);
    }
    return true;
}
#end_block

#method_before
@Override
public void run() {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    PatchList patchList;
    if (// Ignore merges and initial commit.
    commit.getParentCount() == 1 && (patchList = getPatchList(change, ps)) != null) {
        for (PatchListEntry entry : patchList.getPatches()) {
            BlameResult blameResult;
            if ((entry.getChangeType() == ChangeType.MODIFIED || entry.getChangeType() == ChangeType.DELETED) && (blameResult = computeBlame(entry, commit.getParent(0))) != null) {
                List<Edit> edits = entry.getEdits();
                reviewers.putAll(getReviewersForPatch(edits, blameResult));
            }
        }
        Set<Account.Id> topReviewers = findTopReviewers(Collections.unmodifiableSet(reviewers.entrySet()), maxReviewers);
        addReviewers(topReviewers, change);
    }
}
#method_after
@Override
public void run() {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    PatchList patchList;
    try {
        patchList = patchListCache.get(change, ps);
    } catch (PatchListNotAvailableException ex) {
        log.error("Couldn't load patchlist for change {}", change.getKey(), ex);
        return;
    }
    // Ignore merges and initial commit.
    if (commit.getParentCount() != 1) {
        return;
    }
    for (PatchListEntry entry : patchList.getPatches()) {
        BlameResult blameResult;
        if ((entry.getChangeType() == ChangeType.MODIFIED || entry.getChangeType() == ChangeType.DELETED) && (blameResult = computeBlame(entry, commit.getParent(0))) != null) {
            List<Edit> edits = entry.getEdits();
            reviewers.putAll(getReviewersForPatch(edits, blameResult));
        }
    }
    Set<Account.Id> topReviewers = findTopReviewers(reviewers);
    addReviewers(topReviewers, change);
}
#end_block

#method_before
private Set<Account.Id> findTopReviewers(final Set<Entry<Account, Integer>> reviewers, final int max) {
    Set<Account.Id> topReviewers = Sets.newHashSet();
    Queue<Entry<Account, Integer>> pq = new PriorityQueue<Map.Entry<Account, Integer>>(reviewers.size(), new Comparator<Entry<Account, Integer>>() {

        public int compare(Entry<Account, Integer> first, Entry<Account, Integer> second) {
            return second.getValue() - first.getValue();
        }
    });
    pq.addAll(reviewers);
    int curr = 0;
    while (!pq.isEmpty() && curr < max) {
        topReviewers.add(pq.poll().getKey().getId());
        ++curr;
    }
    return topReviewers;
}
#method_after
private Set<Account.Id> findTopReviewers(final Map<Account, Integer> reviewers) {
    Set<Account.Id> topReviewers = Sets.newHashSet();
    List<Entry<Account, Integer>> entries = Ordering.from(new Comparator<Entry<Account, Integer>>() {

        public int compare(Entry<Account, Integer> first, Entry<Account, Integer> second) {
            return first.getValue() - second.getValue();
        }
    }).greatestOf(reviewers.entrySet(), this.maxReviewers);
    for (Entry<Account, Integer> entry : entries) {
        topReviewers.add(entry.getKey().getId());
    }
    return topReviewers;
}
#end_block

#method_before
private Map<Account, Integer> getReviewersForPatch(final List<Edit> edits, final BlameResult blameResult) {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    for (Edit edit : edits) {
        for (int i = edit.getBeginA(); i <= edit.getEndA(); i++) {
            RevCommit commit = blameResult.getSourceCommit(i);
            Set<Account.Id> ids = byEmailCache.get(commit.getAuthorIdent().getEmailAddress());
            for (Account.Id id : ids) {
                Account account = accountCache.get(id).getAccount();
                if (account.isActive() && !change.getOwner().equals(account.getId())) {
                    Integer count = reviewers.get(account);
                    reviewers.put(account, count == null ? 1 : count.intValue() + 1);
                }
            }
        }
    }
    return reviewers;
}
#method_after
private Map<Account, Integer> getReviewersForPatch(final List<Edit> edits, final BlameResult blameResult) {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    for (Edit edit : edits) {
        for (int i = edit.getBeginA(); i < edit.getEndA(); i++) {
            RevCommit commit = blameResult.getSourceCommit(i);
            Set<Account.Id> ids = byEmailCache.get(commit.getAuthorIdent().getEmailAddress());
            for (Account.Id id : ids) {
                Account account = accountCache.get(id).getAccount();
                if (account.isActive() && !change.getOwner().equals(account.getId())) {
                    Integer count = reviewers.get(account);
                    reviewers.put(account, count == null ? 1 : count.intValue() + 1);
                }
            }
        }
    }
    return reviewers;
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(final Event e) {
    Project.NameKey projectName = new Project.NameKey(e.getProjectName());
    Repository git;
    try {
        git = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException x) {
        log.error(x.getMessage(), x);
        return;
    } catch (IOException x) {
        log.error(x.getMessage(), x);
        return;
    }
    final ReviewDb reviewDb;
    try {
        reviewDb = schemaFactory.open();
        try {
            for (Update u : e.getUpdates()) {
                if (!u.getRefName().startsWith("refs/changes/")) {
                    continue;
                }
                final Change change = reviewDb.changes().get(Change.Id.fromRef(u.getRefName()));
                List<PatchSet> patchSets = reviewDb.patchSets().byChange(change.getId()).toList();
                // only compute for the first patch set
                if (patchSets.size() > 1) {
                    continue;
                }
                final PatchSet ps = patchSets.get(0);
                RevWalk rw = new RevWalk(git);
                final RevCommit commit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
                // FIXME Convert to
                int maxReviewers = 3;
                // project.getMaxReviewersByBlame();
                final Runnable task = reviewersByBlameFactory.create(commit, change, ps, maxReviewers, git);
                workQueue.getDefaultQueue().submit(new Runnable() {

                    public void run() {
                        RequestContext old = tl.setContext(new RequestContext() {

                            @Override
                            public CurrentUser getCurrentUser() {
                                return identifiedUserFactory.create(change.getOwner());
                            }

                            @Override
                            public Provider<ReviewDb> getReviewDbProvider() {
                                return new Provider<ReviewDb>() {

                                    @Override
                                    public ReviewDb get() {
                                        if (db == null) {
                                            try {
                                                db = schemaFactory.open();
                                            } catch (OrmException e) {
                                                throw new ProvisionException("Cannot open ReviewDb", e);
                                            }
                                        }
                                        return db;
                                    }
                                };
                            }
                        });
                        try {
                            task.run();
                        } finally {
                            tl.setContext(old);
                            if (db != null) {
                                db.close();
                                db = null;
                            }
                        }
                    }
                });
            }
        } catch (OrmException x) {
            log.error(x.getMessage(), x);
        } catch (MissingObjectException x) {
            log.error(x.getMessage(), x);
        } catch (IncorrectObjectTypeException x) {
            log.error(x.getMessage(), x);
        } catch (IOException x) {
            log.error(x.getMessage(), x);
        } finally {
            reviewDb.close();
        }
    } catch (OrmException x) {
        log.error(x.getMessage(), x);
    } finally {
        git.close();
    }
}
#method_after
@Override
public void onGitReferenceUpdated(final Event e) {
    Project.NameKey projectName = new Project.NameKey(e.getProjectName());
    Repository git;
    try {
        git = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException x) {
        log.error(x.getMessage(), x);
        return;
    } catch (IOException x) {
        log.error(x.getMessage(), x);
        return;
    }
    final ReviewDb reviewDb;
    final RevWalk rw = new RevWalk(git);
    try {
        reviewDb = schemaFactory.open();
        try {
            for (Update u : e.getUpdates()) {
                if (!u.getRefName().startsWith("refs/changes/")) {
                    continue;
                }
                PatchSet.Id psId = PatchSet.Id.fromRef(u.getRefName());
                PatchSet ps = reviewDb.patchSets().get(psId);
                final Change change = reviewDb.changes().get(psId.getParentKey());
                final RevCommit commit = rw.parseCommit(ObjectId.fromString(u.getNewObjectId()));
                // TODO Move to config
                int maxReviewers = 3;
                final Runnable task = reviewersByBlameFactory.create(commit, change, ps, maxReviewers, git);
                workQueue.getDefaultQueue().submit(new Runnable() {

                    public void run() {
                        RequestContext old = tl.setContext(new RequestContext() {

                            @Override
                            public CurrentUser getCurrentUser() {
                                return identifiedUserFactory.create(change.getOwner());
                            }

                            @Override
                            public Provider<ReviewDb> getReviewDbProvider() {
                                return new Provider<ReviewDb>() {

                                    @Override
                                    public ReviewDb get() {
                                        if (db == null) {
                                            try {
                                                db = schemaFactory.open();
                                            } catch (OrmException e) {
                                                throw new ProvisionException("Cannot open ReviewDb", e);
                                            }
                                        }
                                        return db;
                                    }
                                };
                            }
                        });
                        try {
                            task.run();
                        } finally {
                            tl.setContext(old);
                            if (db != null) {
                                db.close();
                                db = null;
                            }
                        }
                    }
                });
            }
        } catch (OrmException x) {
            log.error(x.getMessage(), x);
        } catch (MissingObjectException x) {
            log.error(x.getMessage(), x);
        } catch (IncorrectObjectTypeException x) {
            log.error(x.getMessage(), x);
        } catch (IOException x) {
            log.error(x.getMessage(), x);
        } finally {
            reviewDb.close();
        }
    } catch (OrmException x) {
        log.error(x.getMessage(), x);
    } finally {
        rw.release();
        git.close();
    }
}
#end_block

#method_before
@UiHandler("editArea")
void onEsc(KeyDownEvent e) {
    if (e.getNativeKeyCode() == KeyCodes.KEY_ESCAPE) {
        if (isNew) {
            removeUI();
        } else {
            onCancel(null);
        }
        e.preventDefault();
    }
}
#method_after
void onEsc(KeyDownEvent e) {
    if (e.getNativeKeyCode() == KeyCodes.KEY_ESCAPE) {
        if (isNew) {
            removeUI();
        } else {
            onCancel(null);
        }
        e.preventDefault();
    }
}
#end_block

#method_before
private void removeKeyHandlerRegs() {
    if (regNavigation != null) {
        regNavigation.removeHandler();
        regNavigation = null;
    }
    if (regAction != null) {
        regAction.removeHandler();
        regAction = null;
    }
    if (regOpenByEnter != null) {
        regOpenByEnter.removeHandler();
        regOpenByEnter = null;
    }
    if (regComment != null) {
        regComment.removeHandler();
        regComment = null;
    }
}
#method_after
private void removeKeyHandlerRegs() {
    for (HandlerRegistration h : keyHandlers) {
        h.removeHandler();
    }
    keyHandlers.clear();
}
#end_block

#method_before
private void registerCmEvents(CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("scroll", doScroll(otherCM(cm)));
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)));
    cm.addKeyMap(KeyMap.create().on("'k'", moveCursorDown(cm, -1)));
    cm.addKeyMap(KeyMap.create().on("'o'", toggleOpenBox(cm)));
    cm.addKeyMap(KeyMap.create().on("Enter", toggleOpenBox(cm)));
    if (Gerrit.isSignedIn()) {
        cm.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cm)));
    }
}
#method_after
private void registerCmEvents(CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("scroll", doScroll(otherCM(cm)));
    /**
     * TODO: Trying to prevent right click from updating the cursor.
     * Doesn't seem to work for now.
     */
    cm.on("mousedown", ignoreRightClick());
    cm.addKeyMap(KeyMap.create().on("'u'", upToChange()));
    cm.addKeyMap(KeyMap.create().on("'o'", toggleOpenBox(cm)));
    cm.addKeyMap(KeyMap.create().on("Enter", toggleOpenBox(cm)));
    if (Gerrit.isSignedIn()) {
        cm.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cm)));
    }
    // TODO: Examine if a better way exists.
    for (String c : new String[] { "A", "C", "D", "I", "O", "P", "R", "S", "U", "X", "Y", "~" }) {
        CodeMirror.disableUnwantedKey("vim", c);
    }
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    regNavigation = GlobalKey.add(this, keysNavigation);
    regAction = GlobalKey.add(this, keysAction);
    regOpenByEnter = GlobalKey.add(this, keysOpenByEnter);
    if (keysComment != null) {
        regComment = GlobalKey.add(this, keysComment);
    }
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new NoOpKeyCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    keyHandlers.add(GlobalKey.add(this, keysNavigation));
    keyHandlers.add(GlobalKey.add(this, keysAction));
    keyHandlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        keyHandlers.add(GlobalKey.add(this, keysComment));
    }
}
#end_block

#method_before
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("styleSelectedText", true).set("showTrailingSpace", true).set("value", contents);
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#method_after
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "vim").set("value", contents);
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#end_block

#method_before
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffTable.style.diff() : diffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? DiffTable.style.diff() : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, final CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCM(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 21px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, diffTable.style.padding(), line, 21, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, diffTable.style.padding(), lineToPad, 21, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidget(boxWidget);
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, final CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCM(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 21px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 21, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 21, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidget(boxWidget);
    return box;
}
#end_block

#method_before
private void renderSkips() {
    hiddenSkipMap = new HashMap<LineHandle, Integer>();
    for (CommentBox box : initialBoxes) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < 0 || deltaAfter < 0) {
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                temp.add(before);
                temp.add(skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                temp.add(skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                temp.add(skip);
            }
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#method_after
private void renderSkips() {
    for (CommentBox box : initialBoxes) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < 0 || deltaAfter < 0) {
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                temp.add(before);
                temp.add(skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                temp.add(skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                temp.add(skip);
            }
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#end_block

#method_before
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() - 1 : skip.getStartB() - 1;
    int markEnd = markStart + size;
    hiddenSkipMap.put(cm.getLineHandle(markEnd), size);
    SkipBar bar = new SkipBar(cm, hiddenSkipMap);
    diffTable.add(bar);
    TextMarker marker = cm.markText(CodeMirror.pos(markStart), CodeMirror.pos(markEnd), Configuration.create().set("collapsed", true));
    /**
     * TODO: Due to CodeMirror limitation, there's no way to make the first
     * line disappear completely. The current approach leaves an empty line
     * with line number "1" still showing, and CodeMirror doesn't like manually
     * setting the display of a line to "none". A workaround may be to use
     * inline widget for the first line and regular line widgets for others.
     */
    boolean isZero = markStart == -1;
    Configuration config = Configuration.create().set("coverGutter", true).set("above", isZero);
    LineWidget widget = cm.addLineWidget(isZero ? markEnd + 1 : markStart, bar.getElement(), config);
    bar.setWidget(widget);
    bar.setMarker(marker, size);
    return bar;
}
#method_after
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() - 1 : skip.getStartB() - 1;
    int markEnd = markStart + size;
    SkipBar bar = new SkipBar(cm);
    diffTable.add(bar);
    /**
     * Due to CodeMirror limitation, there's no way to make the first
     * line disappear completely, and CodeMirror doesn't like manually
     * setting the display of a line to "none". The workaround here uses
     * inline widget for the first line and regular line widgets for others.
     */
    Configuration markerConfig;
    if (markStart == -1) {
        markerConfig = Configuration.create().set("inclusiveLeft", true).set("inclusiveRight", true).set("replacedWith", bar.getElement());
        cm.addLineClass(0, LineClassWhere.WRAP, DiffTable.style.hideNumber());
    } else {
        markerConfig = Configuration.create().set("collapsed", true);
        Configuration config = Configuration.create().set("coverGutter", true);
        bar.setWidget(cm.addLineWidget(markStart, bar.getElement(), config));
    }
    bar.setMarker(cm.markText(CodeMirror.pos(markStart), CodeMirror.pos(markEnd), markerConfig), size);
    return bar;
}
#end_block

#method_before
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration intralineBgOpt = Configuration.create().set("className", diffTable.style.intralineBg()).set("readOnly", true);
    Configuration diffOpt = Configuration.create().set("className", diffTable.style.diff()).set("readOnly", true);
    LineCharacter last = CodeMirror.pos(0, 0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, intralineBgOpt);
        } else {
            cm.markText(CodeMirror.pos(fromLine, 0), from, intralineBgOpt);
        }
        cm.markText(from, to, diffOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.diff());
        }
    }
}
#method_after
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration intralineBgOpt = Configuration.create().set("className", DiffTable.style.intralineBg()).set("readOnly", true);
    Configuration diffOpt = Configuration.create().set("className", DiffTable.style.diff()).set("readOnly", true);
    LineCharacter last = CodeMirror.pos(0, 0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, intralineBgOpt);
        } else {
            cm.markText(CodeMirror.pos(fromLine, 0), from, intralineBgOpt);
        }
        cm.markText(from, to, diffOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, DiffTable.style.diff());
        }
    }
}
#end_block

#method_before
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, diffTable.style.padding(), nextLine - 1, cnt, Unit.EM, null);
}
#method_after
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, DiffTable.style.padding(), nextLine - 1, cnt, Unit.EM, null);
}
#end_block

#method_before
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCM(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine());
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine());
                other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
            int line = getCursorLine(cm);
            LineHandle handle = cm.getLineHandle(line);
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(line, LineClassWhere.WRAP, diffTable.style.activeLine());
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(cm == cmA ? Side.PARENT : Side.REVISION, line);
            int oLine = info.getLine();
            if (info.isAligned()) {
                other.setActiveLine(other.getLineHandle(oLine));
                other.addLineClass(oLine, LineClassWhere.WRAP, diffTable.style.activeLine());
                other.addLineClass(oLine, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
        }
    };
}
#method_after
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCM(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            int line = cm.getLineNumber(handle);
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(line, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(line, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(cm == cmA ? Side.PARENT : Side.REVISION, line);
            int oLine = info.getLine();
            if (info.isAligned()) {
                other.setActiveLine(other.getLineHandle(oLine));
                other.addLineClass(oLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#end_block

#method_before
void setMarker(TextMarker marker, int length) {
    this.marker = marker;
    numSkipLines = length;
    skipNum.setText(Integer.toString(length));
    if (!checkAndUpdateArrows()) {
        upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND));
        downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND));
    }
}
#method_after
void setMarker(TextMarker marker, int length) {
    this.marker = marker;
    numSkipLines = length;
    skipNum.setText(Integer.toString(length));
    if (checkAndUpdateArrows()) {
        upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND));
        downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND));
    }
}
#end_block

#method_before
private void updateSkipNum() {
    numSkipLines -= NUM_ROWS_TO_EXPAND;
    skipNum.setText(Integer.toString(numSkipLines));
    checkAndUpdateArrows();
}
#method_after
private void updateSkipNum() {
    numSkipLines -= NUM_ROWS_TO_EXPAND;
    skipNum.setText(String.valueOf(numSkipLines));
    checkAndUpdateArrows();
}
#end_block

#method_before
private boolean checkAndUpdateArrows() {
    if (numSkipLines <= UP_DOWN_THRESHOLD) {
        upArrow.addStyleName(style.noExpand());
        downArrow.addStyleName(style.noExpand());
        return true;
    }
    return false;
}
#method_after
private boolean checkAndUpdateArrows() {
    if (numSkipLines <= UP_DOWN_THRESHOLD) {
        upArrow.addStyleName(style.noExpand());
        downArrow.addStyleName(style.noExpand());
        return false;
    }
    return true;
}
#end_block

#method_before
private void expandAll() {
    marker.clear();
    removeFromParent();
}
#method_after
private void expandAll() {
    hiddenSkipMap.remove(cm.getLineHandle(marker.find().getTo().getLine()));
    marker.clear();
    widget.clear();
    removeFromParent();
}
#end_block

#method_before
private void expandBefore() {
    FromTo fromTo = marker.find();
    marker.clear();
    marker = cm.markText(CodeMirror.Pos(fromTo.getFrom().getLine() + NUM_ROWS_TO_EXPAND), CodeMirror.Pos(fromTo.getTo().getLine()), Configuration.getReplaceConfig(getElement()));
    updateSkipNum();
}
#method_after
private void expandBefore() {
    FromTo fromTo = marker.find();
    marker.clear();
    int oldStart = fromTo.getFrom().getLine();
    int newStart = oldStart + NUM_ROWS_TO_EXPAND;
    int end = fromTo.getTo().getLine();
    marker = cm.markText(CodeMirror.pos(newStart), CodeMirror.pos(end), COLLAPSED);
    Configuration config = Configuration.create().set("coverGutter", true);
    LineWidget newWidget = cm.addLineWidget(newStart, getElement(), config);
    widget.clear();
    setWidget(newWidget);
    updateSkipNum();
    hiddenSkipMap.put(cm.getLineHandle(end), numSkipLines);
}
#end_block

#method_before
private void expandAfter() {
    FromTo fromTo = marker.find();
    marker.clear();
    marker = cm.markText(CodeMirror.Pos(fromTo.getFrom().getLine()), CodeMirror.Pos(fromTo.getTo().getLine() - NUM_ROWS_TO_EXPAND), Configuration.getReplaceConfig(getElement()));
    updateSkipNum();
}
#method_after
private void expandAfter() {
    FromTo fromTo = marker.find();
    marker.clear();
    int oldEnd = fromTo.getTo().getLine();
    int newEnd = oldEnd - NUM_ROWS_TO_EXPAND;
    marker = cm.markText(CodeMirror.pos(fromTo.getFrom().getLine()), CodeMirror.pos(newEnd), COLLAPSED);
    updateSkipNum();
    hiddenSkipMap.remove(cm.getLineHandle(oldEnd));
    hiddenSkipMap.put(cm.getLineHandle(newEnd), numSkipLines);
}
#end_block

#method_before
public final void addLineClass(int line, LineClassWhere where, String className) {
    addLineClassNative(line, where.name().toLowerCase(), className);
}
#method_after
public final void addLineClass(LineHandle line, LineClassWhere where, String className) {
    addLineClassNative(line, where.name().toLowerCase(), className);
}
#end_block

#method_before
@Test
public void testSimpleAdvance() {
    EditIterator iter = new EditIterator(lines, 0);
    assertLineChsEqual(LineCharacter.create(0), iter.advance(1));
}
#method_after
@Test
public void testSimpleAdvance() {
    EditIterator iter = new EditIterator(lines, 0);
    assertLineChsEqual(LineCharacter.create(0, 1), iter.advance(1));
}
#end_block

#method_before
@Test
public void testEndsBeforeNewline() {
    EditIterator iter = new EditIterator(lines, 0);
    assertLineChsEqual(LineCharacter.create(0), iter.advance(3));
}
#method_after
@Test
public void testEndsBeforeNewline() {
    EditIterator iter = new EditIterator(lines, 0);
    assertLineChsEqual(LineCharacter.create(0, 3), iter.advance(3));
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    CommentApi.comments(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
            published = m.get(path);
        }
    }));
    CommentApi.drafts(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
            drafts = m.get(path);
        }
    }));
    ChangeApi.detail(revision.getParentKey().get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Project.NameKey project = result.project_name_key();
            ConfigInfoCache.get(project, group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(CodeMirrorDemo.this) {

                @Override
                protected void preDisplay(ConfigInfoCache.Entry result) {
                    commentLinkProcessor = result.getCommentLinkProcessor();
                    setTheme(result.getTheme());
                    DiffInfo diffInfo = diff;
                    diff = null;
                    display(diffInfo);
                }
            }));
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    CommentApi.comments(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
            published = m.get(path);
        }
    }));
    if (Gerrit.isSignedIn()) {
        CommentApi.drafts(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
                drafts = m.get(path);
            }
        }));
    } else {
        drafts = JsArray.createArray().cast();
    }
    ChangeApi.detail(revision.getParentKey().get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Project.NameKey project = result.project_name_key();
            ConfigInfoCache.get(project, group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(CodeMirrorDemo.this) {

                @Override
                protected void preDisplay(ConfigInfoCache.Entry result) {
                    commentLinkProcessor = result.getCommentLinkProcessor();
                    setTheme(result.getTheme());
                    DiffInfo diffInfo = diff;
                    diff = null;
                    display(diffInfo);
                }
            }));
        }
    });
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            for (Runnable r : resizeCallbacks) {
                r.run();
            }
            resizeCallbacks = null;
        }
    });
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    for (CommentBox box : initialBoxes) {
        box.resizePaddingWidget();
    }
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.getCmA());
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.getCmB());
    skips = new ArrayList<SkippedLine>();
    render(diffInfo);
    renderSkips();
    skips = null;
    resizeCallbacks = new ArrayList<Runnable>();
    renderComments(published, false);
    renderComments(drafts, true);
    published = null;
    drafts = null;
    mapper = null;
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
        }
    });
    cmA.on("scroll", doScroll(cmB));
    cmB.on("scroll", doScroll(cmA));
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.getCmA());
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.getCmB());
    skips = new ArrayList<SkippedLine>();
    render(diffInfo);
    initialBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    cmA.on("cursorActivity", updateActiveLine(cmA));
    cmB.on("cursorActivity", updateActiveLine(cmB));
    if (Gerrit.isSignedIn()) {
        cmA.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cmA)));
        cmB.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cmB)));
    }
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
        }
    });
    cmA.on("scroll", doScroll(cmB));
    cmB.on("scroll", doScroll(cmA));
}
#end_block

#method_before
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    int context = pref == null ? DFLT_CONTEXT : pref.getContext();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            colorLines(cmA, origLineA, aLength);
            colorLines(cmB, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffTable.style.diff() : diffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#end_block

#method_before
private void renderSkips() {
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#method_after
private void renderSkips() {
    hiddenSkipMap = new HashMap<LineHandle, Integer>();
    for (CommentBox box : initialBoxes) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < 0 || deltaAfter < 0) {
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                temp.add(before);
                temp.add(skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                temp.add(skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                temp.add(skip);
            }
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#end_block

#method_before
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int start = cm == cmA ? skip.getStartA() : skip.getStartB();
    SkipBar bar = new SkipBar(cm);
    diffTable.add(bar);
    TextMarker marker = cm.markText(CodeMirror.Pos(start), CodeMirror.Pos(start + size), Configuration.getReplaceConfig(bar.getElement()));
    bar.setMarker(marker, size);
    return bar;
}
#method_after
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() - 1 : skip.getStartB() - 1;
    int markEnd = markStart + size;
    hiddenSkipMap.put(cm.getLineHandle(markEnd), size);
    SkipBar bar = new SkipBar(cm, hiddenSkipMap);
    diffTable.add(bar);
    TextMarker marker = cm.markText(CodeMirror.pos(markStart), CodeMirror.pos(markEnd), Configuration.create().set("collapsed", true));
    /**
     * TODO: Due to CodeMirror limitation, there's no way to make the first
     * line disappear completely. The current approach leaves an empty line
     * with line number "1" still showing, and CodeMirror doesn't like manually
     * setting the display of a line to "none". A workaround may be to use
     * inline widget for the first line and regular line widgets for others.
     */
    boolean isZero = markStart == -1;
    Configuration config = Configuration.create().set("coverGutter", true).set("above", isZero);
    LineWidget widget = cm.addLineWidget(isZero ? markEnd + 1 : markStart, bar.getElement(), config);
    bar.setWidget(widget);
    bar.setMarker(marker, size);
    return bar;
}
#end_block

#method_before
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration diffOpt = Configuration.create().set("className", diffTable.style.diff()).set("readOnly", true);
    Configuration editOpt = Configuration.create().set("className", diffTable.style.intraline()).set("readOnly", true);
    LineCharacter last = CodeMirror.Pos(0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, diffOpt);
        } else {
            cm.markText(CodeMirror.Pos(fromLine), from, diffOpt);
        }
        cm.markText(from, to, editOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.intraline());
        }
    }
}
#method_after
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration intralineBgOpt = Configuration.create().set("className", diffTable.style.intralineBg()).set("readOnly", true);
    Configuration diffOpt = Configuration.create().set("className", diffTable.style.diff()).set("readOnly", true);
    LineCharacter last = CodeMirror.pos(0, 0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, intralineBgOpt);
        } else {
            cm.markText(CodeMirror.pos(fromLine, 0), from, intralineBgOpt);
        }
        cm.markText(from, to, diffOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.diff());
        }
    }
}
#end_block

#method_before
private void colorLines(CodeMirror cm, int line, int cnt) {
    for (int i = 0; i < cnt; i++) {
        cm.addLineClass(line + i, LineClassWhere.WRAP, diffTable.style.diff());
    }
}
#method_after
private void colorLines(CodeMirror cm, String color, int line, int cnt) {
    for (int i = 0; i < cnt; i++) {
        cm.addLineClass(line + i, LineClassWhere.WRAP, color);
    }
}
#end_block

#method_before
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, diffTable.style.padding(), nextLine - 1, cnt, Unit.EM);
}
#method_after
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, diffTable.style.padding(), nextLine - 1, cnt, Unit.EM, null);
}
#end_block

#method_before
private Element addPaddingWidget(CodeMirror cm, String style, int line, int height, Unit unit) {
    Element div = DOM.createDiv();
    div.setClassName(style);
    div.getStyle().setHeight(height, unit);
    Configuration config = Configuration.create().set("coverGutter", true).set("above", line == -1);
    cm.addLineWidget(line == -1 ? 0 : line, div, config);
    return div;
}
#method_after
private LineWidgetElementPair addPaddingWidget(CodeMirror cm, String style, int line, int height, Unit unit, Integer index) {
    Element div = DOM.createDiv();
    div.setClassName(style);
    div.getStyle().setHeight(height, unit);
    Configuration config = Configuration.create().set("coverGutter", true).set("above", line == -1);
    if (index != null) {
        config = config.set("insertAt", index);
    }
    LineWidget widget = cm.addLineWidget(line == -1 ? 0 : line, div, config);
    return new LineWidgetElementPair(widget, div);
}
#end_block

#method_before
LineCharacter advance(int numOfChar) {
    while (currLineIndex < lines.length()) {
        int lengthWithNewline = lines.get(currLineIndex).length() - currLineOffset + 1;
        if (numOfChar < lengthWithNewline) {
            LineCharacter at = CodeMirror.Pos(startLine + currLineIndex, numOfChar + currLineOffset);
            currLineOffset += numOfChar;
            return at;
        }
        numOfChar -= lengthWithNewline;
        advanceLine();
    }
    throw new IllegalStateException("EditIterator index out of bound");
}
#method_after
LineCharacter advance(int numOfChar) {
    while (currLineIndex < lines.length()) {
        int lengthWithNewline = lines.get(currLineIndex).length() - currLineOffset + 1;
        if (numOfChar < lengthWithNewline) {
            LineCharacter at = LineCharacter.create(startLine + currLineIndex, numOfChar + currLineOffset);
            currLineOffset += numOfChar;
            return at;
        }
        numOfChar -= lengthWithNewline;
        advanceLine();
        if (numOfChar == 0) {
            return LineCharacter.create(startLine + currLineIndex, 0);
        }
    }
    throw new IllegalStateException("EditIterator index out of bound");
}
#end_block

#method_before
public void copySettingsFrom(final Project update) {
    description = update.description;
    useContributorAgreements = update.useContributorAgreements;
    useSignedOffBy = update.useSignedOffBy;
    useContentMerge = update.useContentMerge;
    requireChangeID = update.requireChangeID;
    submitType = update.submitType;
    state = update.state;
}
#method_after
public void copySettingsFrom(final Project update) {
    description = update.description;
    useContributorAgreements = update.useContributorAgreements;
    useSignedOffBy = update.useSignedOffBy;
    useContentMerge = update.useContentMerge;
    requireChangeID = update.requireChangeID;
    submitType = update.submitType;
    state = update.state;
    maxObjectSizeLimit = update.maxObjectSizeLimit;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    maxObjectSizeLimit = rc.getLong(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, 0);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    maxObjectSizeLimit = rc.getLong(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, 0);
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, p.getMaxObjectSizeLimit());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), Project.InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), Project.InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    if (Permission.isLabel(permission)) {
        return toRange(permission, access(permission));
    }
    return null;
}
#method_after
public PermissionRange getRange(String permission) {
    if (GlobalCapability.hasRange(permission)) {
        return toRange(permission, access(permission));
    }
    return null;
}
#end_block

#method_before
private String comparePattern() {
    if (getRefPattern().startsWith(REGEX_PREFIX)) {
        return getRefPattern().substring(REGEX_PREFIX.length());
    }
    return getRefPattern();
}
#method_after
private String comparePattern() {
    if (getName().startsWith(REGEX_PREFIX)) {
        return getName().substring(REGEX_PREFIX.length());
    }
    return getName();
}
#end_block

#method_before
@Override
public String toString() {
    return "AccessSection[" + getRefPattern() + "]";
}
#method_after
@Override
public String toString() {
    return "AccessSection[" + getName() + "]";
}
#end_block

#method_before
private void initWildCardProject() throws IOException, ConfigInvalidException {
    Repository git;
    try {
        git = mgr.openRepository(DEFAULT_WILD_NAME);
    } catch (RepositoryNotFoundException notFound) {
        // inheritable permissions. For example '-- All Projects --'.
        try {
            git = mgr.createRepository(DEFAULT_WILD_NAME);
        } catch (RepositoryNotFoundException err) {
            final String name = DEFAULT_WILD_NAME.get();
            throw new IOException("Cannot create repository " + name, err);
        }
    }
    try {
        MetaDataUpdate md = new MetaDataUpdate(new NoReplication(), DEFAULT_WILD_NAME, git);
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        ProjectConfig config = ProjectConfig.read(md);
        Project p = config.getProject();
        p.setDescription("Rights inherited by all other projects");
        p.setUseContributorAgreements(false);
        AccessSection cap = config.getAccessSection(AccessSection.GLOBAL_CAPABILITIES, true);
        cap.getPermission(GlobalCapability.QUERY_LIMIT, true).add(rule(config, registered, 0, 500));
        AccessSection all = config.getAccessSection(AccessSection.ALL, true);
        AccessSection heads = config.getAccessSection(AccessSection.HEADS, true);
        AccessSection meta = config.getAccessSection(GitRepositoryManager.REF_CONFIG, true);
        PermissionRule review = rule(config, registered);
        review.setRange(-1, 1);
        heads.getPermission(Permission.LABEL + "Code-Review", true).add(review);
        // 
        all.getPermission(Permission.READ, true).add(rule(config, admin));
        // 
        all.getPermission(Permission.READ, true).add(rule(config, anonymous));
        // 
        config.getAccessSection("refs/for/" + AccessSection.ALL, true).getPermission(Permission.PUSH, // 
        true).add(rule(config, registered));
        // 
        all.getPermission(Permission.FORGE_AUTHOR, true).add(rule(config, registered));
        // 
        meta.getPermission(Permission.READ, true).add(rule(config, owners));
        md.setMessage("Initialized Gerrit Code Review " + Version.getVersion());
        if (!config.commit(md)) {
            throw new IOException("Cannot create " + DEFAULT_WILD_NAME.get());
        }
    } finally {
        git.close();
    }
}
#method_after
private void initWildCardProject() throws IOException, ConfigInvalidException {
    Repository git;
    try {
        git = mgr.openRepository(DEFAULT_WILD_NAME);
    } catch (RepositoryNotFoundException notFound) {
        // inheritable permissions. For example 'All-Projects'.
        try {
            git = mgr.createRepository(DEFAULT_WILD_NAME);
        } catch (RepositoryNotFoundException err) {
            final String name = DEFAULT_WILD_NAME.get();
            throw new IOException("Cannot create repository " + name, err);
        }
    }
    try {
        MetaDataUpdate md = new MetaDataUpdate(new NoReplication(), DEFAULT_WILD_NAME, git);
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        ProjectConfig config = ProjectConfig.read(md);
        Project p = config.getProject();
        p.setDescription("Rights inherited by all other projects");
        p.setUseContributorAgreements(false);
        AccessSection capabilities = config.getAccessSection(AccessSection.GLOBAL_CAPABILITIES, true);
        PermissionRange.WithDefaults queryLimit = GlobalCapability.getRange(GlobalCapability.QUERY_LIMIT);
        capabilities.getPermission(GlobalCapability.QUERY_LIMIT, true).add(rule(config, anonymous, queryLimit.getDefaultMax(), queryLimit.getDefaultMax()));
        AccessSection all = config.getAccessSection(AccessSection.ALL, true);
        AccessSection heads = config.getAccessSection(AccessSection.HEADS, true);
        AccessSection meta = config.getAccessSection(GitRepositoryManager.REF_CONFIG, true);
        PermissionRule review = rule(config, registered);
        review.setRange(-1, 1);
        heads.getPermission(Permission.LABEL + "Code-Review", true).add(review);
        // 
        all.getPermission(Permission.READ, true).add(rule(config, admin));
        // 
        all.getPermission(Permission.READ, true).add(rule(config, anonymous));
        // 
        config.getAccessSection("refs/for/" + AccessSection.ALL, true).getPermission(Permission.PUSH, // 
        true).add(rule(config, registered));
        // 
        all.getPermission(Permission.FORGE_AUTHOR, true).add(rule(config, registered));
        // 
        meta.getPermission(Permission.READ, true).add(rule(config, owners));
        md.setMessage("Initialized Gerrit Code Review " + Version.getVersion());
        if (!config.commit(md)) {
            throw new IOException("Cannot create " + DEFAULT_WILD_NAME.get());
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
public void remove(AccessSection section) {
    if (section != null) {
        accessSections.remove(section.getRefPattern());
    }
}
#method_after
public void remove(AccessSection section) {
    if (section != null) {
        accessSections.remove(section.getName());
    }
}
#end_block

#method_before
public void replace(AccessSection section) {
    for (Permission permission : section.getPermissions()) {
        for (PermissionRule rule : permission.getRules()) {
            rule.setGroup(resolve(rule.getGroup()));
        }
    }
    accessSections.put(section.getRefPattern(), section);
}
#method_after
public void replace(AccessSection section) {
    for (Permission permission : section.getPermissions()) {
        for (PermissionRule rule : permission.getRules()) {
            rule.setGroup(resolve(rule.getGroup()));
        }
    }
    accessSections.put(section.getName(), section);
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(rc.getBoolean(RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(rc.getBoolean(RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(rc.getBoolean(RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(rc.getEnum(SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(rc.getBoolean(SUBMIT, null, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    prologRules = readUTF8("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#end_block

#method_before
private void loadPermissionRules(Config rc, String section, String subsection, String varName, Map<String, GroupReference> groupsByName, Permission perm, boolean useRange) throws ConfigInvalidException {
    for (String ruleString : rc.getStringList(section, subsection, varName)) {
        PermissionRule rule;
        try {
            rule = PermissionRule.fromString(ruleString, useRange);
        } catch (IllegalArgumentException notRule) {
            throw new ConfigInvalidException("Invalid rule in " + section + (subsection != null ? "." + subsection : "") + "." + varName + ": " + notRule.getMessage(), notRule);
        }
        GroupReference ref = groupsByName.get(rule.getGroup().getName());
        if (ref == null) {
            // The group wasn't mentioned in the groups table, so there is
            // no valid UUID for it. Pool the reference anyway so at least
            // all rules in the same file share the same GroupReference.
            // 
            ref = rule.getGroup();
            groupsByName.put(ref.getName(), ref);
        }
        rule.setGroup(ref);
        perm.add(rule);
    }
}
#method_after
private void loadPermissionRules(Config rc, String section, String subsection, String varName, Map<String, GroupReference> groupsByName, Permission perm, boolean useRange) {
    for (String ruleString : rc.getStringList(section, subsection, varName)) {
        PermissionRule rule;
        try {
            rule = PermissionRule.fromString(ruleString, useRange);
        } catch (IllegalArgumentException notRule) {
            error(new ValidationError(PROJECT_CONFIG, "Invalid rule in " + section + (subsection != null ? "." + subsection : "") + "." + varName + ": " + notRule.getMessage()));
            continue;
        }
        GroupReference ref = groupsByName.get(rule.getGroup().getName());
        if (ref == null) {
            // The group wasn't mentioned in the groups table, so there is
            // no valid UUID for it. Pool the reference anyway so at least
            // all rules in the same file share the same GroupReference.
            // 
            ref = rule.getGroup();
            groupsByName.put(ref.getName(), ref);
            error(new ValidationError(PROJECT_CONFIG, "group \"" + ref.getName() + "\" not in " + GROUP_LIST));
        }
        rule.setGroup(ref);
        perm.add(rule);
    }
}
#end_block

#method_before
private Map<String, GroupReference> readGroupList() throws IOException, ConfigInvalidException {
    groupsByUUID = new HashMap<AccountGroup.UUID, GroupReference>();
    Map<String, GroupReference> groupsByName = new HashMap<String, GroupReference>();
    BufferedReader br = new BufferedReader(new StringReader(readUTF8(GROUP_LIST)));
    String s;
    while ((s = br.readLine()) != null) {
        if (s.isEmpty() || s.startsWith("#")) {
            continue;
        }
        int tab = s.indexOf('\t');
        if (tab < 0) {
            throw new ConfigInvalidException("Invalid group line: " + s);
        }
        AccountGroup.UUID uuid = new AccountGroup.UUID(s.substring(0, tab).trim());
        String name = s.substring(tab + 1).trim();
        GroupReference ref = new GroupReference(uuid, name);
        groupsByUUID.put(uuid, ref);
        groupsByName.put(name, ref);
    }
    return groupsByName;
}
#method_after
private Map<String, GroupReference> readGroupList() throws IOException {
    groupsByUUID = new HashMap<AccountGroup.UUID, GroupReference>();
    Map<String, GroupReference> groupsByName = new HashMap<String, GroupReference>();
    BufferedReader br = new BufferedReader(new StringReader(readUTF8(GROUP_LIST)));
    String s;
    for (int lineNumber = 1; (s = br.readLine()) != null; lineNumber++) {
        if (s.isEmpty() || s.startsWith("#")) {
            continue;
        }
        int tab = s.indexOf('\t');
        if (tab < 0) {
            error(new ValidationError(GROUP_LIST, lineNumber, "missing tab delimiter"));
            continue;
        }
        AccountGroup.UUID uuid = new AccountGroup.UUID(s.substring(0, tab).trim());
        String name = s.substring(tab + 1).trim();
        GroupReference ref = new GroupReference(uuid, name);
        groupsByUUID.put(uuid, ref);
        groupsByName.put(name, ref);
    }
    return groupsByName;
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getRefPattern();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(CapabilityControl.Factory.class).in(SINGLETON);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(CapabilityControl.Factory.class).in(SINGLETON);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includePatchSets) {
                    eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                    }
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (defaultLimit == 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includePatchSets) {
                    eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                    }
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
boolean wouldPushProject(Project.NameKey project) {
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    for (final String projectMatch : projects) {
        String projectName = project.get();
        if (isRE(projectMatch)) {
            // projectMatch is a regular expression
            if (projectName.matches(projectMatch)) {
                return true;
            }
        } else if (isWildcard(projectMatch)) {
            // projectMatch is a wildcard
            if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                return true;
            }
        } else {
            // No special case, so we try to match directly
            if (projectName.equals(projectMatch)) {
                return true;
            }
        }
    }
    // Nothing matched, so don't push the project
    return false;
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    String projectName = project.get();
    for (final String projectMatch : projects) {
        if (isRE(projectMatch)) {
            // projectMatch is a regular expression
            if (projectName.matches(projectMatch)) {
                return true;
            }
        } else if (isWildcard(projectMatch)) {
            // projectMatch is a wildcard
            if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                return true;
            }
        } else {
            // No special case, so we try to match directly
            if (projectName.equals(projectMatch)) {
                return true;
            }
        }
    }
    // Nothing matched, so don't push the project
    return false;
}
#end_block

#method_before
boolean isSingleProjectMatch() {
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (isRE(projectMatch) || isWildcard(projectMatch)) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Eventhough they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#method_after
boolean isSingleProjectMatch() {
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (isRE(projectMatch) || isWildcard(projectMatch)) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setEdit(false);
            setMessageText(message);
            setDateText(FormatUtil.shortFormatDayTime(result.updated()));
            resizePaddingWidget();
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
}
#method_after
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setEdit(false);
            setMessageText(message);
            setDate(result.updated());
            resizePaddingWidget();
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
}
#end_block

#method_before
public static CommentInput create(CommentInfo original) {
    CommentInput input = createObject().cast();
    input.setId(original.id());
    input.setPath(original.path());
    input.setSide(original.side());
    input.setLine(original.line());
    input.setInReplyTo(original.in_reply_to());
    input.setMessage(original.message());
    return input;
}
#method_after
public static CommentInput create(CommentInfo original) {
    CommentInput input = createObject().cast();
    input.setId(original.id());
    input.setPath(original.path());
    input.setSide(original.side());
    if (original.has_line()) {
        input.setLine(original.line());
    }
    input.setInReplyTo(original.in_reply_to());
    input.setMessage(original.message());
    return input;
}
#end_block

#method_before
@Override
public void onUnload() {
    super.onUnload();
    if (messageClick != null) {
        messageClick.removeHandler();
        messageClick = null;
    }
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    if (messageClick != null) {
        messageClick.removeHandler();
        messageClick = null;
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    headerClick = header.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setOpen(!isOpen());
            if (clickCallback != null) {
                clickCallback.run();
            }
        }
    }, ClickEvent.getType());
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    headerClick = header.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setOpen(!isOpen());
            if (clickCallback != null) {
                clickCallback.run();
            }
        }
    }, ClickEvent.getType());
    res.style().ensureInjected();
}
#end_block

#method_before
private void setOpen(boolean open) {
    if (open) {
        removeStyleName(style.close());
        addStyleName(style.open());
    } else {
        removeStyleName(style.open());
        addStyleName(style.close());
    }
}
#method_after
private void setOpen(boolean open) {
    if (open) {
        removeStyleName(res.style().close());
        addStyleName(res.style().open());
    } else {
        removeStyleName(res.style().open());
        addStyleName(res.style().close());
    }
}
#end_block

#method_before
private boolean isOpen() {
    return getStyleName().contains(style.open());
}
#method_after
private boolean isOpen() {
    return getStyleName().contains(res.style().open());
}
#end_block

#method_before
@Override
public void insert(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    commit(openIndex);
    commit(closedIndex);
}
#method_after
@Override
public void insert(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
    commit(openIndex);
    commit(closedIndex);
}
#end_block

#method_before
@Override
public void replace(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    commit(openIndex);
    commit(closedIndex);
}
#method_after
@Override
public void replace(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
    commit(openIndex);
    commit(closedIndex);
}
#end_block

#method_before
@Override
public void delete(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    try {
        if (cd.getChange().getStatus().isOpen()) {
            openIndex.deleteById(id);
            commit(openIndex);
        } else {
            closedIndex.deleteById(id);
            commit(closedIndex);
        }
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
#method_after
@Override
public void delete(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    try {
        if (cd.getChange().getStatus().isOpen()) {
            openIndex.deleteById(id);
            commit(openIndex);
        } else {
            closedIndex.deleteById(id);
            commit(closedIndex);
        }
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public void deleteAll() throws IOException {
    try {
        openIndex.deleteByQuery("*:*");
        closedIndex.deleteByQuery("*:*");
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    commit(openIndex);
    commit(closedIndex);
}
#method_after
@Override
public void deleteAll() throws IOException {
    try {
        openIndex.deleteByQuery("*:*");
        closedIndex.deleteByQuery("*:*");
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
    commit(openIndex);
    commit(closedIndex);
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SolrServer> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, toQuery(p));
}
#method_after
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SolrServer> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, QueryBuilder.toQuery(p));
}
#end_block

#method_before
private void commit(SolrServer server) throws IOException {
    try {
        server.commit();
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
#method_after
private void commit(SolrServer server) throws IOException {
    try {
        server.commit();
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = null;
        SolrDocumentList docs = new SolrDocumentList();
        query.setParam("shards.tolerant", true);
        for (SolrServer index : indexes) {
            QueryResponse rsp = index.query(query);
            docs.addAll(rsp.getResults());
        }
        result = Lists.newArrayListWithCapacity(docs.size());
        for (SolrDocument doc : docs) {
            Integer v = (Integer) doc.getFieldValue(FIELD_CHANGE);
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = null;
        SolrDocumentList docs = new SolrDocumentList();
        query.setParam("shards.tolerant", true);
        for (SolrServer index : indexes) {
            QueryResponse rsp = index.query(query);
            docs.addAll(rsp.getResults());
        }
        result = Lists.newArrayListWithCapacity(docs.size());
        for (SolrDocument doc : docs) {
            Integer v = (Integer) doc.getFieldValue(FIELD_CHANGE);
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (SolrServerException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
public static IndexImplementation getChangeIndexImpl(Injector injector) {
    if (isEnabled(injector)) {
        Config config = injector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String implementation = config.getString("index", null, "implementation");
        if ("solr".equals(implementation)) {
            return IndexImplementation.SOLR;
        } else {
            return IndexImplementation.LUCENE;
        }
    }
    return IndexImplementation.NONE;
}
#method_after
public static IndexType getChangeIndexImpl(Injector injector) {
    if (isEnabled(injector)) {
        Config config = injector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        return config.getEnum("index", null, "type", IndexType.LUCENE);
    }
    return IndexType.NONE;
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(IndexModule.getSolrUrl(cfgInjector));
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = cfgInjector.getInstance(SolrIndexModule.class);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    install(new IndexModule(threads));
    bind(String.class).annotatedWith(Names.named("url")).toInstance(url);
    bind(ChangeIndex.class).to(SolrChangeIndex.class);
    listener().to(SolrChangeIndex.class);
    if (checkVersion) {
        listener().to(SolrIndexVersionCheck.class);
    }
}
#method_after
@Override
protected void configure() {
    install(new IndexModule(threads));
    bind(String.class).annotatedWith(SolrIndexUrl.class).toInstance(url);
    bind(ChangeIndex.class).to(SolrChangeIndex.class);
    listener().to(SolrChangeIndex.class);
    if (checkVersion) {
        listener().to(IndexVersionCheck.class);
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!IndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sitePaths = dbInjector.getInstance(SitePaths.class);
    // Delete before any LuceneChangeIndex may be created.
    deleteAll();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    int result = indexAll();
    writeVersion();
    sysManager.stop();
    dbManager.stop();
    return result;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!IndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    cfgInjector = createCfgInjector();
    sysInjector = createSysInjector();
    // Delete before any LuceneChangeIndex may be created.
    deleteAll();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    int result = indexAll();
    writeVersion();
    sysManager.stop();
    dbManager.stop();
    return result;
}
#end_block

#method_before
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(false, threads, dryRun);
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(IndexModule.getSolrUrl(dbInjector), false, threads);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    modules.add(new AbstractModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(false, threads, dryRun);
            break;
        case SOLR:
            Config config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
            changeIndexModule = new SolrIndexModule(config, false, threads);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    modules.add(new AbstractModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private void writeVersion() throws IOException, ConfigInvalidException {
    if (dryRun) {
        return;
    }
    switch(IndexModule.getChangeIndexImpl(dbInjector)) {
        case LUCENE:
            LuceneIndexVersionCheck.writeVersion(sitePaths);
            break;
        case SOLR:
            SolrIndexVersionCheck.writeVersion(sitePaths);
            break;
        default:
            return;
    }
}
#method_after
private void writeVersion() throws IOException, ConfigInvalidException {
    if (dryRun) {
        return;
    }
    ChangeIndex index = sysInjector.getInstance(ChangeIndex.class);
    index.finishIndex();
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(IndexModule.getSolrUrl(cfgInjector));
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = cfgInjector.getInstance(SolrIndexModule.class);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SubIndex> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, toQuery(p));
}
#method_after
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SubIndex> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, QueryBuilder.toQuery(p));
}
#end_block

#method_before
private Term idTerm(ChangeData cd) {
    return intTerm(FIELD_CHANGE, cd.getId().get());
}
#method_after
private Term idTerm(ChangeData cd) {
    return QueryBuilder.intTerm(FIELD_CHANGE, cd.getId().get());
}
#end_block

#method_before
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#method_after
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw QueryBuilder.badFieldType(f.getType());
    }
}
#end_block

#method_before
private void getPathsAndIndex(RevCommit bCommit) throws Exception {
    RevTree bTree = bCommit.getTree();
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            List<ChangeData> cds = byId.get(bCommit);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                for (ChangeData cd : cds) {
                    try {
                        cd.setCurrentFilePaths(paths);
                        indexer.indexTask(cd).call();
                        done.update(1);
                        if (verbose) {
                            System.out.println("Reindexed change " + cd.getId());
                        }
                    } catch (Exception e) {
                        log.warn("Failed to index change " + cd.getId(), e);
                        if (verbose) {
                            System.out.println("Failed to index change " + cd.getId());
                        }
                        failed.update(1);
                    }
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        log.warn("Failed to index changes for commit " + bCommit.name(), e);
        if (verbose) {
            System.out.println("Failed to index changes for commit " + bCommit.name());
        }
        failed.update(1);
    }
}
#method_after
private void getPathsAndIndex(RevCommit bCommit) throws Exception {
    RevTree bTree = bCommit.getTree();
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            List<ChangeData> cds = byId.get(bCommit);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                for (ChangeData cd : cds) {
                    cd.setCurrentFilePaths(paths);
                    indexer.indexTask(cd).call();
                    done.update(1);
                    if (verbose) {
                        System.out.println("Reindexed change " + cd.getId());
                    }
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        fail("Failed to index commit " + bCommit.name(), e);
    }
}
#end_block

#method_before
@Override
public boolean match(ChangeData object) throws OrmException {
    try {
        return object.commitMessage(repoManager, db).contains(value);
    } catch (IOException e) {
        return false;
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public boolean match(ChangeData object) throws OrmException {
    try {
        for (ChangeData cData : index.getSource(Predicate.and(new LegacyChangeIdPredicate(db, object.getId()), this)).read()) {
            if (cData.getId().equals(object.getId())) {
                return true;
            }
        }
    } catch (QueryParseException e) {
        throw new OrmException(e);
    }
    return false;
}
#end_block

#method_before
@Override
public void start() {
// Do nothing.
}
#method_after
@Override
public void start() {
}
#end_block

#method_before
@Override
public void stop() {
    openIndex.close();
    closedIndex.close();
}
#method_after
@Override
public void stop() {
    List<Future<?>> closeFutures = Lists.newArrayListWithCapacity(2);
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            openIndex.close();
        }
    }));
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            closedIndex.close();
        }
    }));
    for (Future<?> future : closeFutures) {
        Futures.getUnchecked(future);
    }
}
#end_block

#method_before
@Override
public void insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.insert(doc);
    } else {
        openIndex.delete(id);
        closedIndex.insert(doc);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListenableFuture<Void> insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return Futures.immediateFuture(null);
    }
    if (cd.getChange().getStatus().isOpen()) {
        return allOf(closedIndex.delete(id), openIndex.insert(doc));
    } else {
        return allOf(openIndex.delete(id), closedIndex.insert(doc));
    }
}
#end_block

#method_before
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.replace(id, doc);
    } else {
        openIndex.delete(id);
        closedIndex.replace(id, doc);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListenableFuture<Void> replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return Futures.immediateFuture(null);
    }
    if (cd.getChange().getStatus().isOpen()) {
        return allOf(closedIndex.delete(id), openIndex.replace(id, doc));
    } else {
        return allOf(openIndex.delete(id), closedIndex.replace(id, doc));
    }
}
#end_block

#method_before
@Override
public void delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (cd.getChange().getStatus().isOpen()) {
        openIndex.delete(id);
    } else {
        closedIndex.delete(id);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListenableFuture<Void> delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (readOnly) {
        return Futures.immediateFuture(null);
    }
    return allOf(openIndex.delete(id), closedIndex.delete(id));
}
#end_block

#method_before
private Term idTerm(ChangeData cd) {
    return intTerm(FIELD_CHANGE, cd.getId().get());
}
#method_after
private Term idTerm(ChangeData cd) {
    return intTerm(ID_FIELD, cd.getId().get());
}
#end_block

#method_before
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#method_after
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        if (p.getChild(0) instanceof TimestampRangePredicate) {
            return notTimestampQuery((TimestampRangePredicate<ChangeData>) p.getChild(0));
        }
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#end_block

#method_before
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else if (p.getType() == FieldType.FULL_TEXT) {
        return fullTextQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#method_after
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.TIMESTAMP) {
        return timestampQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else if (p.getType() == FieldType.PREFIX) {
        return prefixQuery(p);
    } else if (p.getType() == FieldType.FULL_TEXT) {
        return fullTextQuery(p);
    } else if (p instanceof SortKeyPredicate) {
        return sortKeyQuery((SortKeyPredicate) p);
    } else {
        throw badFieldType(p.getType());
    }
}
#end_block

#method_before
private Query intQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    int value;
    try {
        // Can't use IntPredicate because it and IndexPredicate are different
        // subclasses of OperatorPredicate.
        value = Integer.valueOf(p.getValue());
    } catch (IllegalArgumentException e) {
        throw new QueryParseException("not an integer: " + p.getValue());
    }
    return new TermQuery(intTerm(p.getOperator(), value));
}
#method_after
private Query intQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    int value;
    try {
        // Can't use IntPredicate because it and IndexPredicate are different
        // subclasses of OperatorPredicate.
        value = Integer.valueOf(p.getValue());
    } catch (IllegalArgumentException e) {
        throw new QueryParseException("not an integer: " + p.getValue());
    }
    return new TermQuery(intTerm(p.getField().getName(), value));
}
#end_block

#method_before
private Query exactQuery(IndexPredicate<ChangeData> p) {
    return new TermQuery(new Term(p.getOperator(), p.getValue()));
}
#method_after
private Query exactQuery(IndexPredicate<ChangeData> p) {
    if (p instanceof RegexPredicate<?>) {
        return regexQuery(p);
    } else {
        return new TermQuery(new Term(p.getField().getName(), p.getValue()));
    }
}
#end_block

#method_before
private Query fullTextQuery(IndexPredicate<ChangeData> p) {
    return new FuzzyQuery(new Term(p.getOperator(), p.getValue()));
}
#method_after
private Query fullTextQuery(IndexPredicate<ChangeData> p) {
    return new FuzzyQuery(new Term(p.getField().getName(), p.getValue()));
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = Lists.newArrayListWithExpectedSize(2 * getCardinality());
        for (SubIndex index : indexes) {
            result.addAll(index.search(query, LIMIT));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    Sort sort = new Sort(new SortField(ChangeField.UPDATED.getName(), SortField.Type.INT, true));
    try {
        TopDocs[] hits = new TopDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, LIMIT, sort);
        }
        TopDocs docs = TopDocs.merge(sort, LIMIT, hits);
        List<ChangeData> result = Lists.newArrayListWithCapacity(docs.scoreDocs.length);
        for (ScoreDoc sd : docs.scoreDocs) {
            Document doc = searchers[sd.shardIndex].doc(sd.doc, FIELDS);
            Number v = doc.getField(ID_FIELD).numericValue();
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                add(result, f, Collections.singleton(f.get(cd, fillArgs)));
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#method_after
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                Object val = f.get(cd, fillArgs);
                if (val != null) {
                    add(result, f, Collections.singleton(val));
                }
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else if (f.getType() == FieldType.FULL_TEXT) {
        for (Object value : values) {
            doc.add(new TextField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#method_after
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    String name = f.getName();
    Store store = store(f);
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (f.getType() == FieldType.LONG) {
        for (Object value : values) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (f.getType() == FieldType.TIMESTAMP) {
        for (Object v : values) {
            doc.add(new IntField(name, toIndexTime((Timestamp) v), store));
        }
    } else if (f.getType() == FieldType.EXACT || f.getType() == FieldType.PREFIX) {
        for (Object value : values) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (f.getType() == FieldType.FULL_TEXT) {
        for (Object value : values) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#end_block

#method_before
void scheduleFullSync(final Project.NameKey project, final String urlMatch) {
    if (!running) {
        log.warn("Replication plugin did not finish startup before event");
        return;
    }
    for (Destination cfg : configs) {
        for (URIish uri : cfg.getURIs(project, urlMatch)) {
            cfg.schedule(project, PushOne.ALL_REFS, uri);
        }
    }
}
#method_after
void scheduleFullSync(final Project.NameKey project, final String urlMatch) {
    if (!running) {
        log.warn("Replication plugin did not finish startup before event");
        return;
    }
    for (Destination cfg : configs) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri);
            }
        }
    }
}
#end_block

#method_before
private List<Destination> allDestinations(File cfgPath) throws ConfigInvalidException, IOException {
    FileBasedConfig cfg = new FileBasedConfig(cfgPath, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = cfg.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
            }
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        dest.add(new Destination(injector, c, cfg, database, replicationUserFactory, internalUserFactory, gitRepositoryManager, groupBackend));
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations(File cfgPath) throws ConfigInvalidException, IOException {
    FileBasedConfig cfg = new FileBasedConfig(cfgPath, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = cfg.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
            }
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        dest.add(new Destination(injector, c, cfg, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend));
    }
    return dest.build();
}
#end_block

#method_before
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs) {
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#method_after
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs) {
        if (!config.wouldPushProject(projectName)) {
            continue;
        }
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#end_block

#method_before
boolean wouldPushProject(Project.NameKey project) {
    if (projectMatch != null) {
        if (projectMatch.endsWith("/*")) {
            // special case
            return project.get().startsWith(projectMatch.substring(0, projectMatch.length() - 1));
        } else {
            String projectPattern;
            if (isRE(projectMatch)) {
                projectPattern = projectMatch.substring(1);
            } else {
                projectPattern = projectMatch;
            }
            return (new RegExp(projectPattern)).toAutomaton().run(project.get());
        }
    }
    return true;
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    String projectName = project.get();
    for (final String projectMatch : projects) {
        if (isRE(projectMatch)) {
            // projectMatch is a regular expression
            if (projectName.matches(projectMatch)) {
                return true;
            }
        } else if (isWildcard(projectMatch)) {
            // projectMatch is a wildcard
            if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                return true;
            }
        } else {
            // No special case, so we try to match directly
            if (projectName.equals(projectMatch)) {
                return true;
            }
        }
    }
    // Nothing matched, so don't push the project
    return false;
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name);
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (!remoteNameStyle.equals("slash")) {
                ReplicationQueue.log.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name);
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args.dbProvider, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate(args.dbProvider);
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(args.dbProvider, self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(args.dbProvider, self());
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args.dbProvider, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate(args.dbProvider);
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(args.dbProvider, self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(args.dbProvider, self());
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> branch(String name) {
    if (name.startsWith("^"))
        return new RegexBranchPredicate(args.dbProvider, name);
    return new BranchPredicate(args.dbProvider, name);
}
#method_after
@Operator
public Predicate<ChangeData> branch(String name) {
    if (name.startsWith("^"))
        return ref("^" + branchToRef(name.substring(1)));
    return ref(branchToRef(name));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (!allowsFile) {
        throw error("operator not permitted here: file:" + file);
    }
    if (file.startsWith("^")) {
        return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        if (allowFileRegex || args.index != ChangeIndex.DISABLED) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw error("secondary index must be enabled for file:" + file);
        }
    } else {
        if (args.index == ChangeIndex.DISABLED) {
            throw error("secondary index must be enabled for file:" + file);
        }
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    String[] splitReviewer = name.split("~");
    name = splitReviewer[0];
    if (splitReviewer.length > 2) {
        throw new QueryParseException("more than one user specified");
    } else if (splitReviewer.length == 2) {
        accounts = parseAccount(splitReviewer[1]);
    }
    return new LabelPredicate(args.changeControlGenericFactory, args.userFactory, args.dbProvider, args.approvalTypes, name, accounts);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                accounts = parseAccount(pair.getValue());
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                accounts = parseAccount(value);
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    return new LabelPredicate(args.projectCache, args.changeControlGenericFactory, args.userFactory, args.dbProvider, name, accounts, group);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser instanceof IdentifiedUser && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id)));
        }
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser instanceof IdentifiedUser && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser, false));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id), true));
        }
    }
    return Predicate.or(p);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(args.dbProvider, id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<AccountGroup.UUID>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(args.dbProvider, id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<AccountGroup.UUID>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
public Builder copyFrom(GitilesView other) {
    hostName = other.hostName;
    servletPath = other.servletPath;
    switch(type) {
        case LOG:
        case DIFF:
            oldRevision = other.oldRevision;
        // Fallthrough.
        case PATH:
            path = other.path;
        // Fallthrough.
        case REVISION:
        case TAR:
        case ZIP:
            revision = other.revision;
        // Fallthrough.
        case DESCRIBE:
        case REFS:
        case REPOSITORY_INDEX:
            repositoryName = other.repositoryName;
        // Fallthrough.
        default:
            break;
    }
    // Don't copy params.
    return this;
}
#method_after
public Builder copyFrom(GitilesView other) {
    hostName = other.hostName;
    servletPath = other.servletPath;
    switch(type) {
        case LOG:
        case DIFF:
            oldRevision = other.oldRevision;
        // Fallthrough.
        case PATH:
            path = other.path;
        // Fallthrough.
        case REVISION:
        case ARCHIVE:
            revision = other.revision;
        // Fallthrough.
        case DESCRIBE:
        case REFS:
        case REPOSITORY_INDEX:
            repositoryName = other.repositoryName;
        // Fallthrough.
        default:
            break;
    }
    if (type == Type.ARCHIVE) {
        extension = other.extension;
    }
    // Don't copy params.
    return this;
}
#end_block

#method_before
public Builder setOldRevision(Revision revision) {
    switch(type) {
        case DIFF:
        case LOG:
            this.oldRevision = checkNotNull(revision);
            return this;
        default:
            throw new IllegalStateException(String.format("cannot set old revision on %s view", type));
    }
}
#method_after
public Builder setOldRevision(Revision revision) {
    switch(type) {
        case DIFF:
        case LOG:
            this.oldRevision = revision;
            return this;
        default:
            throw new IllegalStateException(String.format("cannot set old revision on %s view", type));
    }
}
#end_block

#method_before
public GitilesView build() {
    switch(type) {
        case HOST_INDEX:
            checkHostIndex();
            break;
        case REPOSITORY_INDEX:
            checkRepositoryIndex();
            break;
        case REFS:
            checkRefs();
            break;
        case DESCRIBE:
            checkDescribe();
            break;
        case REVISION:
            checkRevision();
            break;
        case PATH:
            checkPath();
            break;
        case DIFF:
            checkDiff();
            break;
        case LOG:
            checkLog();
            break;
        case TAR:
        case ZIP:
            checkArchive();
            break;
    }
    return new GitilesView(type, hostName, servletPath, repositoryName, revision, oldRevision, path, params, anchor);
}
#method_after
public GitilesView build() {
    switch(type) {
        case HOST_INDEX:
            checkHostIndex();
            break;
        case REPOSITORY_INDEX:
            checkRepositoryIndex();
            break;
        case REFS:
            checkRefs();
            break;
        case DESCRIBE:
            checkDescribe();
            break;
        case REVISION:
            checkRevision();
            break;
        case PATH:
            checkPath();
            break;
        case DIFF:
            checkDiff();
            break;
        case LOG:
            checkLog();
            break;
        case ARCHIVE:
            checkArchive();
            break;
    }
    return new GitilesView(type, hostName, servletPath, repositoryName, revision, oldRevision, path, extension, params, anchor);
}
#end_block

#method_before
public String toUrl() {
    StringBuilder url = new StringBuilder(servletPath).append('/');
    ListMultimap<String, String> params = this.params;
    switch(type) {
        case HOST_INDEX:
            params = LinkedListMultimap.create();
            if (!this.params.containsKey("format")) {
                params.put("format", FormatType.HTML.toString());
            }
            params.putAll(this.params);
            break;
        case REPOSITORY_INDEX:
            url.append(repositoryName).append('/');
            break;
        case REFS:
            url.append(repositoryName).append("/+refs");
            break;
        case DESCRIBE:
            url.append(repositoryName).append("/+describe");
            break;
        case REVISION:
            url.append(repositoryName).append("/+/").append(revision.getName());
            break;
        case TAR:
            url.append(repositoryName).append("/+tar/").append(revision.getName());
            break;
        case ZIP:
            url.append(repositoryName).append("/+zip/").append(revision.getName());
            break;
        case PATH:
            url.append(repositoryName).append("/+/").append(revision.getName()).append('/').append(path);
            break;
        case DIFF:
            url.append(repositoryName).append("/+/");
            if (isFirstParent(revision, oldRevision)) {
                url.append(revision.getName()).append("^!");
            } else {
                url.append(oldRevision.getName()).append("..").append(revision.getName());
            }
            url.append('/').append(path);
            break;
        case LOG:
            url.append(repositoryName).append("/+log");
            if (revision != Revision.NULL) {
                url.append('/');
                if (oldRevision != Revision.NULL) {
                    url.append(oldRevision.getName()).append("..");
                }
                url.append(revision.getName());
                if (path != null) {
                    url.append('/').append(path);
                }
            }
            break;
        default:
            throw new IllegalStateException("Unknown view type: " + type);
    }
    String baseUrl = NAME_ESCAPER.apply(url.toString());
    url = new StringBuilder();
    if (!params.isEmpty()) {
        url.append('?').append(paramsToString(params));
    }
    if (!Strings.isNullOrEmpty(anchor)) {
        url.append('#').append(NAME_ESCAPER.apply(anchor));
    }
    return baseUrl + url.toString();
}
#method_after
public String toUrl() {
    StringBuilder url = new StringBuilder(servletPath).append('/');
    ListMultimap<String, String> params = this.params;
    switch(type) {
        case HOST_INDEX:
            params = LinkedListMultimap.create();
            if (!this.params.containsKey("format")) {
                params.put("format", FormatType.HTML.toString());
            }
            params.putAll(this.params);
            break;
        case REPOSITORY_INDEX:
            url.append(repositoryName).append('/');
            break;
        case REFS:
            url.append(repositoryName).append("/+refs");
            break;
        case DESCRIBE:
            url.append(repositoryName).append("/+describe");
            break;
        case REVISION:
            url.append(repositoryName).append("/+/").append(revision.getName());
            break;
        case ARCHIVE:
            url.append(repositoryName).append("/+archive/").append(revision.getName()).append(Objects.firstNonNull(extension, DEFAULT_ARCHIVE_EXTENSION));
            break;
        case PATH:
            url.append(repositoryName).append("/+/").append(revision.getName()).append('/').append(path);
            break;
        case DIFF:
            url.append(repositoryName).append("/+/");
            if (isFirstParent(revision, oldRevision)) {
                url.append(revision.getName()).append("^!");
            } else {
                url.append(oldRevision.getName()).append("..").append(revision.getName());
            }
            url.append('/').append(path);
            break;
        case LOG:
            url.append(repositoryName).append("/+log");
            if (revision != Revision.NULL) {
                url.append('/');
                if (oldRevision != Revision.NULL) {
                    url.append(oldRevision.getName()).append("..");
                }
                url.append(revision.getName());
                if (path != null) {
                    url.append('/').append(path);
                }
            }
            break;
        default:
            throw new IllegalStateException("Unknown view type: " + type);
    }
    String baseUrl = NAME_ESCAPER.apply(url.toString());
    url = new StringBuilder();
    if (!params.isEmpty()) {
        url.append('?').append(paramsToString(params));
    }
    if (!Strings.isNullOrEmpty(anchor)) {
        url.append('#').append(NAME_ESCAPER.apply(anchor));
    }
    return baseUrl + url.toString();
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    GitilesView view = ViewFilter.getView(req);
    Revision rev = view.getRevision();
    Repository repo = ServletUtils.getRepository(req);
    // Check object type before starting the archive. If we just caught the
    // exception from cmd.call() below, we wouldn't know whether it was because
    // the input object is not a tree or something broke later.
    RevWalk walk = new RevWalk(repo);
    try {
        walk.parseTree(rev.getId());
    } catch (IncorrectObjectTypeException e) {
        res.sendError(SC_NOT_FOUND);
        return;
    } finally {
        walk.release();
    }
    String filename = getFilename(view, rev);
    setRawHeaders(req, res, filename, format.mimeType);
    res.setStatus(SC_OK);
    try {
        new ArchiveCommand(repo).setFormat(format.name).setTree(rev.getId()).setOutputStream(res.getOutputStream()).call();
    } catch (GitAPIException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    GitilesView view = ViewFilter.getView(req);
    Revision rev = view.getRevision();
    Repository repo = ServletUtils.getRepository(req);
    // Check object type before starting the archive. If we just caught the
    // exception from cmd.call() below, we wouldn't know whether it was because
    // the input object is not a tree or something broke later.
    RevWalk walk = new RevWalk(repo);
    try {
        walk.parseTree(rev.getId());
    } catch (IncorrectObjectTypeException e) {
        res.sendError(SC_NOT_FOUND);
        return;
    } finally {
        walk.release();
    }
    Format format = FORMATS_BY_EXTENSION.get(view.getExtension());
    String filename = getFilename(view, rev, view.getExtension());
    setDownloadHeaders(req, res, filename, format.mimeType);
    res.setStatus(SC_OK);
    try {
        new ArchiveCommand(repo).setFormat(format.name()).setTree(rev.getId()).setOutputStream(res.getOutputStream()).call();
    } catch (GitAPIException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private String getFilename(GitilesView view, Revision rev) {
    return new StringBuilder().append(view.getRepositoryName().replace('/', '-')).append('-').append(rev.getName()).append(format.format.suffixes().iterator().next()).toString();
}
#method_after
private String getFilename(GitilesView view, Revision rev, String ext) {
    return new StringBuilder().append(Paths.basename(view.getRepositoryName())).append('-').append(rev.getName()).append(ext).toString();
}
#end_block

#method_before
public void testPath() throws Exception {
    RevCommit master = repo.branch("refs/heads/master").commit().create();
    GitilesView view;
    view = getView("/repo/+show/master/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("", view.getPathPart());
    view = getView("/repo/+show/master/foo");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/bar");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo/bar", view.getPathPart());
}
#method_after
public void testPath() throws Exception {
    RevCommit master = repo.branch("refs/heads/master").commit().create();
    repo.branch("refs/heads/stable").commit().create();
    GitilesView view;
    view = getView("/repo/+show/master/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("", view.getPathPart());
    view = getView("/repo/+show/master/foo");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/bar");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo/bar", view.getPathPart());
    assertNull(getView("/repo/+show/stable..master/foo"));
}
#end_block

#method_before
static String trimLeadingSlash(String str) {
    checkArgument(str.startsWith("/"), "expected string starting with a slash: %s", str);
    return str.substring(1);
}
#method_after
static String trimLeadingSlash(String str) {
    return checkLeadingSlash(str).substring(1);
}
#end_block

#method_before
private GitilesView.Builder parse(HttpServletRequest req) throws IOException {
    String repoName = trimLeadingSlash(getRegexGroup(req, 1));
    String command = getRegexGroup(req, 2);
    String path = getRegexGroup(req, 3);
    boolean emptyPath = (path.isEmpty() || path.equals("/"));
    // Non-path cases.
    if (repoName.isEmpty()) {
        return GitilesView.hostIndex();
    } else if (command.equals(CMD_REFS)) {
        return GitilesView.refs().setRepositoryName(repoName).setPathPart(path);
    } else if (command.equals(CMD_LOG) && emptyPath) {
        return GitilesView.log().setRepositoryName(repoName);
    } else if (command.equals(CMD_DESCRIBE) && !emptyPath) {
        return GitilesView.describe().setRepositoryName(repoName).setPathPart(path);
    } else if (command.isEmpty()) {
        return GitilesView.repositoryIndex().setRepositoryName(repoName);
    } else if (path.isEmpty()) {
        // Command that requires a path, but no path.
        return null;
    }
    path = trimLeadingSlash(path);
    RevisionParser revParser = new RevisionParser(ServletUtils.getRepository(req), accessFactory.forRequest(req), visibilityCache);
    RevisionParser.Result result = revParser.parse(path);
    if (result == null) {
        return null;
    }
    path = path.substring(result.getPathStart());
    command = getCommand(command, result, path);
    GitilesView.Builder view;
    if (CMD_LOG.equals(command)) {
        view = GitilesView.log().setPathPart(path);
    } else if (CMD_SHOW.equals(command)) {
        if (path.isEmpty()) {
            view = GitilesView.revision();
        } else {
            view = GitilesView.path().setPathPart(path);
        }
    } else if (CMD_DIFF.equals(command)) {
        view = GitilesView.diff().setPathPart(path);
    } else if (CMD_REFS.equals(command)) {
        view = GitilesView.repositoryIndex();
    } else if (command.equals(CMD_TAR)) {
        view = GitilesView.tar();
    } else if (command.equals(CMD_ZIP)) {
        view = GitilesView.zip();
    } else {
        // Bad command.
        return null;
    }
    if (result.getOldRevision() != null) {
        // May be NULL.
        view.setOldRevision(result.getOldRevision());
    }
    view.setRepositoryName(repoName).setRevision(result.getRevision());
    return view;
}
#method_after
private GitilesView.Builder parse(HttpServletRequest req) throws IOException {
    String repoName = trimLeadingSlash(getRegexGroup(req, 1));
    if (repoName.isEmpty()) {
        return GitilesView.hostIndex();
    }
    String command = getRegexGroup(req, 2);
    String path = getRegexGroup(req, 3);
    if (command.isEmpty()) {
        return parseNoCommand(req, repoName, path);
    } else if (command.equals(CMD_ARCHIVE)) {
        return parseArchiveCommand(req, repoName, path);
    } else if (command.equals(CMD_AUTO)) {
        return parseAutoCommand(req, repoName, path);
    } else if (command.equals(CMD_DESCRIBE)) {
        return parseDescribeCommand(req, repoName, path);
    } else if (command.equals(CMD_DIFF)) {
        return parseDiffCommand(req, repoName, path);
    } else if (command.equals(CMD_LOG)) {
        return parseLogCommand(req, repoName, path);
    } else if (command.equals(CMD_REFS)) {
        return parseRefsCommand(req, repoName, path);
    } else if (command.equals(CMD_SHOW)) {
        return parseShowCommand(req, repoName, path);
    } else {
        return null;
    }
}
#end_block

#method_before
public synchronized BaseServlet getDefaultHandler(GitilesView.Type view) {
    checkNotInitialized();
    switch(view) {
        case HOST_INDEX:
            return new HostIndexServlet(renderer, urls, accessFactory);
        case REPOSITORY_INDEX:
            return new RepositoryIndexServlet(renderer, accessFactory, timeCache);
        case REFS:
            return new RefServlet(renderer, timeCache);
        case REVISION:
            return new RevisionServlet(renderer, linkifier());
        case PATH:
            return new PathServlet(renderer, urls);
        case DIFF:
            return new DiffServlet(renderer, linkifier());
        case LOG:
            return new LogServlet(renderer, linkifier());
        case DESCRIBE:
            return new DescribeServlet();
        case TAR:
            return new ArchiveServlet(ArchiveServlet.Format.TGZ);
        case ZIP:
            return new ArchiveServlet(ArchiveServlet.Format.ZIP);
        default:
            throw new IllegalArgumentException("Invalid view type: " + view);
    }
}
#method_after
public synchronized BaseServlet getDefaultHandler(GitilesView.Type view) {
    checkNotInitialized();
    switch(view) {
        case HOST_INDEX:
            return new HostIndexServlet(renderer, urls, accessFactory);
        case REPOSITORY_INDEX:
            return new RepositoryIndexServlet(renderer, accessFactory, timeCache);
        case REFS:
            return new RefServlet(renderer, timeCache);
        case REVISION:
            return new RevisionServlet(renderer, linkifier());
        case PATH:
            return new PathServlet(renderer, urls);
        case DIFF:
            return new DiffServlet(renderer, linkifier());
        case LOG:
            return new LogServlet(renderer, linkifier());
        case DESCRIBE:
            return new DescribeServlet();
        case ARCHIVE:
            return new ArchiveServlet();
        default:
            throw new IllegalArgumentException("Invalid view type: " + view);
    }
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    try {
        final ReviewDb db = schemaFactory.open();
        try {
            context.setContext(new RequestContext() {

                @Override
                public Provider<ReviewDb> getReviewDbProvider() {
                    return Providers.of(db);
                }

                @Override
                public CurrentUser getCurrentUser() {
                    throw new OutOfScopeException("No user during ChangeIndexer");
                }
            });
            index.replace(cd);
            return null;
        } finally {
            context.setContext(null);
            db.close();
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d in %s", cd.getId(), cd.getChange().getProject().get()), e);
        throw e;
    }
}
#method_after
@Override
public Void call() throws Exception {
    try {
        final ReviewDb db = schemaFactory.open();
        try {
            context.setContext(new RequestContext() {

                @Override
                public Provider<ReviewDb> getReviewDbProvider() {
                    return Providers.of(db);
                }

                @Override
                public CurrentUser getCurrentUser() {
                    throw new OutOfScopeException("No user during ChangeIndexer");
                }
            });
            index.replace(cd);
            return null;
        } finally {
            context.setContext(null);
            db.close();
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d in %s", cd.getId().get(), cd.getChange().getProject().get()), e);
        throw e;
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!IndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sitePaths = dbInjector.getInstance(SitePaths.class);
    // Delete before any index may be created depending on this data.
    deleteAll();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    int result = indexAll();
    writeVersion();
    sysManager.stop();
    dbManager.stop();
    return result;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    if (!IndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sitePaths = dbInjector.getInstance(SitePaths.class);
    // Delete before any index may be created depending on this data.
    deleteAll();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    int result = indexAll();
    writeVersion();
    sysManager.stop();
    dbManager.stop();
    return result;
}
#end_block

#method_before
private int indexAll() throws Exception {
    ReviewDb db = sysInjector.getInstance(ReviewDb.class);
    ListeningScheduledExecutorService executor = sysInjector.getInstance(Key.get(ListeningScheduledExecutorService.class, IndexExecutor.class));
    ProgressMonitor pm = new TextProgressMonitor(new PrintWriter(System.out));
    pm.start(1);
    pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    Set<Project.NameKey> projects;
    try {
        projects = Sets.newTreeSet();
        for (Change change : db.changes().all()) {
            int n = projects.size();
            projects.add(change.getProject());
            int d = projects.size() - n;
            if (d > 0) {
                pm.update(d);
            }
        }
    } finally {
        db.close();
    }
    pm.endTask();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(System.out, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", projects.size());
    final Task doneTask = mpm.beginSubTask(null, MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    Stopwatch sw = new Stopwatch().start();
    final CountDownLatch latch = new CountDownLatch(projects.size());
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        final ListenableFuture<?> future = executor.submit(new ReindexProject(project, doneTask, failedTask));
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    // Logged by indexer.
                    ok.set(false);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                    latch.countDown();
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    mpm.waitFor(sysInjector.getInstance(WorkQueue.class).getDefaultQueue().submit(new Runnable() {

        @Override
        public void run() {
            try {
                latch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            mpm.end();
        }
    }));
    double elapsed = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    int n = doneTask.getCount() + failedTask.getCount();
    System.out.format("Reindexed %d changes in %.01fs (%.01f/s)\n", n, elapsed, n / elapsed);
    return ok.get() ? 0 : 1;
}
#method_after
private int indexAll() throws Exception {
    ReviewDb db = sysInjector.getInstance(ReviewDb.class);
    ListeningScheduledExecutorService executor = sysInjector.getInstance(Key.get(ListeningScheduledExecutorService.class, IndexExecutor.class));
    ProgressMonitor pm = new TextProgressMonitor(new PrintWriter(System.out));
    pm.start(1);
    pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    Set<Project.NameKey> projects = Sets.newTreeSet();
    try {
        for (Change change : db.changes().all()) {
            if (projects.add(change.getProject())) {
                pm.update(1);
            }
        }
    } finally {
        db.close();
    }
    pm.endTask();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(System.out, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", projects.size());
    final Task doneTask = mpm.beginSubTask(null, MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    Stopwatch sw = new Stopwatch().start();
    final List<ListenableFuture<?>> futures = Lists.newArrayListWithCapacity(projects.size());
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        final ListenableFuture<?> future = executor.submit(new ReindexProject(project, doneTask, failedTask));
        futures.add(future);
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    // Logged by indexer.
                    ok.set(false);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    mpm.waitFor(Futures.transform(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

        @Override
        public ListenableFuture<Void> apply(List<?> input) throws Exception {
            mpm.end();
            return Futures.immediateFuture(null);
        }
    }));
    double elapsed = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    int n = doneTask.getCount() + failedTask.getCount();
    System.out.format("Reindexed %d changes in %.01fs (%.01f/s)\n", n, elapsed, n / elapsed);
    return ok.get() ? 0 : 1;
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    ReviewDb db = sysInjector.getInstance(ReviewDb.class);
    GitRepositoryManager mgr = sysInjector.getInstance(GitRepositoryManager.class);
    repo = mgr.openRepository(project);
    try {
        Map<String, Ref> refs = repo.getAllRefs();
        for (Change c : db.changes().all()) {
            Ref r = refs.get(c.currentPatchSetId().toRefName());
            if (r != null) {
                byId.put(r.getObjectId(), new ChangeData(c));
            }
        }
        walk();
    } finally {
        repo.close();
        // Only used once per Reindex call.
        RepositoryCache.close(repo);
    }
    return null;
}
#method_after
@Override
public Void call() throws Exception {
    ReviewDb db = sysInjector.getInstance(ReviewDb.class);
    GitRepositoryManager mgr = sysInjector.getInstance(GitRepositoryManager.class);
    repo = mgr.openRepository(project);
    try {
        Map<String, Ref> refs = repo.getAllRefs();
        for (Change c : db.changes().byProject(project)) {
            Ref r = refs.get(c.currentPatchSetId().toRefName());
            if (r != null) {
                byId.put(r.getObjectId(), new ChangeData(c));
            }
        }
        walk();
    } finally {
        repo.close();
        // Only used once per Reindex call.
        RepositoryCache.close(repo);
    }
    return null;
}
#end_block

#method_before
private void walk() throws Exception {
    walk = new RevWalk(repo);
    try {
        // to mark every single change.
        for (Ref ref : repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            RevObject o = walk.parseAny(ref.getObjectId());
            if (!(o instanceof RevCommit)) {
                continue;
            }
            walk.markStart((RevCommit) o);
        }
        RevCommit bCommit;
        while ((bCommit = walk.next()) != null) {
            if (!byId.containsKey(bCommit)) {
                // Not a change, skip diff.
                continue;
            }
            getPathsAndIndex(bCommit, true);
            if (byId.isEmpty()) {
                break;
            }
        }
        for (ObjectId id : byId.keySet()) {
            getPathsAndIndex(walk.parseCommit(id), false);
        }
    } finally {
        walk.release();
    }
}
#method_after
private void walk() throws Exception {
    walk = new RevWalk(repo);
    try {
        // to mark every single change.
        for (Ref ref : repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            RevObject o = walk.parseAny(ref.getObjectId());
            if (o instanceof RevCommit) {
                walk.markStart((RevCommit) o);
            }
        }
        RevCommit bCommit;
        while ((bCommit = walk.next()) != null && !byId.isEmpty()) {
            if (byId.containsKey(bCommit)) {
                getPathsAndIndex(bCommit);
                byId.removeAll(bCommit);
            }
        }
        for (ObjectId id : byId.keySet()) {
            getPathsAndIndex(walk.parseCommit(id));
        }
    } finally {
        walk.release();
    }
}
#end_block

#method_before
private void getPathsAndIndex(RevCommit bCommit, boolean remove) throws Exception {
    RevTree bTree = bCommit.getTree();
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            List<ChangeData> cds = remove ? byId.removeAll(bCommit) : byId.get(bCommit);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                for (ChangeData cd : cds) {
                    cd.setCurrentFilePaths(paths);
                    indexer.indexTask(cd).call();
                    done.update(1);
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        log.warn("Failed to index changes for commit " + bCommit.name(), e);
        failed.update(1);
    }
}
#method_after
private void getPathsAndIndex(RevCommit bCommit) throws Exception {
    RevTree bTree = bCommit.getTree();
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            List<ChangeData> cds = byId.get(bCommit);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                for (ChangeData cd : cds) {
                    cd.setCurrentFilePaths(paths);
                    indexer.indexTask(cd).call();
                    done.update(1);
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        log.warn("Failed to index changes for commit " + bCommit.name(), e);
        failed.update(1);
    }
}
#end_block

#method_before
private Query exactQuery(IndexPredicate<ChangeData> p) {
    return new TermQuery(new Term(p.getOperator(), p.getValue()));
}
#method_after
private Query exactQuery(IndexPredicate<ChangeData> p) {
    if (p instanceof RegexPredicate<?>) {
        return regexQuery(p);
    } else {
        return new TermQuery(new Term(p.getOperator(), p.getValue()));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    install(new RunAsFilter.Module());
    switch(authConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
            install(new HttpAuthModule());
            break;
        case CLIENT_SSL_CERT_LDAP:
            install(new HttpsClientSslCertModule());
            break;
        case LDAP:
        case LDAP_BIND:
            install(new LdapAuthModule());
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            install(new ServletModule() {

                @Override
                protected void configureServlets() {
                    serve("/become").with(BecomeAnyAccountLoginServlet.class);
                }
            });
            break;
        case OPENID:
        case OPENID_SSO:
        // OpenID support is bound in WebAppInitializer and Daemon.
        case CUSTOM_EXTENSION:
            break;
        default:
            throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
    }
    install(new UrlModule(urlConfig));
    install(new UiRpcModule());
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module());
    bind(GitWebConfig.class).toInstance(gitWebConfig);
    if (gitWebConfig.getGitwebCGI() != null) {
        install(new GitWebModule());
    }
    bind(ContactStore.class).toProvider(ContactStoreProvider.class).in(SINGLETON);
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    factory(ClearPassword.Factory.class);
    install(new CmdLineParserModule());
    factory(GeneratePassword.Factory.class);
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().toInstance(registerInParentInjectors());
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    install(new RunAsFilter.Module());
    switch(authConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
            install(new HttpAuthModule());
            break;
        case CLIENT_SSL_CERT_LDAP:
            install(new HttpsClientSslCertModule());
            break;
        case LDAP:
        case LDAP_BIND:
            install(new LdapAuthModule());
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            install(new BecomeAnyAccountModule());
            break;
        case OPENID:
        case OPENID_SSO:
        // OpenID support is bound in WebAppInitializer and Daemon.
        case CUSTOM_EXTENSION:
            break;
        default:
            throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
    }
    install(new UrlModule(urlConfig, uiOptions));
    install(new UiRpcModule());
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module());
    bind(GitWebConfig.class).toInstance(gitWebConfig);
    if (gitWebConfig.getGitwebCGI() != null) {
        install(new GitWebModule());
    }
    bind(ContactStore.class).toProvider(ContactStoreProvider.class).in(SINGLETON);
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    install(new AsyncReceiveCommits.Module());
    install(new CmdLineParserModule());
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().toInstance(registerInParentInjectors());
        }
    });
}
#end_block

#method_before
@Override
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null);
    saveCookie();
}
#method_after
@Override
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null, null);
    saveCookie();
}
#end_block

#method_before
@Override
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, 0, null);
    user = null;
}
#method_after
@Override
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, 0, null, null);
    user = null;
}
#end_block

#method_before
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    res.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    res.setHeader("Pragma", "no-cache");
    res.setHeader("Cache-Control", "no-cache, must-revalidate");
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    try {
        int status = SC_OK;
        checkUserSession(req);
        List<String> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            view = rc.list();
        } else {
            String id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                view = c.list();
                break;
            } else {
                rsrc = c.parse(rsrc, path.remove(0));
                view = view(c, req.getMethod(), path);
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        Multimap<String, String> params = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        Object result;
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            result = m.apply(rsrc, parseRequest(req, m.inputType()));
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response r = (Response) result;
            status = r.statusCode();
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (AuthException e) {
        replyError(res, SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, SC_BAD_REQUEST, e.getMessage());
    } catch (MethodNotAllowedException e) {
        replyError(res, SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, SC_CONFLICT, e.getMessage());
    } catch (ResourceNotFoundException e) {
        replyError(res, SC_NOT_FOUND, "Not found");
    } catch (AmbiguousViewException e) {
        replyError(res, SC_NOT_FOUND, e.getMessage());
    } catch (JsonParseException e) {
        replyError(res, SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        handleException(e, req, res);
    }
}
#method_after
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long auditStartTs = System.currentTimeMillis();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    Object result = null;
    Multimap<String, String> params = LinkedHashMultimap.create();
    Object inputRequestBody = null;
    try {
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            if ("GET".equals(req.getMethod())) {
                view = rc.list();
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                view = ac.post(rsrc);
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req, rsrc);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                if ("GET".equals(req.getMethod())) {
                    view = c.list();
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    view = ac.post(rsrc);
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            } else {
                IdString id = path.remove(0);
                try {
                    rsrc = c.parse(rsrc, id);
                    checkPreconditions(req, rsrc);
                    view = null;
                } catch (ResourceNotFoundException e) {
                    if (c instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                        @SuppressWarnings("unchecked")
                        AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                        view = ac.create(rsrc, id);
                        status = SC_CREATED;
                    } else {
                        throw e;
                    }
                }
                if (view == null) {
                    view = view(c, req.getMethod(), path);
                }
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, r);
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (AuthException e) {
        replyError(res, status = SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, status = SC_BAD_REQUEST, e.getMessage());
    } catch (MethodNotAllowedException e) {
        replyError(res, status = SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, status = SC_CONFLICT, e.getMessage());
    } catch (PreconditionFailedException e) {
        replyError(res, status = SC_PRECONDITION_FAILED, Objects.firstNonNull(e.getMessage(), "Precondition failed"));
    } catch (ResourceNotFoundException e) {
        replyError(res, status = SC_NOT_FOUND, "Not found");
    } catch (UnprocessableEntityException e) {
        replyError(res, status = 422, Objects.firstNonNull(e.getMessage(), "Unprocessable Entity"));
    } catch (AmbiguousViewException e) {
        replyError(res, status = SC_NOT_FOUND, e.getMessage());
    } catch (MalformedJsonException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (JsonParseException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        globals.auditService.dispatch(new HttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req.getRequestURI(), auditStartTs, params, req.getMethod(), inputRequestBody, status, result));
    }
}
#end_block

#method_before
private Object parseRequest(HttpServletRequest req, Class<Object> type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if ("PUT".equals(req.getMethod()) && acceptsPutInput(type)) {
        return parsePutInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (type.getDeclaredFields().length == 0 && hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#method_after
private Object parseRequest(HttpServletRequest req, Type type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            json.setLenient(true);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if (("PUT".equals(req.getMethod()) || "POST".equals(req.getMethod())) && acceptsRawInput(type)) {
        return parseRawInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#end_block

#method_before
private Object parseString(String value, Class<Object> type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    Object obj = createInstance(type);
    Field[] fields = type.getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#method_after
private Object parseString(String value, Type type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    if (type == String.class) {
        return value;
    }
    Object obj = createInstance(type);
    Field[] fields = obj.getClass().getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#end_block

#method_before
private static Object createInstance(Class<Object> type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    Constructor<Object> c = type.getDeclaredConstructor();
    c.setAccessible(true);
    return c.newInstance();
}
#method_after
private static Object createInstance(Type type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    if (type instanceof Class) {
        @SuppressWarnings("unchecked")
        Class<Object> clazz = (Class<Object>) type;
        Constructor<Object> c = clazz.getDeclaredConstructor();
        c.setAccessible(true);
        return c.newInstance();
    }
    throw new InstantiationException("Cannot make " + type);
}
#end_block

#method_before
private static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    final TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, new BinaryResult() {

        @Override
        public long getContentLength() {
            return buf.length();
        }

        @Override
        public void writeTo(OutputStream os) throws IOException {
            buf.writeTo(os, null);
        }
    }.setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#method_after
private static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, asBinaryResult(buf).setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#end_block

#method_before
private static Gson newGson(Multimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder().setFieldNamingPolicy(NAMING);
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#method_after
private static Gson newGson(Multimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder();
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#end_block

#method_before
private static void enablePartialGetFields(GsonBuilder gb, Multimap<String, String> config) {
    final Set<String> want = Sets.newHashSet();
    for (String p : config.get("fields")) {
        Iterables.addAll(want, Splitter.on(',').omitEmptyStrings().trimResults().split(p));
    }
    if (!want.isEmpty()) {
        gb.addSerializationExclusionStrategy(new ExclusionStrategy() {

            private final Map<String, String> names = Maps.newHashMap();

            @Override
            public boolean shouldSkipField(FieldAttributes field) {
                String name = names.get(field.getName());
                if (name == null) {
                    // Translate and cache the JSON lower_case_style used.
                    try {
                        name = NAMING.translateName(field.getDeclaringClass().getDeclaredField(field.getName()));
                        names.put(field.getName(), name);
                    } catch (SecurityException e) {
                        return true;
                    } catch (NoSuchFieldException e) {
                        return true;
                    }
                }
                return !want.contains(name);
            }

            @Override
            public boolean shouldSkipClass(Class<?> clazz) {
                return false;
            }
        });
    }
}
#method_after
private static void enablePartialGetFields(GsonBuilder gb, Multimap<String, String> config) {
    final Set<String> want = Sets.newHashSet();
    for (String p : config.get("fields")) {
        Iterables.addAll(want, OptionUtil.splitOptionValue(p));
    }
    if (!want.isEmpty()) {
        gb.addSerializationExclusionStrategy(new ExclusionStrategy() {

            private final Map<String, String> names = Maps.newHashMap();

            @Override
            public boolean shouldSkipField(FieldAttributes field) {
                String name = names.get(field.getName());
                if (name == null) {
                    // Translate and cache the JSON lower_case_style used.
                    try {
                        name = // 
                        FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES.translateName(field.getDeclaringClass().getDeclaredField(field.getName()));
                        names.put(field.getName(), name);
                    } catch (SecurityException e) {
                        return true;
                    } catch (NoSuchFieldException e) {
                        return true;
                    }
                }
                return !want.contains(name);
            }

            @Override
            public boolean shouldSkipClass(Class<?> clazz) {
                return false;
            }
        });
    }
}
#end_block

#method_before
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    try {
        res.setContentType(bin.getContentType());
        OutputStream dst = res.getOutputStream();
        try {
            long len = bin.getContentLength();
            boolean gzip = bin.canGzip() && acceptsGzip(req);
            if (gzip && 256 <= len && len <= (10 << 20)) {
                TemporaryBuffer.Heap buf = compress(bin);
                if (buf.length() < len) {
                    res.setContentLength((int) buf.length());
                    res.setHeader("Content-Encoding", "gzip");
                    buf.writeTo(dst, null);
                } else {
                    replyUncompressed(res, dst, bin, len);
                }
            } else if (gzip) {
                res.setHeader("Content-Encoding", "gzip");
                dst = new GZIPOutputStream(dst);
                bin.writeTo(dst);
            } else {
                replyUncompressed(res, dst, bin, len);
            }
        } finally {
            dst.close();
        }
    } finally {
        bin.close();
    }
}
#method_after
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    final BinaryResult appResult = bin;
    try {
        if (bin.isBase64()) {
            bin = stackBase64(res, bin);
        }
        if (bin.canGzip() && acceptsGzip(req)) {
            bin = stackGzip(res, bin);
        }
        res.setContentType(bin.getContentType());
        long len = bin.getContentLength();
        if (0 <= len && len < Integer.MAX_VALUE) {
            res.setContentLength((int) len);
        } else if (0 <= len) {
            res.setHeader("Content-Length", Long.toString(len));
        }
        OutputStream dst = res.getOutputStream();
        try {
            bin.writeTo(dst);
        } finally {
            dst.close();
        }
    } finally {
        appResult.close();
    }
}
#end_block

#method_before
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<String> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final String projection = path.isEmpty() ? "/" : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#method_after
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#end_block

#method_before
private static List<String> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<String> out = Lists.newArrayList(Splitter.on('/').split(path));
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#method_after
private static List<IdString> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<IdString> out = Lists.newArrayList();
    for (String p : Splitter.on('/').split(path)) {
        out.add(IdString.fromUrl(p));
    }
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#end_block

#method_before
private static List<String> splitProjection(String projection) {
    return Lists.newArrayList(Splitter.on('~').limit(2).split(projection));
}
#method_after
private static List<String> splitProjection(IdString projection) {
    List<String> p = Lists.newArrayListWithCapacity(2);
    Iterables.addAll(p, Splitter.on('~').limit(2).split(projection.get()));
    return p;
}
#end_block

#method_before
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isStateChange(req)) {
        if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
            throw new AuthException("Invalid authentication method");
        }
    }
    user.setAccessPath(AccessPath.REST_API);
}
#method_after
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isStateChange(req)) {
        if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
            throw new AuthException("Invalid authentication method. In order to authenticate, prefix the REST endpoint URL with /a/ (e.g. http://example.com/a/projects/).");
        }
    }
    user.setAccessPath(AccessPath.REST_API);
}
#end_block

#method_before
static void replyError(HttpServletResponse res, int statusCode, String msg) throws IOException {
    res.setStatus(statusCode);
    replyText(null, res, msg);
}
#method_after
public static void replyError(HttpServletResponse res, int statusCode, String msg) throws IOException {
    res.setStatus(statusCode);
    CacheHeaders.setNotCacheable(res);
    replyText(null, res, msg);
}
#end_block

#method_before
public static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || "GET".equals(req.getMethod())) && isMaybeHTML(text)) {
        replyJson(req, res, ImmutableMultimap.of("pp", "0"), new JsonPrimitive(text));
    } else {
        if (!text.endsWith("\n")) {
            text += "\n";
        }
        replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
    }
}
#method_after
static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || "GET".equals(req.getMethod())) && isMaybeHTML(text)) {
        replyJson(req, res, ImmutableMultimap.of("pp", "0"), new JsonPrimitive(text));
    } else {
        if (!text.endsWith("\n")) {
            text += "\n";
        }
        replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
    }
}
#end_block

#method_before
private static TemporaryBuffer.Heap compress(BinaryResult bin) throws IOException {
    TemporaryBuffer.Heap buf = heap(20 << 20);
    GZIPOutputStream gz = new GZIPOutputStream(buf);
    bin.writeTo(gz);
    gz.finish();
    gz.flush();
    return buf;
}
#method_after
private static BinaryResult compress(BinaryResult bin) throws IOException {
    TemporaryBuffer.Heap buf = heap(20 << 20);
    GZIPOutputStream gz = new GZIPOutputStream(buf);
    bin.writeTo(gz);
    gz.close();
    return asBinaryResult(buf).setContentType(bin.getContentType());
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        CurrentUser user = session.get().getCurrentUser();
        if (!user.getCapabilities().canAdministrateServer()) {
            error(req, res, SC_FORBIDDEN, "not permitted to use " + RUN_AS);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            error(req, res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS);
            return;
        }
        if (target == null) {
            error(req, res, SC_FORBIDDEN, "no account matches " + RUN_AS);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        CurrentUser self = session.get().getCurrentUser();
        if (!self.getCapabilities().canRunAs()) {
            RestApiServlet.replyError((HttpServletResponse) res, SC_FORBIDDEN, "not permitted to use " + RUN_AS);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            RestApiServlet.replyError((HttpServletResponse) res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS);
            return;
        }
        if (target == null) {
            RestApiServlet.replyError((HttpServletResponse) res, SC_FORBIDDEN, "no account matches " + RUN_AS);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#end_block

#method_before
private void displayHeader(Collection<String> labels) {
    table.resizeColumns(2 + labels.size());
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    List<String> sorted_labels = new ArrayList<String>();
    sorted_labels.addAll(labels);
    Collections.sort(sorted_labels);
    for (String name : sorted_labels) {
        table.setText(0, col, name);
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    fmt.addStyleName(0, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#method_after
private void displayHeader(Collection<String> labels) {
    table.resizeColumns(2 + labels.size());
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    for (String name : labels) {
        table.setText(0, col, name);
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    fmt.addStyleName(0, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
void display(ChangeInfo change) {
    lastChange = change;
    reviewerSuggestOracle.setChange(change.legacy_id());
    Map<Integer, ApprovalDetail> byUser = new LinkedHashMap<Integer, ApprovalDetail>();
    Map<Integer, AccountInfo> accounts = new LinkedHashMap<Integer, AccountInfo>();
    List<String> missingLabels = initLabels(change, accounts, byUser);
    removeAllChildren(missing.getElement());
    for (String label : missingLabels) {
        addMissingLabel(Util.M.needApproval(label));
    }
    if (byUser.isEmpty()) {
        table.setVisible(false);
    } else {
        displayHeader(change.labels());
        table.resizeRows(1 + byUser.size());
        int i = 1;
        for (ApprovalDetail ad : ApprovalDetail.sort(byUser.values(), change.owner()._account_id())) {
            displayRow(i++, ad, change, accounts.get(ad.getAccount().get()));
        }
        table.setVisible(true);
    }
    if (Gerrit.getConfig().testChangeMerge() && change.status() != Change.Status.MERGED && !change.mergeable()) {
        addMissingLabel(Util.C.messageNeedsRebaseOrHasDependency());
    }
    missing.setVisible(DOM.getChildCount(missing.getElement()) > 0);
    addReviewer.setVisible(Gerrit.isSignedIn());
}
#method_after
void display(ChangeInfo change) {
    lastChange = change;
    reviewerSuggestOracle.setChange(change.legacy_id());
    Map<Integer, ApprovalDetail> byUser = new LinkedHashMap<Integer, ApprovalDetail>();
    Map<Integer, AccountInfo> accounts = new LinkedHashMap<Integer, AccountInfo>();
    List<String> missingLabels = initLabels(change, accounts, byUser);
    removeAllChildren(missing.getElement());
    for (String label : missingLabels) {
        addMissingLabel(Util.M.needApproval(label));
    }
    if (byUser.isEmpty()) {
        table.setVisible(false);
    } else {
        List<String> labels = new ArrayList<String>(change.labels());
        Collections.sort(labels);
        displayHeader(labels);
        table.resizeRows(1 + byUser.size());
        int i = 1;
        for (ApprovalDetail ad : ApprovalDetail.sort(byUser.values(), change.owner()._account_id())) {
            displayRow(i++, ad, labels, accounts.get(ad.getAccount().get()));
        }
        table.setVisible(true);
    }
    if (Gerrit.getConfig().testChangeMerge() && change.status() != Change.Status.MERGED && !change.mergeable()) {
        addMissingLabel(Util.C.messageNeedsRebaseOrHasDependency());
    }
    missing.setVisible(DOM.getChildCount(missing.getElement()) > 0);
    addReviewer.setVisible(Gerrit.isSignedIn());
}
#end_block

#method_before
private void displayRow(int row, final ApprovalDetail ad, ChangeInfo change, AccountInfo account) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, new AccountLink(account));
    rows.put(account._account_id(), row);
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(Util.M.removeReviewer(account.name()));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addStyleName(Gerrit.RESOURCES.css().link());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : change.labels()) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().notVotable());
            fmt.getElement(row, col).setTitle(Gerrit.C.userCannotVoteToolTip());
        }
        if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            int v = ad.getValue(labelName);
            if (v == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ad.getValue(labelName));
            if (v > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#method_after
private void displayRow(int row, final ApprovalDetail ad, List<String> labels, AccountInfo account) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, new AccountLinkPanel(account));
    rows.put(account._account_id(), row);
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(Util.M.removeReviewer(account.name()));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addStyleName(Gerrit.RESOURCES.css().link());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : labels) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().notVotable());
            fmt.getElement(row, col).setTitle(Gerrit.C.userCannotVoteToolTip());
        }
        if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            int v = ad.getValue(labelName);
            if (v == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ad.getValue(labelName));
            if (v > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (allowFileRegex) {
        if (file.startsWith("^")) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw new IllegalArgumentException();
        }
    } else {
        if (!file.startsWith("^")) {
            // TODO(dborowitz): Wrap predicates in query rewriter, not here.
            return new PredicateWrapper(args.index, new EqualsFilePredicate(args.dbProvider, args.patchListCache, file));
        } else {
            throw error("regular expression not permitted here: file:" + file);
        }
    }
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (allowFileRegex) {
        if (file.startsWith("^")) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw new IllegalArgumentException();
        }
    } else {
        if (!file.startsWith("^") && args.index != ChangeIndex.DISABLED) {
            // TODO(dborowitz): Wrap predicates in query rewriter, not here.
            return new PredicateWrapper(args.index, new EqualsFilePredicate(args.dbProvider, args.patchListCache, file));
        } else {
            throw error("regular expression not permitted here: file:" + file);
        }
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    sysInjector = createSysInjector();
    manager.add(dbInjector);
    manager.add(sysInjector);
    manager.start();
    SchemaFactory<ReviewDb> schema = dbInjector.getInstance(Key.get(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }));
    ReviewDb db = schema.open();
    Provider<ReviewDb> dbProvider = Providers.of(db);
    PatchListCache plc = sysInjector.getInstance(PatchListCache.class);
    LuceneChangeIndex index = sysInjector.getInstance(LuceneChangeIndex.class);
    index.getWriter().deleteAll();
    int i = 0;
    for (Change change : db.changes().all()) {
        ChangeData cd = new ChangeData(change);
        cd.fillIndexFields(dbProvider, plc);
        index.insert(cd);
        i++;
    }
    index.getWriter().commit();
    System.out.println("Reindexed " + i + " changes");
    manager.stop();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!LuceneIndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    sitePaths = dbInjector.getInstance(SitePaths.class);
    deleteAll();
    sysInjector = createSysInjector();
    manager.add(dbInjector);
    manager.add(sysInjector);
    manager.start();
    SchemaFactory<ReviewDb> schema = dbInjector.getInstance(Key.get(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }));
    ReviewDb db = schema.open();
    dbRef.set(db);
    LuceneChangeIndex index = sysInjector.getInstance(LuceneChangeIndex.class);
    Stopwatch sw = new Stopwatch().start();
    int i = 0;
    for (Change change : db.changes().all()) {
        index.insert(new ChangeData(change));
        i++;
    }
    index.getWriter().commit();
    double elapsed = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Reindexed %d changes in %.02fms", i, elapsed);
    manager.stop();
    return 0;
}
#end_block

#method_before
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    modules.add(LuceneChangeIndex.module());
    modules.add(new LifecycleModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    modules.add(new LuceneIndexModule());
    modules.add(new AbstractModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            bind(ReviewDb.class).toProvider(new Provider<ReviewDb>() {

                @Override
                public ReviewDb get() {
                    return dbRef.get();
                }
            });
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new com.google.gerrit.server.index.Module());
    modules.add(LuceneChangeIndex.module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (LuceneIndexModule.isEnabled(cfgInjector)) {
        modules.add(new LuceneIndexModule());
    } else {
        modules.add(new NoIndexModule());
    }
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(IndexPredicate<ChangeData> p) throws QueryParseException {
    switch(p.getType()) {
        case INTEGER:
            return intQuery(p);
        case EXACT_REPEATABLE:
            return exactQuery(p);
        default:
            throw badFieldType(p.getType());
    }
}
#method_after
@Override
public ChangeDataSource getSource(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    cd.checkIndexFields();
    org.apache.lucene.document.Document result = new Document();
    for (ChangeField f : ChangeField.values()) {
        switch(f.getType()) {
            case INTEGER:
                result.add(new IntField(f.getName(), (Integer) f.get(cd), store(f)));
                break;
            case EXACT_REPEATABLE:
                // Type checked in ChangeField.
                @SuppressWarnings("unchecked")
                Iterable<String> values = (Iterable<String>) f.get(cd);
                for (String value : values) {
                    result.add(new StringField(f.getName(), value, store(f)));
                }
                break;
        }
    }
    return result;
}
#method_after
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                add(result, f, Collections.singleton(f.get(cd, fillArgs)));
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private Field.Store store(ChangeField f) {
    return f.isStored() ? Field.Store.YES : Field.Store.NO;
}
#method_after
private static Field.Store store(FieldDef<?, ?> f) {
    return f.isStored() ? Field.Store.YES : Field.Store.NO;
}
#end_block

#method_before
private static IllegalArgumentException badFieldType(FieldType t) {
    return new IllegalArgumentException("unknown index field type " + t);
}
#method_after
private static IllegalArgumentException badFieldType(FieldType<?> t) {
    return new IllegalArgumentException("unknown index field type " + t);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new com.google.gerrit.server.index.Module());
    modules.add(LuceneChangeIndex.module());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (LuceneIndexModule.isEnabled(cfgInjector)) {
        modules.add(new LuceneIndexModule());
    } else {
        modules.add(new NoIndexModule());
    }
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
public FieldType getType() {
    return type;
}
#method_after
public FieldType<?> getType() {
    return def.getType();
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(change.getProject(), ru);
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, change.currentPatchSetId());
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        db.commit();
        if (changeMessage != null) {
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        workQueue.getDefaultQueue().submit(indexerFactory.create(change));
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    } finally {
        db.rollback();
    }
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(change.getProject(), ru);
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, change.currentPatchSetId());
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        db.commit();
        if (changeMessage != null) {
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        indexer.index(change);
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    } finally {
        db.rollback();
    }
    return updatedChange;
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    changeInserter.insertChange(db, change, ps, commit, labelTypes, info, recipients.getReviewers());
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(changeIndexerFactory.create(change)));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ins.setReviewers(recipients.getReviewers()).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void addPadding(int line, CodeMirror cm) {
    Element div = DOM.createDiv();
    div.setAttribute("style", "background-color: #E6E6E6");
    div.appendChild(DOM.createElement("br"));
    cm.addLineWidget(line, div, null);
}
#method_after
private void addPadding(CodeMirror cm, int line) {
    Element div = DOM.createDiv();
    div.setClassName(diffTable.style.padding());
    cm.addLineWidget(line, div, null);
}
#end_block

#method_before
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    Configuration insertOpt = Configuration.create().set("className", "insert").set("readOnly", "true");
    Configuration deleteOpt = Configuration.create().set("className", "delete").set("readOnly", "true");
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null) {
            lineA += current.ab().length();
            lineB += current.ab().length();
        } else if (current.a() == null && current.b() != null) {
            int delta = current.b().length();
            for (int j = 0; j < delta; j++) {
                addPadding(lineA - 1, cmA);
            }
            for (int j = 0; j < delta; j++) {
                cmB.addLineClass(lineB, "wrap", "insert");
                LineCharacter from = LineCharacter.create(lineB, 0).setLine(lineB).setCh(0);
                cmB.markText(from, from, insertOpt);
                lineB++;
            }
        } else if (current.a() != null && current.b() == null) {
            int delta = current.a().length();
            for (int j = 0; j < delta; j++) {
                addPadding(lineB - 1, cmB);
            }
            for (int j = 0; j < delta; j++) {
                cmA.addLineClass(lineA, "wrap", "delete");
                LineCharacter from = LineCharacter.create(lineA, 0).setLine(lineA).setCh(0);
                cmA.markText(from, from, deleteOpt);
                lineA++;
            }
        } else {
            // TODO: Handle intraline edit.
            lineA += current.a().length();
            lineB += current.a().length();
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    Configuration insertOpt = Configuration.create().set("className", diffTable.style.insert()).set("readOnly", true);
    Configuration deleteOpt = Configuration.create().set("className", diffTable.style.delete()).set("readOnly", true);
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null) {
            lineA += current.ab().length();
            lineB += current.ab().length();
        } else if (current.a() == null && current.b() != null) {
            int delta = current.b().length();
            for (int j = 0; j < delta; j++) {
                addPadding(cmA, lineA - 1);
            }
            for (int j = 0; j < delta; j++) {
                cmB.addLineClass(lineB, LineClassWhere.WRAP, diffTable.style.insert());
                LineCharacter from = LineCharacter.create(lineB, 0);
                cmB.markText(from, from, insertOpt);
                lineB++;
            }
        } else if (current.a() != null && current.b() == null) {
            int delta = current.a().length();
            for (int j = 0; j < delta; j++) {
                addPadding(cmB, lineB - 1);
            }
            for (int j = 0; j < delta; j++) {
                cmA.addLineClass(lineA, LineClassWhere.WRAP, diffTable.style.delete());
                LineCharacter from = LineCharacter.create(lineA, 0);
                cmA.markText(from, from, deleteOpt);
                lineA++;
            }
        } else {
            // TODO: Handle intraline edit.
            lineA += current.a().length();
            lineB += current.a().length();
        }
    }
}
#end_block

#method_before
private static void asyncInjectCss(ExternalTextResource css) {
    try {
        css.getText(new ResourceCallback<TextResource>() {

            @Override
            public void onSuccess(TextResource resource) {
                StyleInjector.inject(resource.getText());
            }

            @Override
            public void onError(ResourceException e) {
            }
        });
    } catch (ResourceException e) {
    }
}
#method_after
private static void asyncInjectCss(ExternalTextResource css) {
    try {
        css.getText(new ResourceCallback<TextResource>() {

            @Override
            public void onSuccess(TextResource resource) {
                StyleInjector.inject(resource.getText());
            }

            @Override
            public void onError(ResourceException e) {
                error(e);
            }
        });
    } catch (ResourceException e) {
        error(e);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
    get(PROJECT_KIND, "config").to(GetConfig.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
    get(PROJECT_KIND, "config").to(GetConfig.class);
}
#end_block

#method_before
@Override
public List<BranchInfo> apply(ProjectResource rsrc) throws ResourceNotFoundException, IOException {
    List<BranchInfo> branches = Lists.newArrayList();
    BranchInfo headBranch = null;
    BranchInfo configBranch = null;
    final Set<String> targets = new HashSet<String>();
    final Repository db;
    try {
        db = repoManager.openRepository(rsrc.getNameKey());
    } catch (RepositoryNotFoundException noGitRepository) {
        throw new ResourceNotFoundException();
    }
    try {
        final Map<String, Ref> all = db.getAllRefs();
        if (!all.containsKey(Constants.HEAD)) {
            // 
            try {
                Ref head = db.getRef(Constants.HEAD);
                if (head != null) {
                    all.put(Constants.HEAD, head);
                }
            } catch (IOException e) {
            // Ignore the failure reading HEAD.
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                targets.add(ref.getTarget().getName());
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                // A symbolic reference to another branch, instead of
                // showing the resolved value, show the name it references.
                // 
                String target = ref.getTarget().getName();
                RefControl targetRefControl = rsrc.getControl().controlForRef(target);
                if (!targetRefControl.isVisible()) {
                    continue;
                }
                if (target.startsWith(Constants.R_HEADS)) {
                    target = target.substring(Constants.R_HEADS.length());
                }
                BranchInfo b = new BranchInfo();
                b.ref = ref.getName();
                b.revision = target;
                if (Constants.HEAD.equals(ref.getName())) {
                    b.setCanDelete(false);
                    headBranch = b;
                } else {
                    b.setCanDelete(targetRefControl.canDelete());
                    branches.add(b);
                }
                continue;
            }
            final RefControl refControl = rsrc.getControl().controlForRef(ref.getName());
            if (refControl.isVisible()) {
                if (ref.getName().startsWith(Constants.R_HEADS)) {
                    branches.add(createBranchInfo(ref, refControl, targets));
                } else if (GitRepositoryManager.REF_CONFIG.equals(ref.getName())) {
                    configBranch = createBranchInfo(ref, refControl, targets);
                }
            }
        }
    } finally {
        db.close();
    }
    Collections.sort(branches, new Comparator<BranchInfo>() {

        @Override
        public int compare(final BranchInfo a, final BranchInfo b) {
            return a.ref.compareTo(b.ref);
        }
    });
    if (configBranch != null) {
        branches.add(0, configBranch);
    }
    if (headBranch != null) {
        branches.add(0, headBranch);
    }
    return branches;
}
#method_after
@Override
public List<BranchInfo> apply(ProjectResource rsrc) throws ResourceNotFoundException, IOException {
    List<BranchInfo> branches = Lists.newArrayList();
    BranchInfo headBranch = null;
    BranchInfo configBranch = null;
    final Set<String> targets = Sets.newHashSet();
    final Repository db;
    try {
        db = repoManager.openRepository(rsrc.getNameKey());
    } catch (RepositoryNotFoundException noGitRepository) {
        throw new ResourceNotFoundException();
    }
    try {
        final Map<String, Ref> all = db.getAllRefs();
        if (!all.containsKey(Constants.HEAD)) {
            // 
            try {
                Ref head = db.getRef(Constants.HEAD);
                if (head != null) {
                    all.put(Constants.HEAD, head);
                }
            } catch (IOException e) {
            // Ignore the failure reading HEAD.
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                targets.add(ref.getTarget().getName());
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                // A symbolic reference to another branch, instead of
                // showing the resolved value, show the name it references.
                // 
                String target = ref.getTarget().getName();
                RefControl targetRefControl = rsrc.getControl().controlForRef(target);
                if (!targetRefControl.isVisible()) {
                    continue;
                }
                if (target.startsWith(Constants.R_HEADS)) {
                    target = target.substring(Constants.R_HEADS.length());
                }
                BranchInfo b = new BranchInfo();
                b.ref = ref.getName();
                b.revision = target;
                if (Constants.HEAD.equals(ref.getName())) {
                    b.setCanDelete(false);
                    headBranch = b;
                } else {
                    b.setCanDelete(targetRefControl.canDelete());
                    branches.add(b);
                }
                continue;
            }
            final RefControl refControl = rsrc.getControl().controlForRef(ref.getName());
            if (refControl.isVisible()) {
                if (ref.getName().startsWith(Constants.R_HEADS)) {
                    branches.add(createBranchInfo(ref, refControl, targets));
                } else if (GitRepositoryManager.REF_CONFIG.equals(ref.getName())) {
                    configBranch = createBranchInfo(ref, refControl, targets);
                }
            }
        }
    } finally {
        db.close();
    }
    Collections.sort(branches, new Comparator<BranchInfo>() {

        @Override
        public int compare(final BranchInfo a, final BranchInfo b) {
            return a.ref.compareTo(b.ref);
        }
    });
    if (configBranch != null) {
        branches.add(0, configBranch);
    }
    if (headBranch != null) {
        branches.add(0, headBranch);
    }
    return branches;
}
#end_block

#method_before
private BranchInfo createBranchInfo(Ref ref, RefControl refControl, Set<String> targets) {
    BranchInfo b = new BranchInfo();
    b.ref = ref.getName();
    if (ref.getObjectId() != null) {
        b.revision = ref.getObjectId().name();
    }
    b.setCanDelete(!targets.contains(ref.getName()) && refControl.canDelete());
    return b;
}
#method_after
private static BranchInfo createBranchInfo(Ref ref, RefControl refControl, Set<String> targets) {
    BranchInfo b = new BranchInfo();
    b.ref = ref.getName();
    if (ref.getObjectId() != null) {
        b.revision = ref.getObjectId().name();
    }
    b.setCanDelete(!targets.contains(ref.getName()) && refControl.canDelete());
    return b;
}
#end_block

#method_before
@Override
public ListBranchesResult call() throws NoSuchProjectException, IOException {
    ProjectControl pctl = projectControlFactory.validateFor(projectName, ProjectControl.OWNER | ProjectControl.VISIBLE);
    try {
        List<Branch> branches = Lists.newArrayList();
        List<BranchInfo> branchInfos = listBranchesProvider.get().apply(new ProjectResource(pctl));
        for (BranchInfo info : branchInfos) {
            Branch b = new Branch(new Branch.NameKey(projectName, info.ref));
            b.setRevision(new RevId(info.revision));
            b.setCanDelete(info.canDelete != null ? true : false);
            branches.add(b);
        }
        return new ListBranchesResult(branches, pctl.canAddRefs(), false);
    } catch (ResourceNotFoundException e) {
        throw new NoSuchProjectException(projectName);
    }
}
#method_after
@Override
public ListBranchesResult call() throws NoSuchProjectException, IOException {
    ProjectControl pctl = projectControlFactory.validateFor(projectName, ProjectControl.OWNER | ProjectControl.VISIBLE);
    try {
        List<Branch> branches = Lists.newArrayList();
        List<BranchInfo> branchInfos = listBranchesProvider.get().apply(new ProjectResource(pctl));
        for (BranchInfo info : branchInfos) {
            Branch b = new Branch(new Branch.NameKey(projectName, info.ref));
            b.setRevision(new RevId(info.revision));
            b.setCanDelete(Objects.firstNonNull(info.canDelete, false));
            branches.add(b);
        }
        return new ListBranchesResult(branches, pctl.canAddRefs(), false);
    } catch (ResourceNotFoundException e) {
        throw new NoSuchProjectException(projectName);
    }
}
#end_block

#method_before
public static File createTempDirectory() throws IOException {
    String dt = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
    File tmp = File.createTempFile("gerrit_test_" + dt + "_", "_site");
    if (!tmp.delete() || !tmp.mkdir()) {
        throw new IOException("Cannot create " + tmp.getPath());
    }
    return tmp;
}
#method_after
public static File createTempDirectory() throws IOException {
    File tmp = File.createTempFile("gerrit_test_", "");
    if (!tmp.delete() || !tmp.mkdir()) {
        throw new IOException("Cannot create " + tmp.getPath());
    }
    return tmp;
}
#end_block

#method_before
public static void recursivelyDelete(File dir) throws IOException {
    if (!dir.getPath().equals(dir.getCanonicalPath())) {
        // Directory symlink reaching outside of temporary space.
        throw new IOException("Refusing to clear symlink " + dir.getPath());
    }
    File[] contents = dir.listFiles();
    if (contents != null) {
        for (File d : contents) {
            if (d.isDirectory()) {
                recursivelyDelete(d);
            } else {
                d.delete();
            }
        }
        dir.delete();
    }
}
#method_after
public static void recursivelyDelete(File dir) throws IOException {
    if (!dir.getPath().equals(dir.getCanonicalPath())) {
        // Directory symlink reaching outside of temporary space.
        throw new IOException("Refusing to clear symlink " + dir.getPath());
    }
    File[] contents = dir.listFiles();
    if (contents != null) {
        for (File d : contents) {
            if (d.isDirectory()) {
                recursivelyDelete(d);
            } else {
                deleteNowOrOnExit(d);
            }
        }
    }
    deleteNowOrOnExit(dir);
}
#end_block

#method_before
private File random() throws IOException {
    String dt = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
    File tmp = File.createTempFile("gerrit_test_" + dt + "_", "_site");
    if (!tmp.delete()) {
        throw new IOException("Cannot create " + tmp.getPath());
    }
    return tmp;
}
#method_after
private static File random() throws IOException {
    File tmp = File.createTempFile("gerrit_test_", "_site");
    if (!tmp.delete()) {
        throw new IOException("Cannot create " + tmp.getPath());
    }
    return tmp;
}
#end_block

#method_before
public Change insertPatchSet(Change change, final PatchSet patchSet, final RevCommit commit, RefControl refControl, ChangeMessage cMessage, boolean copyLabels) throws OrmException, InvalidChangeOperationException, NoSuchChangeException {
    final Change.Id changeId = change.getId();
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    final PatchSet originalPS = db.patchSets().get(currentPatchSetId);
    if (originalPS == null) {
        throw new NoSuchChangeException(changeId);
    }
    db.changes().beginTransaction(change.getId());
    try {
        Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (updatedChange != null) {
            change = updatedChange;
        } else {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange != null) {
            change = updatedChange;
        } else {
            throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), originalPS.getId(), change.currentPatchSetId());
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        if (cMessage != null) {
            db.changeMessages().insert(Collections.singleton(cMessage));
        }
        db.commit();
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    } finally {
        db.rollback();
    }
    return change;
}
#method_after
public Change insertPatchSet(Change change, final PatchSet patchSet, final RevCommit commit, RefControl refControl, String message, boolean copyLabels) throws OrmException, InvalidChangeOperationException, NoSuchChangeException {
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    if (patchSet.getId().get() <= currentPatchSetId.get()) {
        throw new InvalidChangeOperationException("New Patch Set ID [" + patchSet.getId().get() + "] is not greater than the current Patch Set ID [" + currentPatchSetId.get() + "]");
    }
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange != null) {
            change = updatedChange;
        } else {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, change.currentPatchSetId());
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        if (message != null) {
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), patchSet.getId());
            cmsg.setMessage(message);
            db.changeMessages().insert(Collections.singleton(cmsg));
        }
        db.commit();
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    } finally {
        db.rollback();
    }
    return change;
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListGroupMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(ShowCaches.StartupListener.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(ShowCaches.StartupListener.class);
        }
    });
}
#end_block

#method_before
@Override
public boolean match(Repository repo, RevWalk rw, AnyObjectId objectId) {
    try {
        return rFilter.include(rw, rw.parseCommit(objectId));
    } catch (MissingObjectException e) {
        log.error(objectId.getName() + " commit does not exist.", e);
    } catch (IncorrectObjectTypeException e) {
        log.error(objectId.getName() + " revision is not a commit.", e);
    } catch (IOException e) {
        log.error("Could not search for commit message in " + objectId.getName(), e);
    }
    return false;
}
#method_after
@Override
public boolean match(Repository repo, RevWalk rw, Arguments args) {
    try {
        return rFilter.include(rw, rw.parseCommit(args.objectId));
    } catch (MissingObjectException e) {
        log.error(args.projectName.get() + "\" commit does not exist.", e);
    } catch (IncorrectObjectTypeException e) {
        log.error(args.projectName.get() + "\" revision is not a commit.", e);
    } catch (IOException e) {
        log.error("Could not search for commit message in \"" + args.projectName.get() + "\" repository.", e);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean match(ChangeData object) throws OrmException {
    final PatchSet patchSet = object.currentPatchSet(db);
    if (patchSet == null) {
        throw new OrmException("Unable to read patchset for " + object.getId());
    }
    final RevId revision = patchSet.getRevision();
    if (revision == null) {
        throw new OrmException("Unable to read revision for " + object.getId());
    }
    final AnyObjectId objectId = ObjectId.fromString(revision.get());
    if (objectId == null) {
        throw new OrmException("Unable to read objectId(SHA-1) for " + object.getId());
    }
    Change change = object.change(db);
    if (change == null) {
        throw new OrmException("Unable to get change for " + object.getId());
    }
    final Project.NameKey projectName = change.getProject();
    if (projectName == null) {
        throw new OrmException("Unable to get projectName for " + object.getId());
    }
    try {
        final Repository repo = repoManager.openRepository(projectName);
        try {
            final RevWalk rw = new RevWalk(repo);
            try {
                return match(repo, rw, objectId);
            } finally {
                rw.release();
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryNotFoundException e) {
        log.error(projectName.get() + " does not denote an existing repository", e);
    } catch (IOException e) {
        log.error(projectName.get() + " cannot be read as a repository", e);
    }
    return false;
}
#method_after
@Override
public boolean match(ChangeData object) throws OrmException {
    final PatchSet patchSet = object.currentPatchSet(db);
    if (patchSet == null) {
        return false;
    }
    final RevId revision = patchSet.getRevision();
    if (revision == null) {
        return false;
    }
    final AnyObjectId objectId = ObjectId.fromString(revision.get());
    if (objectId == null) {
        return false;
    }
    Change change = object.change(db);
    if (change == null) {
        return false;
    }
    final Project.NameKey projectName = change.getProject();
    if (projectName == null) {
        return false;
    }
    Arguments args = new Arguments(patchSet, revision, objectId, change, projectName);
    try {
        final Repository repo = repoManager.openRepository(projectName);
        try {
            final RevWalk rw = new RevWalk(repo);
            try {
                return match(repo, rw, args);
            } finally {
                rw.release();
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryNotFoundException e) {
        log.error("Repository \"" + projectName.get() + "\" unknown.", e);
    } catch (IOException e) {
        log.error(projectName.get() + " cannot be read as a repository", e);
    }
    return false;
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), null, false, r.getPatchSetInfo(), r.getAccounts(), r.getSubmitTypeRecord(), commentLinkProcessor);
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(approvalPanel);
        approvals.display(change);
    } else {
        approvals.setVisible(false);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    revision = r.getPatchSetInfo().getRevId();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), null, patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c, commentLinkProcessor);
            if (c.getLine() == AbstractPatchContentTable.R_HEAD) {
                editor.setAuthorNameText(Gerrit.getUserAccount().getId(), Util.C.fileCommentHeader());
            } else {
                editor.setAuthorNameText(Gerrit.getUserAccount().getId(), Util.M.lineHeader(c.getLine()));
            }
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#method_after
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), null, false, r.getPatchSetInfo(), r.getAccounts(), r.getSubmitTypeRecord(), commentLinkProcessor);
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(approvalPanel);
        approvals.display(change);
    } else {
        approvals.setVisible(false);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    revision = r.getPatchSetInfo().getRevId();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), null, patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c, commentLinkProcessor);
            if (c.getLine() == AbstractPatchContentTable.R_HEAD) {
                editor.setAuthorNameText(Gerrit.getUserAccount().getPreferredEmail(), Util.C.fileCommentHeader());
            } else {
                editor.setAuthorNameText(Gerrit.getUserAccount().getPreferredEmail(), Util.M.lineHeader(c.getLine()));
            }
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#end_block

#method_before
public void setAuthorNameText(final Account.Id author, final String nameText) {
    header.setWidget(0, 0, new AvatarImage(author, 26));
    header.setText(0, 1, nameText);
}
#method_after
public void setAuthorNameText(final String authorEmail, final String nameText) {
    header.setWidget(0, 0, new AvatarImage(authorEmail, 26));
    header.setText(0, 1, nameText);
}
#end_block

#method_before
protected void setDateText(final String dateText) {
    header.setText(0, 2, dateText);
}
#method_after
protected void setDateText(final String dateText) {
    header.setText(0, 3, dateText);
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    changeInserter.insertChange(db, change, ps, commit, labelTypes, footerLines, info, recipients.getReviewers());
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(change, ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    changeInserter.insertChange(db, change, ps, commit, labelTypes, footerLines, info, recipients.getReviewers());
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void submit(Change change, PatchSet ps) throws OrmException {
    if (!projectControl.controlForRef(MagicBranch.NEW_CHANGE + change.getDest().get()).canSubmit()) {
        addError("Submitting of change " + change.getChangeId() + " not allowed.");
    } else {
        Change c = SubmitChange.submit(db, change, ps, currentUser);
        if (c == null) {
            addError("Submitting change " + change.getChangeId() + " failed.");
        } else {
            addMessage("");
            mergeQueue.merge(c.getDest());
            c = db.changes().get(c.getId());
            switch(c.getStatus()) {
                case SUBMITTED:
                    addMessage("Change " + c.getChangeId() + " submitted.");
                    break;
                case MERGED:
                    addMessage("Change " + c.getChangeId() + " merged.");
                    break;
                case NEW:
                    // If the merge was attempted and it failed the system usually
                    // writes a comment as a ChangeMessage and sets status to NEW.
                    // Find the relevant message and report that as the conflict.
                    final Timestamp before = change.getLastUpdatedOn();
                    ChangeMessage msg = Iterables.getFirst(Iterables.filter(Lists.reverse(db.changeMessages().byChange(c.getId()).toList()), new Predicate<ChangeMessage>() {

                        @Override
                        public boolean apply(ChangeMessage input) {
                            return input.getAuthor() == null && input.getWrittenOn().getTime() >= before.getTime();
                        }
                    }), null);
                    if (msg != null) {
                        addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                        break;
                    }
                default:
                    addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
            }
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(new ChangeResource(changeCtl), ps);
    Change c = submit.submit(rsrc, currentUser);
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final MailRecipients oldRecipients = getRecipientsFromApprovals(ApprovalsUtil.copyLabels(db, labelTypes, priorPatchSet, newPatchSet.getId()));
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(change, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final MailRecipients oldRecipients = getRecipientsFromApprovals(ApprovalsUtil.copyLabels(db, labelTypes, priorPatchSet, newPatchSet.getId()));
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private void initUserAuth(final PublickeyAuthenticator pubkey, final GSSAuthenticator kerberosAuthenticator, String kerberosKeytab, String kerberosPrincipal) {
    List<NamedFactory<UserAuth>> authFactories = new ArrayList<NamedFactory<UserAuth>>();
    if (kerberosKeytab != null) {
        authFactories.add(new UserAuthGSS.Factory());
        log.info("Enabling kerberos with keytab " + kerberosKeytab);
        if (!new File(kerberosKeytab).canRead()) {
            log.error("Keytab " + kerberosKeytab + " does not exist or is not readable; furhter errors are possible");
        }
        kerberosAuthenticator.setKeytabFile(kerberosKeytab);
        if (kerberosPrincipal == null) {
            try {
                kerberosPrincipal = "host/" + InetAddress.getLocalHost().getCanonicalHostName();
            } catch (UnknownHostException e) {
                kerberosPrincipal = "host/localhost";
            }
        }
        log.info("Using kerberos principal " + kerberosPrincipal);
        if (!kerberosPrincipal.startsWith("host/")) {
            log.warn("Host principal does not start with host/ which most SSH clients will supply automatically");
        }
        kerberosAuthenticator.setServicePrincipalName(kerberosPrincipal);
        setGSSAuthenticator(kerberosAuthenticator);
    }
    authFactories.add(new UserAuthPublicKey.Factory());
    setUserAuthFactories(authFactories);
    setPublickeyAuthenticator(pubkey);
}
#method_after
private void initUserAuth(final PublickeyAuthenticator pubkey, final GSSAuthenticator kerberosAuthenticator, String kerberosKeytab, String kerberosPrincipal) {
    List<NamedFactory<UserAuth>> authFactories = Lists.newArrayList();
    if (kerberosKeytab != null) {
        authFactories.add(new UserAuthGSS.Factory());
        log.info("Enabling kerberos with keytab " + kerberosKeytab);
        if (!new File(kerberosKeytab).canRead()) {
            log.error("Keytab " + kerberosKeytab + " does not exist or is not readable; further errors are possible");
        }
        kerberosAuthenticator.setKeytabFile(kerberosKeytab);
        if (kerberosPrincipal == null) {
            try {
                kerberosPrincipal = "host/" + InetAddress.getLocalHost().getCanonicalHostName();
            } catch (UnknownHostException e) {
                kerberosPrincipal = "host/localhost";
            }
        }
        log.info("Using kerberos principal " + kerberosPrincipal);
        if (!kerberosPrincipal.startsWith("host/")) {
            log.warn("Host principal does not start with host/ " + "which most SSH clients will supply automatically");
        }
        kerberosAuthenticator.setServicePrincipalName(kerberosPrincipal);
        setGSSAuthenticator(kerberosAuthenticator);
    }
    authFactories.add(new UserAuthPublicKey.Factory());
    setUserAuthFactories(authFactories);
    setPublickeyAuthenticator(pubkey);
}
#end_block

#method_before
@Override
public boolean validateIdentity(final ServerSession session, final String identity) {
    final SshSession sd = session.getAttribute(SshSession.KEY);
    int at = identity.indexOf('@');
    String username;
    if (at == -1) {
        username = identity;
    } else {
        username = identity.substring(0, at);
    }
    AccountState state = accounts.getByUsername(username);
    Account account = state == null ? null : state.getAccount();
    boolean active = account != null && account.isActive();
    if (active) {
        return SshUtil.success(username, session, sd, SshUtil.createUser(sd, account, userFactory), sshScope, sshLog);
    } else {
        return false;
    }
}
#method_after
@Override
public boolean validateIdentity(final ServerSession session, final String identity) {
    final SshSession sd = session.getAttribute(SshSession.KEY);
    int at = identity.indexOf('@');
    String username;
    if (at == -1) {
        username = identity;
    } else {
        username = identity.substring(0, at);
    }
    AccountState state = accounts.getByUsername(username);
    Account account = state == null ? null : state.getAccount();
    boolean active = account != null && account.isActive();
    if (active) {
        return SshUtil.success(username, session, sshScope, sshLog, sd, SshUtil.createUser(sd, userFactory, account.getId()));
    } else {
        return false;
    }
}
#end_block

#method_before
public GarbageCollectionResult run(final List<Project.NameKey> projectNames, final GarbageCollectionProgressMonitor pm) {
    final GarbageCollectionResult result = new GarbageCollectionResult();
    if (!currentUser.getCapabilities().canRunGC()) {
        result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_PERMITTED, currentUser.getUserName()));
        return result;
    }
    for (final Project.NameKey projectName : projectNames) {
        pm.startGarbageCollection(projectName);
        try {
            final Repository repo = repoManager.openRepository(projectName);
            try {
                if (!(repo instanceof FileRepository)) {
                    result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_SUPPORTED, projectName));
                    continue;
                }
                GC.gc(pm, (FileRepository) repo);
            } catch (IOException e) {
                log.error("garbage collection for project \"" + projectName + "\" failed", e);
                result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_FAILED, projectName));
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException e) {
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.REPOSITORY_NOT_FOUND, projectName));
        } finally {
            pm.endGarbageCollection();
        }
    }
    return result;
}
#method_after
public GarbageCollectionResult run(final List<Project.NameKey> projectNames, final PrintWriter writer) {
    final GarbageCollectionResult result = new GarbageCollectionResult();
    if (!currentUser.getCapabilities().canRunGC()) {
        result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_PERMITTED, currentUser.getUserName()));
        return result;
    }
    for (final Project.NameKey projectName : projectNames) {
        writer.print("collecting garbage for \"" + projectName + "\":\n");
        try {
            final Repository repo = repoManager.openRepository(projectName);
            try {
                if (!(repo instanceof FileRepository)) {
                    result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_SUPPORTED, projectName));
                    continue;
                }
                GC.gc(new TextProgressMonitor(writer), (FileRepository) repo);
            } catch (IOException e) {
                log.error("garbage collection for project \"" + projectName + "\" failed", e);
                result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_FAILED, projectName));
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException e) {
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.REPOSITORY_NOT_FOUND, projectName));
        } finally {
            writer.print("done.\n\n");
        }
    }
    return result;
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            stdout = toPrintWriter(out);
            try {
                parseCommandLine();
                verifyCommandLine();
                collectGarbage();
            } finally {
                stdout.flush();
            }
        }
    });
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            stdout = toPrintWriter(out);
            try {
                parseCommandLine();
                verifyCommandLine();
                runGC();
            } finally {
                stdout.flush();
            }
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    get(PROJECT_KIND, "head").to(GetHead.class);
    put(PROJECT_KIND, "head").to(SetHead.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
}
#end_block

#method_before
@Override
public String apply(ProjectResource rsrc, Input input) throws AuthException, ResourceNotFoundException, BadRequestException, UnprocessableEntityException, IOException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.ref)) {
        throw new BadRequestException("ref required");
    }
    String ref = input.ref;
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        if (repo.getRef(ref) == null) {
            throw new UnprocessableEntityException(String.format("Ref Not Found: %s", input.ref));
        }
        if (!repo.getRef(Constants.HEAD).getTarget().getName().equals(ref)) {
            final RefUpdate u = repo.updateRef(Constants.HEAD, true);
            u.disableRefLog();
            RefUpdate.Result res = u.link(ref);
            switch(res) {
                case NO_CHANGE:
                case RENAMED:
                case FORCED:
                    break;
                default:
                    throw new IOException("Setting HEAD failed with " + res);
            }
        }
        return ref;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#method_after
@Override
public String apply(ProjectResource rsrc, Input input) throws AuthException, ResourceNotFoundException, BadRequestException, UnprocessableEntityException, IOException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.ref)) {
        throw new BadRequestException("ref required");
    }
    String ref = input.ref;
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        if (repo.getRef(ref) == null) {
            throw new UnprocessableEntityException(String.format("Ref Not Found: %s", ref));
        }
        if (!repo.getRef(Constants.HEAD).getTarget().getName().equals(ref)) {
            final RefUpdate u = repo.updateRef(Constants.HEAD, true);
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            RefUpdate.Result res = u.link(ref);
            switch(res) {
                case NO_CHANGE:
                case RENAMED:
                case FORCED:
                case NEW:
                    break;
                default:
                    throw new IOException("Setting HEAD failed with " + res);
            }
        }
        return ref;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#end_block

#method_before
@Override
public String apply(ProjectResource rsrc) throws AuthException, ResourceNotFoundException, IOException {
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        String headRef = repo.getRef(Constants.HEAD).getTarget().getName();
        if (!rsrc.getControl().controlForRef(headRef).isVisible()) {
            throw new AuthException();
        }
        return headRef;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#method_after
@Override
public String apply(ProjectResource rsrc) throws AuthException, ResourceNotFoundException, IOException {
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        Ref head = repo.getRef(Constants.HEAD);
        if (head == null) {
            throw new ResourceNotFoundException(Constants.HEAD);
        } else if (head.isSymbolic()) {
            String n = head.getTarget().getName();
            if (rsrc.getControl().controlForRef(n).isVisible()) {
                return n;
            }
            throw new AuthException();
        } else if (head.getObjectId() != null) {
            if (rsrc.getControl().isOwner()) {
                return head.getObjectId().name();
            }
            throw new AuthException();
        }
        throw new ResourceNotFoundException(Constants.HEAD);
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.mergeable = in.getStatus() != Change.Status.MERGED ? in.isMergeable() : null;
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd, options.contains(LABELS), options.contains(DETAILED_LABELS));
    if (options.contains(DETAILED_LABELS)) {
        out.permitted_labels = permittedLabels(cd);
        out.removable_reviewers = removableReviewers(cd);
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION) || cd.getLimitedPatchSets() != null) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.mergeable = in.getStatus() != Change.Status.MERGED ? in.isMergeable() : null;
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd, options.contains(LABELS), options.contains(DETAILED_LABELS));
    if (options.contains(DETAILED_LABELS)) {
        out.permitted_labels = permittedLabels(cd);
        out.removable_reviewers = removableReviewers(cd, out.labels.values());
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION) || cd.getLimitedPatchSets() != null) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> initLabels(ChangeData cd, boolean standard) throws OrmException {
    // For the following TreeMap, we'd rather use
    // [...] = Maps.newTreeMap(LabelOrdering.create(approvalTypes));
    // but this fails on OpenJDK 6. See:
    // http://bugs.openjdk.java.net/show_bug.cgi?id=100167#c1
    // To still be able to compile on OpenJDK 6, we instantiate the following
    // TreeMap directly.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(LabelOrdering.create(approvalTypes));
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> initLabels(ChangeData cd, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(LabelOrdering.create(approvalTypes));
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsForClosedChange(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    // For the following TreeMap, we'd rather use
    // [...] = Maps.newTreeMap(LabelOrdering.create(approvalTypes));
    // but this fails on OpenJDK 6. See:
    // http://bugs.openjdk.java.net/show_bug.cgi?id=100167#c1
    // To still be able to compile on OpenJDK 6, we instantiate the following
    // TreeMap directly.
    // 
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(LabelOrdering.create(approvalTypes));
    for (PatchSetApproval psa : cd.currentApprovals(db)) {
        ApprovalType type = approvalTypes.byId(psa.getCategoryId());
        if (type == null) {
            continue;
        }
        String label = type.getCategory().getLabelName();
        LabelInfo li = labels.get(label);
        if (li == null) {
            li = new LabelInfo();
            labels.put(label, li);
            if (detailed) {
                setLabelValues(type, li);
            }
        }
        short val = psa.getValue();
        if (detailed) {
            li.addApproval(approvalInfo(psa.getAccountId(), val));
        }
        if (!standard || li.approved != null || li.rejected != null) {
            continue;
        }
        if (val == type.getMax().getValue()) {
            li.approved = accountInfo(psa);
        } else if (val == type.getMin().getValue() && // A merged change can't have been rejected.
        cd.getChange().getStatus() != Status.MERGED) {
            li.rejected = accountInfo(psa);
        } else if (val > 0) {
            li.recommended = accountInfo(psa);
            li.value = val;
        } else if (val < 0) {
            li.disliked = accountInfo(psa);
            li.value = val;
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsForClosedChange(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    // 
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(LabelOrdering.create(approvalTypes));
    for (PatchSetApproval psa : cd.currentApprovals(db)) {
        ApprovalType type = approvalTypes.byId(psa.getCategoryId());
        if (type == null) {
            continue;
        }
        String label = type.getCategory().getLabelName();
        LabelInfo li = labels.get(label);
        if (li == null) {
            li = new LabelInfo();
            labels.put(label, li);
            if (detailed) {
                setLabelValues(type, li);
            }
        }
        short val = psa.getValue();
        if (detailed) {
            li.addApproval(approvalInfo(psa.getAccountId(), val));
        }
        if (!standard || li.approved != null || li.rejected != null) {
            continue;
        }
        if (val == type.getMax().getValue()) {
            li.approved = accountInfo(psa);
        } else if (val == type.getMin().getValue() && // A merged change can't have been rejected.
        cd.getChange().getStatus() != Status.MERGED) {
            li.rejected = accountInfo(psa);
        } else if (val > 0) {
            li.recommended = accountInfo(psa);
            li.value = val;
        } else if (val < 0) {
            li.disliked = accountInfo(psa);
            li.value = val;
        }
    }
    return labels;
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return ImmutableList.of();
    }
    Change change = ctl.getChange();
    if (!change.getStatus().isOpen() || !(ctl.getCurrentUser() instanceof IdentifiedUser)) {
        return ImmutableList.of();
    }
    Set<Account.Id> fixed = Sets.newHashSet();
    Set<Account.Id> removable = Sets.newHashSet();
    for (PatchSetApproval app : cd.currentApprovals(db)) {
        if (ctl.canRemoveReviewer(app)) {
            removable.add(app.getAccountId());
        } else {
            fixed.add(app.getAccountId());
        }
    }
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeData cd, Collection<LabelInfo> labels) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return ImmutableList.of();
    }
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            if (ctl.canRemoveReviewer(ai._id, ai.value)) {
                removable.add(ai._id);
            } else {
                fixed.add(ai._id);
            }
        }
    }
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#end_block

#method_before
public ReviewerInfo format(ReviewerInfo out, ChangeControl ctl, List<PatchSetApproval> approvals) throws OrmException {
    PatchSet.Id psId = ctl.getChange().currentPatchSetId();
    if (approvals == null) {
        approvals = ChangeData.sortApprovals(db.get().patchSetApprovals().byPatchSetUser(psId, out._id));
    }
    FunctionState fs = functionState.create(ctl, psId, approvals);
    for (ApprovalType at : approvalTypes.getApprovalTypes()) {
        CategoryFunction.forCategory(at.getCategory()).run(at, fs);
    }
    // For the following TreeMap, we'd rather use
    // [...] = Maps.newTreeMap(LabelOrdering.create(approvalTypes));
    // but this fails on OpenJDK 6. See:
    // http://bugs.openjdk.java.net/show_bug.cgi?id=100167#c1
    // To still be able to compile on OpenJDK 6, we instantiate the following
    // TreeMap directly.
    out.approvals = new TreeMap<String, String>(LabelOrdering.create(approvalTypes));
    for (PatchSetApproval ca : approvals) {
        for (PermissionRange pr : ctl.getLabelRanges()) {
            if (!pr.isEmpty()) {
                // TODO: Support arbitrary labels.
                ApprovalType at = approvalTypes.byId(ca.getCategoryId());
                if (at != null) {
                    out.approvals.put(at.getCategory().getLabelName(), formatValue(ca.getValue()));
                }
            }
        }
    }
    // Add dummy approvals for all permitted labels for the user even if they
    // do not exist in the DB.
    ChangeData cd = new ChangeData(ctl);
    PatchSet ps = cd.currentPatchSet(db);
    if (ps != null) {
        for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
            for (SubmitRecord.Label label : rec.labels) {
                String name = label.label;
                if (!out.approvals.containsKey(name) && !ctl.getRange(Permission.forLabel(name)).isEmpty()) {
                    out.approvals.put(name, formatValue((short) 0));
                }
            }
        }
    }
    if (out.approvals.isEmpty()) {
        out.approvals = null;
    }
    return out;
}
#method_after
public ReviewerInfo format(ReviewerInfo out, ChangeControl ctl, List<PatchSetApproval> approvals) throws OrmException {
    PatchSet.Id psId = ctl.getChange().currentPatchSetId();
    if (approvals == null) {
        approvals = ChangeData.sortApprovals(db.get().patchSetApprovals().byPatchSetUser(psId, out._id));
    }
    FunctionState fs = functionState.create(ctl, psId, approvals);
    for (ApprovalType at : approvalTypes.getApprovalTypes()) {
        CategoryFunction.forCategory(at.getCategory()).run(at, fs);
    }
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    out.approvals = new TreeMap<String, String>(LabelOrdering.create(approvalTypes));
    for (PatchSetApproval ca : approvals) {
        for (PermissionRange pr : ctl.getLabelRanges()) {
            if (!pr.isEmpty()) {
                // TODO: Support arbitrary labels.
                ApprovalType at = approvalTypes.byId(ca.getCategoryId());
                if (at != null) {
                    out.approvals.put(at.getCategory().getLabelName(), formatValue(ca.getValue()));
                }
            }
        }
    }
    // Add dummy approvals for all permitted labels for the user even if they
    // do not exist in the DB.
    ChangeData cd = new ChangeData(ctl);
    PatchSet ps = cd.currentPatchSet(db);
    if (ps != null) {
        for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
            for (SubmitRecord.Label label : rec.labels) {
                String name = label.label;
                if (!out.approvals.containsKey(name) && !ctl.getRange(Permission.forLabel(name)).isEmpty()) {
                    out.approvals.put(name, formatValue((short) 0));
                }
            }
        }
    }
    if (out.approvals.isEmpty()) {
        out.approvals = null;
    }
    return out;
}
#end_block

#method_before
public final Set<String> values() {
    return Natives.keys(values0());
}
#method_after
public final Set<String> values() {
    return Natives.keys(_values());
}
#end_block

#method_before
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    if (!accounts.isEmpty()) {
        for (Account account : db.get().accounts().get(accounts.keySet())) {
            AccountAttribute a = accounts.get(account.getId());
            a.name = Strings.emptyToNull(account.getFullName());
        }
    }
    return res;
}
#method_after
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = asAccountAttribute(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    if (options.contains(LABELS) || options.contains(DETAILED_LABELS)) {
        out.labels = labelsFor(cd, options.contains(DETAILED_LABELS));
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd, options.contains(LABELS), options.contains(DETAILED_LABELS));
    if (options.contains(DETAILED_LABELS)) {
        out.permitted_labels = permittedLabels(cd);
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean detailed) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = asAccountAttribute(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = asAccountAttribute(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                if (detailed) {
                    ApprovalType at = approvalTypes.byLabel(r.label);
                    if (at != null) {
                        PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
                        n.category = at.getCategory().getName();
                        n.id = at.getCategory().getId().get();
                        n.values = Maps.newLinkedHashMap();
                        for (ApprovalCategoryValue acv : at.getValues()) {
                            if (range.contains(acv.getValue())) {
                                n.values.put(acv.formatValue(), acv.getName());
                            }
                        }
                        if (n.values.size() == 1 && " 0".equals(Iterables.getOnlyElement(n.values.keySet()))) {
                            n.values = ImmutableMap.of();
                        }
                    }
                }
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    initLabels(cd, labels, standard);
    Collection<PatchSetApproval> approvals = null;
    if (detailed) {
        approvals = cd.currentApprovals(db);
        setAllApprovals(labels, approvals);
    }
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null) {
            // TODO: Support arbitrary labels.
            continue;
        }
        if (standard) {
            approvals = setRecommendedAndDisliked(cd, approvals, type, e.getValue());
        }
        if (detailed) {
            setLabelValues(type, e.getValue());
        }
    }
    return labels;
}
#end_block

#method_before
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountInfoCache = new AccountInfo.Cache(db, !options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountInfoCache.fill();
    return res;
}
#method_after
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountInfoCache.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = options.contains(LABELS) ? labelsFor(cd) : null;
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = options.contains(LABELS) ? labelsFor(cd) : null;
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = accountInfoCache.get(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = accountInfoCache.get(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = accountInfoCache.get(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = accountInfoCache.get(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = accountLoader.get(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = accountLoader.get(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = accountLoader.get(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = accountLoader.get(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#end_block

#method_before
@Override
public GroupInfo apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, BadRequestException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    } else if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    if (input == null || Strings.emptyToNull(input.owner) == null) {
        throw new BadRequestException("new owner is missing");
    }
    GroupReference owner = GroupBackends.findExactSuggestion(groupBackend, input.owner);
    if (owner == null) {
        throw new BadRequestException(String.format("No such group: %s", input.owner));
    }
    try {
        GroupControl c = controlFactory.validateFor(owner.getUUID());
        if (!internalGroup.getOwnerGroupUUID().equals(owner.getUUID())) {
            internalGroup.setOwnerGroupUUID(owner.getUUID());
            db.accountGroups().update(Collections.singleton(internalGroup));
            groupCache.evict(internalGroup);
        }
        return new GroupInfo(c.getGroup());
    } catch (NoSuchGroupException e) {
        throw new BadRequestException(String.format("No such group: %s", input.owner));
    }
}
#method_after
@Override
public GroupInfo apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, BadRequestException, ResourceNotFoundException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    } else if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.owner)) {
        throw new BadRequestException("owner is required");
    }
    GroupReference owner = GroupBackends.findExactSuggestion(groupBackend, input.owner);
    if (owner == null) {
        throw new BadRequestException(String.format("No such group: %s", input.owner));
    }
    try {
        GroupControl c = controlFactory.validateFor(owner.getUUID());
        group = db.accountGroups().get(group.getId());
        if (group == null) {
            throw new ResourceNotFoundException();
        }
        if (!group.getOwnerGroupUUID().equals(owner.getUUID())) {
            group.setOwnerGroupUUID(owner.getUUID());
            db.accountGroups().update(Collections.singleton(group));
            groupCache.evict(group);
        }
        return new GroupInfo(c.getGroup());
    } catch (NoSuchGroupException e) {
        throw new BadRequestException(String.format("No such group: %s", input.owner));
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    com.google.gwtjsonrpc.common.AsyncCallback<PatchSetPublishDetail> load = new ScreenLoadCallback<PatchSetPublishDetail>(this) {

        @Override
        protected void preDisplay(final PatchSetPublishDetail result) {
            send.setEnabled(true);
            display(result);
        }

        @Override
        protected void postDisplay() {
            message.setFocus(true);
        }
    };
    CallbackGroup cbs = new CallbackGroup();
    Util.DETAIL_SVC.patchSetPublishDetail(patchSetId, cbs.add(load));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cbs = new CallbackGroup();
    Util.DETAIL_SVC.patchSetPublishDetail(patchSetId, cbs.addGwtjsonrpc(new ScreenLoadCallback<PatchSetPublishDetail>(this) {

        @Override
        protected void preDisplay(final PatchSetPublishDetail result) {
            send.setEnabled(true);
            display(result);
        }

        @Override
        protected void postDisplay() {
            message.setFocus(true);
        }
    }));
}
#end_block

#method_before
private void onSuccess() {
    if (results.size() < callbacks.size()) {
        return;
    }
    Throwable caught = null;
    for (Object o : callbacks) {
        try {
            Object result = results.get(o);
            if (o instanceof AsyncCallback) {
                @SuppressWarnings("unchecked")
                AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
                cb.onSuccess(result);
            } else {
                @SuppressWarnings("unchecked")
                com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
                cb.onSuccess(result);
            }
        } catch (Throwable t) {
            if (caught != null) {
                caught = t;
            }
        }
    }
    if (caught != null) {
        if (caught instanceof RuntimeException) {
            throw (RuntimeException) caught;
        } else if (caught instanceof Error) {
            throw (Error) caught;
        } else {
            throw new RuntimeException(caught);
        }
    }
}
#method_after
private void onSuccess() {
    if (results.size() < callbacks.size()) {
        return;
    }
    for (Object o : callbacks) {
        Object result = results.get(o);
        if (o instanceof AsyncCallback) {
            @SuppressWarnings("unchecked")
            AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
            cb.onSuccess(result);
        } else {
            @SuppressWarnings("unchecked")
            com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
            cb.onSuccess(result);
        }
    }
}
#end_block

#method_before
private void onFailure(Throwable caught) {
    for (Object o : callbacks) {
        if (o instanceof AsyncCallback) {
            @SuppressWarnings("unchecked")
            AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
            cb.onFailure(caught);
        } else {
            @SuppressWarnings("unchecked")
            com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
            cb.onFailure(caught);
        }
    }
}
#method_after
private void onFailure(Throwable caught) {
    if (failed) {
        return;
    }
    failed = true;
    for (Object o : callbacks) {
        if (o instanceof AsyncCallback) {
            @SuppressWarnings("unchecked")
            AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
            cb.onFailure(caught);
        } else {
            @SuppressWarnings("unchecked")
            com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
            cb.onFailure(caught);
        }
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    if (!headless) {
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    if (uiOptions.enableDefaultUi()) {
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bindConstant().annotatedWith(Names.named("Headless")).to(false);
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    modules.add(SshKeyCacheImpl.module());
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bindConstant().annotatedWith(Names.named("HEADLESS")).to(headless);
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    modules.add(SshKeyCacheImpl.module());
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    switch(authConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
            install(new HttpAuthModule());
            break;
        case CLIENT_SSL_CERT_LDAP:
            install(new HttpsClientSslCertModule());
            break;
        case LDAP:
        case LDAP_BIND:
            install(new LdapAuthModule());
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            install(new ServletModule() {

                @Override
                protected void configureServlets() {
                    serve("/become").with(BecomeAnyAccountLoginServlet.class);
                }
            });
            break;
        case OPENID:
        case OPENID_SSO:
        // OpenID support is bound in WebAppInitializer and Daemon.
        case CUSTOM_EXTENSION:
            break;
        default:
            throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
    }
    install(new UrlModule(urlConfig, headless));
    install(new UiRpcModule());
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module());
    bind(GitWebConfig.class).toInstance(gitWebConfig);
    if (gitWebConfig.getGitwebCGI() != null) {
        install(new GitWebModule());
    }
    bind(ContactStore.class).toProvider(ContactStoreProvider.class).in(SINGLETON);
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    factory(ClearPassword.Factory.class);
    install(new CmdLineParserModule());
    factory(GeneratePassword.Factory.class);
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().toInstance(registerInParentInjectors());
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    switch(authConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
            install(new HttpAuthModule());
            break;
        case CLIENT_SSL_CERT_LDAP:
            install(new HttpsClientSslCertModule());
            break;
        case LDAP:
        case LDAP_BIND:
            install(new LdapAuthModule());
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            install(new ServletModule() {

                @Override
                protected void configureServlets() {
                    serve("/become").with(BecomeAnyAccountLoginServlet.class);
                }
            });
            break;
        case OPENID:
        case OPENID_SSO:
        // OpenID support is bound in WebAppInitializer and Daemon.
        case CUSTOM_EXTENSION:
            break;
        default:
            throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
    }
    install(new UrlModule(urlConfig, uiOptions));
    install(new UiRpcModule());
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module());
    bind(GitWebConfig.class).toInstance(gitWebConfig);
    if (gitWebConfig.getGitwebCGI() != null) {
        install(new GitWebModule());
    }
    bind(ContactStore.class).toProvider(ContactStoreProvider.class).in(SINGLETON);
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    factory(ClearPassword.Factory.class);
    install(new CmdLineParserModule());
    factory(GeneratePassword.Factory.class);
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().toInstance(registerInParentInjectors());
        }
    });
}
#end_block

#method_before
public static void removeMembers(AccountGroup.UUID groupUUID, Set<Account.Id> ids, AsyncCallback<VoidResult> cb) {
    RestApi call = new RestApi(membersBase(groupUUID));
    MemberInput input = MemberInput.create();
    for (Account.Id id : ids) {
        input.add_member(Integer.toString(id.get()));
    }
    call.data(input).delete(cb);
}
#method_after
public static void removeMembers(AccountGroup.UUID groupUUID, Set<Account.Id> ids, AsyncCallback<VoidResult> cb) {
    RestApi call = new RestApi(membersBase(groupUUID));
    MemberInput input = MemberInput.create();
    for (Account.Id id : ids) {
        input.add_member(id.toString());
    }
    call.data(input).delete(cb);
}
#end_block

#method_before
void doAddNewMember() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    GroupApi.addMembers(getGroupUUID(), Collections.singleton(nameEmail), new GerritCallback<NativeList<MemberInfo>>() {

        public void onSuccess(final NativeList<MemberInfo> memberInfo) {
            Gerrit.display(Dispatcher.toGroup(getGroupUUID(), AccountGroupScreen.MEMBERS));
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
void doAddNewMember() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    GroupApi.addMember(getGroupUUID(), nameEmail, new GerritCallback<MemberInfo>() {

        public void onSuccess(final MemberInfo memberInfo) {
            Gerrit.display(Dispatcher.toGroup(getGroupUUID(), AccountGroupScreen.MEMBERS));
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), INCLUDED_GROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(GROUP_KIND, "members").to(PutMember.class);
    delete(GROUP_KIND, "members").to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(IncludedGroupsCollection.class);
    get(INCLUDED_GROUP_KIND).to(GetIncludedGroup.class);
}
#method_after
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), INCLUDED_GROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(GROUP_KIND, "members").to(PutMembers.class);
    delete(GROUP_KIND, "members").to(DeleteMembers.class);
    delete(MEMBER_KIND).to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(IncludedGroupsCollection.class);
    get(INCLUDED_GROUP_KIND).to(GetIncludedGroup.class);
}
#end_block

#method_before
private static void whoAmI(boolean canLogOut) {
    Account account = getUserAccount();
    final CurrentUserPopupPanel userPopup = new CurrentUserPopupPanel(account, canLogOut);
    final String name = FormatUtil.name(account);
    String[] names = name.split("\\s+", 2);
    final InlineLabel l = new InlineLabel(names[0] + " ▾");
    l.setStyleName(RESOURCES.css().menuBarUserName());
    l.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (userPopup.isShowing()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(l);
            }
        }
    });
    userPopup.addAutoHidePartner(l.getElement());
    menuRight.add(l);
}
#method_after
private static void whoAmI(boolean canLogOut) {
    Account account = getUserAccount();
    final CurrentUserPopupPanel userPopup = new CurrentUserPopupPanel(account, canLogOut);
    final InlineLabel l = new InlineLabel(FormatUtil.name(account) + " ▾");
    l.setStyleName(RESOURCES.css().menuBarUserName());
    l.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (userPopup.isShowing()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(l);
            }
        }
    });
    userPopup.addAutoHidePartner(l.getElement());
    FocusPanel fp = new FocusPanel(l);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(new KeyDownHandler() {

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                if (userPopup.isShowing()) {
                    userPopup.hide();
                } else {
                    userPopup.showRelativeTo(l);
                }
                event.preventDefault();
            }
        }
    });
    menuRight.add(fp);
}
#end_block

#method_before
public JsonElement display(OutputStream displayOutputStream) throws NoSuchGroupException {
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        try {
            stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, "UTF-8")));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("JVM lacks UTF-8 encoding", e);
        }
    }
    try {
        List<GroupInfo> groups;
        if (user != null) {
            groups = accountGetGroups.get().apply(new AccountResource(userFactory.create(user)));
        } else {
            VisibleGroups visibleGroups = visibleGroupsFactory.create();
            visibleGroups.setOnlyVisibleToAll(visibleToAll);
            visibleGroups.setGroupType(groupType);
            visibleGroups.setMatch(matchSubstring);
            List<AccountGroup> groupList;
            if (!projects.isEmpty()) {
                groupList = visibleGroups.get(projects);
            } else {
                groupList = visibleGroups.get();
            }
            groups = Lists.newArrayListWithCapacity(groupList.size());
            for (AccountGroup group : groupList) {
                groups.add(new GroupInfo(GroupDescriptions.forAccountGroup(group)));
            }
        }
        if (stdout == null) {
            final Map<String, GroupInfo> output = Maps.newTreeMap();
            for (GroupInfo info : groups) {
                output.put(Objects.firstNonNull(info.name, "Group " + info.id), info);
                info.name = null;
            }
            return OutputFormat.JSON.newGson().toJsonTree(output, new TypeToken<Map<String, GroupInfo>>() {
            }.getType());
        } else {
            final ColumnFormatter formatter = new ColumnFormatter(stdout, '\t');
            for (GroupInfo info : groups) {
                formatter.addColumn(info.name);
                if (verboseOutput) {
                    formatter.addColumn(info.id);
                    formatter.addColumn(Strings.nullToEmpty(info.description));
                    formatter.addColumn(Objects.firstNonNull(info.ownerId, "n/a"));
                    formatter.addColumn(Boolean.toString(Objects.firstNonNull(info.visibleToAll, Boolean.FALSE)));
                }
                formatter.nextLine();
            }
            formatter.finish();
            return null;
        }
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#method_after
public JsonElement display(OutputStream displayOutputStream) throws NoSuchGroupException {
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        try {
            stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, "UTF-8")));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("JVM lacks UTF-8 encoding", e);
        }
    }
    try {
        List<GroupInfo> groups;
        if (user != null) {
            groups = accountGetGroups.get().apply(new AccountResource(userFactory.create(user)));
        } else {
            VisibleGroups visibleGroups = visibleGroupsFactory.create();
            visibleGroups.setOnlyVisibleToAll(visibleToAll);
            visibleGroups.setGroupType(groupType);
            visibleGroups.setMatch(matchSubstring);
            List<AccountGroup> groupList;
            if (!projects.isEmpty()) {
                groupList = visibleGroups.get(projects);
            } else {
                groupList = visibleGroups.get();
            }
            groups = Lists.newArrayListWithCapacity(groupList.size());
            for (AccountGroup group : groupList) {
                groups.add(new GroupInfo(GroupDescriptions.forAccountGroup(group)));
            }
        }
        if (stdout == null) {
            final Map<String, GroupInfo> output = Maps.newTreeMap();
            for (GroupInfo info : groups) {
                output.put(Objects.firstNonNull(info.name, "Group " + Url.decode(info.id)), info);
                info.name = null;
            }
            return OutputFormat.JSON.newGson().toJsonTree(output, new TypeToken<Map<String, GroupInfo>>() {
            }.getType());
        } else {
            final ColumnFormatter formatter = new ColumnFormatter(stdout, '\t');
            for (GroupInfo info : groups) {
                formatter.addColumn(info.name);
                if (verboseOutput) {
                    AccountGroup o = info.ownerId != null ? groupCache.get(new AccountGroup.UUID(Url.decode(info.ownerId))) : null;
                    formatter.addColumn(Url.decode(info.id));
                    formatter.addColumn(Strings.nullToEmpty(info.description));
                    formatter.addColumn(o != null ? o.getName() : "n/a");
                    formatter.addColumn(o != null ? o.getGroupUUID().get() : "");
                    formatter.addColumn(Boolean.toString(Objects.firstNonNull(info.visibleToAll, Boolean.FALSE)));
                }
                formatter.nextLine();
            }
            formatter.finish();
            return null;
        }
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#end_block

#method_before
public DynamicItem<T> get() {
    return new DynamicItem<T>(find(injector, type));
}
#method_after
public DynamicItem<T> get() {
    return new DynamicItem<T>(key, find(injector, type), "gerrit");
}
#end_block

#method_before
private static <T> AtomicReference<Provider<T>> find(Injector src, TypeLiteral<T> type) {
    List<Binding<T>> bindings = src.findBindingsByType(type);
    if (bindings != null) {
        for (Binding<T> b : bindings) {
            if (b.getKey().getAnnotation() != null) {
                // TODO: throw exception if > 1 match?
                return new AtomicReference<Provider<T>>(b.getProvider());
            }
        }
    }
    return new AtomicReference<Provider<T>>();
}
#method_after
private static <T> Provider<T> find(Injector src, TypeLiteral<T> type) {
    List<Binding<T>> bindings = src.findBindingsByType(type);
    if (bindings != null && bindings.size() == 1) {
        return bindings.get(0).getProvider();
    } else if (bindings != null && bindings.size() > 1) {
        throw new ProvisionException(String.format("Multiple providers bound for DynamicItem<%s>\n" + "This is not allowed; check the server configuration.", type));
    } else {
        return null;
    }
}
#end_block

#method_before
public static List<RegistrationHandle> attachItems(Injector src, Map<TypeLiteral<?>, DynamicItem<?>> items) {
    if (src == null || items == null || items.isEmpty()) {
        return Collections.emptyList();
    }
    List<RegistrationHandle> handles = new ArrayList<RegistrationHandle>(4);
    try {
        for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
            @SuppressWarnings("unchecked")
            TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
            @SuppressWarnings("unchecked")
            DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
            for (Binding<Object> b : bindings(src, type)) {
                if (b.getKey().getAnnotation() != null) {
                    handles.add(item.set(b.getKey(), b.getProvider()));
                }
            }
        }
    } catch (RuntimeException e) {
        remove(handles);
        throw e;
    } catch (Error e) {
        remove(handles);
        throw e;
    }
    return handles;
}
#method_after
public static List<RegistrationHandle> attachItems(Injector src, Map<TypeLiteral<?>, DynamicItem<?>> items, String pluginName) {
    if (src == null || items == null || items.isEmpty()) {
        return Collections.emptyList();
    }
    List<RegistrationHandle> handles = new ArrayList<RegistrationHandle>(4);
    try {
        for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
            @SuppressWarnings("unchecked")
            TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
            @SuppressWarnings("unchecked")
            DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
            for (Binding<Object> b : bindings(src, type)) {
                if (b.getKey().getAnnotation() != null) {
                    handles.add(item.set(b.getKey(), b.getProvider(), pluginName));
                }
            }
        }
    } catch (RuntimeException e) {
        remove(handles);
        throw e;
    } catch (Error e) {
        remove(handles);
        throw e;
    }
    return handles;
}
#end_block

#method_before
public static <T> void itemOf(Binder binder, TypeLiteral<T> member) {
    @SuppressWarnings("unchecked")
    Key<DynamicItem<T>> key = (Key<DynamicItem<T>>) Key.get(Types.newParameterizedType(DynamicItem.class, member.getType()));
    binder.bind(key).toProvider(new DynamicItemProvider<T>(member)).in(Scopes.SINGLETON);
}
#method_after
public static <T> void itemOf(Binder binder, TypeLiteral<T> member) {
    @SuppressWarnings("unchecked")
    Key<DynamicItem<T>> key = (Key<DynamicItem<T>>) Key.get(Types.newParameterizedType(DynamicItem.class, member.getType()));
    binder.bind(key).toProvider(new DynamicItemProvider<T>(member, key)).in(Scopes.SINGLETON);
}
#end_block

#method_before
public static <T> LinkedBindingBuilder<T> bind(Binder binder, TypeLiteral<T> type) {
    return binder.bind(type).annotatedWith(UniqueAnnotations.create());
}
#method_after
public static <T> LinkedBindingBuilder<T> bind(Binder binder, TypeLiteral<T> type) {
    return binder.bind(type);
}
#end_block

#method_before
public T get() {
    Provider<T> p = item.get();
    T t = null;
    if (p != null) {
        t = p.get();
    }
    return t;
}
#method_after
public T get() {
    NamedProvider<T> item = ref.get();
    return item != null ? item.impl.get() : null;
}
#end_block

#method_before
public ReloadableRegistrationHandle<T> set(Key<T> key, Provider<T> item) {
    if (!this.item.compareAndSet(null, item)) {
        // We already have an item bound.
        throw new RuntimeException("Type already provided by " + this.item.get());
    }
    return new ReloadableHandle(key, item);
}
#method_after
public RegistrationHandle set(T item, String pluginName) {
    return set(Providers.of(item), pluginName);
}
#end_block

#method_before
@Override
public void remove() {
    DynamicItem.this.item.compareAndSet(item, null);
}
#method_after
@Override
public void remove() {
    ref.compareAndSet(item, null);
}
#end_block

#method_before
@Override
public ReloadableHandle replace(Key<T> newKey, Provider<T> newItem) {
    if (DynamicItem.this.item.compareAndSet(item, newItem)) {
        return new ReloadableHandle(newKey, newItem);
    }
    return null;
}
#method_after
@Override
public ReloadableHandle replace(Key<T> newKey, Provider<T> newItem) {
    NamedProvider<T> n = new NamedProvider<T>(newItem, item.pluginName);
    if (ref.compareAndSet(item, n)) {
        return new ReloadableHandle(newKey, n);
    }
    return null;
}
#end_block

#method_before
private void attachItem(Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin plugin) {
    for (RegistrationHandle h : PrivateInternals_DynamicTypes.attachItems(src, items)) {
        plugin.add(h);
    }
}
#method_after
private void attachItem(Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin plugin) {
    for (RegistrationHandle h : PrivateInternals_DynamicTypes.attachItems(src, items, plugin.getName())) {
        plugin.add(h);
    }
}
#end_block

#method_before
private void reattachItem(ListMultimap<TypeLiteral<?>, ReloadableRegistrationHandle<?>> oldHandles, Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin newPlugin) {
    if (src == null || items == null || items.isEmpty()) {
        return;
    }
    for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
        @SuppressWarnings("unchecked")
        TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
        @SuppressWarnings("unchecked")
        DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
        // Index all old handles that match this DynamicItem<T> keyed by
        // annotations. Ignore the unique annotations, thereby favoring
        // the @Named annotations or some other non-unique naming.
        Map<Annotation, ReloadableRegistrationHandle<?>> am = Maps.newHashMap();
        List<ReloadableRegistrationHandle<?>> old = oldHandles.get(type);
        Iterator<ReloadableRegistrationHandle<?>> oi = old.iterator();
        while (oi.hasNext()) {
            ReloadableRegistrationHandle<?> h = oi.next();
            Annotation a = h.getKey().getAnnotation();
            if (a != null && !UNIQUE_ANNOTATION.isInstance(a)) {
                am.put(a, h);
                oi.remove();
            }
        }
        // Replace old handles with new bindings, favoring cases where there
        // is an exact match on an @Named annotation. If there is no match
        // pick any handle and replace it. We generally expect only one
        // handle of each DynamicItem type when using unique annotations, but
        // possibly multiple ones if @Named was used. Plugin authors that want
        // atomic replacement across reloads should use @Named annotations with
        // stable names that do not change across plugin versions to ensure the
        // handles are swapped correctly.
        oi = old.iterator();
        for (Binding<?> binding : bindings(src, type)) {
            @SuppressWarnings("unchecked")
            Binding<Object> b = (Binding<Object>) binding;
            Key<Object> key = b.getKey();
            if (key.getAnnotation() == null) {
                continue;
            }
            @SuppressWarnings("unchecked")
            ReloadableRegistrationHandle<Object> h1 = (ReloadableRegistrationHandle<Object>) am.remove(key.getAnnotation());
            if (h1 != null) {
                replace(newPlugin, h1, b);
            } else if (oi.hasNext()) {
                @SuppressWarnings("unchecked")
                ReloadableRegistrationHandle<Object> h2 = (ReloadableRegistrationHandle<Object>) oi.next();
                oi.remove();
                replace(newPlugin, h2, b);
            } else {
                newPlugin.add(item.set(b.getKey(), b.getProvider()));
            }
        }
    }
}
#method_after
private void reattachItem(ListMultimap<TypeLiteral<?>, ReloadableRegistrationHandle<?>> oldHandles, Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin newPlugin) {
    if (src == null || items == null || items.isEmpty()) {
        return;
    }
    for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
        @SuppressWarnings("unchecked")
        TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
        @SuppressWarnings("unchecked")
        DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
        Iterator<ReloadableRegistrationHandle<?>> oi = oldHandles.get(type).iterator();
        for (Binding<?> binding : bindings(src, type)) {
            @SuppressWarnings("unchecked")
            Binding<Object> b = (Binding<Object>) binding;
            if (oi.hasNext()) {
                @SuppressWarnings("unchecked")
                ReloadableRegistrationHandle<Object> h = (ReloadableRegistrationHandle<Object>) oi.next();
                oi.remove();
                replace(newPlugin, h, b);
            } else {
                newPlugin.add(item.set(b.getKey(), b.getProvider(), newPlugin.getName()));
            }
        }
    }
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() == null) {
                continue;
            } else if (ref.getName().startsWith("refs/changes/")) {
                existing.add(ref.getObjectId());
            } else if (ref.getName().startsWith(R_HEADS) || ref.getName().equals(destBranchCtl.getRefName())) {
                try {
                    walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
                } catch (IOException e) {
                    log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                    continue;
                }
            }
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            boolean validCommit = CommitUtil.validateCommit(destBranchCtl, newChange, c, rp.getRevWalk(), gerritIdent, currentUser, canonicalWebUrl, projectControl, rejectCommits, repo, commitValidators, sshInfo, new CommitValidationCallback() {

                public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                    reject(newChange, rejectReason);
                }

                @Override
                public void onAccepted(List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                }
            });
            if (!validCommit) {
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(newChange, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(newChange, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(newChange, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(newChange, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(newChange, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() == null) {
                continue;
            } else if (ref.getName().startsWith("refs/changes/")) {
                existing.add(ref.getObjectId());
            } else if (ref.getName().startsWith(R_HEADS) || ref.getName().equals(destBranchCtl.getRefName())) {
                try {
                    walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
                } catch (IOException e) {
                    log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                    continue;
                }
            }
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(newChange, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(newChange, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(newChange, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(newChange, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(newChange, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    boolean validCommit = CommitUtil.validateCommit(changeCtl.getRefControl(), inputCommand, newCommit, rp.getRevWalk(), gerritIdent, currentUser, canonicalWebUrl, projectControl, rejectCommits, repo, commitValidators, sshInfo, new CommitValidationCallback() {

        public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
            getMessages().addAll(messages);
            reject(newChange, rejectReason);
        }

        @Override
        public void onAccepted(List<CommitValidationMessage> messages) {
            getMessages().addAll(messages);
        }
    });
    if (!validCommit) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !autoClose) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    change.nextPatchSetId();
    PatchSet.Id id = change.currPatchSetId();
    while (allRefs.containsKey(id.toRefName())) {
        change.nextPatchSetId();
        id = change.currPatchSetId();
    }
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !autoClose) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    change.nextPatchSetId();
    PatchSet.Id id = change.currPatchSetId();
    while (allRefs.containsKey(id.toRefName())) {
        change.nextPatchSetId();
        id = change.currPatchSetId();
    }
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            boolean validCommit = CommitUtil.validateCommit(ctl, cmd, c, rp.getRevWalk(), gerritIdent, currentUser, canonicalWebUrl, projectControl, rejectCommits, repo, commitValidators, sshInfo, new CommitValidationCallback() {

                public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                    reject(newChange, rejectReason);
                }

                @Override
                public void onAccepted(List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                }
            });
            if (!validCommit) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing) {
    for (Ref ref : repo.getAllRefs().values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith("refs/changes/")) {
            if (existing != null)
                existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || ref.getName().equals(destBranchCtl.getRefName())) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing) {
    for (Ref ref : repo.getAllRefs().values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith("refs/changes/")) {
            existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || (destBranchCtl != null && ref.getName().equals(destBranchCtl.getRefName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !project.isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, null);
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !project.isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing);
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
public void setFullName(final String name) {
    fullName = name != null ? name.replaceAll("^\\s+", "").trim() : null;
}
#method_after
public void setFullName(final String name) {
    fullName = name != null ? name.trim() : null;
}
#end_block

#method_before
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct, final PermissionRange range) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!range.contains(buttonValue.getValue())) {
            continue;
        }
        final ValueRadioButton b = new ValueRadioButton(buttonValue, ct.getCategory().getName());
        b.setHTML(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#method_after
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct, final PermissionRange range) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!range.contains(buttonValue.getValue())) {
            continue;
        }
        ValueRadioButton b = new ValueRadioButton(ct.getCategory(), buttonValue);
        SafeHtml buf = new SafeHtmlBuilder().append(buttonValue.format());
        buf = CommentLinkProcessor.apply(buf);
        SafeHtml.set(b, buf);
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), null, r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
        approvals.setAccountInfoCache(r.getAccounts());
        approvals.display(r);
    } else {
        approvals.setVisible(false);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), null, patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#method_after
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), null, false, r.getPatchSetInfo(), r.getAccounts(), r.getSubmitTypeRecord());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
        approvals.setAccountInfoCache(r.getAccounts());
        approvals.display(r);
    } else {
        approvals.setVisible(false);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    revision = r.getPatchSetInfo().getRevId();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), null, patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#end_block

#method_before
private void onSend2(final boolean submit) {
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> values = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            values.put(b.value.getCategoryId(), b.value.getId());
        }
    }
    enableForm(false);
    PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new HashSet<ApprovalCategoryValue.Id>(values.values()), new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#method_after
private void onSend2(final boolean submit) {
    ReviewInput data = ReviewInput.create();
    data.message(ChangeApi.emptyToNull(message.getText().trim()));
    data.init();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            data.label(b.category.getLabelName(), b.value.getValue());
        }
    }
    enableForm(false);
    new RestApi("/changes/" + patchSetId.getParentKey().get() + "/revisions/" + revision + "/review").data(data).post(new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#end_block

#method_before
private void submit() {
    Util.MANAGE_SVC.submit(patchSetId, new GerritCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            saveStateOnUnload = false;
            goChange();
        }

        @Override
        public void onFailure(Throwable caught) {
            goChange();
            super.onFailure(caught);
        }
    });
}
#method_after
private void submit() {
    ChangeApi.submit(patchSetId.getParentKey().get(), revision, new GerritCallback<SubmitInfo>() {

        public void onSuccess(SubmitInfo result) {
            saveStateOnUnload = false;
            goChange();
        }

        @Override
        public void onFailure(Throwable err) {
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
            } else {
                super.onFailure(err);
            }
            goChange();
        }
    });
}
#end_block

#method_before
@Override
public Object apply(ChangeResource rsrc) throws BadRequestException, OrmException {
    List<Object> reviewers = new ArrayList<Object>();
    ReviewDb db = dbProvider.get();
    Change.Id changeId = rsrc.getChange().getId();
    for (PatchSetApproval patchSetApproval : db.patchSetApprovals().byChange(changeId)) {
        Account account = accountCache.get(patchSetApproval.getAccountId()).getAccount();
        reviewers.add(json.format(new ReviewerResource(rsrc, account)));
    }
    return reviewers;
}
#method_after
@Override
public Object apply(ChangeResource rsrc) throws BadRequestException, OrmException {
    Map<Account.Id, Object> reviewers = Maps.newLinkedHashMap();
    ReviewDb db = dbProvider.get();
    Change.Id changeId = rsrc.getChange().getId();
    for (PatchSetApproval patchSetApproval : db.patchSetApprovals().byChange(changeId)) {
        Account.Id accountId = patchSetApproval.getAccountId();
        if (!reviewers.containsKey(accountId)) {
            Account account = accountCache.get(accountId).getAccount();
            reviewers.put(accountId, json.format(new ReviewerResource(rsrc, account)));
        }
    }
    return reviewers.values();
}
#end_block

#method_before
@Override
public ReviewerResource parse(ChangeResource changeResource, String id) throws OrmException, ResourceNotFoundException {
    // Get the account id
    if (!id.matches("^[0-9]+$")) {
        throw new ResourceNotFoundException(id);
    }
    Account.Id accountId = Account.Id.parse(id);
    // See if the id exists as a reviewer for this change
    if (fetchAccountIds(changeResource).contains(accountId)) {
        Account account = accountCache.get(accountId).getAccount();
        return new ReviewerResource(changeResource, account);
    }
    throw new ResourceNotFoundException(id);
}
#method_after
@Override
public ReviewerResource parse(ChangeResource rsrc, String id) throws OrmException, ResourceNotFoundException, AuthException {
    Account.Id accountId;
    if (id.equals("self")) {
        CurrentUser user = rsrc.getControl().getCurrentUser();
        if (user instanceof IdentifiedUser) {
            accountId = ((IdentifiedUser) user).getAccountId();
        } else if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else {
            throw new ResourceNotFoundException(id);
        }
    } else if (id.matches("^[0-9]+$")) {
        accountId = Account.Id.parse(id);
    } else {
        throw new ResourceNotFoundException(id);
    }
    // See if the id exists as a reviewer for this change
    if (fetchAccountIds(rsrc).contains(accountId)) {
        Account account = accountCache.get(accountId).getAccount();
        return new ReviewerResource(rsrc, account);
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
private Set<Account.Id> fetchAccountIds(ChangeResource changeResource) throws OrmException {
    ReviewDb db = dbProvider.get();
    Change.Id changeId = changeResource.getChange().getId();
    Set<Account.Id> accountIds = new HashSet<Account.Id>();
    for (PatchSetApproval patchSetApproval : db.patchSetApprovals().byChange(changeId)) {
        accountIds.add(patchSetApproval.getAccountId());
    }
    return accountIds;
}
#method_after
private Set<Account.Id> fetchAccountIds(ChangeResource rsrc) throws OrmException {
    Set<Account.Id> accountIds = Sets.newHashSet();
    for (PatchSetApproval a : dbProvider.get().patchSetApprovals().byChange(rsrc.getChange().getId())) {
        accountIds.add(a.getAccountId());
    }
    return accountIds;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (RepositoryNotFoundException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#method_after
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (IOException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#end_block

#method_before
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(openRepository(change), patchsetCreatedHook, args);
}
#method_after
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        addArg(args, "--" + approval.getKey().get(), Short.toString(approval.getValue().get()));
    }
    runHook(openRepository(change), commentAddedHook, args);
}
#method_after
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        addArg(args, "--" + approval.getKey().get(), Short.toString(approval.getValue().get()));
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(openRepository(change), changeMergedHook, args);
}
#method_after
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
public void doChangeAbandonedHook(final Change change, final Account account, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(openRepository(change), changeAbandonedHook, args);
}
#method_after
public void doChangeAbandonedHook(final Change change, final Account account, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, final Account account) {
    final RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(openRepository(refName.getParentKey()), refUpdatedHook, args);
}
#method_after
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, final Account account) {
    final RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        final List<String> args = new ArrayList<String>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-id", cla.getId().toString());
        runHook(claSignedHook, args);
    }
}
#method_after
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        final List<String> args = new ArrayList<String>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", cla.getName());
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new HookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, File hook, List<String> args) {
    if (project != null && hook.exists()) {
        hookQueue.execute(new AsyncHookTask(project, hook, args));
    }
}
#end_block

#method_before
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new HookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Repository repo, File hook, List<String> args) throws TimeoutException {
    if (hook.exists()) {
        SyncHookTask syncHook = new SyncHookTask(repo, hook, args);
        FutureTask<HookResult> task = new FutureTask<HookResult>(syncHook);
        syncHookThreadPool.execute(task);
        try {
            return task.get(syncHookTimeout, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Error running hook " + hook.getAbsolutePath(), e);
        } catch (ExecutionException e) {
            log.error("Error running hook " + hook.getAbsolutePath(), e);
        } catch (TimeoutException e) {
            log.error("Synchronous hook timed out " + hook.getAbsolutePath());
            throw e;
        }
    }
    return null;
}
#method_after
private HookResult runSyncHook(Project.NameKey project, File hook, List<String> args) throws TimeoutException {
    if (!hook.exists()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<HookResult>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.getAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.getAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
@Override
public HookResult call() throws Exception {
    HookResult result = null;
    StringBuilder output = new StringBuilder();
    try {
        final List<String> argv = new ArrayList<String>(1 + args.size());
        argv.add(hook.getAbsolutePath());
        argv.addAll(args);
        final ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (repo != null) {
            pb.directory(repo.getDirectory());
            final Map<String, String> env = pb.environment();
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        Process ps = pb.start();
        ps.getOutputStream().close();
        BufferedReader br = new BufferedReader(new InputStreamReader(ps.getInputStream()));
        try {
            String line = br.readLine();
            while (line != null) {
                output.append(line);
                line = br.readLine();
                if (line != null) {
                    output.append(System.getProperty("line.separator"));
                }
            }
        } finally {
            try {
                br.close();
            } catch (IOException closeErr) {
            }
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output.toString());
        }
    } catch (Throwable err) {
        log.error("Error running hook " + hook.getAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return result;
}
#method_after
@Override
public HookResult call() throws Exception {
    return super.runHook();
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        // Run the update hook, if it returns output then reject the push
        // passing the output back to the user
        String output = hooks.doUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (output != null) {
            reject(cmd, output);
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private Collection<ObjectId> existingObjects() {
    if (existingObjects == null) {
        Map<String, Ref> refs = repo.getAllRefs();
        existingObjects = new ArrayList<ObjectId>(refs.size());
        for (Ref r : refs.values()) {
            existingObjects.add(r.getObjectId());
        }
    }
    return existingObjects;
}
#method_after
private Collection<ObjectId> existingObjects() {
    if (existingObjects == null) {
        existingObjects = new ArrayList<ObjectId>(allRefs.size());
        for (Ref r : allRefs.values()) {
            existingObjects.add(r.getObjectId());
        }
    }
    return existingObjects;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    for (CommitValidationListener validator : commitValidators) {
        CommitValidationResult validationResult = validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser));
        final String message = validationResult.getValidationReason();
        if (!validationResult.isValidated()) {
            reject(cmd, message);
            return false;
        } else if (!Strings.isNullOrEmpty(message)) {
            addMessage(String.format("(W) %s", message));
        }
    }
    return true;
}
#end_block

#method_before
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    return sb.toString();
}
#method_after
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    return sb.toString();
}
#end_block

#method_before
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceivePack().sendMessage(sb.toString());
}
#method_after
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    addMessage(sb.toString());
}
#end_block

#method_before
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#method_after
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceRequest result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceRequest result) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(result.change);
                cm.setFrom(currentUser.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void insertAncestors(PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#method_after
private void insertAncestors(ReviewDb db, PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
public void display(final PatchSet.Id patchSetId, Boolean starred, Boolean canEditCommitMessage, final String commitMessage) {
    starPanel.clear();
    if (patchSetId != null && starred != null && Gerrit.isSignedIn()) {
        Change.Id changeId = patchSetId.getParentKey();
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    permalinkPanel.clear();
    if (patchSetId != null) {
        Change.Id changeId = patchSetId.getParentKey();
        permalinkPanel.add(new ChangeLink(Util.C.changePermalink(), changeId));
        permalinkPanel.add(new CopyableLabel(ChangeLink.permalink(changeId), false));
        if (canEditCommitMessage) {
            final Image edit = new Image(Gerrit.RESOURCES.edit());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    new CommentedActionDialog<ChangeDetail>(Util.C.titleEditCommitMessage(), Util.C.headingEditCommitMessage(), new ChangeDetailCache.IgnoreErrorCallback() {
                    }) {

                        {
                            message.setCharacterWidth(80);
                            message.setVisibleLines(20);
                            message.setText(commitMessage);
                        }

                        @Override
                        public void onSend() {
                            final String newCommitMessage = getMessageText();
                            Util.MANAGE_SVC.createNewPatchSet(patchSetId, newCommitMessage, createCallback());
                            display(newCommitMessage);
                        }
                    }.center();
                }
            });
            permalinkPanel.add(edit);
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n\n", "<p></p>");
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n", "<br />");
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#method_after
public void display(final PatchSet.Id patchSetId, Boolean starred, Boolean canEditCommitMessage, final String commitMessage) {
    starPanel.clear();
    if (patchSetId != null && starred != null && Gerrit.isSignedIn()) {
        Change.Id changeId = patchSetId.getParentKey();
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    permalinkPanel.clear();
    if (patchSetId != null) {
        final Change.Id changeId = patchSetId.getParentKey();
        permalinkPanel.add(new ChangeLink(Util.C.changePermalink(), changeId));
        permalinkPanel.add(new CopyableLabel(ChangeLink.permalink(changeId), false));
        if (canEditCommitMessage) {
            final Image edit = new Image(Gerrit.RESOURCES.edit());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    new CommentedActionDialog<ChangeDetail>(Util.C.titleEditCommitMessage(), Util.C.headingEditCommitMessage(), new ChangeDetailCache.IgnoreErrorCallback() {
                    }) {

                        {
                            message.setCharacterWidth(80);
                            message.setVisibleLines(20);
                            message.setText(commitMessage);
                        }

                        @Override
                        public void onSend() {
                            Util.MANAGE_SVC.createNewPatchSet(patchSetId, getMessageText(), new AsyncCallback<ChangeDetail>() {

                                @Override
                                public void onSuccess(ChangeDetail result) {
                                    Gerrit.display(PageLinks.toChange(changeId));
                                    hide();
                                }

                                @Override
                                public void onFailure(Throwable caught) {
                                    enableButtons(true);
                                    new ErrorDialog(caught.getMessage()).center();
                                }
                            });
                        }
                    }.center();
                }
            });
            permalinkPanel.add(edit);
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n\n", "<p></p>");
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n", "<br />");
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#end_block

#method_before
static DashboardInfo parse(Project project, String refName, String path, Config config) throws UnsupportedEncodingException {
    DashboardInfo info = new DashboardInfo(refName, path);
    info.title = config.getString("dashboard", null, "title");
    info.description = config.getString("dashboard", null, "description");
    info.allQueries = config.getString("dashboard", null, "allQueries");
    info.isDefault = info.id.equals(defaultOf(project)) ? true : null;
    UrlEncoded u = new UrlEncoded("/dashboard/");
    u.put("title", Objects.firstNonNull(info.title, info.path));
    if (info.allQueries != null) {
        u.put("allQueries", replace(project.getName(), info.allQueries));
    }
    for (String name : config.getSubsections("section")) {
        Section s = new Section();
        s.name = name;
        s.query = config.getString("section", name, "query");
        u.put(s.name, replace(project.getName(), s.query));
        info.sections.add(s);
    }
    info.url = u.toString().replace("%3A", ":");
    return info;
}
#method_after
static DashboardInfo parse(Project project, String refName, String path, Config config, boolean setDefault) throws UnsupportedEncodingException {
    DashboardInfo info = new DashboardInfo(refName, path);
    info.title = config.getString("dashboard", null, "title");
    info.description = config.getString("dashboard", null, "description");
    info.isDefault = setDefault ? (info.id.equals(defaultOf(project)) ? true : null) : null;
    info.foreach = config.getString("dashboard", null, "foreach");
    UrlEncoded u = new UrlEncoded("/dashboard/");
    u.put("title", Objects.firstNonNull(info.title, info.path));
    if (info.foreach != null) {
        u.put("foreach", replace(project.getName(), info.foreach));
    }
    for (String name : config.getSubsections("section")) {
        Section s = new Section();
        s.name = name;
        s.query = config.getString("section", name, "query");
        u.put(s.name, replace(project.getName(), s.query));
        info.sections.add(s);
    }
    info.url = u.toString().replace("%3A", ":");
    return info;
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.nextPatchSetId();
        change.setTopic(changeToRevert.getTopic());
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        Change change = db.changes().get(changeId);
        RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        CommitBuilder commitBuilder = new CommitBuilder();
        commitBuilder.addParentId(commit);
        commitBuilder.setTreeId(commit.getTree());
        commitBuilder.setAuthor(authorIdent);
        commitBuilder.setCommitter(myIdent);
        commitBuilder.setMessage(message);
        RevCommit newCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(commitBuilder);
            oi.flush();
            newCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        change.nextPatchSetId();
        final PatchSet originalPS = db.patchSets().get(patchSetId);
        final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
        newPatchSet.setCreatedOn(change.getCreatedOn());
        newPatchSet.setUploader(change.getOwner());
        newPatchSet.setRevision(new RevId(newCommit.name()));
        newPatchSet.setDraft(originalPS.isDraft());
        final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
        final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(newCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            Change updatedChange;
            updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (updatedChange != null) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
            }
            ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
            db.patchSets().insert(Collections.singleton(newPatchSet));
            updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(patchSetId)) {
                        return null;
                    }
                    if (change.getStatus() != Change.Status.DRAFT) {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (updatedChange != null) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
            final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
            cmsg.setMessage(msg);
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
        } finally {
            db.rollback();
        }
        hooks.doPatchsetCreatedHook(change, newPatchSet, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            Change change = db.changes().get(changeId);
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.addParentId(commit);
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setAuthor(authorIdent);
            commitBuilder.setCommitter(myIdent);
            commitBuilder.setMessage(message);
            RevCommit newCommit;
            final ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            change.nextPatchSetId();
            final PatchSet originalPS = db.patchSets().get(patchSetId);
            final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
            newPatchSet.setCreatedOn(change.getCreatedOn());
            newPatchSet.setUploader(change.getOwner());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            newPatchSet.setDraft(originalPS.isDraft());
            final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
            final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
            ru.setExpectedOldObjectId(ObjectId.zeroId());
            ru.setNewObjectId(newCommit);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
            }
            replication.fire(change.getProject(), ru.getName());
            db.changes().beginTransaction(change.getId());
            try {
                Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isOpen()) {
                            change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                            return change;
                        } else {
                            return null;
                        }
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
                }
                ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
                db.patchSets().insert(Collections.singleton(newPatchSet));
                updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isClosed()) {
                            return null;
                        }
                        if (!change.currentPatchSetId().equals(patchSetId)) {
                            return null;
                        }
                        if (change.getStatus() != Change.Status.DRAFT) {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setLastSha1MergeTested(null);
                        change.setCurrentPatchSet(info);
                        ChangeUtil.updated(change);
                        return change;
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
                }
                final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
                final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
                cmsg.setMessage(msg);
                db.changeMessages().insert(Collections.singleton(cmsg));
                db.commit();
            } finally {
                db.rollback();
            }
            hooks.doPatchsetCreatedHook(change, newPatchSet, db);
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    detail.setCanEditCommitMessage(change.getStatus() == Change.Status.NEW && control.canAddPatchSet());
    detail.setCanEditTopicName(control.canEditTopicName());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    detail.setSubmitTypeRecord(control.getSubmitTypeRecord(db, patch));
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && RebaseChange.canDoRebase(db, change, repoManager, currentPatchSetAncestors, currentDepPatchSets, currentDepChanges));
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    detail.setCanEditCommitMessage(change.getStatus().isOpen() && control.canAddPatchSet());
    detail.setCanEditTopicName(control.canEditTopicName());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    detail.setSubmitTypeRecord(control.getSubmitTypeRecord(db, patch));
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && RebaseChange.canDoRebase(db, change, repoManager, currentPatchSetAncestors, currentDepPatchSets, currentDepChanges));
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AbandonChangeHandler.Factory.class);
            factory(EditCommitMessageHandler.Factory.class);
            factory(AlterTopicHandler.Factory.class);
            factory(RestoreChangeHandler.Factory.class);
            factory(RevertChange.Factory.class);
            factory(RebaseChangeHandler.Factory.class);
            factory(ChangeDetailFactory.Factory.class);
            factory(IncludedInDetailFactory.Factory.class);
            factory(PatchSetDetailFactory.Factory.class);
            factory(PatchSetPublishDetailFactory.Factory.class);
            factory(SubmitAction.Factory.class);
            factory(PublishAction.Factory.class);
            factory(DeleteDraftChange.Factory.class);
        }
    });
    rpc(ChangeDetailServiceImpl.class);
    rpc(ChangeManageServiceImpl.class);
}
#method_after
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EditCommitMessageHandler.Factory.class);
            factory(RestoreChangeHandler.Factory.class);
            factory(RevertChange.Factory.class);
            factory(RebaseChangeHandler.Factory.class);
            factory(ChangeDetailFactory.Factory.class);
            factory(IncludedInDetailFactory.Factory.class);
            factory(PatchSetDetailFactory.Factory.class);
            factory(PatchSetPublishDetailFactory.Factory.class);
            factory(SubmitAction.Factory.class);
            factory(PublishAction.Factory.class);
            factory(DeleteDraftChange.Factory.class);
        }
    });
    rpc(ChangeDetailServiceImpl.class);
    rpc(ChangeManageServiceImpl.class);
}
#end_block

#method_before
public void display(final String commitMessage) {
    display(null, null, null, commitMessage);
}
#method_after
public void display(final String commitMessage) {
    display(null, null, false, commitMessage);
}
#end_block

#method_before
public void display(Change.Id changeId, final PatchSet.Id patchSetId, Boolean starred, final String commitMessage) {
    starPanel.clear();
    if (changeId != null && starred != null && Gerrit.isSignedIn()) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    permalinkPanel.clear();
    if (changeId != null && patchSetId != null) {
        ChangeDetailCache detailCache = ChangeCache.get(patchSetId.getParentKey()).getChangeDetailCache();
        ChangeDetail changeDetail = detailCache.get();
        if (changeDetail.canEditCommitMessage()) {
            permalinkPanel.add(new ChangeLink(Util.C.changePermalink(), changeId));
            permalinkPanel.add(new CopyableLabel(ChangeLink.permalink(changeId), false));
            final Image edit = new Image(Gerrit.RESOURCES.edit());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    new EditCommitMessageActionDialog() {

                        {
                            message.setText(commitMessage);
                        }

                        @Override
                        public void onSend() {
                            Util.MANAGE_SVC.editCommitMessage(patchSetId, getMessageText(), createCallback());
                        }
                    }.center();
                }
            });
            edit.addStyleName(Gerrit.RESOURCES.css().changeInfoBlockEdit());
            permalinkPanel.add(edit);
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n\n", "<p></p>");
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n", "<br />");
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#method_after
public void display(final PatchSet.Id patchSetId, Boolean starred, Boolean canEditCommitMessage, final String commitMessage) {
    starPanel.clear();
    Change.Id changeId = patchSetId.getParentKey();
    if (changeId != null && starred != null && Gerrit.isSignedIn()) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    permalinkPanel.clear();
    if (changeId != null) {
        permalinkPanel.add(new ChangeLink(Util.C.changePermalink(), changeId));
        permalinkPanel.add(new CopyableLabel(ChangeLink.permalink(changeId), false));
        if (canEditCommitMessage) {
            final Image edit = new Image(Gerrit.RESOURCES.edit());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    new CommentedActionDialog<ChangeDetail>(Util.C.titleEditCommitMessage(), Util.C.headingEditCommitMessage(), new ChangeDetailCache.IgnoreErrorCallback() {
                    }) {

                        {
                            message.setCharacterWidth(80);
                            message.setVisibleLines(20);
                            message.setText(commitMessage);
                        }

                        @Override
                        public void onSend() {
                            Util.MANAGE_SVC.createNewPatchSet(patchSetId, getMessageText(), createCallback());
                        }
                    }.center();
                }
            });
            permalinkPanel.add(edit);
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n\n", "<p></p>");
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n", "<br />");
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAddPatchSet()) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.editCommitMessage(patchSetId, currentUser, message, db, hooks, gitManager, patchSetInfoFactory, replication, myIdent);
    return changeDetailFactory.create(changeId).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAddPatchSet()) {
        throw new InvalidChangeOperationException("Not allowed to add new Patch Sets to: " + changeId.toString());
    }
    ChangeUtil.editCommitMessage(patchSetId, currentUser, message, db, hooks, gitManager, patchSetInfoFactory, replication, myIdent);
    return changeDetailFactory.create(changeId).call();
}
#end_block

#method_before
public void display(Change chg, Boolean starred, PatchSetInfo info, final AccountInfoCache acc, SubmitTypeRecord submitTypeRecord) {
    infoBlock.display(chg, acc, submitTypeRecord);
    messageBlock.display(chg.getId(), chg.currentPatchSetId(), starred, info.getMessage());
}
#method_after
public void display(Change chg, Boolean starred, Boolean canEditCommitMessage, PatchSetInfo info, final AccountInfoCache acc, SubmitTypeRecord submitTypeRecord) {
    infoBlock.display(chg, acc, submitTypeRecord);
    messageBlock.display(chg.currentPatchSetId(), starred, canEditCommitMessage, info.getMessage());
}
#end_block

#method_before
@Override
protected void onCellDoubleClick(final int row, final int column) {
    if (getRowItem(row) instanceof PatchLine) {
        final PatchLine pl = (PatchLine) getRowItem(row);
        switch(pl.getType()) {
            case DELETE:
            case CONTEXT:
                createCommentEditor(row + 1, PC, pl.getLineA(), (short) 0);
                break;
            case INSERT:
                createCommentEditor(row + 1, PC, pl.getLineB(), (short) 1);
                break;
        }
    }
}
#method_after
@Override
protected void onCellDoubleClick(final int row, final int column) {
    if (column > C_ARROW && getRowItem(row) instanceof PatchLine) {
        final PatchLine pl = (PatchLine) getRowItem(row);
        switch(pl.getType()) {
            case DELETE:
            case CONTEXT:
                createCommentEditor(row + 1, PC, pl.getLineA(), (short) 0);
                break;
            case INSERT:
                createCommentEditor(row + 1, PC, pl.getLineB(), (short) 1);
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#end_block

#method_before
@Override
protected void render(final PatchScript script) {
    final SparseHtmlFile a = getSparseHtmlFileA(script);
    final SparseHtmlFile b = getSparseHtmlFileB(script);
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    // Display the patch header
    for (final String line : script.getPatchHeader()) {
        appendFileHeader(nc, line);
    }
    if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String rawBase = GWT.getHostPageBaseURL() + "cat/";
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("align", "center");
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        if (script.getDisplayMethodA() == DisplayMethod.IMG) {
            if (idSideA == null) {
                appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^1");
            } else {
                Patch.Key k = new Patch.Key(idSideA, patchKey.get());
                appendImgTag(nc, rawBase + KeyUtil.encode(k.toString()) + "^0");
            }
        }
        if (script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^0");
        }
        nc.closeTd();
        nc.closeTr();
    }
    final boolean syntaxHighlighting = script.getDiffPrefs().isSyntaxHighlighting();
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final EditList.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.next()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, false, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                padLineNumber(nc);
                appendLineText(nc, syntaxHighlighting, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                if (a.size() == hunk.getCurA() && script.getA().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumber(nc);
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, syntaxHighlighting, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && script.getB().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            }
        }
    }
    resetHtml(nc);
    initScript(script);
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n;
        switch(l.getType()) {
            case CONTEXT:
                n = Gerrit.RESOURCES.css().diffTextCONTEXT();
                break;
            case DELETE:
                n = Gerrit.RESOURCES.css().diffTextDELETE();
                break;
            case INSERT:
                n = Gerrit.RESOURCES.css().diffTextINSERT();
                break;
            default:
                continue;
        }
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#method_after
@Override
protected void render(final PatchScript script, final PatchSetDetail detail) {
    final SparseHtmlFile a = getSparseHtmlFileA(script);
    final SparseHtmlFile b = getSparseHtmlFileB(script);
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    allocateTableHeader(nc);
    // Display the patch header
    for (final String line : script.getPatchHeader()) {
        appendFileHeader(nc, line);
    }
    if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String rawBase = GWT.getHostPageBaseURL() + "cat/";
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("align", "center");
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        if (script.getDisplayMethodA() == DisplayMethod.IMG) {
            if (idSideA == null) {
                appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^1");
            } else {
                Patch.Key k = new Patch.Key(idSideA, patchKey.get());
                appendImgTag(nc, rawBase + KeyUtil.encode(k.toString()) + "^0");
            }
        }
        if (script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^0");
        }
        nc.closeTd();
        nc.closeTr();
    }
    final boolean syntaxHighlighting = script.getDiffPrefs().isSyntaxHighlighting();
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final EditList.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.next()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumberForSideA(nc, hunk.getCurA());
                appendLineNumberForSideB(nc, hunk.getCurB());
                appendLineText(nc, false, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumberForSideA(nc, hunk.getCurA());
                padLineNumberForSideB(nc);
                appendLineText(nc, syntaxHighlighting, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), -1));
                if (a.size() == hunk.getCurA() && script.getA().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumberForSideA(nc);
                appendLineNumberForSideB(nc, hunk.getCurB());
                appendLineText(nc, syntaxHighlighting, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, -1, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && script.getB().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            }
        }
    }
    resetHtml(nc);
    populateTableHeader(script, detail);
    initScript(script);
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n;
        switch(l.getType()) {
            case CONTEXT:
                n = Gerrit.RESOURCES.css().diffTextCONTEXT();
                break;
            case DELETE:
                n = Gerrit.RESOURCES.css().diffTextDELETE();
                break;
            case INSERT:
                n = Gerrit.RESOURCES.css().diffTextINSERT();
                break;
            default:
                continue;
        }
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#end_block

#method_before
@Override
public void display(final CommentDetail cd, boolean expandComments) {
    if (cd.isEmpty()) {
        return;
    }
    setAccountInfoCache(cd.getAccounts());
    final ArrayList<PatchLineComment> all = new ArrayList<PatchLineComment>();
    for (int row = 0; row < table.getRowCount(); ) {
        final List<PatchLineComment> fora;
        final List<PatchLineComment> forb;
        if (row == 0) {
            fora = cd.getForA(0);
            forb = cd.getForB(0);
        } else if (getRowItem(row) instanceof PatchLine) {
            final PatchLine pLine = (PatchLine) getRowItem(row);
            fora = cd.getForA(pLine.getLineA());
            forb = cd.getForB(pLine.getLineB());
        } else {
            row++;
            continue;
        }
        row++;
        if (!fora.isEmpty() && !forb.isEmpty()) {
            all.clear();
            all.addAll(fora);
            all.addAll(forb);
            Collections.sort(all, BY_DATE);
            row = insert(all, row, expandComments);
        } else if (!fora.isEmpty()) {
            row = insert(fora, row, expandComments);
        } else if (!forb.isEmpty()) {
            row = insert(forb, row, expandComments);
        }
    }
}
#method_after
@Override
public void display(final CommentDetail cd, boolean expandComments) {
    if (cd.isEmpty()) {
        return;
    }
    setAccountInfoCache(cd.getAccounts());
    final ArrayList<PatchLineComment> all = new ArrayList<PatchLineComment>();
    for (int row = 0; row < table.getRowCount(); ) {
        final List<PatchLineComment> fora;
        final List<PatchLineComment> forb;
        if (row == R_HEAD) {
            fora = cd.getForA(R_HEAD);
            forb = cd.getForB(R_HEAD);
            row++;
            if (!fora.isEmpty()) {
                row = insert(fora, row, expandComments);
            }
            rowOfTableHeaderB = row;
            borderRowOfFileComment = row + 1;
            if (!forb.isEmpty()) {
                // Skip the Header of sideB.
                row++;
                row = insert(forb, row, expandComments);
                borderRowOfFileComment = row;
                createFileCommentBorderRow();
            }
        } else if (getRowItem(row) instanceof PatchLine) {
            final PatchLine pLine = (PatchLine) getRowItem(row);
            fora = cd.getForA(pLine.getLineA());
            forb = cd.getForB(pLine.getLineB());
            row++;
            if (!fora.isEmpty() && !forb.isEmpty()) {
                all.clear();
                all.addAll(fora);
                all.addAll(forb);
                Collections.sort(all, BY_DATE);
                row = insert(all, row, expandComments);
            } else if (!fora.isEmpty()) {
                row = insert(fora, row, expandComments);
            } else if (!forb.isEmpty()) {
                row = insert(forb, row, expandComments);
            }
        } else {
            row++;
            continue;
        }
    }
}
#end_block

#method_before
@Override
protected void insertRow(final int row) {
    super.insertRow(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, PC - 2, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, PC - 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, PC, Gerrit.RESOURCES.css().diffText());
}
#method_after
@Override
protected void insertRow(final int row) {
    super.insertRow(row);
    final CellFormatter fmt = table.getCellFormatter();
    defaultStyle(row, fmt);
}
#end_block

#method_before
private int insert(final List<PatchLineComment> in, int row, boolean expandComment) {
    for (Iterator<PatchLineComment> ci = in.iterator(); ci.hasNext(); ) {
        final PatchLineComment c = ci.next();
        insertRow(row);
        bindComment(row, PC, c, !ci.hasNext(), expandComment);
        row++;
    }
    return row;
}
#method_after
private int insert(final List<PatchLineComment> in, int row, boolean expandComment) {
    for (Iterator<PatchLineComment> ci = in.iterator(); ci.hasNext(); ) {
        final PatchLineComment c = ci.next();
        if (c.getLine() == R_HEAD) {
            insertFileCommentRow(row);
        } else {
            insertRow(row);
        }
        bindComment(row, PC, c, !ci.hasNext(), expandComment);
        row++;
    }
    return row;
}
#end_block

#method_before
private void appendFileHeader(final SafeHtmlBuilder m, final String line) {
    openLine(m);
    padLineNumber(m);
    padLineNumber(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextFileHeader());
    m.append(line);
    m.closeTd();
    closeLine(m);
}
#method_after
private void appendFileHeader(final SafeHtmlBuilder m, final String line) {
    openLine(m);
    padLineNumberForSideA(m);
    padLineNumberForSideB(m);
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileLine());
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextFileHeader());
    m.append(line);
    m.closeTd();
    closeLine(m);
}
#end_block

#method_before
private void appendHunkHeader(final SafeHtmlBuilder m, final Hunk hunk) {
    openLine(m);
    padLineNumber(m);
    padLineNumber(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextHunkHeader());
    m.append("@@ -");
    appendRange(m, hunk.getCurA() + 1, hunk.getEndA() - hunk.getCurA());
    m.append(" +");
    appendRange(m, hunk.getCurB() + 1, hunk.getEndB() - hunk.getCurB());
    m.append(" @@");
    m.closeTd();
    closeLine(m);
}
#method_after
private void appendHunkHeader(final SafeHtmlBuilder m, final Hunk hunk) {
    openLine(m);
    padLineNumberForSideA(m);
    padLineNumberForSideB(m);
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileLine());
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextHunkHeader());
    m.append("@@ -");
    appendRange(m, hunk.getCurA() + 1, hunk.getEndA() - hunk.getCurA());
    m.append(" +");
    appendRange(m, hunk.getCurB() + 1, hunk.getEndB() - hunk.getCurB());
    m.append(" @@");
    m.closeTd();
    closeLine(m);
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, boolean syntaxHighlighting, final PatchLine.Type type, final SparseHtmlFile src, final int i) {
    final SafeHtml text = src.getSafeHtmlLine(i);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextCONTEXT());
            m.nbsp();
            m.append(text);
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextDELETE());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            }
            m.append("-");
            m.append(text);
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextINSERT());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            }
            m.append("+");
            m.append(text);
            break;
    }
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, boolean syntaxHighlighting, final PatchLine.Type type, final SparseHtmlFile src, final int i) {
    final SafeHtml text = src.getSafeHtmlLine(i);
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileLine());
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextCONTEXT());
            m.nbsp();
            m.append(text);
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextDELETE());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            }
            m.append("-");
            m.append(text);
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextINSERT());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            }
            m.append("+");
            m.append(text);
            break;
    }
    m.closeTd();
}
#end_block

#method_before
private void appendNoLF(final SafeHtmlBuilder m) {
    openLine(m);
    padLineNumber(m);
    padLineNumber(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextNoLF());
    m.append("\\ No newline at end of file");
    m.closeTd();
    closeLine(m);
}
#method_after
private void appendNoLF(final SafeHtmlBuilder m) {
    openLine(m);
    padLineNumberForSideA(m);
    padLineNumberForSideB(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextNoLF());
    m.append("\\ No newline at end of file");
    m.closeTd();
    closeLine(m);
}
#end_block

#method_before
public void notifyDraftDelta(final int delta) {
    if (fileList != null) {
        fileList.notifyDraftDelta(patchKey, delta);
    }
    Widget p = getParent();
    while (p != null) {
        if (p instanceof CommentEditorContainer) {
            ((CommentEditorContainer) p).notifyDraftDelta(delta);
            break;
        }
        p = p.getParent();
    }
}
#method_after
@Override
public void notifyDraftDelta(final int delta) {
    if (fileList != null) {
        fileList.notifyDraftDelta(patchKey, delta);
    }
    Widget p = getParent();
    while (p != null) {
        if (p instanceof CommentEditorContainer) {
            ((CommentEditorContainer) p).notifyDraftDelta(delta);
            break;
        }
        p = p.getParent();
    }
}
#end_block

#method_before
protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) {
    if (Gerrit.isSignedIn()) {
        if (R_HEAD <= line) {
            final Patch.Key parentKey;
            final short side;
            switch(file) {
                case 0:
                    if (idSideA == null) {
                        parentKey = new Patch.Key(idSideB, patchKey.get());
                        side = (short) 0;
                    } else {
                        parentKey = new Patch.Key(idSideA, patchKey.get());
                        side = (short) 1;
                    }
                    break;
                case 1:
                    parentKey = new Patch.Key(idSideB, patchKey.get());
                    side = (short) 1;
                    break;
                default:
                    throw new RuntimeException("unexpected file id " + file);
            }
            final PatchLineComment newComment = new PatchLineComment(new PatchLineComment.Key(parentKey, null), line, Gerrit.getUserAccount().getId(), null);
            newComment.setSide(side);
            newComment.setMessage("");
            createCommentEditor(suggestRow, column, newComment).setFocus(true);
        }
    } else {
        Gerrit.doSignIn(History.getToken());
    }
}
#method_after
protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) {
    if (Gerrit.isSignedIn()) {
        if (R_HEAD <= line) {
            final Patch.Key parentKey;
            final short side;
            switch(file) {
                case 0:
                    if (idSideA == null) {
                        parentKey = new Patch.Key(idSideB, patchKey.get());
                        side = (short) 0;
                    } else {
                        parentKey = new Patch.Key(idSideA, patchKey.get());
                        side = (short) 1;
                    }
                    break;
                case 1:
                    parentKey = new Patch.Key(idSideB, patchKey.get());
                    side = (short) 1;
                    break;
                default:
                    throw new RuntimeException("unexpected file id " + file);
            }
            final PatchLineComment newComment = new PatchLineComment(new PatchLineComment.Key(parentKey, null), line, Gerrit.getUserAccount().getId(), null);
            newComment.setSide(side);
            newComment.setMessage("");
            findOrCreateCommentEditor(suggestRow, column, newComment, true).setFocus(true);
        }
    } else {
        Gerrit.doSignIn(History.getToken());
    }
}
#end_block

#method_before
private void createReplyEditor() {
    final PatchLineComment newComment = newComment();
    newComment.setMessage("");
    createEditor(newComment).setFocus(true);
}
#method_after
private void createReplyEditor() {
    final PatchLineComment newComment = newComment();
    newComment.setMessage("");
    findOrCreateEditor(newComment, true).setFocus(true);
}
#end_block

#method_before
private void cannedReply(String message) {
    final PatchLineComment newComment = newComment();
    newComment.setMessage(message);
    CommentEditorPanel p = createEditor(newComment);
    if (p == null) {
        enableButtons(false);
        PatchUtil.DETAIL_SVC.saveDraft(newComment, new GerritCallback<PatchLineComment>() {

            public void onSuccess(final PatchLineComment result) {
                enableButtons(true);
                notifyDraftDelta(1);
                createEditor(result).setOpen(false);
            }

            @Override
            public void onFailure(Throwable caught) {
                enableButtons(true);
                super.onFailure(caught);
            }
        });
    } else {
        if (!p.isOpen()) {
            p.setOpen(true);
        }
        p.setFocus(true);
    }
}
#method_after
private void cannedReply(String message) {
    final PatchLineComment newComment = newComment();
    newComment.setMessage(message);
    CommentEditorPanel p = findOrCreateEditor(newComment, false);
    if (p == null) {
        enableButtons(false);
        PatchUtil.DETAIL_SVC.saveDraft(newComment, new GerritCallback<PatchLineComment>() {

            @Override
            public void onSuccess(final PatchLineComment result) {
                enableButtons(true);
                notifyDraftDelta(1);
                findOrCreateEditor(result, true).setOpen(false);
            }

            @Override
            public void onFailure(Throwable caught) {
                enableButtons(true);
                super.onFailure(caught);
            }
        });
    } else {
        if (!p.isOpen()) {
            p.setOpen(true);
        }
        p.setFocus(true);
    }
}
#end_block

#method_before
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB, DoubleClickHandler handler) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    isFile = isFile();
    linkPanel.clear();
    doubleClickPanel.addDoubleClickHandler(handler);
    if (isFile) {
        doubleClickPanel.setTitle(PatchUtil.C.addFileCommentByDoubleClick());
    }
    Label patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    patchSet.addDoubleClickHandler(handler);
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#method_after
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    linkPanel.clear();
    if (isFile()) {
        linkPanel.setTitle(PatchUtil.C.addFileCommentByDoubleClick());
    }
    patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#end_block

#method_before
private boolean isFile() {
    boolean isCommitMessage = Patch.COMMIT_MSG.equals(script.getNewName());
    return !(// 
    isCommitMessage || // 
    (side == Side.A && 0 >= script.getA().size()) || (side == Side.B && 0 >= script.getB().size()));
}
#method_after
public boolean isFile() {
    boolean isCommitMessage = Patch.COMMIT_MSG.equals(script.getNewName());
    return !(// 
    isCommitMessage || // 
    (side == Side.A && 0 >= script.getA().size()) || (side == Side.B && 0 >= script.getB().size()));
}
#end_block

#method_before
private Anchor createDownloadLink() {
    if (!isFile) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#method_after
private Anchor createDownloadLink() {
    if (!isFile()) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, A, psListOfHeaderA);
    table.setWidget(R_HEAD, B, psListOfHeaderB);
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, A, headerSideA);
    table.setWidget(R_HEAD, B, headerSideB);
}
#end_block

#method_before
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    isFile = isFile();
    linkPanel.clear();
    Label patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#method_after
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    linkPanel.clear();
    Label patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#end_block

#method_before
private Anchor createDownloadLink() {
    if (!isFile) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#method_after
private Anchor createDownloadLink() {
    if (!isFile()) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, PC, psListOfHeaderA);
    table.setWidget(rowOfTableHeaderB, PC, psListOfHeaderB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, PC, headerSideA);
    table.setWidget(rowOfTableHeaderB, PC, headerSideB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    try {
        final Map<String, DashboardInfo> dashboards;
        if (level != null) {
            switch(level) {
                case PROJECT:
                    final Project.NameKey projectName = new Project.NameKey(entityName);
                    final ProjectState projectState = projectCache.get(projectName);
                    if (defaultDashboard) {
                        dashboards = Maps.newTreeMap();
                        DashboardInfo info = findProjectDefaultDashboard(projectState);
                        dashboards.put(info.id, info);
                    } else {
                        dashboards = allDashboardsFor(projectState);
                    }
                    break;
                default:
                    throw new IllegalStateException("unsupported dashboard level: " + level);
            }
        } else {
            dashboards = Maps.newTreeMap();
        }
        format.newGson().toJson(dashboards, new TypeToken<Map<String, DashboardInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    } finally {
        stdout.flush();
    }
}
#method_after
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    try {
        final Map<String, DashboardInfo> dashboards;
        if (level != null) {
            switch(level) {
                case PROJECT:
                    final Project.NameKey projectName = new Project.NameKey(entityName);
                    final ProjectState projectState = projectCache.get(projectName);
                    DashboardInfo defaultInfo = findProjectDefaultDashboard(projectState);
                    if (defaultDashboard) {
                        dashboards = Maps.newTreeMap();
                        if (defaultInfo != null) {
                            dashboards.put(defaultInfo.id, defaultInfo);
                        }
                    } else {
                        dashboards = allDashboardsFor(projectState, defaultInfo != null ? defaultInfo.id : null);
                    }
                    break;
                default:
                    throw new IllegalStateException("unsupported dashboard level: " + level);
            }
        } else {
            dashboards = Maps.newTreeMap();
        }
        format.newGson().toJson(dashboards, new TypeToken<Map<String, DashboardInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
private Map<String, DashboardInfo> allDashboardsFor(ProjectState projectState) {
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Project.NameKey parent;
    Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(projectName);
    do {
        dashboards = addProjectDashboards(projectState, dashboards);
        parent = projectState.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        projectState = projectCache.get(parent);
    } while (projectState != null);
    projectState = projectCache.getAllProjects();
    parent = projectState.getProject().getNameKey();
    if (seen.add(parent)) {
        dashboards = addProjectDashboards(projectState, dashboards);
    }
    for (String id : dashboards.keySet()) {
        DashboardInfo info = dashboards.get(id);
        info.parameters = info.parameters.replaceAll("[$][{]project[}]", projectName.get());
    }
    return dashboards;
}
#method_after
private Map<String, DashboardInfo> allDashboardsFor(ProjectState projectState, final String defaultId) {
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Project.NameKey parent;
    Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(projectName);
    do {
        dashboards = addProjectDashboards(projectState, dashboards, defaultId);
        parent = projectState.getProject().getParent(allProjects);
        projectState = projectCache.get(parent);
    } while (projectState != null && seen.add(parent));
    for (String id : dashboards.keySet()) {
        replaceTokens(dashboards.get(id), projectName.get());
    }
    return dashboards;
}
#end_block

#method_before
private Map<String, DashboardInfo> addProjectDashboards(final ProjectState projectState, Map<String, DashboardInfo> all) {
    final Map<String, DashboardInfo> dashboards = projectDashboards(projectState);
    dashboards.putAll(all);
    return dashboards;
}
#method_after
private Map<String, DashboardInfo> addProjectDashboards(final ProjectState projectState, Map<String, DashboardInfo> all, final String defaultId) {
    final Map<String, DashboardInfo> dashboards = projectDashboards(projectState, defaultId);
    dashboards.putAll(all);
    return dashboards;
}
#end_block

#method_before
private Map<String, DashboardInfo> projectDashboards(final ProjectState projectState) {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return dashboards;
    }
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Repository repo = null;
    RevWalk revWalk = null;
    try {
        repo = repoManager.openRepository(projectName);
        revWalk = new RevWalk(repo);
        final Map<String, Ref> refs = repo.getRefDatabase().getRefs(REFS_DASHBOARDS);
        for (final Ref ref : refs.values()) {
            if (projectControl.controlForRef(ref.getName()).canRead()) {
                dashboards.putAll(loadDashboards(projectControl.getProject(), repo, revWalk, ref));
            }
        }
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + projectName.get(), e);
    } finally {
        if (revWalk != null) {
            revWalk.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
    return dashboards;
}
#method_after
private Map<String, DashboardInfo> projectDashboards(final ProjectState projectState, final String defaultId) {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return dashboards;
    }
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Repository repo = null;
    RevWalk revWalk = null;
    try {
        repo = repoManager.openRepository(projectName);
        revWalk = new RevWalk(repo);
        final Map<String, Ref> refs = repo.getRefDatabase().getRefs(REFS_DASHBOARDS);
        for (final Ref ref : refs.values()) {
            if (projectControl.controlForRef(ref.getName()).canRead()) {
                dashboards.putAll(loadDashboards(projectControl.getProject(), repo, revWalk, ref, defaultId));
            }
        }
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + projectName.get(), e);
    } finally {
        if (revWalk != null) {
            revWalk.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
    return dashboards;
}
#end_block

#method_before
private Map<String, DashboardInfo> loadDashboards(final Project project, final Repository repo, final RevWalk revWalk, final Ref ref) throws IOException {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    TreeWalk treeWalk = new TreeWalk(repo);
    try {
        final RevCommit commit = revWalk.parseCommit(ref.getObjectId());
        final RevTree tree = commit.getTree();
        treeWalk.addTree(tree);
        treeWalk.setRecursive(true);
        while (treeWalk.next()) {
            final ObjectLoader loader = repo.open(treeWalk.getObjectId(0));
            final DashboardInfo info = loadDashboard(project, ref.getName(), treeWalk.getPathString(), loader);
            dashboards.put(info.id, info);
        }
    } catch (ConfigInvalidException e) {
        log.warn("Failed to load dashboards of project " + project.getName() + " from ref " + ref.getName(), e);
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + project.getName() + " from ref " + ref.getName(), e);
    } finally {
        treeWalk.release();
    }
    return dashboards;
}
#method_after
private Map<String, DashboardInfo> loadDashboards(final Project project, final Repository repo, final RevWalk revWalk, final Ref ref, final String defaultId) throws IOException {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    TreeWalk treeWalk = new TreeWalk(repo);
    try {
        final RevCommit commit = revWalk.parseCommit(ref.getObjectId());
        final RevTree tree = commit.getTree();
        treeWalk.addTree(tree);
        treeWalk.setRecursive(true);
        while (treeWalk.next()) {
            final ObjectLoader loader = repo.open(treeWalk.getObjectId(0));
            final DashboardInfo info = loadDashboard(project, ref.getName(), treeWalk.getPathString(), defaultId, loader);
            dashboards.put(info.id, info);
        }
    } catch (ConfigInvalidException e) {
        log.warn("Failed to load dashboards of project " + project.getName() + " from ref " + ref.getName(), e);
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + project.getName() + " from ref " + ref.getName(), e);
    } finally {
        treeWalk.release();
    }
    return dashboards;
}
#end_block

#method_before
private DashboardInfo findProjectDefaultDashboard(ProjectState projectState) {
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Project.NameKey parent;
    DashboardInfo info;
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(projectName);
    boolean considerLocal = true;
    do {
        info = loadProjectDefaultDashboard(projectState, considerLocal);
        if (info != null) {
            return info;
        }
        parent = projectState.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        projectState = projectCache.get(parent);
        considerLocal = false;
    } while (projectState != null);
    projectState = projectCache.getAllProjects();
    parent = projectState.getProject().getNameKey();
    if (seen.add(parent)) {
        info = loadProjectDefaultDashboard(projectState, considerLocal);
    }
    return info;
}
#method_after
private DashboardInfo findProjectDefaultDashboard(ProjectState projectState) {
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    Project.NameKey parent;
    DashboardInfo info;
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(projectName);
    boolean considerLocal = true;
    do {
        info = loadProjectDefaultDashboard(projectState, considerLocal);
        if (info != null) {
            replaceTokens(info, projectName.get());
            return info;
        }
        considerLocal = false;
        parent = projectState.getProject().getParent(allProjects);
        projectState = projectCache.get(parent);
    } while (projectState != null && seen.add(parent));
    return null;
}
#end_block

#method_before
private DashboardInfo loadProjectDefaultDashboard(final ProjectState projectState, boolean considerLocal) {
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return null;
    }
    final Project project = projectControl.getProject();
    String defaultDashboardId = project.getDefaultDashboard();
    if (considerLocal && project.getLocalDefaultDashboard() != null) {
        defaultDashboardId = project.getLocalDefaultDashboard();
    }
    final Project.NameKey projectName = projectState.getProject().getNameKey();
    DashboardInfo info = loadDashboard(projectControl, defaultDashboardId);
    info.parameters = info.parameters.replaceAll("[$][{]project[}]", projectName.get());
    return info;
}
#method_after
private DashboardInfo loadProjectDefaultDashboard(final ProjectState projectState, boolean considerLocal) {
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return null;
    }
    final Project project = projectControl.getProject();
    String defaultDashboardId = project.getDefaultDashboard();
    if (considerLocal && project.getLocalDefaultDashboard() != null) {
        defaultDashboardId = project.getLocalDefaultDashboard();
    }
    if (defaultDashboardId == null) {
        return null;
    }
    return loadDashboard(projectControl, defaultDashboardId, defaultDashboardId);
}
#end_block

#method_before
private DashboardInfo loadDashboard(final Project project, final String refName, final String path, final ObjectLoader loader) throws IOException, ConfigInvalidException {
    DashboardInfo info = new DashboardInfo();
    info.dashboardName = path;
    info.refName = refName;
    info.projectName = project.getName();
    info.id = createId(info.refName, info.dashboardName);
    final String defaultDashboardId = project.getLocalDefaultDashboard() != null ? project.getLocalDefaultDashboard() : project.getDefaultDashboard();
    info.isDefault = info.id.equals(defaultDashboardId);
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    loader.copyTo(out);
    Config dashboardConfig = new Config();
    dashboardConfig.fromText(new String(out.toByteArray(), "UTF-8"));
    info.description = dashboardConfig.getString("main", null, "description");
    final StringBuilder query = new StringBuilder();
    query.append("title=");
    query.append(info.dashboardName.replaceAll(" ", "+"));
    final Set<String> sections = dashboardConfig.getSubsections("section");
    for (final String section : sections) {
        query.append("&");
        query.append(section.replaceAll(" ", "+"));
        query.append("=");
        query.append(dashboardConfig.getString("section", section, "query"));
    }
    info.parameters = query.toString();
    return info;
}
#method_after
private DashboardInfo loadDashboard(final ProjectControl projectControl, final String dashboardId, final String defaultId) {
    StringTokenizer t = new StringTokenizer(dashboardId, ":");
    if (t.countTokens() != 2) {
        throw new IllegalStateException("failed to load dashboard, invalid dashboard id: " + dashboardId);
    }
    final String refName = t.nextToken();
    final String path = t.nextToken();
    Repository repo = null;
    RevWalk revWalk = null;
    TreeWalk treeWalk = null;
    try {
        repo = repoManager.openRepository(projectControl.getProject().getNameKey());
        final Ref ref = repo.getRef(refName);
        if (ref == null) {
            return null;
        }
        if (!projectControl.controlForRef(ref.getName()).canRead()) {
            return null;
        }
        revWalk = new RevWalk(repo);
        final RevCommit commit = revWalk.parseCommit(ref.getObjectId());
        treeWalk = new TreeWalk(repo);
        treeWalk.addTree(commit.getTree());
        treeWalk.setRecursive(true);
        treeWalk.setFilter(PathFilter.create(path));
        if (!treeWalk.next()) {
            return null;
        }
        final ObjectLoader loader = repo.open(treeWalk.getObjectId(0));
        return loadDashboard(projectControl.getProject(), refName, path, defaultId, loader);
    } catch (IOException e) {
        log.warn("Failed to load default dashboard", e);
    } catch (ConfigInvalidException e) {
        log.warn("Failed to load dashboards of project " + projectControl.getProject().getName() + " from ref " + refName, e);
    } finally {
        if (treeWalk != null) {
            treeWalk.release();
        }
        if (revWalk != null) {
            revWalk.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
    return null;
}
#end_block

#method_before
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    try {
        final ReviewDb db = schema.open();
        try {
            p.parents = new ArrayList<String>();
            for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
                p.parents.add(a.getAncestorRevision().get());
            }
            p.author = asAccountAttribute(psInfoFactory.get(db, patchSet.getId()).getAuthor().getAccount());
            Change change = db.changes().get(patchSet.getId().getParentKey());
            List<Patch> list = patchListCache.get(change, patchSet).toPatchList(patchSet.getId());
            for (Patch pe : list) {
                if (!Patch.COMMIT_MSG.equals(pe.getFileName())) {
                    p.sizeDeletions -= pe.getDeletions();
                    p.sizeInsertions += pe.getInsertions();
                }
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(String.format("Cannot get authorEmail for %s ", patchSet.getId()), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get deletions and insertions for %s ", patchSet.getId()), e);
    }
    return p;
}
#method_after
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    final PatchSet.Id pId = patchSet.getId();
    try {
        final ReviewDb db = schema.open();
        try {
            p.parents = new ArrayList<String>();
            for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
                p.parents.add(a.getAncestorRevision().get());
            }
            p.author = asAccountAttribute(psInfoFactory.get(db, pId).getAuthor().getAccount());
            Change change = db.changes().get(pId.getParentKey());
            List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
            for (Patch pe : list) {
                if (!Patch.COMMIT_MSG.equals(pe.getFileName())) {
                    p.sizeDeletions -= pe.getDeletions();
                    p.sizeInsertions += pe.getInsertions();
                }
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(String.format("Cannot get authorEmail for %s.", pId), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    try {
        final Map<String, DashboardInfo> output;
        if (level != null) {
            switch(level) {
                case PROJECT:
                    output = projectDashboards(new Project.NameKey(entityName));
                    break;
                default:
                    throw new IllegalStateException("unsupported dashboard level: " + level);
            }
        } else {
            output = Maps.newTreeMap();
        }
        format.newGson().toJson(output, new TypeToken<Map<String, DashboardInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    } finally {
        stdout.flush();
    }
}
#method_after
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    try {
        final Map<String, DashboardInfo> dashboards;
        if (level != null) {
            switch(level) {
                case PROJECT:
                    dashboards = projectDashboards(new Project.NameKey(entityName));
                    break;
                default:
                    throw new IllegalStateException("unsupported dashboard level: " + level);
            }
        } else {
            dashboards = Maps.newTreeMap();
        }
        format.newGson().toJson(dashboards, new TypeToken<Map<String, DashboardInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
private Map<String, DashboardInfo> projectDashboards(final Project.NameKey projectName) {
    final Map<String, DashboardInfo> output = Maps.newTreeMap();
    final ProjectState projectState = projectCache.get(projectName);
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return output;
    }
    Repository repo = null;
    RevWalk revWalk = null;
    try {
        repo = repoManager.openRepository(projectName);
        final Map<String, Ref> refs = repo.getRefDatabase().getRefs(REFS_DASHBOARDS);
        for (final Ref ref : refs.values()) {
            if (projectControl.controlForRef(ref.getName()).canRead()) {
                revWalk = new RevWalk(repo);
                output.putAll(loadDashboards(projectName, repo, revWalk, ref));
            }
        }
    } catch (IOException e) {
        log.warn("Failed to load dashboards", e);
    } finally {
        if (revWalk != null) {
            revWalk.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
    return output;
}
#method_after
private Map<String, DashboardInfo> projectDashboards(final Project.NameKey projectName) {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    final ProjectState projectState = projectCache.get(projectName);
    final ProjectControl projectControl = projectState.controlFor(currentUser);
    if (projectState == null || !projectControl.isVisible()) {
        return dashboards;
    }
    Repository repo = null;
    RevWalk revWalk = null;
    try {
        repo = repoManager.openRepository(projectName);
        revWalk = new RevWalk(repo);
        final Map<String, Ref> refs = repo.getRefDatabase().getRefs(REFS_DASHBOARDS);
        for (final Ref ref : refs.values()) {
            if (projectControl.controlForRef(ref.getName()).canRead()) {
                dashboards.putAll(loadDashboards(projectName, repo, revWalk, ref));
            }
        }
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + projectName.get(), e);
    } finally {
        if (revWalk != null) {
            revWalk.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
    return dashboards;
}
#end_block

#method_before
private Map<String, DashboardInfo> loadDashboards(final Project.NameKey projectName, final Repository repo, final RevWalk revWalk, final Ref ref) throws IOException {
    final Map<String, DashboardInfo> output = Maps.newTreeMap();
    final RevCommit commit = revWalk.parseCommit(ref.getObjectId());
    final RevTree tree = commit.getTree();
    TreeWalk treeWalk = new TreeWalk(repo);
    try {
        treeWalk.addTree(tree);
        treeWalk.setRecursive(true);
        while (treeWalk.next()) {
            DashboardInfo info = new DashboardInfo();
            info.name = treeWalk.getPathString();
            info.refName = ref.getName();
            info.projectName = projectName.get();
            info.id = createId(info.refName, info.name);
            final ObjectLoader loader = repo.open(treeWalk.getObjectId(0));
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            loader.copyTo(out);
            Config dashboardConfig = new Config();
            try {
                dashboardConfig.fromText(new String(out.toByteArray(), "UTF-8"));
            } catch (ConfigInvalidException e) {
                log.warn("Failed to load dashboards", e);
            }
            info.description = dashboardConfig.getString("main", null, "description");
            final StringBuilder query = new StringBuilder();
            query.append("title=");
            query.append(info.name.replaceAll(" ", "+"));
            final Set<String> sections = dashboardConfig.getSubsections("section");
            for (final String section : sections) {
                query.append("&");
                query.append(section.replaceAll(" ", "+"));
                query.append("=");
                query.append(dashboardConfig.getString("section", section, "query"));
            }
            info.parameters = query.toString();
            output.put(info.id, info);
        }
    } finally {
        treeWalk.release();
    }
    return output;
}
#method_after
private Map<String, DashboardInfo> loadDashboards(final Project.NameKey projectName, final Repository repo, final RevWalk revWalk, final Ref ref) {
    final Map<String, DashboardInfo> dashboards = Maps.newTreeMap();
    TreeWalk treeWalk = new TreeWalk(repo);
    try {
        final RevCommit commit = revWalk.parseCommit(ref.getObjectId());
        final RevTree tree = commit.getTree();
        treeWalk.addTree(tree);
        treeWalk.setRecursive(true);
        while (treeWalk.next()) {
            DashboardInfo info = new DashboardInfo();
            info.dashboardName = treeWalk.getPathString();
            info.refName = ref.getName();
            info.projectName = projectName.get();
            info.id = createId(info.refName, info.dashboardName);
            final ObjectLoader loader = repo.open(treeWalk.getObjectId(0));
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            loader.copyTo(out);
            Config dashboardConfig = new Config();
            dashboardConfig.fromText(new String(out.toByteArray(), "UTF-8"));
            info.description = dashboardConfig.getString("main", null, "description");
            final StringBuilder query = new StringBuilder();
            query.append("title=");
            query.append(info.dashboardName.replaceAll(" ", "+"));
            final Set<String> sections = dashboardConfig.getSubsections("section");
            for (final String section : sections) {
                query.append("&");
                query.append(section.replaceAll(" ", "+"));
                query.append("=");
                query.append(dashboardConfig.getString("section", section, "query"));
            }
            info.parameters = query.toString();
            dashboards.put(info.id, info);
        }
    } catch (IOException e) {
        log.warn("Failed to load dashboards of project " + projectName.get() + " from ref " + ref.getName(), e);
    } catch (ConfigInvalidException e) {
        log.warn("Failed to load dashboards of project " + projectName.get() + " from ref " + ref.getName(), e);
    } finally {
        treeWalk.release();
    }
    return dashboards;
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(MaterializedGroupMembership.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    bind(GitReferenceUpdated.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), CommitValidatorListener.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    newProgress.end();
    doReplaces();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
                commandProgress.update(1);
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                addMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                addMessage("  " + url + c.getChangeId());
            }
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        cmd.execute(rp);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd, "can not create new references");
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        if (cmd.getResult().equals(ReceiveCommand.Result.NOT_ATTEMPTED)) {
            cmd.execute(rp);
        }
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        cmd.execute(rp);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "can not delete references");
        }
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        cmd.execute(rp);
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "can not upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    for (CommitValidatorListener validator : commitValidators) {
        CommitValidationResult validationResult = validator.validate(cmd, project, ctl.getRefName(), c, currentUser);
        if (!validationResult.validated) {
            reject(cmd, validationResult.why);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    for (CommitValidationListener validator : commitValidators) {
        CommitValidationResult validationResult = validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser));
        String pluginName = pluginLoader.getPluginName(validator);
        if (!validationResult.validated) {
            reject(cmd, String.format("%s (rejected by plugin %s)", validationResult.message, pluginName));
            return false;
        } else if (!Strings.isNullOrEmpty(validationResult.message)) {
            addMessage(String.format("%s (from plugin %s)", pluginName));
        }
    }
    return true;
}
#end_block

#method_before
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    return sb.toString();
}
#method_after
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    return sb.toString();
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req, true);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceRequest result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (Exception e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceRequest result) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(result.change);
                cm.setFrom(currentUser.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void insertAncestors(PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#method_after
private void insertAncestors(ReviewDb db, PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
public static CommitValidationResult newFailure(String why) {
    return new CommitValidationResult(false, why);
}
#method_after
public static CommitValidationResult newFailure(String message) {
    return new CommitValidationResult(false, message);
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(MaterializedGroupMembership.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
protected void doLogout(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    webSession.get().logout();
    if (logoutUrl != null) {
        rsp.sendRedirect(logoutUrl);
    } else {
        String url = urlProvider.get();
        if (Strings.isNullOrEmpty(url)) {
            url = req.getContextPath();
        }
        if (Strings.isNullOrEmpty(url)) {
            url = "/";
        }
        if (!url.endsWith("/")) {
            url += "/";
        }
        rsp.sendRedirect(url);
    }
}
#method_after
private void doLogout(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    webSession.get().logout();
    if (logoutUrl != null) {
        rsp.sendRedirect(logoutUrl);
    } else {
        String url = urlProvider.get();
        if (Strings.isNullOrEmpty(url)) {
            url = req.getContextPath();
        }
        if (Strings.isNullOrEmpty(url)) {
            url = "/";
        }
        if (!url.endsWith("/")) {
            url += "/";
        }
        rsp.sendRedirect(url);
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final String sid = webSession.get().getToken();
    final String username = webSession.get().getCurrentUser().getUserName();
    final String what = "sign out";
    final AuditEvent record = new AuditEvent(sid, username, what, null);
    try {
        doLogout(req, rsp);
    } finally {
        record.setResult("{\"Success\":true}");
        audit.track(record);
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final String sid = webSession.get().getToken();
    final CurrentUser currentUser = webSession.get().getCurrentUser();
    final String what = "sign out";
    final long when = System.currentTimeMillis();
    try {
        doLogout(req, rsp);
    } finally {
        audit.dispatch(new AuditEvent(sid, currentUser, what, when, null, null));
    }
}
#end_block

#method_before
public void setSession(final ServerSession session) {
    final SshSession s = session.getAttribute(SshSession.KEY);
    this.ctx = new Context(s, commandLine);
}
#method_after
public void setSession(final ServerSession session) {
    final SshSession s = session.getAttribute(SshSession.KEY);
    this.ctx = sshScope.newContext(s, commandLine);
}
#end_block

#method_before
private void onStart() throws IOException {
    synchronized (this) {
        final Context old = SshScope.set(ctx);
        try {
            cmd = dispatcher.get();
            cmd.setArguments(argv);
            cmd.setInputStream(in);
            cmd.setOutputStream(out);
            cmd.setErrorStream(err);
            cmd.setExitCallback(new ExitCallback() {

                @Override
                public void onExit(int rc, String exitMessage) {
                    exit.onExit(translateExit(rc), exitMessage);
                    log(rc);
                }

                @Override
                public void onExit(int rc) {
                    exit.onExit(translateExit(rc));
                    log(rc);
                }
            });
            cmd.start(env);
        } finally {
            SshScope.set(old);
        }
    }
}
#method_after
private void onStart() throws IOException {
    synchronized (this) {
        final Context old = sshScope.set(ctx);
        try {
            cmd = dispatcher.get();
            cmd.setArguments(argv);
            cmd.setInputStream(in);
            cmd.setOutputStream(out);
            cmd.setErrorStream(err);
            cmd.setExitCallback(new ExitCallback() {

                @Override
                public void onExit(int rc, String exitMessage) {
                    exit.onExit(translateExit(rc), exitMessage);
                    log(rc);
                }

                @Override
                public void onExit(int rc) {
                    exit.onExit(translateExit(rc));
                    log(rc);
                }
            });
            cmd.start(env);
        } finally {
            sshScope.set(old);
        }
    }
}
#end_block

#method_before
private void onDestroy() {
    synchronized (this) {
        if (cmd != null) {
            final Context old = SshScope.set(ctx);
            try {
                cmd.destroy();
                log(BaseCommand.STATUS_CANCEL);
            } finally {
                ctx = null;
                cmd = null;
                SshScope.set(old);
            }
        }
    }
}
#method_after
private void onDestroy() {
    synchronized (this) {
        if (cmd != null) {
            final Context old = sshScope.set(ctx);
            try {
                cmd.destroy();
                log(BaseCommand.STATUS_CANCEL);
            } finally {
                ctx = null;
                cmd = null;
                sshScope.set(old);
            }
        }
    }
}
#end_block

#method_before
static String[] split(String commandLine) {
    final List<String> list = new ArrayList<String>();
    boolean inquote = false;
    boolean inDblQuote = false;
    StringBuilder r = new StringBuilder();
    for (int ip = 0; ip < commandLine.length(); ) {
        final char b = commandLine.charAt(ip++);
        switch(b) {
            case '\t':
            case ' ':
                if (inquote || inDblQuote)
                    r.append(b);
                else if (r.length() > 0) {
                    list.add(r.toString());
                    r = new StringBuilder();
                }
                continue;
            case '\"':
                if (inquote)
                    r.append(b);
                else
                    inDblQuote = !inDblQuote;
                continue;
            case '\'':
                if (inDblQuote)
                    r.append(b);
                else
                    inquote = !inquote;
                continue;
            case '\\':
                if (inquote || ip == commandLine.length())
                    // literal within a quote
                    r.append(b);
                else
                    r.append(commandLine.charAt(ip++));
                continue;
            default:
                r.append(b);
                continue;
        }
    }
    if (r.length() > 0) {
        list.add(r.toString());
    }
    return list.toArray(new String[list.size()]);
}
#method_after
static public String[] split(String commandLine) {
    final List<String> list = new ArrayList<String>();
    boolean inquote = false;
    boolean inDblQuote = false;
    StringBuilder r = new StringBuilder();
    for (int ip = 0; ip < commandLine.length(); ) {
        final char b = commandLine.charAt(ip++);
        switch(b) {
            case '\t':
            case ' ':
                if (inquote || inDblQuote)
                    r.append(b);
                else if (r.length() > 0) {
                    list.add(r.toString());
                    r = new StringBuilder();
                }
                continue;
            case '\"':
                if (inquote)
                    r.append(b);
                else
                    inDblQuote = !inDblQuote;
                continue;
            case '\'':
                if (inDblQuote)
                    r.append(b);
                else
                    inquote = !inquote;
                continue;
            case '\\':
                if (inquote || ip == commandLine.length())
                    // literal within a quote
                    r.append(b);
                else
                    r.append(commandLine.charAt(ip++));
                continue;
            default:
                r.append(b);
                continue;
        }
    }
    if (r.length() > 0) {
        list.add(r.toString());
    }
    return list.toArray(new String[list.size()]);
}
#end_block

#method_before
void onLogin() {
    async.append(log("LOGIN FROM " + session.get().getRemoteAddressAsString()));
    audit("0", "LOGIN", Collections.emptyList());
}
#method_after
void onLogin() {
    async.append(log("LOGIN FROM " + session.get().getRemoteAddressAsString()));
    audit("0", "LOGIN", new String[] {});
}
#end_block

#method_before
void onAuthFail(final SshSession sd) {
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger (optional)
    null, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    "AUTH FAILURE FROM " + sd.getRemoteAddressAsString(), // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    event.setProperty(P_USER_NAME, sd.getUsername());
    final String error = sd.getAuthenticationError();
    if (error != null) {
        event.setProperty(P_STATUS, error);
    }
    async.append(event);
    audit("FAIL", "AUTH", Arrays.asList(sd.getRemoteAddressAsString()));
}
#method_after
void onAuthFail(final SshSession sd) {
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger
    log, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    "AUTH FAILURE FROM " + sd.getRemoteAddressAsString(), // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    event.setProperty(P_USER_NAME, sd.getUsername());
    final String error = sd.getAuthenticationError();
    if (error != null) {
        event.setProperty(P_STATUS, error);
    }
    async.append(event);
    audit("FAIL", "AUTH", new String[] { sd.getRemoteAddressAsString() });
}
#end_block

#method_before
void onExecute(int exitValue) {
    final Context ctx = context.get();
    ctx.finished = System.currentTimeMillis();
    final String commandLine = ctx.getCommandLine();
    String cmd = QuotedString.BOURNE.quote(commandLine);
    if (cmd == commandLine) {
        cmd = "'" + commandLine + "'";
    }
    final LoggingEvent event = log(cmd);
    event.setProperty(P_WAIT, (ctx.started - ctx.created) + "ms");
    event.setProperty(P_EXEC, (ctx.finished - ctx.started) + "ms");
    final String status;
    switch(exitValue) {
        case BaseCommand.STATUS_CANCEL:
            status = "killed";
            break;
        case BaseCommand.STATUS_NOT_FOUND:
            status = "not-found";
            break;
        case BaseCommand.STATUS_NOT_ADMIN:
            status = "not-admin";
            break;
        default:
            status = String.valueOf(exitValue);
            break;
    }
    event.setProperty(P_STATUS, status);
    async.append(event);
    audit(status, getCommand(commandLine), getCommandArgs(commandLine));
}
#method_after
void onExecute(int exitValue) {
    final Context ctx = context.get();
    ctx.finished = System.currentTimeMillis();
    final String commandLine = ctx.getCommandLine();
    String cmd = QuotedString.BOURNE.quote(commandLine);
    if (cmd == commandLine) {
        cmd = "'" + commandLine + "'";
    }
    final LoggingEvent event = log(cmd);
    event.setProperty(P_WAIT, (ctx.started - ctx.created) + "ms");
    event.setProperty(P_EXEC, (ctx.finished - ctx.started) + "ms");
    final String status;
    switch(exitValue) {
        case BaseCommand.STATUS_CANCEL:
            status = "killed";
            break;
        case BaseCommand.STATUS_NOT_FOUND:
            status = "not-found";
            break;
        case BaseCommand.STATUS_NOT_ADMIN:
            status = "not-admin";
            break;
        default:
            status = String.valueOf(exitValue);
            break;
    }
    event.setProperty(P_STATUS, status);
    async.append(event);
    audit(status, getCommand(commandLine), CommandFactoryProvider.split(commandLine));
}
#end_block

#method_before
void onLogout() {
    async.append(log("LOGOUT"));
    audit("0", "LOGOUT", Collections.emptyList());
}
#method_after
void onLogout() {
    async.append(log("LOGOUT"));
    audit("0", "LOGOUT", new String[] {});
}
#end_block

#method_before
private LoggingEvent log(final String msg) {
    final SshSession sd = session.get();
    final CurrentUser user = sd.getCurrentUser();
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger (optional)
    null, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    msg, // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    String userName = "-", accountId = "-";
    if (user instanceof IdentifiedUser) {
        IdentifiedUser u = (IdentifiedUser) user;
        userName = u.getAccount().getUserName();
        accountId = "a/" + u.getAccountId().toString();
    } else if (user instanceof PeerDaemonUser) {
        userName = PeerDaemonUser.USER_NAME;
    }
    event.setProperty(P_USER_NAME, userName);
    event.setProperty(P_ACCOUNT_ID, accountId);
    return event;
}
#method_after
private LoggingEvent log(final String msg) {
    final SshSession sd = session.get();
    final CurrentUser user = sd.getCurrentUser();
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger
    log, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    msg, // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    String userName = "-", accountId = "-";
    if (user instanceof IdentifiedUser) {
        IdentifiedUser u = (IdentifiedUser) user;
        userName = u.getAccount().getUserName();
        accountId = "a/" + u.getAccountId().toString();
    } else if (user instanceof PeerDaemonUser) {
        userName = PeerDaemonUser.USER_NAME;
    }
    event.setProperty(P_USER_NAME, userName);
    event.setProperty(P_ACCOUNT_ID, accountId);
    return event;
}
#end_block

#method_before
void audit(Object result, String commandName, List<?> args) {
    final Context ctx = context.get();
    final String sid = extractSessionId(ctx);
    final String username = extractUsername(ctx);
    final long elapsed = extractElapsed(ctx);
    final long created = extractCreated(ctx);
    final String what = extractWhat(commandName, args);
    auditService.track(new AuditEvent(sid, username, "ssh:" + what, created, args, result, elapsed));
}
#method_after
void audit(Object result, String commandName, String[] args) {
    final Context ctx = context.get();
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    final String what = extractWhat(commandName, args);
    auditService.dispatch(new AuditEvent(sid, extractCurrentUser(ctx), "ssh:" + what, created, Arrays.asList(args), result));
}
#end_block

#method_before
private String extractWhat(String commandName, List<?> args) {
    String result = commandName;
    if ("gerrit".equals(commandName)) {
        if (args.size() > 1)
            result = "gerrit" + "." + args.get(1);
    }
    return result;
}
#method_after
private String extractWhat(String commandName, String[] args) {
    String result = commandName;
    if ("gerrit".equals(commandName)) {
        if (args.length > 1)
            result = "gerrit" + "." + args[1];
    }
    return result;
}
#end_block

#method_before
@Override
protected GsonBuilder createGsonBuilder() {
    final GsonBuilder g = super.createGsonBuilder();
    g.registerTypeAdapter(org.eclipse.jgit.diff.Edit.class, new org.eclipse.jgit.diff.EditDeserializer());
    return g;
}
#method_after
@Override
protected GsonBuilder createGsonBuilder() {
    return gerritDefaultGsonBuilder();
}
#end_block

#method_before
@Override
protected void service(final HttpServletRequest req, final HttpServletResponse resp) throws IOException {
    try {
        super.service(req, resp);
    } finally {
        try {
            audit();
        } catch (Throwable ignoreExceptionWhileLogging) {
        } finally {
            currentCall.set(null);
        }
    }
}
#method_after
@Override
protected void service(final HttpServletRequest req, final HttpServletResponse resp) throws IOException {
    try {
        super.service(req, resp);
    } finally {
        audit();
        currentCall.set(null);
    }
}
#end_block

#method_before
private void audit() {
    try {
        GerritCall call = currentCall.get();
        Audit note = (Audit) call.getMethod().getAnnotation(Audit.class);
        if (note != null) {
            final Gson gson = createGsonBuilder().setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).setVersion(1.0).create();
            final String sid = call.getWebSession().getToken();
            final String username = extractUsername(call);
            final List<Object> args = extractParams(note, call, gson);
            final String what = extractWhat(note, call.getMethod().getName());
            final Object result = call.getResult();
            audit.track(new AuditEvent(sid, username, what, call.getWhen(), args, result, call.getElapsed()));
        }
    } catch (Throwable all) {
        LOG.error("Unable to log the call", all);
    }
}
#method_after
private void audit() {
    try {
        GerritCall call = currentCall.get();
        Audit note = (Audit) call.getMethod().getAnnotation(Audit.class);
        if (note != null) {
            final String sid = call.getWebSession().getToken();
            final CurrentUser username = call.getWebSession().getCurrentUser();
            final List<Object> args = extractParams(note, call);
            final String what = extractWhat(note, call.getMethod().getName());
            final Object result = call.getResult();
            audit.dispatch(new AuditEvent(sid, username, what, call.getWhen(), args, result));
        }
    } catch (Throwable all) {
        log.error("Unable to log the call", all);
    }
}
#end_block

#method_before
private List<Object> extractParams(final Audit note, final GerritCall call, Gson gson) {
    final List<Object> args = new ArrayList<Object>();
    final Object[] params = call.getParams();
    final int[] obfuscate = note.obfuscate();
    for (int i = 0; i < params.length; i++) {
        Object param = params[i];
        if (obfuscate.length > 0) {
            for (int id : obfuscate) {
                if (id == i) {
                    param = "*****";
                    break;
                }
            }
        }
        args.add(param);
    }
    return args;
}
#method_after
private List<Object> extractParams(final Audit note, final GerritCall call) {
    List<Object> args = Lists.newArrayList(Arrays.asList(call.getParams()));
    for (int idx : note.obfuscate()) {
        args.set(idx, "*****");
    }
    return args;
}
#end_block

#method_before
private String extractWhat(final Audit note, final String methodName) {
    String what = note.action();
    if (what.length() == 0) {
        boolean ccase = Character.isLowerCase(methodName.charAt(0));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < methodName.length(); i++) {
            char c = methodName.charAt(i);
            if (Character.isLowerCase(c) != ccase) {
                sb.append(' ');
            }
            sb.append(Character.toLowerCase(c));
        }
        what = sb.toString();
    }
    return what;
}
#method_after
private String extractWhat(final Audit note, final String methodName) {
    String what = note.action();
    if (what.length() == 0) {
        boolean ccase = Character.isLowerCase(methodName.charAt(0));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < methodName.length(); i++) {
            char c = methodName.charAt(i);
            if (ccase && !Character.isLowerCase(c)) {
                sb.append(' ');
            }
            sb.append(Character.toLowerCase(c));
        }
        what = sb.toString();
    }
    return what;
}
#end_block

#method_before
public Object getResult() {
    try {
        return resultField.get(this);
    } catch (IllegalArgumentException e) {
        LOG.error("Cannot access result field");
    } catch (IllegalAccessException e) {
        LOG.error("No permissions to access result field");
    }
    return null;
}
#method_after
public Object getResult() {
    if (resultField == null) {
        return null;
    }
    try {
        return resultField.get(this);
    } catch (IllegalArgumentException e) {
        log.error("Cannot access result field");
    } catch (IllegalAccessException e) {
        log.error("No permissions to access result field");
    }
    return null;
}
#end_block

#method_before
@Override
public MethodHandle getMethod() {
    if (currentMethod.get() == null)
        return super.getMethod();
    else
        return currentMethod.get();
}
#method_after
@Override
public MethodHandle getMethod() {
    if (currentMethod.get() == null) {
        return super.getMethod();
    } else {
        return currentMethod.get();
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    return asString().hashCode();
}
#method_after
@Override
public int hashCode() {
    return uuid.hashCode();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    AuditEvent other = (AuditEvent) obj;
    return this.asString().equals(other.asString());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    AuditEvent other = (AuditEvent) obj;
    return this.uuid.equals(other.uuid);
}
#end_block

#method_before
@Override
public String toString() {
    return asString();
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(uuid.toString());
    sb.append("|");
    sb.append(sessionId);
    sb.append('|');
    sb.append(who);
    sb.append('|');
    sb.append(when);
    sb.append('|');
    sb.append(what);
    sb.append('|');
    sb.append(elapsed);
    sb.append('|');
    if (params != null) {
        sb.append('[');
        for (int i = 0; i < params.size(); i++) {
            if (i > 0)
                sb.append(',');
            Object param = params.get(i);
            if (param == null) {
                sb.append("null");
            } else {
                sb.append(param);
            }
        }
        sb.append(']');
    }
    sb.append('|');
    if (result != null) {
        sb.append(result);
    }
    return sb.toString();
}
#end_block

#method_before
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        public void onSuccess(final HostPageData result) {
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xsrfToken = result.xsrfToken;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2();
            loadPlugins(result.plugnis);
        }
    });
}
#method_after
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xsrfToken = result.xsrfToken;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    });
}
#end_block

#method_before
private void onModuleLoad2() {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    final RootPanel gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(menuRight);
    menuRightPanel.add(searchPanel);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            final String token = view.getToken();
            if (!token.equals(History.getToken())) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xsrfToken;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    display(token);
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    final RootPanel gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(menuRight);
    menuRightPanel.add(searchPanel);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            final String token = view.getToken();
            if (!token.equals(History.getToken())) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xsrfToken;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    loadPlugins(hpd, token);
}
#end_block

#method_before
private void loadPlugins(String[] pluginsUrls) {
    for (final String url : pluginsUrls) {
        ScriptInjector.fromUrl(url).setWindow(ScriptInjector.TOP_WINDOW).setCallback(new Callback<Void, Exception>() {

            @Override
            public void onSuccess(Void result) {
            // does nothing
            }

            @Override
            public void onFailure(Exception reason) {
                Window.alert("Failed load pluing: " + url);
            }
        }).inject();
    }
}
#method_after
private void loadPlugins(HostPageData hpd, final String token) {
    if (hpd.plugins != null) {
        for (final String url : hpd.plugins) {
            ScriptInjector.fromUrl(url).setWindow(ScriptInjector.TOP_WINDOW).setCallback(new Callback<Void, Exception>() {

                @Override
                public void onSuccess(Void result) {
                }

                @Override
                public void onFailure(Exception reason) {
                    ErrorDialog d = new ErrorDialog(reason);
                    d.setTitle(M.pluginFailed(url));
                    d.center();
                }
            }).inject();
        }
    }
    CallbackHandle<Void> cb = new CallbackHandle<Void>(new ResultDeserializer<Void>() {

        @Override
        public Void fromResult(JavaScriptObject responseObject) {
            return null;
        }
    }, new AsyncCallback<Void>() {

        @Override
        public void onFailure(Throwable caught) {
        }

        @Override
        public void onSuccess(Void result) {
            display(token);
        }
    });
    cb.install();
    ScriptInjector.fromString(cb.getFunctionName() + "();").setWindow(ScriptInjector.TOP_WINDOW).inject();
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    diffBar = new LinkMenuBar();
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    if (signedIn) {
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    addLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT);
                }
            }
        }, CREATE_PROJECT);
    }
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar menuBar = new LinkMenuBar();
        addLink(menuBar, C.menuGroups(), PageLinks.ADMIN_GROUPS);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    addLink(menuBar, C.menuPlugins(), PageLinks.ADMIN_PLUGINS);
                }
            }
        }, ADMINISTRATE_SERVER);
        menuLeft.add(menuBar, C.menuAdmin());
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        if (cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP) {
            menuRight.add(anchor(C.menuSignOut(), selfRedirect("/logout")));
        }
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", selfRedirect("/become")));
                break;
        }
    }
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    diffBar = new LinkMenuBar();
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    if (signedIn) {
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    addLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT);
                }
            }
        }, CREATE_PROJECT);
    }
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar groupsBar = new LinkMenuBar();
        addLink(groupsBar, C.menuGroupsList(), PageLinks.ADMIN_GROUPS);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_GROUP)) {
                    addLink(groupsBar, C.menuGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP);
                }
            }
        }, CREATE_GROUP);
        menuLeft.add(groupsBar, C.menuGroups());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    addLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(groupsBar) + 1);
                }
            }
        }, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        if (cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP) {
            menuRight.add(anchor(C.menuSignOut(), selfRedirect("/logout")));
        }
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", selfRedirect("/become")));
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final Page.Content page = get().get(select(req));
    final byte[] raw;
    final CurrentUser user = currentUser.get();
    if (user instanceof IdentifiedUser) {
        final StringWriter w = new StringWriter();
        w.write(HPD_ID + ".account=");
        json(((IdentifiedUser) user).getAccount(), w);
        w.write(";");
        w.write(HPD_ID + ".xsrfToken=");
        json(session.get().getToken(), w);
        w.write(";");
        w.write(HPD_ID + ".accountDiffPref=");
        json(((IdentifiedUser) user).getAccountDiffPreference(), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
        final byte[] userData = w.toString().getBytes("UTF-8");
        raw = concat(page.part1, userData, page.part2);
    } else {
        raw = page.full;
    }
    final byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = raw == page.full ? page.full_gz : HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC);
    rsp.setContentLength(tosend.length);
    final OutputStream out = rsp.getOutputStream();
    try {
        out.write(tosend);
    } finally {
        out.close();
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final Page.Content page = get().get(select(req));
    final StringWriter w = new StringWriter();
    final CurrentUser user = currentUser.get();
    if (user instanceof IdentifiedUser) {
        w.write(HPD_ID + ".account=");
        json(((IdentifiedUser) user).getAccount(), w);
        w.write(";");
        w.write(HPD_ID + ".xsrfToken=");
        json(session.get().getToken(), w);
        w.write(";");
        w.write(HPD_ID + ".accountDiffPref=");
        json(((IdentifiedUser) user).getAccountDiffPreference(), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
    } else {
        w.write(HPD_ID + ".theme=");
        json(signedOutTheme, w);
        w.write(";");
    }
    plugins(w);
    final byte[] hpd = w.toString().getBytes("UTF-8");
    final byte[] raw = Bytes.concat(page.part1, hpd, page.part2);
    final byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC);
    rsp.setContentLength(tosend.length);
    final OutputStream out = rsp.getOutputStream();
    try {
        out.write(tosend);
    } finally {
        out.close();
    }
}
#end_block

#method_before
private void asScript(final Element scriptNode) {
    scriptNode.removeAttribute("id");
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#method_after
private void asScript(final Element scriptNode) {
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#end_block

#method_before
@Override
public String getUrl() {
    // not used
    return null;
}
#method_after
@Override
public String getUrl() {
    // not used
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public String getUrl() {
    String database = optional(cfg, "database");
    if (database == null || database.isEmpty()) {
        database = "db/ReviewDB";
    }
    File db = site.resolve(database);
    try {
        db = db.getCanonicalFile();
    } catch (IOException e) {
        db = db.getAbsoluteFile();
    }
    return "jdbc:h2:" + db.toURI().toString();
}
#method_after
@Override
public String getUrl() {
    String database = cfg.getString("database", null, "database");
    if (database == null || database.isEmpty()) {
        database = "db/ReviewDB";
    }
    File db = site.resolve(database);
    try {
        db = db.getCanonicalFile();
    } catch (IOException e) {
        db = db.getAbsoluteFile();
    }
    return "jdbc:h2:" + db.toURI().toString();
}
#end_block

#method_before
@Override
public String getUrl() {
    return required(cfg, "url");
}
#method_after
@Override
public String getUrl() {
    return ConfigUtil.getRequired(cfg, "database", "url");
}
#end_block

#method_before
private DataSource open(final SitePaths site, final Config cfg, final Context context, final DataSourceType dst) {
    String driver = optional(cfg, "driver");
    if (Strings.isNullOrEmpty(driver)) {
        driver = dst.getDriver();
    }
    String url = optional(cfg, "url");
    if (Strings.isNullOrEmpty(url)) {
        url = dst.getUrl();
    }
    String username = optional(cfg, "username");
    String password = optional(cfg, "password");
    boolean usePool;
    if (context == Context.SINGLE_USER) {
        usePool = false;
    } else {
        usePool = cfg.getBoolean("database", "connectionpool", dst.usePool());
    }
    if (usePool) {
        final BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        if (username != null && !username.isEmpty()) {
            ds.setUsername(username);
        }
        if (password != null && !password.isEmpty()) {
            ds.setPassword(password);
        }
        ds.setMaxActive(cfg.getInt("database", "poollimit", 8));
        ds.setMinIdle(cfg.getInt("database", "poolminidle", 4));
        ds.setMaxIdle(cfg.getInt("database", "poolmaxidle", 4));
        ds.setMaxWait(ConfigUtil.getTimeUnit(cfg, "database", null, "poolmaxwait", MILLISECONDS.convert(30, SECONDS), MILLISECONDS));
        ds.setInitialSize(ds.getMinIdle());
        return ds;
    } else {
        // 
        try {
            final Properties p = new Properties();
            p.setProperty("driver", driver);
            p.setProperty("url", url);
            if (username != null) {
                p.setProperty("user", username);
            }
            if (password != null) {
                p.setProperty("password", password);
            }
            return new SimpleDataSource(p);
        } catch (SQLException se) {
            throw new ProvisionException("Database unavailable", se);
        }
    }
}
#method_after
private DataSource open(final SitePaths site, final Config cfg, final Context context, final DataSourceType dst) {
    ConfigSection dbs = new ConfigSection(cfg, "database");
    String driver = dbs.optional("driver");
    if (Strings.isNullOrEmpty(driver)) {
        driver = dst.getDriver();
    }
    String url = dbs.optional("url");
    if (Strings.isNullOrEmpty(url)) {
        url = dst.getUrl();
    }
    String username = dbs.optional("username");
    String password = dbs.optional("password");
    boolean usePool;
    if (context == Context.SINGLE_USER) {
        usePool = false;
    } else {
        usePool = cfg.getBoolean("database", "connectionpool", dst.usePool());
    }
    if (usePool) {
        final BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        if (username != null && !username.isEmpty()) {
            ds.setUsername(username);
        }
        if (password != null && !password.isEmpty()) {
            ds.setPassword(password);
        }
        ds.setMaxActive(cfg.getInt("database", "poollimit", 8));
        ds.setMinIdle(cfg.getInt("database", "poolminidle", 4));
        ds.setMaxIdle(cfg.getInt("database", "poolmaxidle", 4));
        ds.setMaxWait(ConfigUtil.getTimeUnit(cfg, "database", null, "poolmaxwait", MILLISECONDS.convert(30, SECONDS), MILLISECONDS));
        ds.setInitialSize(ds.getMinIdle());
        return ds;
    } else {
        // 
        try {
            final Properties p = new Properties();
            p.setProperty("driver", driver);
            p.setProperty("url", url);
            if (username != null) {
                p.setProperty("user", username);
            }
            if (password != null) {
                p.setProperty("password", password);
            }
            return new SimpleDataSource(p);
        } catch (SQLException se) {
            throw new ProvisionException("Database unavailable", se);
        }
    }
}
#end_block

#method_before
@Override
public final NamedInputStream getIndexScript() {
    return getScriptAsStream(indexScript);
}
#method_after
@Override
public ScriptRunner getIndexScript() throws IOException {
    return getScriptRunner("index_generic.sql");
}
#end_block

#method_before
@Override
public final NamedInputStream getNextValScript() {
    return getScriptAsStream(nextValScript);
}
#method_after
@Override
public ScriptRunner getNextValScript() throws IOException {
    return ScriptRunner.NOOP;
}
#end_block

#method_before
public void create(final ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    final JdbcExecutor e = new JdbcExecutor(jdbc);
    try {
        jdbc.updateSchema(e);
    } finally {
        e.close();
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = versionNbr;
    db.schemaVersion().insert(Collections.singleton(sVer));
    final SystemConfig sConfig = initSystemConfig(db);
    initVerifiedCategory(db);
    initCodeReviewCategory(db, sConfig);
    if (mgr != null) {
        // TODO This should never be null when initializing a site.
        initWildCardProject();
    }
    runScript(dataSourceType.getIndexScript(), db);
    runScript(dataSourceType.getNextValScript(), db);
}
#method_after
public void create(final ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    final JdbcExecutor e = new JdbcExecutor(jdbc);
    try {
        jdbc.updateSchema(e);
    } finally {
        e.close();
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = versionNbr;
    db.schemaVersion().insert(Collections.singleton(sVer));
    final SystemConfig sConfig = initSystemConfig(db);
    initVerifiedCategory(db);
    initCodeReviewCategory(db, sConfig);
    if (mgr != null) {
        // TODO This should never be null when initializing a site.
        initWildCardProject();
    }
    dataSourceType.getIndexScript().run(db);
    dataSourceType.getNextValScript().run(db);
}
#end_block

#method_before
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    b.append("jdbc:postgresql://");
    b.append(hostname(optional(cfg, "hostname")));
    b.append(port(optional(cfg, "port")));
    b.append("/");
    b.append(required(cfg, "database"));
    return b.toString();
}
#method_after
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    final ConfigSection dbc = new ConfigSection(cfg, "database");
    b.append("jdbc:postgresql://");
    b.append(hostname(dbc.optional("hostname")));
    b.append(port(dbc.optional("port")));
    b.append("/");
    b.append(dbc.required("database"));
    return b.toString();
}
#end_block

#method_before
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    b.append("jdbc:mysql://");
    b.append(hostname(optional(cfg, "hostname")));
    b.append(port(optional(cfg, "port")));
    b.append("/");
    b.append(required(cfg, "database"));
    return b.toString();
}
#method_after
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    final ConfigSection dbs = new ConfigSection(cfg, "database");
    b.append("jdbc:mysql://");
    b.append(hostname(dbs.optional("hostname")));
    b.append(port(dbs.optional("port")));
    b.append("/");
    b.append(dbs.required("database"));
    return b.toString();
}
#end_block

#method_before
@Override
public int hashCode() {
    int h = 0;
    h = h * 31 + aId.hashCode();
    h = h * 31 + bId.hashCode();
    h = h * 31 + ignoreWhitespace.hashCode();
    return h;
}
#method_after
@Override
public int hashCode() {
    int h = 0;
    h = h * 31 + aId.hashCode();
    h = h * 31 + bId.hashCode();
    h = h * 31 + (ignoreWhitespace ? 1 : 0);
    return h;
}
#end_block

#method_before
@Override
public boolean equals(final Object o) {
    if (o instanceof IntraLineDiffKey) {
        final IntraLineDiffKey k = (IntraLineDiffKey) o;
        return // 
        aId.equals(k.aId) && // 
        bId.equals(k.bId) && ignoreWhitespace.equals(k.ignoreWhitespace);
    }
    return false;
}
#method_after
@Override
public boolean equals(final Object o) {
    if (o instanceof IntraLineDiffKey) {
        final IntraLineDiffKey k = (IntraLineDiffKey) o;
        return // 
        aId.equals(k.aId) && // 
        bId.equals(k.bId) && ignoreWhitespace == k.ignoreWhitespace;
    }
    return false;
}
#end_block

#method_before
public boolean canAbandon() {
    return // owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getCurrentUser().getCapabilities().canAdministrateServer();
}
#method_after
public boolean canAbandon() {
    return // owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getCurrentUser().getCapabilities().canAdministrateServer() || // user can abandon a specific ref
    getRefControl().canAbandon();
}
#end_block

#method_before
public boolean canRestore() {
    // Anyone who can abandon the change can restore it back
    return canAbandon();
}
#method_after
public boolean canRestore() {
    return // Anyone who can abandon the change can restore it back
    canAbandon() && // as long as you can upload too
    getRefControl().canUpload();
}
#end_block

#method_before
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // 
        if (// branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed) {
    if (!allowClosed && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (patchSet.isDraft()) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    return evaluatePrologRules(db, patchSet, cd, fastEvalLabels, "submit_rule", "locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results");
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed) {
    if (!allowClosed && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (patchSet.isDraft()) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(db, patchSet, getProjectControl(), this, change, cd, fastEvalLabels, "locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results");
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        return logRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    return resultsToSubmitRecord(evaluator.getSubmitRule(), results);
}
#end_block

#method_before
private void appliedBy(SubmitRecord.Label label, Term status) throws UserTermExpected {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        } else {
            throw new UserTermExpected(label);
        }
    }
}
#method_after
private void appliedBy(SubmitRecord.Label label, Term status) {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        }
    }
}
#end_block

#method_before
private static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#method_after
public static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#end_block

#method_before
public void close() {
// FIXME: TBC
}
#method_after
public void close() {
// Do not really know at the moment if there should be something to release
// on the Jira side. Cannot find at the moment a "logout" XML-RPC API for this.
}
#end_block

#method_before
public void start() {
    try {
        JiraClientSession session = newSession();
        session.close();
    } catch (Exception e) {
        log.error("Cannot connect to Jira:", e);
    }
}
#method_after
public void start() {
    try {
        JiraClientSession session = newSession();
        session.close();
    } catch (XmlRpcException e) {
        log.error("Cannot validate Jira configuration and connectivity", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public void onGitReferenceUpdated(Event event) {
    try {
        final Repository repo = new RepositoryBuilder().setGitDir(new File(gitDir, event.getProjectName() + ".git")).setBare().build();
        RevWalk revWalk = new RevWalk(repo);
        JiraClientSession jira = jiraRpc.newSession();
        for (Update u : event.getUpdates()) {
            String newObjId = u.getNewObjectId();
            if (newObjId == null)
                continue;
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(newObjId));
            process(jira, u.getRefName(), commit);
        }
    } catch (Exception e) {
        log.error("Error processing event " + event, e);
    }
}
#method_after
public void onGitReferenceUpdated(Event event) {
    Repository repo;
    try {
        repo = repositoryManager.openRepository(new NameKey(event.getProjectName()));
    } catch (IOException e) {
        log.error("Cannot open Gerrit Project " + event.getProjectName(), e);
        return;
    }
    try {
        RevWalk revWalk = new RevWalk(repo);
        JiraClientSession jira;
        try {
            jira = jiraRpc.newSession();
        } catch (XmlRpcException e) {
            log.error("Cannot open a new session to Jira", e);
            return;
        }
        try {
            for (Update u : event.getUpdates()) {
                String newObjId = u.getNewObjectId();
                if (newObjId == null) {
                    continue;
                }
                RevCommit commit;
                try {
                    commit = revWalk.parseCommit(ObjectId.fromString(newObjId));
                } catch (Exception e) {
                    log.error("Unable to parse commit object " + newObjId + ": skipping to next update event", e);
                    continue;
                }
                process(jira, event.getProjectName(), u.getRefName(), commit);
            }
        } finally {
            jira.close();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private void process(JiraClientSession jira, String refName, RevCommit commit) throws XmlRpcException {
    String commitMsg = commit.getFullMessage();
    Matcher matcher = commentPattern.matcher(commitMsg);
    while (matcher.find()) {
        String matched = matcher.group();
        try {
            addComment(jira, matched, refName, commit);
        } catch (XmlRpcException e) {
            log.warn("Jira issue " + matched + " was not found: comment not added");
        }
    }
}
#method_after
private void process(JiraClientSession jira, String projectName, String refName, RevCommit commit) {
    String commitMsg = commit.getFullMessage();
    Matcher matcher = commentPattern.matcher(commitMsg);
    while (matcher.find()) {
        String matched = matcher.group();
        try {
            addComment(jira, matched, projectName, refName, commit);
        } catch (XmlRpcException e) {
            log.error("Unable to add new comment to Jira issue " + matched, e);
        }
    }
}
#end_block

#method_before
private void addComment(JiraClientSession jira, String commentMatch, String refName, RevCommit commit) throws XmlRpcException {
    Matcher matcher = issuePattern.matcher(commentMatch);
    if (!matcher.find())
        return;
    jira.addComment(matcher.group(), getComment(refName, commit));
}
#method_after
private void addComment(JiraClientSession jira, String commentMatch, String projectName, String refName, RevCommit commit) throws XmlRpcException {
    Matcher matcher = issuePattern.matcher(commentMatch);
    if (!matcher.find()) {
        return;
    }
    jira.addComment(matcher.group(), getComment(projectName, refName, commit));
}
#end_block

#method_before
private String getComment(String refName, RevCommit commit) {
    String commitId = commit.getName();
    String comment = String.format("Git commit: %s\n" + "Branch: %s\n" + "Author: %s\n" + "Committer: %s\n" + "%s", commitId, refName, getIdentity(commit.getAuthorIdent()), getIdentity(commit.getCommitterIdent()), commit.getFullMessage());
    if (gitwebUrl != null) {
        comment = comment + "\n" + gitwebUrl + "?p=dev-test.git;a=commit;h=" + commitId;
    }
    return comment;
}
#method_after
private String getComment(String projectName, String refName, RevCommit commit) {
    String commitId = commit.getName();
    String comment = String.format("Git commit: %s\n" + "Branch: %s\n" + "Author: %s\n" + "Committer: %s\n" + "%s", commitId, refName, getIdentity(commit.getAuthorIdent()), getIdentity(commit.getCommitterIdent()), commit.getFullMessage());
    if (gitwebUrl != null) {
        comment = String.format("%s\n%s?p=%s.git;a=commit;h=%s", comment, gitwebUrl, projectName, commitId);
    }
    return comment;
}
#end_block

#method_before
private void reduceToMinimalMerge() throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = new MergeSorter(rw, alreadyAccepted, CAN_MERGE).sort(toMerge);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toMerge.clear();
    toMerge.addAll(heads);
    Collections.sort(toMerge, new Comparator<CodeReviewCommit>() {

        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#method_after
private void reduceToMinimalMerge() throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = new MergeSorter(rw, alreadyAccepted, CAN_MERGE).sort(toMerge);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toMerge.clear();
    toMerge.addAll(heads);
    Collections.sort(toMerge, new Comparator<CodeReviewCommit>() {

        @Override
        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    final Change oldChange = n.change;
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    db.patchSets().insert(Collections.singleton(ps));
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    this.submitted.remove(oldChange);
    this.submitted.add(n.change);
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            @Override
            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    final Change oldChange = n.change;
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    db.patchSets().insert(Collections.singleton(ps));
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    this.submitted.remove(oldChange);
    this.submitted.add(n.change);
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    switch(destProject.getSubmitType()) {
                        case FAST_FORWARD_ONLY:
                            break;
                        case CHERRY_PICK:
                        case MERGE_ALWAYS:
                        case MERGE_IF_NECESSARY:
                        default:
                            mergeQueue.recheckAfter(destBranch, random.nextInt(1000), MILLISECONDS);
                            break;
                    }
                    break;
            }
            throw new IOException(branchUpdate.getResult().name());
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    switch(destProject.getSubmitType()) {
                        case CHERRY_PICK:
                        case MERGE_ALWAYS:
                        case MERGE_IF_NECESSARY:
                            mergeQueue.recheckAfter(destBranch, random.nextInt(1000), MILLISECONDS);
                            break;
                        case FAST_FORWARD_ONLY:
                            // Not mergeable, no need to recheck.
                            break;
                        default:
                            log.warn("Lock failure in project with unknown merge type " + destProject.getSubmitType());
                            break;
                    }
                    break;
            }
            throw new IOException(branchUpdate.getResult().name());
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void displayRow(final int row, final ApprovalDetail ad, final Change change, List<String> columns) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : columns) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            final Image readOnlyIcon = new Image(Gerrit.RESOURCES.readonly());
            readOnlyIcon.setTitle(Gerrit.C.userCannotVoteToolTip());
            table.setWidget(row, col, readOnlyIcon);
        } else if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            ApprovalType legacyType = types.byLabel(labelName);
            if (legacyType == null) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            PatchSetApproval ca = ad.getPatchSetApproval(legacyType.getCategory().getId());
            if (ca == null || ca.getValue() == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#method_after
private void displayRow(final int row, final ApprovalDetail ad, final Change change, List<String> columns) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : columns) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().notVotable());
            fmt.getElement(row, col).setTitle(Gerrit.C.userCannotVoteToolTip());
        } else if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            ApprovalType legacyType = types.byLabel(labelName);
            if (legacyType == null) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            PatchSetApproval ca = ad.getPatchSetApproval(legacyType.getCategory().getId());
            if (ca == null || ca.getValue() == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            d.votable(pr.getLabel());
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            if (pr.getMin() != 0 || pr.getMax() != 0) {
                d.votable(pr.getLabel());
            }
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
private void loadApprovals(final PatchSetPublishDetail detail, final ChangeControl control) throws OrmException, NoSuchChangeException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final Change.Id changeId = patchSetId.getParentKey();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            d.votable(pr.getLabel());
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void loadApprovals(final PatchSetPublishDetail detail, final ChangeControl control) throws OrmException, NoSuchChangeException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final Change.Id changeId = patchSetId.getParentKey();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            if (pr.getMin() != 0 || pr.getMax() != 0) {
                d.votable(pr.getLabel());
            }
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    String token = "token=" + verifier.encode(currentUser.get().getUserName(), getReqUrl(req));
    sendText(req, res, token);
}
#method_after
@Override
protected final void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    CurrentUser user = userProvider.get();
    if (!(user instanceof IdentifiedUser)) {
        sendError(res, SC_UNAUTHORIZED, "API requires authentication");
        return;
    }
    TokenInfo info = new TokenInfo();
    info._authkey = verifier.sign(((IdentifiedUser) user).getAccountId(), computeUrl(req));
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    String type;
    buf.write(JSON_MAGIC);
    if (acceptsJson(req)) {
        type = JSON_TYPE;
        buf.write(gson.toJson(info).getBytes(UTF_8));
    } else {
        type = FORM_ENCODED;
        buf.write(String.format("%s=%s", AUTHKEY_NAME, URLEncoder.encode(info._authkey, UTF_8)).getBytes(UTF_8));
    }
    res.setContentType(type);
    res.setCharacterEncoding(UTF_8);
    res.setHeader("Content-Disposition", "attachment");
    send(req, res, buf.toByteArray());
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    noCache(res);
    try {
        checkRequiresCapability();
        super.service(req, res);
    } catch (RequireCapabilityException err) {
        res.setStatus(HttpServletResponse.SC_FORBIDDEN);
        noCache(res);
        sendText(req, res, err.getMessage());
    } catch (Error err) {
        handleError(err, req, res);
    } catch (RuntimeException err) {
        handleError(err, req, res);
    }
}
#method_after
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    res.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    res.setHeader("Pragma", "no-cache");
    res.setHeader("Cache-Control", "no-cache, must-revalidate");
    res.setHeader("Content-Disposition", "attachment");
    try {
        checkRequiresCapability();
        super.service(req, res);
    } catch (RequireCapabilityException err) {
        sendError(res, SC_FORBIDDEN, err.getMessage());
    } catch (Error err) {
        handleException(err, req, res);
    } catch (RuntimeException err) {
        handleException(err, req, res);
    }
}
#end_block

#method_before
private void checkRequiresCapability() throws RequireCapabilityException {
    RequiresCapability rc = getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", Objects.firstNonNull(user.getUserName(), ((IdentifiedUser) user).getNameEmail()), rc.value());
            throw new RequireCapabilityException(msg);
        }
    }
}
#method_after
private void checkRequiresCapability() throws RequireCapabilityException {
    RequiresCapability rc = getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", Objects.firstNonNull(user.getUserName(), user instanceof IdentifiedUser ? ((IdentifiedUser) user).getNameEmail() : user.toString()), rc.value());
            throw new RequireCapabilityException(msg);
        }
    }
}
#end_block

#method_before
protected static void sendText(HttpServletRequest req, HttpServletResponse res, String data) throws IOException {
    res.setContentType("text/plain");
    res.setCharacterEncoding("UTF-8");
    send(req, res, data.getBytes("UTF-8"));
}
#method_after
protected static void sendText(@Nullable HttpServletRequest req, HttpServletResponse res, String data) throws IOException {
    res.setContentType("text/plain");
    res.setCharacterEncoding("UTF-8");
    send(req, res, data.getBytes("UTF-8"));
}
#end_block

#method_before
protected static void send(HttpServletRequest req, HttpServletResponse res, byte[] data) throws IOException {
    if (data.length > 256 && RPCServletUtils.acceptsGzipEncoding(req)) {
        res.setHeader("Content-Encoding", "gzip");
        data = HtmlDomUtil.compress(data);
    }
    res.setContentLength(data.length);
    OutputStream out = res.getOutputStream();
    try {
        out.write(data);
    } finally {
        out.close();
    }
}
#method_after
protected static void send(@Nullable HttpServletRequest req, HttpServletResponse res, byte[] data) throws IOException {
    if (data.length > 256 && req != null && RPCServletUtils.acceptsGzipEncoding(req)) {
        res.setHeader("Content-Encoding", "gzip");
        data = HtmlDomUtil.compress(data);
    }
    res.setContentLength(data.length);
    OutputStream out = res.getOutputStream();
    try {
        out.write(data);
    } finally {
        out.close();
    }
}
#end_block

#method_before
@Override
public void onResponseReceived(Request req, Response res) {
    String text = res.getText();
    if (text.startsWith("token=")) {
        RestApi.this.sendPost(cb, text);
        return;
    }
    RpcStatus.INSTANCE.onRpcComplete();
    int status = res.getStatusCode();
    if (status != 200) {
        if ((400 <= status && status < 500) && isTextBody(res)) {
            cb.onFailure(new RemoteJsonException(res.getText(), status, null));
        } else {
            cb.onFailure(new StatusCodeException(status, res.getStatusText()));
        }
        return;
    }
    if (!isJsonBody(res)) {
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    String json = res.getText();
    if (!json.startsWith(JSON_MAGIC)) {
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    T data;
    try {
        // javac generics bug
        data = Natives.<T>parseJSON(json.substring(JSON_MAGIC.length()));
    } catch (RuntimeException e) {
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    cb.onSuccess(data);
}
#method_after
@Override
public void onResponseReceived(Request req, Response res) {
    int status = res.getStatusCode();
    if (status != 200) {
        RpcStatus.INSTANCE.onRpcComplete();
        if ((400 <= status && status < 600) && isTextBody(res)) {
            cb.onFailure(new RemoteJsonException(res.getText(), status, null));
        } else {
            cb.onFailure(new StatusCodeException(status, res.getStatusText()));
        }
        return;
    }
    if (!isJsonBody(res)) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    String json = res.getText();
    if (!json.startsWith(JSON_MAGIC)) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    json = json.substring(JSON_MAGIC.length());
    if (wasGet && json.startsWith("{\"_authkey\":")) {
        RestApi.this.resendPost(cb, json);
        return;
    }
    T data;
    try {
        // javac generics bug
        data = Natives.<T>parseJSON(json);
    } catch (RuntimeException e) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    cb.onSuccess(data);
    RpcStatus.INSTANCE.onRpcComplete();
}
#end_block

#method_before
public RestApi addParameter(String name, int value) {
    return addParameterRaw(name, String.valueOf(value));
}
#method_after
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#end_block

#method_before
public <T extends JavaScriptObject> void send(final AsyncCallback<T> cb) {
    RequestBuilder req = new RequestBuilder(RequestBuilder.GET, url.toString());
    req.setHeader("Accept", JsonConstants.JSON_TYPE);
    req.setCallback(new MyRequestCallback<T>(cb));
    try {
        RpcStatus.INSTANCE.onRpcStart();
        req.send();
    } catch (RequestException e) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(e);
    }
}
#method_after
public <T extends JavaScriptObject> void send(final AsyncCallback<T> cb) {
    RequestBuilder req = new RequestBuilder(RequestBuilder.GET, url.toString());
    req.setHeader("Accept", JsonConstants.JSON_TYPE);
    req.setCallback(new MyRequestCallback<T>(true, cb));
    try {
        RpcStatus.INSTANCE.onRpcStart();
        req.send();
    } catch (RequestException e) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(e);
    }
}
#end_block

#method_before
@Deprecated
public Change.Id getId() {
    return changeId;
}
#method_after
public Change.Id getId() {
    return changeId;
}
#end_block

#method_before
@Deprecated
public int getChangeId() {
    return changeId.get();
}
#method_after
public int getChangeId() {
    return changeId.get();
}
#end_block

#method_before
public void merge() throws MergeException {
    final ProjectState pe = projectCache.get(destBranch.getParentKey());
    if (pe == null) {
        throw new MergeException("No such project: " + destBranch.getParentKey());
    }
    destProject = pe.getProject();
    try {
        schema = schemaFactory.open();
    } catch (OrmException e) {
        throw new MergeException("Cannot open database", e);
    }
    try {
        mergeImpl();
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        submitted = schema.changes().submitted(destBranch).toList();
        preMerge();
        updateBranch();
        updateChangeStatus();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#end_block

#method_before
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : merged) {
        PatchSetApproval s = getSubmitter(c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : merged) {
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(merged.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    mergeTip = (CodeReviewCommit) rw.parseCommit(commit(m, mergeCommit));
}
#method_after
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeAuthor(merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    mergeTip = (CodeReviewCommit) rw.parseCommit(commit(m, mergeCommit));
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.getApprovalType(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(db, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateChangeStatus() {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    this.testMergeabilityOfChangesbyBranch();
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    this.testMergeabilityOfChangesbyBranch();
                    break;
                }
            case ALREADY_MERGED:
                {
                    setMerged(c, null);
                    break;
                }
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    String str = dependencyError(commit);
                    if (submitStillPossible) {
                        if (str != null) {
                            sendMergeFail(c, message(c, str), false, false);
                        }
                    } else {
                        setNew(c, message(c, str));
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(c, merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unused")
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#method_after
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#end_block

#method_before
public static void testMerge(MergeOp.Factory opFactory, Change change) {
    opFactory.create(change.getDest()).runTestMerge(change);
}
#method_after
public static void testMerge(MergeOp.Factory opFactory, Change change) {
    opFactory.create(change.getDest()).verifyMergeability(change);
}
#end_block

#method_before
public static void submit(MergeOp.Factory opFactory, PatchSet.Id patchSetId, IdentifiedUser user, ReviewDb db, MergeQueue merger) throws OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSetApproval approval = createSubmitApproval(patchSetId, user, db);
    db.patchSetApprovals().upsert(Collections.singleton(approval));
    final Change change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.NEW) {
                change.setStatus(Change.Status.SUBMITTED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
    if (change.getStatus() == Change.Status.SUBMITTED) {
        merger.merge(opFactory, change.getDest());
    }
}
#method_after
public static void submit(final PatchSet.Id patchSetId, final IdentifiedUser user, final ReviewDb db, final MergeOp.Factory opFactory, final MergeQueue merger) throws OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSetApproval approval = createSubmitApproval(patchSetId, user, db);
    db.patchSetApprovals().upsert(Collections.singleton(approval));
    final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.NEW) {
                change.setStatus(Change.Status.SUBMITTED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
    if (updatedChange.getStatus() == Change.Status.SUBMITTED) {
        merger.merge(opFactory, updatedChange.getDest());
    }
}
#end_block

#method_before
public static PatchSetApproval createSubmitApproval(PatchSet.Id patchSetId, IdentifiedUser user, ReviewDb db) throws OrmException {
    final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
    final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, user.getAccountId(), SUBMIT);
    for (final PatchSetApproval approval : allApprovals) {
        if (akey.equals(approval.getKey())) {
            approval.setValue((short) 1);
            approval.setGranted();
            return approval;
        }
    }
    return new PatchSetApproval(akey, (short) 1);
}
#method_after
public static PatchSetApproval createSubmitApproval(final PatchSet.Id patchSetId, final IdentifiedUser user, final ReviewDb db) throws OrmException {
    final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
    final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, user.getAccountId(), SUBMIT);
    for (final PatchSetApproval approval : allApprovals) {
        if (akey.equals(approval.getKey())) {
            approval.setValue((short) 1);
            approval.setGranted();
            return approval;
        }
    }
    return new PatchSetApproval(akey, (short) 1);
}
#end_block

#method_before
public Capable canUpload() {
    if (!projectControl.canPushToAtLeastOneRef()) {
        String reqName = project.getName();
        return new Capable("Upload denied for project '" + reqName + "'");
    }
    // Don't permit receive-pack to be executed if a refs/for/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    Map<String, Ref> blockingFors;
    try {
        blockingFors = repo.getRefDatabase().getRefs("refs/for/");
    } catch (IOException err) {
        String projName = project.getName();
        log.warn("Cannot scan refs in '" + projName + "'", err);
        return new Capable("Server process cannot read '" + projName + "'");
    }
    if (!blockingFors.isEmpty()) {
        String projName = project.getName();
        log.error("Repository '" + projName + "' needs the following refs removed to receive changes: " + blockingFors.keySet());
        return new Capable("One or more refs/for/ names blocks change upload");
    }
    if (project.isUseContributorAgreements()) {
        try {
            return verifyActiveContributorAgreement();
        } catch (OrmException e) {
            log.error("Cannot query database for agreements", e);
            return new Capable("Cannot verify contribution agreement");
        }
    } else {
        return Capable.OK;
    }
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    // Don't permit receive-pack to be executed if a refs/for/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    Map<String, Ref> blockingFors;
    try {
        blockingFors = repo.getRefDatabase().getRefs("refs/for/");
    } catch (IOException err) {
        String projName = project.getName();
        log.warn("Cannot scan refs in '" + projName + "'", err);
        return new Capable("Server process cannot read '" + projName + "'");
    }
    if (!blockingFors.isEmpty()) {
        String projName = project.getName();
        log.error("Repository '" + projName + "' needs the following refs removed to receive changes: " + blockingFors.keySet());
        return new Capable("One or more refs/for/ names blocks change upload");
    }
    return Capable.OK;
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        boolean haveHeads = false;
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            if (isHead(r) || isTag(r)) {
                try {
                    final RevCommit h = walk.parseCommit(r.getObjectId());
                    h.add(SIDE_HAVE);
                    walk.markStart(h);
                    haveHeads = true;
                } catch (IOException e) {
                    continue;
                }
            }
        }
        if (haveHeads) {
            boolean isConnected = false;
            RevCommit c;
            while ((c = walk.next()) != null) {
                if (c.hasAll(COMMON)) {
                    isConnected = true;
                    break;
                }
            }
            if (!isConnected) {
                reject(newChange, "no common ancestry");
                return;
            }
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                final Change.Key key = new Change.Key(idStr);
                final List<Change> changes = db.changes().byProjectKey(project.getNameKey(), key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
    ChangeUtil.testMerge(opFactory, change);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    ChangeUtil.testMerge(opFactory, change);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                change.setLastSha1MergeTested(null);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID()) {
            reject(cmd, "missing Change-Id in commit message");
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey();
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        ChangeUtil.mergeTestChangesByBranch(opFactory, destBranch);
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey() throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byProjectOpenAll(project.getNameKey())) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    patchTable = new PatchTable();
    patchTable.setSavePointerId("PatchTable " + patchSet.getId());
    patchTable.display(detail);
    body.add(infoTable);
    actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(actionsPanel);
    if (Gerrit.isSignedIn()) {
        populateReviewAction();
        if (changeDetail.isCurrentPatchSet(detail)) {
            populateActions(detail);
        }
    }
    populateDiffAllActions(detail);
    body.add(patchTable);
    if (!isMergeable) {
        final Label lbl = new Label();
        lbl.setText(Util.C.messageMergeFail());
        actionsPanel.add(lbl);
    }
    for (ClickHandler clickHandler : registeredClickHandler) {
        patchTable.addClickHandler(clickHandler);
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            populateReviewAction();
            if (changeDetail.isCurrentPatchSet(detail)) {
                populateActions(detail);
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && allowedSchemes.contains(DownloadScheme.ANON_GIT)) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    Set<ApprovalCategory.Id> allowed = changeDetail.getCurrentActions();
    if (allowed == null) {
        allowed = Collections.emptySet();
    }
    if (isOpen && allowed.contains(ApprovalCategory.SUBMIT)) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.setEnabled(isMergeable);
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new RestoreChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void populateReviewAction() {
    final Button b = new Button(Util.C.buttonReview());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            Gerrit.display("change,publish," + patchSet.getId().toString(), new PublishCommentScreen(patchSet.getId()));
        }
    });
    actionsPanel.add(b);
}
#method_after
private void populateReviewAction() {
    final Button b = new Button(Util.C.buttonReview());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            Gerrit.display(Dispatcher.toPublish(patchSet.getId()));
        }
    });
    actionsPanel.add(b);
}
#end_block

#method_before
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#method_after
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().publishCommentsScreen());
    approvalButtons = new ArrayList<ValueRadioButton>();
    descBlock = new ChangeDescriptionBlock();
    add(descBlock);
    final FormPanel form = new FormPanel();
    final FlowPanel body = new FlowPanel();
    form.setWidget(body);
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
        }
    });
    add(form);
    approvalPanel = new FlowPanel();
    body.add(approvalPanel);
    initMessage(body);
    draftsPanel = new FlowPanel();
    body.add(draftsPanel);
    final FlowPanel buttonRow = new FlowPanel();
    buttonRow.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(buttonRow);
    send = new Button(Util.C.buttonPublishCommentsSend());
    send.addClickHandler(this);
    buttonRow.add(send);
    submit = new Button(Util.C.buttonPublishSubmitSend());
    submit.addClickHandler(this);
    buttonRow.add(submit);
    cancel = new Button(Util.C.buttonPublishCommentsCancel());
    cancel.addClickHandler(this);
    buttonRow.add(cancel);
    errorlabel.setText(Util.C.messageMergeFail());
    body.add(errorlabel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().publishCommentsScreen());
    approvalButtons = new ArrayList<ValueRadioButton>();
    descBlock = new ChangeDescriptionBlock();
    add(descBlock);
    final FormPanel form = new FormPanel();
    final FlowPanel body = new FlowPanel();
    form.setWidget(body);
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
        }
    });
    add(form);
    approvalPanel = new FlowPanel();
    body.add(approvalPanel);
    initMessage(body);
    draftsPanel = new FlowPanel();
    body.add(draftsPanel);
    final FlowPanel buttonRow = new FlowPanel();
    buttonRow.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(buttonRow);
    send = new Button(Util.C.buttonPublishCommentsSend());
    send.addClickHandler(this);
    buttonRow.add(send);
    submit = new Button(Util.C.buttonPublishSubmitSend());
    submit.addClickHandler(this);
    buttonRow.add(submit);
    cancel = new Button(Util.C.buttonPublishCommentsCancel());
    cancel.addClickHandler(this);
    buttonRow.add(cancel);
}
#end_block

#method_before
private void initApprovals(final PatchSetPublishDetail r, final Panel body) {
    for (final ApprovalType ct : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        if (r.isAllowed(ct.getCategory().getId())) {
            initApprovalType(r, body, ct);
        }
    }
}
#method_after
private void initApprovals(final PatchSetPublishDetail r, final Panel body) {
    ApprovalTypes types = Gerrit.getConfig().getApprovalTypes();
    for (PermissionRange range : r.getLabels()) {
        ApprovalType type = types.byLabel(range.getLabel());
        if (type != null) {
            // Legacy type, use radio buttons.
            initApprovalType(r, body, type, range);
        } else {
        // TODO Newer style label.
        }
    }
}
#end_block

#method_before
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final Set<ApprovalCategoryValue.Id> allowed = r.getAllowed(catId);
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!allowed.contains(buttonValue.getId())) {
            continue;
        }
        final ValueRadioButton b = new ValueRadioButton(buttonValue, ct.getCategory().getName());
        b.setText(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#method_after
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct, final PermissionRange range) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!range.contains(buttonValue.getValue())) {
            continue;
        }
        final ValueRadioButton b = new ValueRadioButton(buttonValue, ct.getCategory().getName());
        b.setText(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.isSubmitAllowed());
    submit.setEnabled(r.getChange().isMergeable());
    errorlabel.setVisible(!r.getChange().isMergeable());
}
#method_after
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#end_block

#method_before
private void onSend2(final boolean submit) {
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> values = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            values.put(b.value.getCategoryId(), b.value.getId());
        }
    }
    PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new HashSet<ApprovalCategoryValue.Id>(values.values()), new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }
    });
}
#method_after
private void onSend2(final boolean submit) {
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> values = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            values.put(b.value.getCategoryId(), b.value.getId());
        }
    }
    enableForm(false);
    PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new HashSet<ApprovalCategoryValue.Id>(values.values()), new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#end_block

#method_before
private void submit() {
    Util.MANAGE_SVC.submit(patchSetId, new GerritCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            saveStateOnUnload = false;
            goChange();
        }
    });
}
#method_after
private void submit() {
    Util.MANAGE_SVC.submit(patchSetId, new GerritCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            saveStateOnUnload = false;
            goChange();
        }

        @Override
        public void onFailure(Throwable caught) {
            goChange();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
protected void onRequestSuggestions(Request request, Callback done) {
    final String query = request.getQuery();
    int lastSpace = query.lastIndexOf(' ');
    final String lastWord;
    if (query.length() == 0) {
        done.onSuggestionsReady(request, null);
        return;
    } else if (lastSpace == query.length() - 1) {
        // Starting a new word - don't show suggestions yet.
        done.onSuggestionsReady(request, null);
        return;
    } else if (lastSpace == -1) {
        lastWord = query;
    } else {
        lastWord = query.substring(lastSpace + 1);
    }
    final ArrayList<SearchSuggestion> r = new ArrayList<SearchSuggestOracle.SearchSuggestion>();
    for (String suggestion : suggestions) {
        if ((lastWord.length() < suggestion.length()) && suggestion.startsWith(lastWord)) {
            r.add(new SearchSuggestion(suggestion, query + suggestion.substring(lastWord.length())));
        }
    }
    done.onSuggestionsReady(request, new Response(r));
}
#method_after
@Override
protected void onRequestSuggestions(Request request, Callback done) {
    final String query = request.getQuery();
    int lastSpace = query.lastIndexOf(' ');
    final String lastWord;
    // NOTE: this method is not called if the query is empty.
    if (lastSpace == query.length() - 1) {
        // Starting a new word - don't show suggestions yet.
        done.onSuggestionsReady(request, null);
        return;
    } else if (lastSpace == -1) {
        lastWord = query;
    } else {
        lastWord = query.substring(lastSpace + 1);
    }
    final ArrayList<SearchSuggestion> r = new ArrayList<SearchSuggestOracle.SearchSuggestion>();
    for (String suggestion : suggestions.tailSet(lastWord)) {
        if ((lastWord.length() < suggestion.length()) && suggestion.startsWith(lastWord)) {
            if (suggestion.contains("self") && !Gerrit.isSignedIn()) {
                continue;
            }
            r.add(new SearchSuggestion(suggestion, query + suggestion.substring(lastWord.length())));
        }
    }
    done.onSuggestionsReady(request, new Response(r));
}
#end_block

#method_before
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    for (index--; index > -1; index--) {
        InlineHyperlink link = createLink(index, patchType, SafeHtml.asis(Util.C.prevPatchLinkIcon()), null);
        if (link != null) {
            return link;
        }
    }
    return null;
}
#method_after
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    int previousPatchIndex = getPreviousPatch(index, PREFERENCE_VALIDATOR);
    if (previousPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(previousPatchIndex, patchType, SafeHtml.asis(Util.C.prevPatchLinkIcon()), null);
    return link;
}
#end_block

#method_before
public InlineHyperlink getNextPatchLink(int index, PatchScreen.Type patchType) {
    for (index++; index < patchList.size(); index++) {
        InlineHyperlink link = createLink(index, patchType, null, SafeHtml.asis(Util.C.nextPatchLinkIcon()));
        if (link != null) {
            return link;
        }
    }
    return null;
}
#method_after
public InlineHyperlink getNextPatchLink(int index, PatchScreen.Type patchType) {
    int nextPatchIndex = getNextPatch(index, false, PREFERENCE_VALIDATOR);
    if (nextPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(nextPatchIndex, patchType, null, SafeHtml.asis(Util.C.nextPatchLinkIcon()));
    return link;
}
#end_block

#method_before
private PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    if ((listenablePrefs.get().isSkipDeleted() && patch.getChangeType().equals(ChangeType.DELETED)) || (listenablePrefs.get().isSkipUncommented() && patch.getCommentCount() == 0)) {
        return null;
    }
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#method_after
public PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    loadedInfoTable(detail);
    loadedActionPanel(detail);
    loadedPatchTable(detail);
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    loadInfoTable(detail);
    loadActionPanel(detail);
    loadPatchTable(detail);
}
#end_block

#method_before
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(parent.shortMessage));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#method_after
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(Util.cropSubject(parent.shortMessage)));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#end_block

#method_before
public void refresh() {
    if (patchSet.getId().equals(diffBaseId)) {
        if (patchTable != null) {
            patchTable.setVisible(false);
        }
        if (actionsPanel != null) {
            actionsPanel.setVisible(false);
        }
    } else {
        if (patchTable != null) {
            if (patchTable.getBase() == null && diffBaseId == null || patchTable.getBase() != null && patchTable.getBase().equals(diffBaseId)) {
                actionsPanel.setVisible(true);
                patchTable.setVisible(true);
                return;
            }
        }
        AccountDiffPreference diffPrefs;
        if (patchTable == null) {
            diffPrefs = new ListenableAccountDiffPreference().get();
        } else {
            diffPrefs = patchTable.getPreferences().get();
            patchTable.setVisible(false);
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                if (actionsPanel != null) {
                    actionsPanel.setVisible(true);
                } else {
                    loadedActionPanel(result);
                }
                loadedPatchTable(result);
            }
        });
    }
}
#method_after
public void refresh() {
    if (patchSet.getId().equals(diffBaseId)) {
        if (patchTable != null) {
            patchTable.setVisible(false);
        }
        if (actionsPanel != null) {
            actionsPanel.setVisible(false);
        }
    } else {
        if (patchTable != null) {
            if (patchTable.getBase() == null && diffBaseId == null || patchTable.getBase() != null && patchTable.getBase().equals(diffBaseId)) {
                actionsPanel.setVisible(true);
                patchTable.setVisible(true);
                return;
            }
        }
        AccountDiffPreference diffPrefs;
        if (patchTable == null) {
            diffPrefs = new ListenableAccountDiffPreference().get();
        } else {
            diffPrefs = patchTable.getPreferences().get();
            patchTable.setVisible(false);
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                if (actionsPanel != null) {
                    actionsPanel.setVisible(true);
                } else {
                    loadActionPanel(result);
                }
                loadPatchTable(result);
            }
        });
    }
}
#end_block

#method_before
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                loadedInfoTable(result);
                loadedActionPanel(result);
            }
        });
    }
}
#method_after
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                loadInfoTable(result);
                loadActionPanel(result);
            }
        });
    }
}
#end_block

#method_before
public static void doSignIn(String token) {
    switch(myConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
            Location.assign(loginRedirect(token));
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            Location.assign(selfRedirect("/become"));
            break;
        case OPENID_SSO:
            singleSignOnPanel.authenticate(SignInMode.SIGN_IN, token);
            break;
        case OPENID:
            new OpenIdSignInDialog(SignInMode.SIGN_IN, token, null).center();
            break;
        case LDAP:
        case LDAP_BIND:
            new UserPassSignInDialog(token, null).center();
            break;
    }
}
#method_after
public static void doSignIn(String token) {
    switch(myConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
            Location.assign(loginRedirect(token));
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            Location.assign(selfRedirect("/become"));
            break;
        case OPENID_SSO:
            final RootPanel gBody = RootPanel.get("gerrit_body");
            OpenIdSsoPanel singleSignOnPanel = new OpenIdSsoPanel();
            gBody.add(singleSignOnPanel);
            singleSignOnPanel.authenticate(SignInMode.SIGN_IN, token);
            break;
        case OPENID:
            new OpenIdSignInDialog(SignInMode.SIGN_IN, token, null).center();
            break;
        case LDAP:
        case LDAP_BIND:
            new UserPassSignInDialog(token, null).center();
            break;
    }
}
#end_block

#method_before
private void onModuleLoad2() {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    final RootPanel gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    singleSignOnPanel = new OpenIdSsoPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(menuRight);
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(singleSignOnPanel);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            final String token = view.getToken();
            if (!token.equals(History.getToken())) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xsrfToken;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    display(token);
}
#method_after
private void onModuleLoad2() {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    final RootPanel gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(menuRight);
    menuRightPanel.add(searchPanel);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            final String token = view.getToken();
            if (!token.equals(History.getToken())) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xsrfToken;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    display(token);
}
#end_block

#method_before
public void authenticate(SignInMode requestedMode, final String token) {
    OpenIdUtil.SVC.discover(ssoUrl, requestedMode, /* remember */
    false, token, new GerritCallback<DiscoveryResult>() {

        public void onSuccess(final DiscoveryResult result) {
            onDiscovery(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            super.onFailure(caught);
        }
    });
}
#method_after
public void authenticate(SignInMode requestedMode, final String token) {
    OpenIdUtil.SVC.discover(ssoUrl, requestedMode, /* remember */
    false, token, new GerritCallback<DiscoveryResult>() {

        public void onSuccess(final DiscoveryResult result) {
            onDiscovery(result);
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(SingleUserGroup.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(SingleUserGroup.class);
}
#method_after
@Override
protected void configure() {
    DynamicSet.bind(binder(), GroupBackend.class).to(SingleUserGroup.class);
}
#end_block

#method_before
@Override
public GroupMembership membershipsOf(final IdentifiedUser user) {
    return new GroupMembership() {

        @Override
        public boolean contains(AccountGroup.UUID uuid) {
            return username(uuid).equals(user.getUserName());
        }

        @Override
        public boolean containsAnyOf(Iterable<AccountGroup.UUID> groups) {
            for (AccountGroup.UUID uuid : groups) {
                if (contains(uuid)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public Set<AccountGroup.UUID> getKnownGroups() {
            return Collections.emptySet();
        }
    };
}
#method_after
@Override
public GroupMembership membershipsOf(final IdentifiedUser user) {
    ImmutableList.Builder<AccountGroup.UUID> groups = ImmutableList.builder();
    groups.add(uuid(user.getAccountId()));
    if (user.getUserName() != null) {
        groups.add(uuid(user.getUserName()));
    }
    return new ListGroupMembership(groups.build());
}
#end_block

#method_before
@Override
public GroupDescription.Basic get(final AccountGroup.UUID uuid) {
    AccountState state = accountCache.getByUsername(username(uuid));
    if (state != null) {
        final String name = nameOf(state);
        return new GroupDescription.Basic() {

            @Override
            public AccountGroup.UUID getGroupUUID() {
                return uuid;
            }

            @Override
            public String getName() {
                return name;
            }

            @Override
            public boolean isVisibleToAll() {
                return false;
            }
        };
    }
    return null;
}
#method_after
@Override
public GroupDescription.Basic get(final AccountGroup.UUID uuid) {
    String ident = username(uuid);
    AccountState state;
    if (ident.matches(ACCOUNT_ID_PATTERN)) {
        state = accountCache.get(new Account.Id(Integer.parseInt(ident)));
    } else if (ident.matches(Account.USER_NAME_PATTERN)) {
        state = accountCache.getByUsername(ident);
    } else {
        return null;
    }
    if (state != null) {
        final String name = nameOf(uuid, state);
        return new GroupDescription.Basic() {

            @Override
            public AccountGroup.UUID getGroupUUID() {
                return uuid;
            }

            @Override
            public String getName() {
                return name;
            }

            @Override
            public boolean isVisibleToAll() {
                return false;
            }
        };
    }
    return null;
}
#end_block

#method_before
@Override
public Collection<GroupReference> suggest(String name) {
    if (name.startsWith(NAME_PREFIX)) {
        name = name.substring(NAME_PREFIX.length());
    }
    if (name.length() < 3) {
        return Collections.emptyList();
    }
    try {
        AccountControl ctl = accountControlFactory.get();
        Set<Account.Id> ids = Sets.newHashSet();
        List<GroupReference> matches = Lists.newArrayListWithCapacity(MAX);
        String a = name;
        String b = end(a);
        ReviewDb db = schemaFactory.open();
        try {
            if (name.matches("[1-9][0-9]*")) {
                Account.Id id = new Account.Id(Integer.parseInt(name));
                if (db.accounts().get(id) != null && ctl.canSee(id)) {
                    add(matches, id);
                    if (!matches.isEmpty()) {
                        return matches;
                    }
                }
            }
            if (name.matches(Account.USER_NAME_PATTERN)) {
                for (AccountExternalId e : db.accountExternalIds().suggestByKey(new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME + a), new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME + b), MAX)) {
                    if (!e.getSchemeRest().startsWith(a)) {
                        break;
                    } else if (ids.add(e.getAccountId()) && ctl.canSee(e.getAccountId())) {
                        add(matches, e.getAccountId());
                    }
                    if (matches.size() == MAX) {
                        return matches;
                    }
                }
            }
            for (Account p : db.accounts().suggestByFullName(a, b, MAX)) {
                if (!p.getFullName().startsWith(a)) {
                    break;
                } else if (ids.add(p.getId()) && ctl.canSee(p.getId())) {
                    add(matches, p.getId());
                }
                if (matches.size() == MAX) {
                    return matches;
                }
            }
            for (Account p : db.accounts().suggestByPreferredEmail(a, b, MAX)) {
                if (!p.getPreferredEmail().startsWith(a)) {
                    break;
                } else if (ids.add(p.getId()) && ctl.canSee(p.getId())) {
                    add(matches, p.getId());
                }
                if (matches.size() == MAX) {
                    return matches;
                }
            }
            for (AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, MAX)) {
                if (!e.getEmailAddress().startsWith(a)) {
                    break;
                } else if (ids.add(e.getAccountId()) && ctl.canSee(e.getAccountId())) {
                    add(matches, e.getAccountId());
                }
                if (matches.size() == MAX) {
                    return matches;
                }
            }
            return matches;
        } finally {
            db.close();
        }
    } catch (OrmException err) {
        log.warn("Cannot suggest users", err);
        return Collections.emptyList();
    }
}
#method_after
@Override
public Collection<GroupReference> suggest(String name) {
    if (name.startsWith(NAME_PREFIX)) {
        name = name.substring(NAME_PREFIX.length());
    } else if (name.startsWith(ACCOUNT_PREFIX)) {
        name = name.substring(ACCOUNT_PREFIX.length());
    }
    if (name.isEmpty()) {
        return Collections.emptyList();
    }
    try {
        AccountControl ctl = accountControlFactory.get();
        Set<Account.Id> ids = Sets.newHashSet();
        List<GroupReference> matches = Lists.newArrayListWithCapacity(MAX);
        String a = name;
        String b = end(a);
        ReviewDb db = schemaFactory.open();
        try {
            if (name.matches(ACCOUNT_ID_PATTERN)) {
                Account.Id id = new Account.Id(Integer.parseInt(name));
                if (db.accounts().get(id) != null) {
                    add(matches, ids, ctl, id);
                    return matches;
                }
            }
            if (name.matches(Account.USER_NAME_PATTERN)) {
                for (AccountExternalId e : db.accountExternalIds().suggestByKey(new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME + a), new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME + b), MAX)) {
                    if (!e.getSchemeRest().startsWith(a)) {
                        break;
                    }
                    add(matches, ids, ctl, e.getAccountId());
                }
            }
            for (Account p : db.accounts().suggestByFullName(a, b, MAX)) {
                if (!p.getFullName().startsWith(a)) {
                    break;
                }
                add(matches, ids, ctl, p.getId());
            }
            for (Account p : db.accounts().suggestByPreferredEmail(a, b, MAX)) {
                if (!p.getPreferredEmail().startsWith(a)) {
                    break;
                }
                add(matches, ids, ctl, p.getId());
            }
            for (AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, MAX)) {
                if (!e.getEmailAddress().startsWith(a)) {
                    break;
                }
                add(matches, ids, ctl, e.getAccountId());
            }
            return matches;
        } finally {
            db.close();
        }
    } catch (OrmException err) {
        log.warn("Cannot suggest users", err);
        return Collections.emptyList();
    }
}
#end_block

#method_before
private void add(List<GroupReference> matches, Account.Id id) {
    AccountState state = accountCache.get(id);
    if (state != null && state.getUserName() != null) {
        matches.add(new GroupReference(uuid(state.getUserName()), nameOf(state)));
    }
}
#method_after
private void add(List<GroupReference> matches, Set<Account.Id> ids, AccountControl ctl, Account.Id id) {
    if (!ids.add(id) || !ctl.canSee(id)) {
        return;
    }
    AccountState state = accountCache.get(id);
    if (state == null) {
        return;
    }
    AccountGroup.UUID uuid;
    if (state.getUserName() != null) {
        uuid = uuid(state.getUserName());
    } else {
        uuid = uuid(id);
    }
    matches.add(new GroupReference(uuid, nameOf(uuid, state)));
}
#end_block

#method_before
private static AccountGroup.UUID uuid(String username) {
    return new AccountGroup.UUID(UUID_PREFIX + username);
}
#method_after
private static AccountGroup.UUID uuid(Account.Id ident) {
    return uuid(Integer.toString(ident.get()));
}
#end_block

#method_before
private static String nameOf(AccountState account) {
    if (account.getAccount().getFullName() != null) {
        return account.getAccount().getFullName();
    } else if (account.getUserName() != null) {
        return NAME_PREFIX + account.getUserName();
    } else {
        return NAME_PREFIX + account.getAccount().getId().get();
    }
}
#method_after
private static String nameOf(AccountGroup.UUID uuid, AccountState account) {
    StringBuilder buf = new StringBuilder();
    if (account.getAccount().getFullName() != null) {
        buf.append(account.getAccount().getFullName());
    }
    if (account.getUserName() != null) {
        if (buf.length() > 0) {
            buf.append(" (").append(account.getUserName()).append(")");
        } else {
            buf.append(account.getUserName());
        }
    } else if (buf.length() > 0) {
        buf.append(" (").append(account.getAccount().getId().get()).append(")");
    } else {
        buf.append(account.getAccount().getId().get());
    }
    String ident = username(uuid);
    if (ident.matches(ACCOUNT_ID_PATTERN)) {
        buf.insert(0, ACCOUNT_PREFIX);
    } else {
        buf.insert(0, NAME_PREFIX);
    }
    return buf.toString();
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    projectsPopup.closePopup();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS, sugestParent);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
    /* popup */
    projectsPopup = new ProjectListPopup() {

        @Override
        protected void onMovePointerTo(String projectName) {
            // prevent user input from being overwritten by simply poping up
            if (!projectsPopup.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectName);
            }
        }
    };
    projectsPopup.initPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS);
}
#end_block

#method_before
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), suggestedParentsTab.getAbsoluteLeft() + suggestedParentsTab.getOffsetWidth());
            projectListPopup.setCoordinates(top, left);
            projectListPopup.display();
        }
    });
}
#method_after
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), suggestedParentsTab.getAbsoluteLeft() + suggestedParentsTab.getOffsetWidth());
            projectsPopup.setPreferredCoordinates(top, left);
            projectsPopup.displayPopup();
        }
    });
}
#end_block

#method_before
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            final Anchor projectLink = new Anchor(k.name());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).name());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.description());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    ProjectMap.suggestParentCandidates(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(ProjectMap list) {
            if (!list.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(list);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#method_after
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            final Anchor projectLink = new Anchor(k.name());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).name());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.description());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    ProjectMap.parentCandidates(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(ProjectMap list) {
            if (!list.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(list);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                continue;
            }
            if (!isVisible && !(showTree && pctl.isOwner())) {
                // 
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && format.isJson() || (type == FilterType.SUGGEST_PARENT_CANDIDATES)) {
                ProjectState parent = e.getParentState();
                if (parent != null) {
                    ProjectControl parentCtrl = parent.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        if (type == FilterType.SUGGEST_PARENT_CANDIDATES) {
                            info.name = parent.getProject().getName();
                            info.description = parent.getProject().getDescription();
                            if (format.isJson()) {
                                output.put(info.name, info);
                            }
                            continue;
                        }
                        info.parent = parent.getProject().getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getProject().getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getProject().getName(), info.parent);
                        }
                    }
                } else {
                    if (type == FilterType.SUGGEST_PARENT_CANDIDATES) {
                        continue;
                    }
                }
            }
            info.name = projectName.get();
            if (showDescription && !e.getProject().getDescription().isEmpty()) {
                info.description = e.getProject().getDescription();
            }
            try {
                if (showBranch != null) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                        List<Ref> refs = getBranchRefs(projectName, pctl);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = Maps.newLinkedHashMap();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    } finally {
                        git.close();
                    }
                } else if (!showTree && type != FilterType.ALL) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                    } finally {
                        git.close();
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                log.warn("Unexpected error reading " + projectName, err);
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (showBranch != null) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + info.description.replace("\n", "\\n"));
            }
            stdout.print('\n');
        }
        if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#method_after
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    Set<String> rejected = new HashSet<String>();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (type == FilterType.PARENT_CANDIDATES) {
                ProjectState parentState = e.getParentState();
                if (parentState != null && !output.keySet().contains(parentState.getProject().getName()) && !rejected.contains(parentState.getProject().getName())) {
                    ProjectControl parentCtrl = parentState.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        info.name = parentState.getProject().getName();
                        info.description = parentState.getProject().getDescription();
                    } else {
                        rejected.add(parentState.getProject().getName());
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                final ProjectControl pctl = e.controlFor(currentUser);
                final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
                if (showTree && !format.isJson()) {
                    treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                    continue;
                }
                if (!isVisible && !(showTree && pctl.isOwner())) {
                    // 
                    continue;
                }
                info.name = projectName.get();
                if (showTree && format.isJson()) {
                    ProjectState parent = e.getParentState();
                    if (parent != null) {
                        ProjectControl parentCtrl = parent.controlFor(currentUser);
                        if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                            info.parent = parent.getProject().getName();
                        } else {
                            info.parent = hiddenNames.get(parent.getProject().getName());
                            if (info.parent == null) {
                                info.parent = "?-" + (hiddenNames.size() + 1);
                                hiddenNames.put(parent.getProject().getName(), info.parent);
                            }
                        }
                    }
                }
                if (showDescription && !e.getProject().getDescription().isEmpty()) {
                    info.description = e.getProject().getDescription();
                }
                try {
                    if (showBranch != null) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                            List<Ref> refs = getBranchRefs(projectName, pctl);
                            if (!hasValidRef(refs)) {
                                continue;
                            }
                            for (int i = 0; i < showBranch.size(); i++) {
                                Ref ref = refs.get(i);
                                if (ref != null && ref.getObjectId() != null) {
                                    if (info.branches == null) {
                                        info.branches = Maps.newLinkedHashMap();
                                    }
                                    info.branches.put(showBranch.get(i), ref.getObjectId().name());
                                }
                            }
                        } finally {
                            git.close();
                        }
                    } else if (!showTree && type != FilterType.ALL) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                        } finally {
                            git.close();
                        }
                    }
                } catch (RepositoryNotFoundException err) {
                    // If the Git repository is gone, the project doesn't actually exist anymore.
                    continue;
                } catch (IOException err) {
                    log.warn("Unexpected error reading " + projectName, err);
                    continue;
                }
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (showBranch != null) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.SETTINGS_PROJECTS, nameTxt, this);
    projectListPopup.addProjectListPopupOnOpenRowHandler(new ProjectListPopup.ProjectListPopupOnOpenRowHandler() {

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            doAddNew();
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    projectsPopup = new ProjectListPopup() {

        @Override
        protected void onMovePointerTo(String projectName) {
            // prevent user input from being overwritten by simply poping up
            if (!projectsPopup.isPopingUp() || "".equals(nameBox.getText())) {
                nameBox.setText(projectName);
            }
        }

        @Override
        protected void openRow(String projectName) {
            nameBox.setText(projectName);
            doAddNew();
        }
    };
    projectsPopup.initPopup(Util.C.projects(), PageLinks.SETTINGS_PROJECTS);
}
#end_block

#method_before
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            calculatePopupCoordinates();
            projectListPopup.display();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#method_after
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), watchesTab.getAbsoluteLeft() + watchesTab.getOffsetWidth());
            projectsPopup.setPreferredCoordinates(top, left);
            projectsPopup.displayPopup();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    projectsPopup.closePopup();
}
#end_block

#method_before
protected void initPopup() {
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popupPosition = new PopupPanel.PositionCallback() {

        public void setPosition(int offsetWidth, int offsetHeight) {
            if (preferredPopupWidth == -1) {
                preferredPopupWidth = offsetWidth;
            }
            if (top + offsetHeight > Window.getClientWidth()) {
                top = Window.getClientWidth() - offsetHeight;
            }
            if (left + offsetWidth > Window.getClientWidth()) {
                left = Window.getClientWidth() - offsetWidth;
            }
            if (top < 0) {
                sp.setHeight((sp.getOffsetHeight() + top) + "px");
                top = 0;
            }
            if (left < 0) {
                sp.setWidth((sp.getOffsetWidth() + left) + "px");
                left = 0;
            }
            popup.setPopupPosition(left, top);
        }
    };
}
#method_after
public void initPopup(final String popupText, final String currentPageLink) {
    createWidgets(popupText, currentPageLink);
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    sp.setSize("100%", "100%");
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popup.setHeight("100%");
    popupPosition = getPositionCallback();
}
#end_block

#method_before
protected void createWidgets(final String popupText, final String currentPageLink) {
    projectsTab = new ProjectsTable() {

        @Override
        protected void movePointerTo(final int row, final boolean scroll) {
            super.movePointerTo(row, scroll);
            handlerManager.fireEvent(new ProjectListPopupOnMovePointerEvent(popingUp, getRowItem(row).getName()));
        }

        @Override
        protected void onOpenRow(final int row) {
            super.onOpenRow(row);
            handlerManager.fireEvent(new ProjectListPopupOnOpenRowEvent(getRowItem(row).getName()));
        }
    };
    projectsTab.setSavePointerId(currentPageLink);
    close = new Button(Util.C.projectsClose());
    close.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            closePopup();
            handlerManager.fireEvent(new ProjectListPopupOnCloseEvent());
        }
    });
    popup = new PluginSafeDialogBox();
    popup.setModal(false);
    popup.setText(popupText);
}
#method_after
private void createWidgets(final String popupText, final String currentPageLink) {
    projectsTab = new ProjectsTable() {

        @Override
        protected void movePointerTo(final int row, final boolean scroll) {
            super.movePointerTo(row, scroll);
            onMovePointerTo(getRowItem(row).name());
        }

        @Override
        protected void onOpenRow(final int row) {
            super.onOpenRow(row);
            openRow(getRowItem(row).name());
        }
    };
    projectsTab.setSavePointerId(currentPageLink);
    close = new Button(Util.C.projectsClose());
    close.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            closePopup();
        }
    });
    popup = new PluginSafeDialogBox();
    popup.setModal(false);
    popup.setText(popupText);
}
#end_block

#method_before
public void closePopup() {
    popup.hide();
    resetHandlerRegistration();
}
#method_after
public void closePopup() {
    popup.hide();
}
#end_block

#method_before
protected void populateProjects() {
    Util.PROJECT_SVC.visibleProjects(new GerritCallback<ProjectList>() {

        @Override
        public void onSuccess(final ProjectList result) {
            projectsTab.display(result.getProjects());
            if (firstPopupLoad) {
                // Display was delayed until table was loaded
                firstPopupLoad = false;
                display();
            }
        }
    });
}
#method_after
protected void populateProjects() {
    ProjectMap.all(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(final ProjectMap result) {
            projectsTab.display(result);
            if (firstPopupLoad) {
                // Display was delayed until table was loaded
                firstPopupLoad = false;
                displayPopup();
            }
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    if (Gerrit.isSignedIn()) {
        setTitleFarEast(reviewed);
    }
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(patchKey.getParentKey(), 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    commitMessageBlock = new CommitMessageBlock();
    topPanel = new FlowPanel();
    add(topPanel);
    header = new PatchTableHeader();
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(header);
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    if (Gerrit.isSignedIn()) {
        setTitleFarEast(reviewed);
    }
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(patchKey.getParentKey(), 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    commitMessageBlock = new CommitMessageBlock();
    topPanel = new FlowPanel();
    add(topPanel);
    header = new PatchTableHeader(getPatchScreenType());
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(header);
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(idSideA, patchKey));
    }
    header.display(script, patchKey, idSideA, idSideB, getPatchScreenType());
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(idSideA, patchKey));
    }
    header.display(patchSetDetail, script, patchKey, idSideA, idSideB);
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#end_block

#method_before
public void display(final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB, final PatchScreen.Type type) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.screenType = type;
    this.links = new LinkedList<Anchor>();
    linkPanel.add(new Label(PatchUtil.C.patchSet() + " "));
    if (side == Side.A) {
        addLink("Base", null);
    } else {
        links.add(null);
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        addLink(Integer.toString(psId.get()), psId);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    downloadLink();
}
#method_after
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new LinkedList<Anchor>();
    if (screenType == PatchScreen.Type.UNIFIED) {
        sideMarker.setInnerText((side == Side.A) ? "(-)" : "(+)");
    }
    if (detail.getInfo().getParents().size() > 1) {
        addLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        addLink(PatchUtil.C.patchBase(), null);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        addLink(Integer.toString(psId.get()), psId);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = getDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(new Label(" - "));
        linkPanel.add(downloadLink);
    }
}
#end_block

#method_before
private void addLink(String label, final PatchSet.Id id) {
    final Anchor anchor = new Anchor(label);
    anchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (side == Side.A) {
                idSideA = id;
            } else {
                idSideB = id;
            }
            Patch.Key k = new Patch.Key(idSideB, patchKey.get());
            switch(screenType) {
                case SIDE_BY_SIDE:
                    Gerrit.display(Dispatcher.toPatchSideBySide(idSideA, k));
                    break;
                case UNIFIED:
                    Gerrit.display(Dispatcher.toPatchUnified(idSideA, k));
                    break;
            }
        }
    });
    links.add(anchor);
    linkPanel.add(anchor);
}
#method_after
private void addLink(String label, final PatchSet.Id id) {
    final Anchor anchor = new Anchor(label);
    anchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (side == Side.A) {
                idSideA = id;
            } else {
                idSideB = id;
            }
            Patch.Key keySideB = new Patch.Key(idSideB, patchKey.get());
            switch(screenType) {
                case SIDE_BY_SIDE:
                    Gerrit.display(Dispatcher.toPatchSideBySide(idSideA, keySideB));
                    break;
                case UNIFIED:
                    Gerrit.display(Dispatcher.toPatchUnified(idSideA, keySideB));
                    break;
            }
        }
    });
    links.add(anchor);
    linkPanel.add(anchor);
}
#end_block

#method_before
public void display(PatchScript script, final Patch.Key patchKey, final PatchSet.Id idSideA, final PatchSet.Id idSideB, PatchScreen.Type type) {
    listA.display(script, patchKey, idSideA, idSideB, type);
    listB.display(script, patchKey, idSideA, idSideB, type);
    if (type == PatchScreen.Type.UNIFIED) {
        aligner.getStyle().setDisplay(Display.NONE);
    }
}
#method_after
public void display(final PatchSetDetail detail, PatchScript script, final Patch.Key patchKey, final PatchSet.Id idSideA, final PatchSet.Id idSideB) {
    listA.display(detail, script, patchKey, idSideA, idSideB);
    listB.display(detail, script, patchKey, idSideA, idSideB);
}
#end_block

#method_before
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        String parentMsg = parent.shortMessage;
        if (parentMsg.length() > 80) {
            parentMsg = parentMsg.substring(0, 80) + "...";
        }
        parentsTable.setWidget(row, 1, new InlineLabel(parentMsg));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#method_after
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(Util.cropSubject(parent.shortMessage)));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#end_block

#method_before
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or change/patch sets to review")
void addPatchSetId(final String token) {
    try {
        patchSetIds.addAll(parsePatchSetId(token));
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#method_after
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or patch sets to review")
void addPatchSetId(final String token) {
    try {
        patchSetIds.addAll(parsePatchSetId(token));
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable2();
    table.addStyleName(Gerrit.RESOURCES.css().accountDashboard());
    outgoing = new ChangeTable2.Section();
    incoming = new ChangeTable2.Section();
    closed = new ChangeTable2.Section();
    outgoing.setTitleText(Util.C.outgoingReviews());
    incoming.setTitleText(Util.C.incomingReviews());
    incoming.initHighlightUnreviewed(true, ownerId);
    closed.setTitleText(Util.C.recentlyClosed());
    table.addSection(outgoing);
    table.addSection(incoming);
    table.addSection(closed);
    add(table);
    table.setSavePointerId("owner:" + ownerId);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable2();
    table.addStyleName(Gerrit.RESOURCES.css().accountDashboard());
    outgoing = new ChangeTable2.Section();
    incoming = new ChangeTable2.Section();
    closed = new ChangeTable2.Section();
    outgoing.setTitleText(Util.C.outgoingReviews());
    incoming.setTitleText(Util.C.incomingReviews());
    incoming.setHighlightUnreviewed(true);
    closed.setTitleText(Util.C.recentlyClosed());
    table.addSection(outgoing);
    table.addSection(incoming);
    table.addSection(closed);
    add(table);
    table.setSavePointerId("owner:" + ownerId);
}
#end_block

#method_before
private void display(NativeList<ChangeList> result) {
    if (!mine && !hasChanges(result)) {
        // When no results are returned and the data is not for the
        // current user, the target user is presumed to not exist.
        Gerrit.display(getToken(), new NotFoundScreen());
        return;
    }
    ChangeList out = result.get(0);
    ChangeList in = result.get(1);
    ChangeList done = result.get(2);
    if (mine) {
        setWindowTitle(Util.C.myDashboardTitle());
        setPageTitle(Util.C.myDashboardTitle());
    } else {
        // The server doesn't tell us who the dashboard is for. Try to guess
        // by looking at a change started by the owner and extract the name.
        String name = guessName(out);
        if (name == null) {
            name = guessName(done);
        }
        if (name != null) {
            setWindowTitle(name);
            setPageTitle(Util.M.accountDashboardTitle(name));
        } else {
            setWindowTitle(Util.C.unknownDashboardTitle());
            setWindowTitle(Util.C.unknownDashboardTitle());
        }
    }
    Collections.sort(out.asList(), compare());
    Collections.sort(in.asList(), compare());
    table.updateColumnsForLabels(out, in, done);
    outgoing.display(out);
    incoming.display(in);
    closed.display(done);
    table.finishDisplay();
}
#method_after
private void display(NativeList<ChangeList> result) {
    if (!mine && !hasChanges(result)) {
        // When no results are returned and the data is not for the
        // current user, the target user is presumed to not exist.
        Gerrit.display(getToken(), new NotFoundScreen());
        return;
    }
    ChangeList out = result.get(0);
    ChangeList in = result.get(1);
    ChangeList done = result.get(2);
    if (mine) {
        setWindowTitle(Util.C.myDashboardTitle());
        setPageTitle(Util.C.myDashboardTitle());
    } else {
        // The server doesn't tell us who the dashboard is for. Try to guess
        // by looking at a change started by the owner and extract the name.
        String name = guessName(out);
        if (name == null) {
            name = guessName(done);
        }
        if (name != null) {
            setWindowTitle(name);
            setPageTitle(Util.M.accountDashboardTitle(name));
        } else {
            setWindowTitle(Util.C.unknownDashboardTitle());
            setWindowTitle(Util.C.unknownDashboardTitle());
        }
    }
    Collections.sort(out.asList(), outComparator());
    table.updateColumnsForLabels(out, in, done);
    outgoing.display(out);
    incoming.display(in);
    closed.display(done);
    table.finishDisplay();
}
#end_block

#method_before
public final SubmitRecord.Label.Status status() {
    if (approved() != null) {
        return SubmitRecord.Label.Status.OK;
    } else if (rejected() != null) {
        return SubmitRecord.Label.Status.REJECT;
    } else {
        return SubmitRecord.Label.Status.NEED;
    }
}
#method_after
public final SubmitRecord.Label.Status status() {
    if (approved() != null) {
        return SubmitRecord.Label.Status.OK;
    } else if (rejected() != null) {
        return SubmitRecord.Label.Status.REJECT;
    } else if (optional()) {
        return SubmitRecord.Label.Status.MAY;
    } else {
        return SubmitRecord.Label.Status.NEED;
    }
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed, Account.Id accountId) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(c.id_abbreviated(), c));
    String subject = c.subject();
    if (subject.length() > 80) {
        subject = subject.substring(0, 80);
    }
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        subject += " (" + Util.toLongString(status) + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    String owner = "";
    if (c.owner() != null && c.owner().name() != null) {
        owner = c.owner().name();
    }
    table.setWidget(row, C_OWNER, new InlineHyperlink(owner, PageLinks.toAccountQuery(owner)));
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    boolean reviewScored = false;
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            table.clearCell(row, col);
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
        reviewScored = true;
    }
    boolean needHighlight = false;
    // patch set, we also don't highlight it.
    if (highlightUnreviewed && !reviewScored && accountId != null) {
        needHighlight = true;
        for (int i = 0; i < c.messageAuthorIds().length(); i++) {
            if (accountId.get() == c.messageAuthorIds().get(i)) {
                needHighlight = false;
                break;
            }
        }
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(c.id_abbreviated(), c));
    String subject = c.subject();
    if (subject.length() > 80) {
        subject = subject.substring(0, 80);
    }
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        subject += " (" + Util.toLongString(status) + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    String owner = "";
    if (c.owner() != null && c.owner().name() != null) {
        owner = c.owner().name();
    }
    table.setWidget(row, C_OWNER, new InlineHyperlink(owner, PageLinks.toAccountQuery(owner)));
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            table.clearCell(row, col);
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
public void display(ChangeList changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    } else {
        parent.removeRow(dataBegin);
    }
    if (sz == 0) {
        parent.insertNoneRow(dataBegin);
        return;
    }
    while (rows < sz) {
        parent.insertChangeRow(dataBegin + rows);
        rows++;
    }
    for (int i = 0; i < sz; i++) {
        parent.populateChangeRow(dataBegin + i, changeList.get(i), highlightUnreviewed, ownerId);
    }
}
#method_after
public void display(ChangeList changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    } else {
        parent.removeRow(dataBegin);
    }
    if (sz == 0) {
        parent.insertNoneRow(dataBegin);
        return;
    }
    while (rows < sz) {
        parent.insertChangeRow(dataBegin + rows);
        rows++;
    }
    for (int i = 0; i < sz; i++) {
        parent.populateChangeRow(dataBegin + i, changeList.get(i), highlightUnreviewed);
    }
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.id = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = asAccountAttribute(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.labels = labelsFor(cd);
    out.messageauthors = recentMessageAuthorIds(cd);
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.id = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = asAccountAttribute(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd);
    return out;
}
#end_block

#method_before
private AccountAttribute asAccountAttribute(Account.Id user) {
    AccountAttribute a = accounts.get(user);
    if (a == null) {
        a = new AccountAttribute();
        accounts.put(user, a);
    }
    return a;
}
#method_after
private AccountAttribute asAccountAttribute(Account.Id user) {
    if (user == null) {
        return null;
    }
    AccountAttribute a = accounts.get(user);
    if (a == null) {
        a = new AccountAttribute();
        accounts.put(user, a);
    }
    return a;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    Change in = cd.change(db);
    ChangeControl ctl = cd.changeControl();
    if (ctl == null || ctl.getCurrentUser() != user) {
        try {
            ctl = changeControlFactory.controlFor(in);
        } catch (NoSuchChangeException e) {
            return null;
        }
    }
    PatchSet ps = cd.currentPatchSet(db);
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = asAccountAttribute(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = asAccountAttribute(r.appliedBy);
                        break;
                }
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    Change in = cd.change(db);
    ChangeControl ctl = cd.changeControl();
    if (ctl == null || ctl.getCurrentUser() != user) {
        try {
            ctl = changeControlFactory.controlFor(in);
        } catch (NoSuchChangeException e) {
            return null;
        }
    }
    PatchSet ps = cd.currentPatchSet(db);
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = asAccountAttribute(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = asAccountAttribute(r.appliedBy);
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.SETTINGS_PROJECTS, nameTxt, null);
    projectListPopup.addOpenRowHandler(new ProjectListPopup.ProjectListPopupOnOpenRowHandler() {

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            doAddNew();
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    final Grid grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    sp.setSize("100%", "100%");
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popup.setHeight("100%");
    popupPosition = new PopupPanel.PositionCallback() {

        public void setPosition(int offsetWidth, int offsetHeight) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), watchesTab.getAbsoluteLeft() + watchesTab.getOffsetWidth());
            if (top + offsetHeight > Window.getClientHeight()) {
                top = Window.getClientHeight() - offsetHeight;
            }
            if (left + offsetWidth > Window.getClientWidth()) {
                left = Window.getClientWidth() - offsetWidth;
            }
            if (top < 0) {
                sp.setHeight((sp.getOffsetHeight() + top) + "px");
                top = 0;
            }
            if (left < 0) {
                sp.setWidth((sp.getOffsetWidth() + left) + "px");
                left = 0;
            }
            popup.setPopupPosition(left, top);
        }
    };
}
#end_block

#method_before
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            calculatePopupCoordinates();
            projectListPopup.display();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#method_after
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    projectsTab = new ProjectsTable() {

        {
            keysNavigation.add(new OpenKeyCommand(0, 'o', Util.C.projectListOpen()));
            keysNavigation.add(new OpenKeyCommand(0, KeyCodes.KEY_ENTER, Util.C.projectListOpen()));
        }

        @Override
        protected void movePointerTo(final int row, final boolean scroll) {
            super.movePointerTo(row, scroll);
            // prevent user input from being overwritten by simply poping up
            if (!popingUp || "".equals(nameBox.getText())) {
                nameBox.setText(getRowItem(row).name());
            }
        }

        @Override
        protected void onOpenRow(final int row) {
            super.onOpenRow(row);
            nameBox.setText(getRowItem(row).name());
            doAddNew();
        }
    };
    projectsTab.setSavePointerId(PageLinks.SETTINGS_PROJECTS);
    close = new Button(Util.C.projectsClose());
    close.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            closePopup();
        }
    });
    popup = new PluginSafeDialogBox();
    popup.setModal(false);
    popup.setText(Util.C.projects());
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            displayPopup();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    closePopup();
}
#end_block

#method_before
public static String toAccountQuery(final String fullname) {
    return "/q/owner:\"" + KeyUtil.encode(fullname) + "\"," + TOP;
}
#method_after
public static String toAccountQuery(final String fullname) {
    String query = op("owner", fullname) + " status:open";
    return toChangeQuery(query, TOP);
}
#end_block

#method_before
public static String toChangeQuery(String query, String page) {
    query = KeyUtil.encode(query).replaceAll("%3[Aa]", ":");
    return "/q/" + query + "," + page;
}
#method_after
public static String toChangeQuery(String query, String page) {
    return "/q/" + KeyUtil.encode(query) + "," + page;
}
#end_block

#method_before
public static String op(String name, String value) {
    if (value.indexOf(' ') >= 0) {
        return name + ":\"" + value + "\"";
    }
    return name + ":" + value;
}
#method_after
public static String op(String op, String value) {
    if (isSingleWord(value)) {
        return op + ":" + value;
    }
    return op + ":\"" + value + "\"";
}
#end_block

#method_before
private static String loginRedirect(String token) {
    if (token == null) {
        token = "";
    } else if (token.startsWith("/")) {
        token = token.substring(1);
    }
    return selfRedirect("/login/" + token);
}
#method_after
public static String loginRedirect(String token) {
    if (token == null) {
        token = "";
    } else if (token.startsWith("/")) {
        token = token.substring(1);
    }
    return selfRedirect("/login/" + token);
}
#end_block

#method_before
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        public void onSuccess(final HostPageData result) {
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xsrfToken = result.xsrfToken;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2();
        }
    });
}
#method_after
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        public void onSuccess(final HostPageData result) {
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xsrfToken = result.xsrfToken;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2();
        }
    });
}
#end_block

#method_before
private void initPluginList() {
    pluginTable = new PluginTable();
    pluginTable.addStyleName(Gerrit.RESOURCES.css().pluginsTable());
    // TODO: create buttons and handlers here.
    pluginPanel = new FlowPanel();
    pluginPanel.setWidth("500px");
    pluginPanel.add(pluginTable);
    add(pluginPanel);
}
#method_after
private void initPluginList() {
    pluginTable = new PluginTable();
    pluginTable.addStyleName(Gerrit.RESOURCES.css().pluginsTable());
    pluginPanel = new FlowPanel();
    pluginPanel.setWidth("500px");
    pluginPanel.add(pluginTable);
    add(pluginPanel);
}
#end_block

#method_before
void display(final PluginMap plugins) {
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    List<PluginInfo> list = plugins.values().asList();
    for (final PluginInfo p : list) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, p);
    }
}
#method_after
void display(final PluginMap plugins) {
    while (1 < table.getRowCount()) {
        table.removeRow(table.getRowCount() - 1);
    }
    for (final PluginInfo p : plugins.values().asList()) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, p);
    }
}
#end_block

#method_before
void populate(final int row, final PluginInfo plugin) {
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    table.setText(row, 2, plugin.name());
    table.setText(row, 3, plugin.version());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#method_after
void populate(final int row, final PluginInfo plugin) {
    table.setText(row, 1, plugin.name());
    table.setText(row, 2, plugin.version());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#end_block

#method_before
public String getUnifiedDiff() {
    StringBuilder detail = new StringBuilder();
    if (patchSet != null) {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        DiffFormatter df = new DiffFormatter(out);
        db = openRepository();
        reader = db.newObjectReader();
        PatchList patchList = getPatchList();
        for (PatchListEntry p : patchList.getPatches()) {
            if (Patch.COMMIT_MSG.equals(p.getNewName())) {
                continue;
            }
            detail.append("\n");
            List<String> headers = p.getHeaderLines();
            for (String hdr : headers) {
                detail.append(hdr);
            }
            try {
                String filename = p.getNewName();
                RawText aText = resolve(patchList.getOldId(), filename);
                RawText bText = resolve(patchList.getNewId(), filename);
                df.format(toEditList(p.getEdits()), aText, bText);
                detail.append(out.toString());
            } catch (IOException err) {
            }
        }
        detail.append("\n");
    }
    return detail.toString();
}
#method_after
public String getUnifiedDiff() {
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    Repository repo = getRepository();
    if (repo != null) {
        DiffFormatter df = new DiffFormatter(out);
        try {
            PatchList patchList = getPatchList();
            if (patchList.getOldId() != null) {
                df.setRepository(repo);
                df.setDetectRenames(true);
                df.format(patchList.getOldId(), patchList.getNewId());
            }
        } catch (PatchListNotAvailableException e) {
            log.error("Cannot format patch", e);
        } catch (IOException e) {
            log.error("Cannot format patch", e);
        } finally {
            df.release();
            repo.close();
        }
    }
    return RawParseUtils.decode(out.toByteArray());
}
#end_block

#method_before
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    final Repository repo = getRepository();
    try {
        final PatchList patchList = repo != null ? getPatchList() : null;
        Patch.Key currentFileKey = null;
        PatchFile currentFileData = null;
        for (final PatchLineComment c : inlineComments) {
            final Patch.Key pk = c.getKey().getParentKey();
            final int lineNbr = c.getLine();
            final short side = c.getSide();
            if (!pk.equals(currentFileKey)) {
                cmts.append("....................................................\n");
                if (Patch.COMMIT_MSG.equals(pk.get())) {
                    cmts.append("Commit Message\n");
                } else {
                    cmts.append("File ");
                    cmts.append(pk.get());
                    cmts.append("\n");
                }
                currentFileKey = pk;
                if (patchList != null) {
                    try {
                        currentFileData = new PatchFile(repo, patchList, pk.getFileName());
                    } catch (IOException e) {
                    // Don't quote the line if we can't load it.
                    }
                } else {
                    currentFileData = null;
                }
            }
            for (int line = lineNbr - lines + 1; line <= lineNbr; ++line) {
                appendFileLine(cmts, currentFileData, side, line);
            }
            cmts.append(c.getMessage().trim());
            cmts.append("\n");
            for (int line = lineNbr + 1; line < lineNbr + lines; ++line) {
                appendFileLine(cmts, currentFileData, side, line);
            }
            cmts.append("\n\n");
        }
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return cmts.toString();
}
#method_after
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    final Repository repo = getRepository();
    try {
        final PatchList patchList = repo != null ? getPatchList() : null;
        Patch.Key currentFileKey = null;
        PatchFile currentFileData = null;
        for (final PatchLineComment c : inlineComments) {
            final Patch.Key pk = c.getKey().getParentKey();
            final int lineNbr = c.getLine();
            final short side = c.getSide();
            if (!pk.equals(currentFileKey)) {
                cmts.append("....................................................\n");
                if (Patch.COMMIT_MSG.equals(pk.get())) {
                    cmts.append("Commit Message\n");
                } else {
                    cmts.append("File ");
                    cmts.append(pk.get());
                    cmts.append("\n");
                }
                currentFileKey = pk;
                if (patchList != null) {
                    try {
                        currentFileData = new PatchFile(repo, patchList, pk.getFileName());
                    } catch (IOException e) {
                    // Don't quote the line if we can't load it.
                    }
                } else {
                    currentFileData = null;
                }
            }
            if (currentFileData != null) {
                int maxLines;
                try {
                    maxLines = currentFileData.getLineCount(side);
                } catch (Throwable e) {
                    maxLines = lineNbr;
                }
                final int startLine = Math.max(1, lineNbr - lines + 1);
                final int stopLine = Math.min(maxLines, lineNbr + lines);
                for (int line = startLine; line <= lineNbr; ++line) {
                    appendFileLine(cmts, currentFileData, side, line);
                }
                cmts.append(c.getMessage().trim());
                cmts.append("\n");
                for (int line = lineNbr + 1; line < stopLine; ++line) {
                    appendFileLine(cmts, currentFileData, side, line);
                }
            }
            cmts.append("\n\n");
        }
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return cmts.toString();
}
#end_block

#method_before
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    cmts.append("Line " + line);
    if (fileData != null) {
        try {
            final String lineStr = fileData.getLine(side, line);
            cmts.append(": ");
            cmts.append(lineStr);
        } catch (Throwable cce) {
        // Don't quote the line if we can't safely convert it.
        }
    }
    cmts.append("\n");
}
#method_after
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    cmts.append("Line " + line);
    try {
        final String lineStr = fileData.getLine(side, line);
        cmts.append(": ");
        cmts.append(lineStr);
    } catch (Throwable e) {
    // Don't quote the line if we can't safely convert it.
    }
    cmts.append("\n");
}
#end_block

#method_before
private List<GroupReference> suggestAccountGroup(@Nullable final ProjectControl projectControl, final String query, final int limit) {
    final int n = limit <= 0 ? 10 : Math.min(limit, 10);
    List<GroupReference> out = Lists.newArrayListWithCapacity(n);
    for (GroupReference g : groupBackend.suggest(query)) {
        try {
            if (groupControlFactory.controlFor(g.getUUID()).isVisible() || (GroupBackends.isExactSuggestion(g, query) && (projectControl != null) && projectControl.isOwnerAnyRef())) {
                out.add(g);
                if (out.size() == n) {
                    break;
                }
            }
        } catch (NoSuchGroupException e) {
            continue;
        }
    }
    return out;
}
#method_after
private List<GroupReference> suggestAccountGroup(@Nullable final ProjectControl projectControl, final String query, final int limit) {
    final int n = limit <= 0 ? 10 : Math.min(limit, 10);
    List<GroupReference> out = Lists.newArrayListWithCapacity(n);
    for (GroupReference g : groupBackend.suggest(query)) {
        try {
            if (groupControlFactory.controlFor(g.getUUID()).isVisible() || (GroupBackends.isExactSuggestion(g, query) && projectControl != null && projectControl.isOwnerAnyRef())) {
                out.add(g);
                if (out.size() == n) {
                    break;
                }
            }
        } catch (NoSuchGroupException e) {
            continue;
        }
    }
    return out;
}
#end_block

#method_before
public void createProject() throws ProjectCreationFailedException {
    validateParameters();
    final Project.NameKey nameKey = createProjectArgs.getProject();
    try {
        final String head = createProjectArgs.permissionsOnly ? GitRepositoryManager.REF_CONFIG : createProjectArgs.branch.get(0);
        final Repository repo = repoManager.createRepository(nameKey);
        try {
            replication.replicateNewProject(nameKey, head);
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig();
            if (!createProjectArgs.permissionsOnly && createProjectArgs.createEmptyCommit) {
                createEmptyCommits(repo, nameKey, createProjectArgs.branch);
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.", e);
    } catch (RepositoryNotFoundException badName) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey, badName);
    } catch (IllegalStateException err) {
        try {
            final Repository repo = repoManager.openRepository(nameKey);
            try {
                if (repo.getObjectDatabase().exists()) {
                    throw new ProjectCreationFailedException("project \"" + nameKey + "\" exists");
                }
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException doesNotExist) {
            final String msg = "Cannot create " + nameKey;
            log.error(msg, err);
            throw new ProjectCreationFailedException(msg, err);
        }
    } catch (Exception e) {
        final String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw new ProjectCreationFailedException(msg, e);
    }
}
#method_after
public void createProject() throws ProjectCreationFailedException {
    validateParameters();
    final Project.NameKey nameKey = createProjectArgs.getProject();
    try {
        final String head = createProjectArgs.permissionsOnly ? GitRepositoryManager.REF_CONFIG : createProjectArgs.branch.get(0);
        final Repository repo = repoManager.createRepository(nameKey);
        try {
            NewProjectCreatedListener.Event event = new NewProjectCreatedListener.Event() {

                @Override
                public String getProjectName() {
                    return nameKey.get();
                }

                @Override
                public String getHeadName() {
                    return head;
                }
            };
            for (NewProjectCreatedListener l : createdListener) {
                l.onNewProjectCreated(event);
            }
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig();
            if (!createProjectArgs.permissionsOnly && createProjectArgs.createEmptyCommit) {
                createEmptyCommits(repo, nameKey, createProjectArgs.branch);
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.", e);
    } catch (RepositoryNotFoundException badName) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey, badName);
    } catch (IllegalStateException err) {
        try {
            final Repository repo = repoManager.openRepository(nameKey);
            try {
                if (repo.getObjectDatabase().exists()) {
                    throw new ProjectCreationFailedException("project \"" + nameKey + "\" exists");
                }
            } finally {
                repo.close();
            }
        } catch (IOException ioErr) {
            final String msg = "Cannot create " + nameKey;
            log.error(msg, err);
            throw new ProjectCreationFailedException(msg, ioErr);
        }
    } catch (Exception e) {
        final String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw new ProjectCreationFailedException(msg, e);
    }
}
#end_block

#method_before
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(createProjectArgs.submitType);
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                AccountGroup accountGroup = groupCache.get(ownerId);
                if (accountGroup != null) {
                    GroupReference group = config.resolve(accountGroup);
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        if (!config.commit(md)) {
            throw new IOException("Cannot create " + createProjectArgs.getProjectName());
        }
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
    replication.scheduleUpdate(createProjectArgs.getProject(), GitRepositoryManager.REF_CONFIG);
}
#method_after
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(createProjectArgs.submitType);
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                AccountGroup accountGroup = groupCache.get(ownerId);
                if (accountGroup != null) {
                    GroupReference group = config.resolve(accountGroup);
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        if (!config.commit(md)) {
            throw new IOException("Cannot create " + createProjectArgs.getProjectName());
        }
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
    referenceUpdated.fire(createProjectArgs.getProject(), GitRepositoryManager.REF_CONFIG);
}
#end_block

#method_before
private void createEmptyCommits(final Repository repo, final Project.NameKey project, final List<String> refs) throws IOException {
    ObjectInserter oi = repo.newObjectInserter();
    try {
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[] {}));
        cb.setAuthor(metaDataUpdateFactory.getUserPersonIdent());
        cb.setCommitter(serverIdent);
        cb.setMessage("Initial empty repository\n");
        ObjectId id = oi.insert(cb);
        oi.flush();
        for (String ref : refs) {
            RefUpdate ru = repo.updateRef(ref);
            ru.setNewObjectId(id);
            final Result result = ru.update();
            switch(result) {
                case NEW:
                    replication.scheduleUpdate(project, ref);
                    break;
                default:
                    {
                        throw new IOException(String.format("Failed to create ref \"%s\": %s", ref, result.name()));
                    }
            }
        }
    } catch (IOException e) {
        log.error("Cannot create empty commit for " + createProjectArgs.getProjectName(), e);
        throw e;
    } finally {
        oi.release();
    }
}
#method_after
private void createEmptyCommits(final Repository repo, final Project.NameKey project, final List<String> refs) throws IOException {
    ObjectInserter oi = repo.newObjectInserter();
    try {
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[] {}));
        cb.setAuthor(metaDataUpdateFactory.getUserPersonIdent());
        cb.setCommitter(serverIdent);
        cb.setMessage("Initial empty repository\n");
        ObjectId id = oi.insert(cb);
        oi.flush();
        for (String ref : refs) {
            RefUpdate ru = repo.updateRef(ref);
            ru.setNewObjectId(id);
            final Result result = ru.update();
            switch(result) {
                case NEW:
                    referenceUpdated.fire(project, ref);
                    break;
                default:
                    {
                        throw new IOException(String.format("Failed to create ref \"%s\": %s", ref, result.name()));
                    }
            }
        }
    } catch (IOException e) {
        log.error("Cannot create empty commit for " + createProjectArgs.getProjectName(), e);
        throw e;
    } finally {
        oi.release();
    }
}
#end_block

#method_before
public void start(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    manager = new LifecycleManager();
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(name, env, jarFile, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        manager.add(sysInjector);
    } else if (auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        manager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (sshModule != null && env.hasSshModule()) {
        sshInjector = sysInjector.createChildInjector(env.getSshModule(), sysInjector.getInstance(sshModule));
        manager.add(sshInjector);
    } else if (auto.sshModule != null && env.hasSshModule()) {
        sshInjector = sysInjector.createChildInjector(env.getSshModule(), auto.sshModule);
        manager.add(sshInjector);
    }
    if (httpModule != null && env.hasHttpModule()) {
        httpInjector = sysInjector.createChildInjector(env.getHttpModule(), sysInjector.getInstance(httpModule));
        manager.add(httpInjector);
    } else if (auto.httpModule != null && env.hasHttpModule()) {
        httpInjector = sysInjector.createChildInjector(env.getHttpModule(), auto.httpModule);
        manager.add(httpInjector);
    }
    manager.start();
}
#method_after
public void start(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    manager = new LifecycleManager();
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(name, env, jarFile, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        manager.add(sysInjector);
    } else if (auto != null && auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        manager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (env.hasSshModule()) {
        if (sshModule != null) {
            sshInjector = sysInjector.createChildInjector(env.getSshModule(), sysInjector.getInstance(sshModule));
            manager.add(sshInjector);
        } else if (auto != null && auto.sshModule != null) {
            sshInjector = sysInjector.createChildInjector(env.getSshModule(), auto.sshModule);
            manager.add(sshInjector);
        }
    }
    if (env.hasHttpModule()) {
        if (httpModule != null) {
            httpInjector = sysInjector.createChildInjector(env.getHttpModule(), sysInjector.getInstance(httpModule));
            manager.add(httpInjector);
        } else if (auto != null && auto.httpModule != null) {
            httpInjector = sysInjector.createChildInjector(env.getHttpModule(), auto.httpModule);
            manager.add(httpInjector);
        }
    }
    manager.start();
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore(repoManager));
    detail.setCanDeleteDraft(change.getStatus() == Change.Status.DRAFT && control.isOwner());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, repoManager, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch);
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    CurrentUser user = control.getCurrentUser();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#method_after
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#end_block

#method_before
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (!control.canRestore(repoManager)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RESTORE_NOT_PERMITTED));
    } else if (patch == null) {
        throw new NoSuchChangeException(changeId);
    } else {
        // Create a message to accompany the restored change
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
        if (changeComment != null && changeComment.length() > 0) {
            msgBuf.append("\n\n");
            msgBuf.append(changeComment);
        }
        cmsg.setMessage(msgBuf.toString());
        // Restore the change
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                    change.setStatus(Change.Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, restoredSenderFactory, "Change is not abandoned or patchset is not latest");
        hooks.doChangeRestoreHook(updatedChange, currentUser.getAccount(), changeComment, db);
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException, RepositoryNotFoundException, IOException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canRestore()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RESTORE_NOT_PERMITTED));
        return result;
    }
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Branch.NameKey destBranch = control.getChange().getDest();
    if (!ProjectUtil.branchExists(repoManager, destBranch)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.DEST_BRANCH_NOT_FOUND, destBranch.get()));
        return result;
    }
    // Create a message to accompany the restored change
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
    if (changeComment != null && changeComment.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(changeComment);
    }
    cmsg.setMessage(msgBuf.toString());
    // Restore the change
    final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.NEW);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, restoredSenderFactory, "Change is not abandoned or patchset is not latest");
    hooks.doChangeRestoreHook(updatedChange, currentUser.getAccount(), changeComment, db);
    return result;
}
#end_block

#method_before
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            if (!currentUser.getCapabilities().canAdministrateServer()) {
                String msg = String.format("fatal: %s does not have \"Administrator\" capability.", currentUser.getUserName());
                throw new UnloggedFailure(1, msg);
            }
            parseCommandLine();
            if (active && inactive) {
                throw new UnloggedFailure(1, "You can't use both --active and --inactive");
            }
            setAccount();
        }
    });
}
#method_after
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            if (!currentUser.getCapabilities().canAdministrateServer()) {
                String msg = String.format("fatal: %s does not have \"Administrator\" capability.", currentUser.getUserName());
                throw new UnloggedFailure(1, msg);
            }
            parseCommandLine();
            validate();
            setAccount();
        }
    });
}
#end_block

#method_before
private void setAccount() throws OrmException, IOException, InvalidSshKeyException, UnloggedFailure {
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw die("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    final Account account;
    AccountExternalId.Key key = new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username);
    AccountExternalId accExtId = db.accountExternalIds().get(key);
    if (accExtId != null) {
        account = db.accounts().get(accExtId.getAccountId());
    } else {
        throw die("Could not find user : " + username);
    }
    Account.Id id = account.getId();
    if (newEmail != null) {
        link(id, newEmail);
    }
    if (oldEmail != null) {
        deleteMail(id, oldEmail);
    }
    if (fullName != null && realm.allowsEdit(FieldName.FULL_NAME)) {
        account.setFullName(fullName);
    }
    if (active) {
        account.setActive(true);
    } else if (inactive) {
        account.setActive(false);
    }
    final String readAddKey = readSshKey(addSshKey);
    if (readAddKey != null) {
        addSshKey(readAddKey, account);
    }
    final String readDeleteKey = readSshKey(deleteSshKey);
    if (readDeleteKey != null) {
        deleteSshKeys(readDeleteKey, account);
    }
    db.accounts().update(Collections.singleton(account));
    byIdCache.evict(id);
    db.close();
}
#method_after
private void setAccount() throws OrmException, IOException, UnloggedFailure {
    final Account account = db.accounts().get(id);
    boolean accountUpdated = false;
    boolean sshKeysUpdated = false;
    for (String email : addEmails) {
        link(id, email);
    }
    for (String email : deleteEmails) {
        deleteMail(id, email);
    }
    if (fullName != null) {
        if (realm.allowsEdit(FieldName.FULL_NAME)) {
            account.setFullName(fullName);
        } else {
            throw new UnloggedFailure(1, "The realm doesn't allow editing names");
        }
    }
    if (active) {
        accountUpdated = true;
        account.setActive(true);
    } else if (inactive) {
        accountUpdated = true;
        account.setActive(false);
    }
    addSshKeys = readSshKey(addSshKeys);
    if (!addSshKeys.isEmpty()) {
        sshKeysUpdated = true;
        addSshKeys(addSshKeys, account);
    }
    deleteSshKeys = readSshKey(deleteSshKeys);
    if (!deleteSshKeys.isEmpty()) {
        sshKeysUpdated = true;
        deleteSshKeys(deleteSshKeys, account);
    }
    if (accountUpdated) {
        db.accounts().update(Collections.singleton(account));
        byIdCache.evict(id);
    }
    if (sshKeysUpdated) {
        sshKeyCache.evict(account.getUserName());
    }
    db.close();
}
#end_block

#method_before
private void deleteSshKeys(final String readDeleteKey, final Account account) throws OrmException {
    ResultSet<AccountSshKey> keys = db.accountSshKeys().byAccount(account.getId());
    if (readDeleteKey.equals("ALL")) {
        db.accountSshKeys().delete(keys);
    } else {
        for (AccountSshKey accountSshKey : keys) {
            if (accountSshKey.getSshPublicKey().equals(readDeleteKey)) {
                db.accountSshKeys().delete(Collections.singleton(accountSshKey));
            }
        }
    }
    sshKeyCache.evict(account.getUserName());
}
#method_after
private void deleteSshKeys(final List<String> keys, final Account account) throws OrmException {
    ResultSet<AccountSshKey> allKeys = db.accountSshKeys().byAccount(account.getId());
    if (keys.contains("ALL")) {
        db.accountSshKeys().delete(allKeys);
    } else {
        List<AccountSshKey> accountKeys = new ArrayList<AccountSshKey>();
        for (String key : keys) {
            for (AccountSshKey accountSshKey : allKeys) {
                if (key.trim().equals(accountSshKey.getSshPublicKey()) || accountSshKey.getComment().trim().equals(key)) {
                    accountKeys.add(accountSshKey);
                }
            }
        }
        db.accountSshKeys().delete(accountKeys);
    }
}
#end_block

#method_before
private void deleteMail(Account.Id id, final String mailAddress) throws UnloggedFailure {
    if (mailAddress.equals("ALL")) {
        ResultSet<AccountExternalId> ids;
        try {
            ids = db.accountExternalIds().byAccount(id);
        } catch (OrmException e) {
            throw die("Could not query database: " + e.getMessage());
        }
        for (AccountExternalId extId : ids) {
            unlink(id, extId.getEmailAddress());
        }
    } else {
        unlink(id, mailAddress);
    }
}
#method_after
private void deleteMail(Account.Id id, final String mailAddress) throws UnloggedFailure, OrmException {
    if (mailAddress.equals("ALL")) {
        ResultSet<AccountExternalId> ids = db.accountExternalIds().byAccount(id);
        for (AccountExternalId extId : ids) {
            if (extId.isScheme(AccountExternalId.SCHEME_MAILTO)) {
                unlink(id, extId.getEmailAddress());
            }
        }
    } else {
        AccountExternalId.Key key = new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, mailAddress);
        AccountExternalId extId = db.accountExternalIds().get(key);
        if (extId != null) {
            unlink(id, mailAddress);
        }
    }
}
#end_block

#method_before
private String readSshKey(String sshKey) throws UnsupportedEncodingException, IOException, InvalidSshKeyException {
    if (sshKey == null) {
        return null;
    }
    if ("-".equals(sshKey)) {
        sshKey = "";
        BufferedReader br = new BufferedReader(new InputStreamReader(in, "UTF-8"));
        String line;
        while ((line = br.readLine()) != null) {
            sshKey += line + "\n";
        }
    }
    return sshKey.trim();
}
#method_after
private List<String> readSshKey(final List<String> sshKeys) throws UnsupportedEncodingException, IOException {
    if (!sshKeys.isEmpty()) {
        String sshKey = "";
        int idx = sshKeys.indexOf("-");
        if (idx >= 0) {
            sshKey = "";
            BufferedReader br = new BufferedReader(new InputStreamReader(in, "UTF-8"));
            String line;
            while ((line = br.readLine()) != null) {
                sshKey += line + "\n";
            }
            sshKeys.set(idx, sshKey);
        }
    }
    return sshKeys;
}
#end_block

#method_before
public void initSshModule(String name) {
    name = pluginName;
}
#method_after
public void initSshModule(String pluginName) {
    command = Commands.named(pluginName);
}
#end_block

#method_before
@Override
protected LinkedBindingBuilder<Command> command(String name) {
    final CommandName parent = Commands.named(pluginName);
    return command(parent, name);
}
#method_after
protected LinkedBindingBuilder<Command> command(String subCmd) {
    return bind(Commands.key(command, subCmd));
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#end_block

#method_before
private void publishApprovals(ChangeControl ctl) throws InvalidChangeOperationException, OrmException {
    ChangeUtil.updated(change);
    final Set<ApprovalCategory.Id> dirty = new HashSet<ApprovalCategory.Id>();
    final List<PatchSetApproval> ins = new ArrayList<PatchSetApproval>();
    final List<PatchSetApproval> upd = new ArrayList<PatchSetApproval>();
    final Collection<PatchSetApproval> all = db.patchSetApprovals().byPatchSet(patchSetId).toList();
    final Map<ApprovalCategory.Id, PatchSetApproval> mine = mine(all);
    // 
    for (final ApprovalCategoryValue.Id want : approvals) {
        PatchSetApproval a = mine.get(want.getParentKey());
        if (a == null) {
            a = new PatchSetApproval(new // 
            PatchSetApproval.Key(patchSetId, user.getAccountId(), want.getParentKey()), want.get());
            a.cache(change);
            ins.add(a);
            all.add(a);
            mine.put(a.getCategoryId(), a);
            dirty.add(a.getCategoryId());
        }
    }
    // Normalize all of the items the user is changing.
    // 
    final FunctionState functionState = functionStateFactory.create(ctl, patchSetId, all);
    for (final ApprovalCategoryValue.Id want : approvals) {
        final PatchSetApproval a = mine.get(want.getParentKey());
        final short o = a.getValue();
        a.setValue(want.get());
        a.cache(change);
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            functionState.normalize(types.byId(a.getCategoryId()), a);
        }
        if (o != a.getValue()) {
            throw new InvalidChangeOperationException(types.byId(a.getCategoryId()).getCategory().getLabelName() + "=" + o + " not permitted");
        }
        if (!ins.contains(a)) {
            upd.add(a);
        }
    }
    // Format a message explaining the actions taken.
    // 
    final StringBuilder msgbuf = new StringBuilder();
    for (final ApprovalType at : types.getApprovalTypes()) {
        if (dirty.contains(at.getCategory().getId())) {
            final PatchSetApproval a = mine.get(at.getCategory().getId());
            if (a.getValue() == 0 && ins.contains(a)) {
                // Don't say "no score" for an initial entry.
                continue;
            }
            final ApprovalCategoryValue val = at.getValue(a);
            if (msgbuf.length() > 0) {
                msgbuf.append("; ");
            }
            if (val != null && val.getName() != null && !val.getName().isEmpty()) {
                msgbuf.append(val.getName());
            } else {
                msgbuf.append(at.getCategory().getName());
                msgbuf.append(" ");
                if (a.getValue() > 0)
                    msgbuf.append('+');
                msgbuf.append(a.getValue());
            }
        }
    }
    // 
    for (PatchSetApproval a : all) {
        if (!user.getAccountId().equals(a.getAccountId())) {
            a.cache(change);
            upd.add(a);
        }
    }
    db.patchSetApprovals().update(upd);
    db.patchSetApprovals().insert(ins);
    summarizeInlineComments(msgbuf);
    message(msgbuf.toString());
}
#method_after
private void publishApprovals(ChangeControl ctl) throws InvalidChangeOperationException, OrmException {
    ChangeUtil.updated(change);
    final Set<ApprovalCategory.Id> dirty = new HashSet<ApprovalCategory.Id>();
    final List<PatchSetApproval> ins = new ArrayList<PatchSetApproval>();
    final List<PatchSetApproval> upd = new ArrayList<PatchSetApproval>();
    final Collection<PatchSetApproval> all = db.patchSetApprovals().byPatchSet(patchSetId).toList();
    final Map<ApprovalCategory.Id, PatchSetApproval> mine = mine(all);
    // 
    for (final ApprovalCategoryValue.Id want : approvals) {
        PatchSetApproval a = mine.get(want.getParentKey());
        if (a == null) {
            a = new PatchSetApproval(new // 
            PatchSetApproval.Key(patchSetId, user.getAccountId(), want.getParentKey()), want.get());
            a.cache(change);
            ins.add(a);
            all.add(a);
            mine.put(a.getCategoryId(), a);
            dirty.add(a.getCategoryId());
        }
    }
    // Normalize all of the items the user is changing.
    // 
    final FunctionState functionState = functionStateFactory.create(ctl, patchSetId, all);
    for (final ApprovalCategoryValue.Id want : approvals) {
        final PatchSetApproval a = mine.get(want.getParentKey());
        final short o = a.getValue();
        a.setValue(want.get());
        a.cache(change);
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            functionState.normalize(types.byId(a.getCategoryId()), a);
        }
        if (want.get() != a.getValue()) {
            throw new InvalidChangeOperationException(types.byId(a.getCategoryId()).getCategory().getLabelName() + "=" + want.get() + " not permitted");
        }
        if (o != a.getValue()) {
            // Value changed, ensure we update the database.
            // 
            a.setGranted();
            dirty.add(a.getCategoryId());
        }
        if (!ins.contains(a)) {
            upd.add(a);
        }
    }
    // Format a message explaining the actions taken.
    // 
    final StringBuilder msgbuf = new StringBuilder();
    for (final ApprovalType at : types.getApprovalTypes()) {
        if (dirty.contains(at.getCategory().getId())) {
            final PatchSetApproval a = mine.get(at.getCategory().getId());
            if (a.getValue() == 0 && ins.contains(a)) {
                // Don't say "no score" for an initial entry.
                continue;
            }
            final ApprovalCategoryValue val = at.getValue(a);
            if (msgbuf.length() > 0) {
                msgbuf.append("; ");
            }
            if (val != null && val.getName() != null && !val.getName().isEmpty()) {
                msgbuf.append(val.getName());
            } else {
                msgbuf.append(at.getCategory().getName());
                msgbuf.append(" ");
                if (a.getValue() > 0)
                    msgbuf.append('+');
                msgbuf.append(a.getValue());
            }
        }
    }
    // 
    for (PatchSetApproval a : all) {
        if (!user.getAccountId().equals(a.getAccountId())) {
            a.cache(change);
            upd.add(a);
        }
    }
    db.patchSetApprovals().update(upd);
    db.patchSetApprovals().insert(ins);
    summarizeInlineComments(msgbuf);
    message(msgbuf.toString());
}
#end_block

#method_before
private void email() {
    try {
        if (message != null) {
            final CommentSender cm = commentSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfoFactory.get(db, patchSetId));
            cm.setChangeMessage(message);
            cm.setPatchLineComments(drafts);
            cm.send();
        }
    } catch (EmailException e) {
        log.error("Cannot send comments by email for patch set " + patchSetId, e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
    }
}
#method_after
private void email() {
    if (message == null) {
        return;
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSetInfo patchSetInfo;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSetInfo = patchSetInfoFactory.get(reviewDb, patchSetId);
                } finally {
                    reviewDb.close();
                }
            } catch (PatchSetInfoNotAvailableException e) {
                log.error("Cannot read PatchSetInfo of " + patchSetId, e);
                return;
            } catch (OrmException e) {
                log.error("Cannot email comments for " + patchSetId, e);
                return;
            }
            try {
                final CommentSender cm = commentSenderFactory.create(change);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, patchSetInfo);
                cm.setChangeMessage(message);
                cm.setPatchLineComments(drafts);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot email comments for " + patchSetId, e);
            }
        }

        @Override
        public String toString() {
            return "send-email comments";
        }
    }));
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
private DependencyAttribute newDependsOn(Change c, PatchSet ps) {
    DependencyAttribute d = newDependencyAttribute(c, ps);
    if (c.currPatchSetId().equals(ps.getId())) {
        d.isCurrentPatchSet = "true";
    } else {
        d.isCurrentPatchSet = "false";
    }
    return d;
}
#method_after
private DependencyAttribute newDependsOn(Change c, PatchSet ps) {
    DependencyAttribute d = newDependencyAttribute(c, ps);
    d.isCurrentPatchSet = c.currPatchSetId().equals(ps.getId());
    return d;
}
#end_block

#method_before
public Task beginSubTask(final String subTask, final int subTaskWork) {
    Task task = new Task(subTaskWork);
    tasks.put(subTask, task);
    return task;
}
#method_after
public Task beginSubTask(final String subTask, final int subTaskWork) {
    Task task = new Task(subTask, subTaskWork);
    tasks.add(task);
    return task;
}
#end_block

#method_before
private StringBuilder format() {
    StringBuilder s = new StringBuilder().append("\r").append(taskName).append(':');
    if (!tasks.isEmpty()) {
        boolean first = true;
        for (Map.Entry<String, Task> e : tasks.entrySet()) {
            Task t = e.getValue();
            if (t.count == 0) {
                continue;
            }
            if (!first) {
                s.append(',');
            } else {
                first = false;
            }
            s.append(' ').append(e.getKey()).append(": ");
            if (t.total == UNKNOWN) {
                s.append(t.count);
            } else {
                s.append(t.count * 100 / t.total).append("% (").append(t.count).append('/').append(t.total).append(')');
            }
        }
    }
    if (spinnerState != NO_SPINNER) {
        // Don't output a spinner until the alarm fires for the first time.
        s.append(" (").append(spinnerState).append(')');
    }
    return s;
}
#method_after
private StringBuilder format() {
    StringBuilder s = new StringBuilder().append("\r").append(taskName).append(':');
    if (!tasks.isEmpty()) {
        boolean first = true;
        for (Task t : tasks) {
            int count = t.count;
            if (count == 0) {
                continue;
            }
            if (!first) {
                s.append(',');
            } else {
                first = false;
            }
            s.append(' ').append(t.name).append(": ");
            if (t.total == UNKNOWN) {
                s.append(count);
            } else {
                s.append(String.format("%d%% (%d/%d)", count * 100 / t.total, count, t.total));
            }
        }
    }
    if (spinnerState != NO_SPINNER) {
        // Don't output a spinner until the alarm fires for the first time.
        s.append(" (").append(spinnerState).append(')');
    }
    return s;
}
#end_block

#method_before
@Override
public void advertiseRefs(ReceiveSession rs) throws ServiceMayNotContinueException {
    base.advertiseRefs(rs);
    HashMap<String, Ref> r = new HashMap<String, Ref>();
    for (Map.Entry<String, Ref> e : rs.getAdvertisedRefs().entrySet()) {
        if (!e.getKey().startsWith("refs/changes/")) {
            r.put(e.getKey(), e.getValue());
        }
    }
    rs.setAdvertisedRefs(r, rs.getAdvertisedObjects());
}
#method_after
@Override
public void advertiseRefs(UploadPack us) {
    throw new UnsupportedOperationException("ReceiveCommitsAdvertiseRefsHook cannot be used for UploadPack");
}
#end_block

#method_before
@Override
public void onPreReceive(final ReceiveSession rs, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#method_after
@Override
public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceiveSession rs, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                rp.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                rp.sendMessage("  " + url + c.getChangeId());
            }
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                rp.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                rp.sendMessage("  " + url + c.getChangeId());
            }
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceiveSession().sendMessage(sb.toString());
}
#method_after
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceivePack().sendMessage(sb.toString());
}
#end_block

#method_before
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotAuthorizedException {
    final ProjectControl pc = (ProjectControl) req.getAttribute(ATT_CONTROL);
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        // Anonymous users are not permitted to push.
        throw new ServiceNotAuthorizedException();
    }
    final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
    final ReceiveCommits rc = factory.create(pc, db);
    final ReceivePack rp = (ReceivePack) rc.getReceiveSession();
    rp.setRefLogIdent(user.newRefLogIdent());
    req.setAttribute(ATT_RC, rc);
    session.get().setAccessPath(AccessPath.GIT);
    return rp;
}
#method_after
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotAuthorizedException {
    final ProjectControl pc = (ProjectControl) req.getAttribute(ATT_CONTROL);
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        // Anonymous users are not permitted to push.
        throw new ServiceNotAuthorizedException();
    }
    final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
    final ReceiveCommits rc = factory.create(pc, db);
    rc.getReceivePack().setRefLogIdent(user.newRefLogIdent());
    req.setAttribute(ATT_RC, rc);
    session.get().setAccessPath(AccessPath.GIT);
    return rc.getReceivePack();
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = (ReceivePack) rc.getReceiveSession();
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        if (isGet) {
            rc.advertiseHistory();
        }
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        rc.advertiseHistory();
        cache.remove(cacheKey);
    } else {
        Set<ObjectId> ids = cache.get(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.remove(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<ObjectId>(rp.getAdvertisedObjects())));
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        if (isGet) {
            rc.advertiseHistory();
        }
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        rc.advertiseHistory();
        cache.remove(cacheKey);
    } else {
        Set<ObjectId> ids = cache.get(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.remove(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<ObjectId>(rp.getAdvertisedObjects())));
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunReceivePack()) {
        throw new Failure(1, "fatal: receive-pack not permitted on this server");
    }
    final ReceiveCommits receive = factory.create(projectControl, repo);
    Capable r = receive.canUpload();
    if (r != Capable.OK) {
        throw new UnloggedFailure(1, "\nfatal: " + r.getMessage());
    }
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    receive.addReviewers(reviewerId);
    receive.addExtraCC(ccId);
    final ReceivePack rp = (ReceivePack) receive.getReceiveSession();
    rp.setRefLogIdent(currentUser.newRefLogIdent());
    rp.setTimeout(config.getTimeout());
    rp.setMaxObjectSizeLimit(config.getMaxObjectSizeLimit());
    try {
        receive.advertiseHistory();
        rp.receive(in, out, err);
    } catch (UnpackException badStream) {
        // This may have been triggered by branch level access controls.
        // Log what the heck is going on, as detailed as we can.
        // 
        StringBuilder msg = new StringBuilder();
        msg.append("Unpack error on project \"" + projectControl.getProject().getName() + "\":\n");
        msg.append("  AdvertiseRefsHook: " + rp.getAdvertiseRefsHook());
        if (rp.getAdvertiseRefsHook() == AdvertiseRefsHook.DEFAULT) {
            msg.append("DEFAULT");
        } else if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            msg.append("VisibleRefFilter");
        } else {
            msg.append(rp.getAdvertiseRefsHook().getClass());
        }
        msg.append("\n");
        if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            Map<String, Ref> adv = rp.getAdvertisedRefs();
            msg.append("  Visible references (" + adv.size() + "):\n");
            for (Ref ref : adv.values()) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
            List<Ref> hidden = new ArrayList<Ref>();
            for (Ref ref : rp.getRepository().getAllRefs().values()) {
                if (!adv.containsKey(ref.getName())) {
                    hidden.add(ref);
                }
            }
            msg.append("  Hidden references (" + hidden.size() + "):\n");
            for (Ref ref : hidden) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
        }
        IOException detail = new IOException(msg.toString(), badStream);
        throw new Failure(128, "fatal: Unpack error, check server log", detail);
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunReceivePack()) {
        throw new Failure(1, "fatal: receive-pack not permitted on this server");
    }
    final ReceiveCommits receive = factory.create(projectControl, repo);
    Capable r = receive.canUpload();
    if (r != Capable.OK) {
        throw new UnloggedFailure(1, "\nfatal: " + r.getMessage());
    }
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    receive.addReviewers(reviewerId);
    receive.addExtraCC(ccId);
    final ReceivePack rp = receive.getReceivePack();
    rp.setRefLogIdent(currentUser.newRefLogIdent());
    rp.setTimeout(config.getTimeout());
    rp.setMaxObjectSizeLimit(config.getMaxObjectSizeLimit());
    try {
        receive.advertiseHistory();
        rp.receive(in, out, err);
    } catch (UnpackException badStream) {
        // This may have been triggered by branch level access controls.
        // Log what the heck is going on, as detailed as we can.
        // 
        StringBuilder msg = new StringBuilder();
        msg.append("Unpack error on project \"" + projectControl.getProject().getName() + "\":\n");
        msg.append("  AdvertiseRefsHook: " + rp.getAdvertiseRefsHook());
        if (rp.getAdvertiseRefsHook() == AdvertiseRefsHook.DEFAULT) {
            msg.append("DEFAULT");
        } else if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            msg.append("VisibleRefFilter");
        } else {
            msg.append(rp.getAdvertiseRefsHook().getClass());
        }
        msg.append("\n");
        if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            Map<String, Ref> adv = rp.getAdvertisedRefs();
            msg.append("  Visible references (" + adv.size() + "):\n");
            for (Ref ref : adv.values()) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
            List<Ref> hidden = new ArrayList<Ref>();
            for (Ref ref : rp.getRepository().getAllRefs().values()) {
                if (!adv.containsKey(ref.getName())) {
                    hidden.add(ref);
                }
            }
            msg.append("  Hidden references (" + hidden.size() + "):\n");
            for (Ref ref : hidden) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
        }
        IOException detail = new IOException(msg.toString(), badStream);
        throw new Failure(128, "fatal: Unpack error, check server log", detail);
    }
}
#end_block

#method_before
private JdbcAccess<Data, Data.DataKey> createClassUnderTest() {
    final SqlDialect dialect = mock(SqlDialect.class, CALLS_REAL_METHODS);
    JdbcSchema schema = setupSchema(dialect);
    JdbcAccess<Data, Data.DataKey> classUnderTest = new DataJdbcAccess(schema);
    return classUnderTest;
}
#method_after
private JdbcAccess<Data, Data.DataKey> createClassUnderTest() {
    return createJdbcAccess(DIALECT);
}
#end_block

#method_before
private JdbcSchema setupSchema(final SqlDialect dialect) {
    @SuppressWarnings("rawtypes")
    Database db = mock(Database.class);
    try {
        stub(db.getDialect()).toReturn(dialect);
        JdbcSchema schema = new Schema(db, conn);
        return schema;
    } catch (OrmException e) {
        throw new RuntimeException(e);
    }
}
#method_after
private JdbcSchema setupSchema(final SqlDialect dialect) {
    @SuppressWarnings("rawtypes")
    Database db = mock(Database.class);
    try {
        when(db.getDialect()).thenReturn(dialect);
        when(db.newConnection()).thenReturn(conn);
        JdbcSchema schema = new Schema(db);
        return schema;
    } catch (OrmException e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
@Test
public void testInsertNothing() throws OrmException, SQLException {
    setup();
    createClassUnderTest().insert(NO_DATA);
}
#method_after
@Test
public void testInsertNothing() throws OrmException {
    setup();
    createClassUnderTest().insert(NO_DATA);
}
#end_block

#method_before
@Test
public void testInsertOne() throws OrmException, SQLException {
    stubExecuteBatchOK(INSERT, 1);
    createClassUnderTest().insert(ONE_ROW);
}
#method_after
@Test
public void testInsertOne() throws OrmException, SQLException {
    PreparedStatement insert = stubStatementWithUpdateCounts(INSERT, 1);
    createClassUnderTest().insert(ONE_ROW);
    assertUsedBatchingOnly(insert);
}
#end_block

#method_before
@Test
public void testUpdateNothing() throws OrmException, SQLException {
    createClassUnderTest().update(NO_DATA);
}
#method_after
@Test
public void testUpdateNothing() throws OrmException {
    createClassUnderTest().update(NO_DATA);
}
#end_block

#method_before
@Test
public void testUpdateOne() throws OrmException, SQLException {
    stubExecuteBatchOK(UPDATE, 1);
    createClassUnderTest().update(ONE_ROW);
}
#method_after
@Test
public void testUpdateOne() throws OrmException, SQLException {
    PreparedStatement update = stubStatementWithUpdateCounts(UPDATE, 1);
    createClassUnderTest().update(ONE_ROW);
    assertUsedBatchingOnly(update);
}
#end_block

#method_before
@Test
public void testUpsertOneExisting() throws OrmException, SQLException {
    stubExecuteBatchOK(UPDATE, 1);
    createClassUnderTest().upsert(ONE_ROW);
}
#method_after
@Test
public void testUpsertOneExisting() throws OrmException, SQLException {
    PreparedStatement update = stubStatementWithUpdateCounts(UPDATE, 1);
    PreparedStatement insert = stubStatementWithUpdateCounts(INSERT);
    createClassUnderTest().upsert(ONE_ROW);
    assertUsedBatchingOnly(update);
    assertNotUsed(insert);
}
#end_block

#method_before
@Test
public void testUpsertOneException() throws OrmException, SQLException {
    stubExecuteBatchException(UPDATE, new BatchUpdateException());
    try {
        createClassUnderTest().upsert(ONE_ROW);
        fail("missingException");
    } catch (OrmException e) {
    // expected
    }
}
#method_after
@Test
public void testUpsertOneException() throws OrmException, SQLException {
    SQLException exception = new BatchUpdateException();
    PreparedStatement update = stubStatementThrowExceptionOnExecute(UPDATE, exception);
    JdbcAccess<Data, Data.DataKey> classUnderTest = createClassUnderTest();
    try {
        classUnderTest.upsert(ONE_ROW);
        fail("missingException");
    } catch (OrmException e) {
        // expected
        assertSame(e.getCause(), exception);
    }
    assertUsedBatchingOnly(update);
}
#end_block

#method_before
@Test
public void testUpsertOneNotExisting() throws OrmException, SQLException {
    stubExecuteBatchOK(UPDATE);
    PreparedStatement insert = stubExecuteBatchOK(INSERT, 1);
    createClassUnderTest().upsert(ONE_ROW);
    verifyIds(insert, 1);
}
#method_after
@Test
public void testUpsertOneNotExisting() throws OrmException, SQLException {
    PreparedStatement update = stubStatementWithUpdateCounts(UPDATE);
    PreparedStatement insert = stubStatementWithUpdateCounts(INSERT, 1);
    createClassUnderTest().upsert(ONE_ROW);
    assertUsedBatchingOnly(update);
    assertUsedBatchingOnly(insert);
    assertExpectedIdsUsed(insert, 1);
}
#end_block

#method_before
@Test
public void testDeleteOneExisting() throws SQLException, OrmException {
    stubExecuteBatchOK(DELETE, 1);
    createClassUnderTest().delete(ONE_ROW);
}
#method_after
@Test
public void testDeleteOneExisting() throws SQLException, OrmException {
    PreparedStatement delete = stubStatementWithUpdateCounts(DELETE, 1);
    createClassUnderTest().delete(ONE_ROW);
    assertUsedBatchingOnly(delete);
}
#end_block

#method_before
@Test
public void testDeleteOneNotExisting() throws SQLException, OrmException {
    stubExecuteBatchOK(DELETE, 0);
    try {
        createClassUnderTest().delete(ONE_ROW);
        fail("missing OrmConcurrencyException");
    } catch (OrmConcurrencyException e) {
    // expected
    }
}
#method_after
@Test
public void testDeleteOneNotExisting() throws SQLException, OrmException {
    PreparedStatement delete = stubStatementWithUpdateCounts(DELETE, 0);
    JdbcAccess<Data, Data.DataKey> classUnderTest = createClassUnderTest();
    try {
        classUnderTest.delete(ONE_ROW);
        fail("missing OrmConcurrencyException");
    } catch (OrmConcurrencyException e) {
    // expected
    }
    assertUsedBatchingOnly(delete);
}
#end_block

#method_before
public static String toPatchSideBySide(final Patch.Key id) {
    return toPatch("", id);
}
#method_after
public static String toPatchSideBySide(final Patch.Key id) {
    return toPatch("", null, id);
}
#end_block

#method_before
public static String toPatchSideBySide(final Patch.Key id) {
    return toPatch("", id);
}
#method_after
public static String toPatchSideBySide(PatchSet.Id diffBase, Patch.Key id) {
    return toPatch("", diffBase, id);
}
#end_block

#method_before
public static String toPatchUnified(final Patch.Key id) {
    return toPatch("unified", id);
}
#method_after
public static String toPatchUnified(final Patch.Key id) {
    return toPatch("unified", null, id);
}
#end_block

#method_before
public static String toPatchUnified(final Patch.Key id) {
    return toPatch("unified", id);
}
#method_after
public static String toPatchUnified(PatchSet.Id diffBase, Patch.Key id) {
    return toPatch("unified", diffBase, id);
}
#end_block

#method_before
public static String toPatch(final PatchScreen.Type type, final Patch.Key id) {
    if (type == PatchScreen.Type.SIDE_BY_SIDE) {
        return toPatchSideBySide(id);
    } else {
        return toPatchUnified(id);
    }
}
#method_after
private static String toPatch(String type, PatchSet.Id diffBase, Patch.Key id) {
    PatchSet.Id ps = id.getParentKey();
    Change.Id c = ps.getParentKey();
    StringBuilder p = new StringBuilder();
    p.append("/c/").append(c).append("/");
    if (diffBase != null) {
        p.append(diffBase.get()).append("..");
    }
    p.append(ps.get()).append("/").append(KeyUtil.encode(id.get()));
    if (type != null && !type.isEmpty()) {
        p.append(",").append(type);
    }
    return p.toString();
}
#end_block

#method_before
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, // 
        panel == null ? // 
        new ChangeScreen(id) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, rest);
        patch(token, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, new ChangeScreen(ps));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#method_after
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, // 
        panel == null ? // 
        new ChangeScreen(id) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(dotdot + 2)));
    } else {
        base = null;
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    }
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, rest);
        patch(token, base, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, new ChangeScreen(ps));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#end_block

#method_before
public static void patch(String token, final Patch.Key id, final int patchIndex, final PatchSetDetail patchSetDetail, final PatchTable patchTable, final PatchScreen.TopView topView, final String panelType) {
    final String parametersUrl;
    if (token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START) != -1) {
        parametersUrl = token.substring(token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START) + 1);
        token = token.substring(0, token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START));
    } else {
        parametersUrl = null;
    }
    final PatchScreen.TopView top = topView == null ? Gerrit.getPatchScreenTopView() : topView;
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            Gerrit.display(token, select());
        }

        private Screen select() {
            if (id != null) {
                String panel = panelType;
                if (panel == null) {
                    int c = token.lastIndexOf(',');
                    panel = 0 <= c ? token.substring(c + 1) : "";
                }
                if ("".equals(panel)) {
                    return new // 
                    PatchScreen.SideBySide(// 
                    id, // 
                    patchIndex, // 
                    patchSetDetail, // 
                    patchTable, // 
                    top, // 
                    parametersUrl);
                } else if ("unified".equals(panel)) {
                    return new // 
                    PatchScreen.Unified(// 
                    id, // 
                    patchIndex, // 
                    patchSetDetail, // 
                    patchTable, // 
                    top, // 
                    parametersUrl);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
public static void patch(String token, PatchSet.Id base, Patch.Key id, int patchIndex, PatchSetDetail patchSetDetail, PatchTable patchTable, PatchScreen.TopView topView) {
    patch(token, base, id, patchIndex, patchSetDetail, patchTable, topView, null);
}
#end_block

#method_before
private static String skip(String token) {
    if (token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START) != -1) {
        return token.substring(0, token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START)).substring(prefixlen);
    } else {
        return token.substring(prefixlen);
    }
}
#method_after
private static String skip(String token) {
    return token.substring(prefixlen);
}
#end_block

#method_before
private void update(AccountDiffPreference dp) {
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#method_after
private void update(AccountDiffPreference dp) {
    // Did the user just turn on auto-review?
    if (!reviewed.getValue() && prefs.getOld().isManualReview() && !dp.isManualReview()) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable(prefs);
                    fileList.display(result);
                    patchIndex = fileList.indexOf(patchKey);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable(prefs);
                    fileList.display(idSideA, result);
                    patchIndex = fileList.indexOf(patchKey);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(idSideA, patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable(prefs);
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#method_after
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable(prefs);
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(idSideA, result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.display(diffBaseId, detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void populateDiffAllActions(final PatchSetDetail detail) {
    diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    addHandlerForDiffButton(detail);
    actionsPanel.add(diffAllSideBySide);
    actionsPanel.add(diffAllUnified);
}
#method_after
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchSideBySide(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchUnified(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#end_block

#method_before
private void populateDeleteDraftPatchSetAction() {
    final Button b = new Button(Util.C.buttonDeleteDraftPatchSet());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            b.setEnabled(false);
            PatchUtil.DETAIL_SVC.deleteDraftPatchSet(patchSet.getId(), new GerritCallback<VoidResult>() {

                public void onSuccess(VoidResult result) {
                    Gerrit.display(PageLinks.MINE);
                }

                @Override
                public void onFailure(Throwable caught) {
                    b.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    actionsPanel.add(b);
}
#method_after
private void populateDeleteDraftPatchSetAction() {
    final Button b = new Button(Util.C.buttonDeleteDraftPatchSet());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            b.setEnabled(false);
            PatchUtil.DETAIL_SVC.deleteDraftPatchSet(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                public void onSuccess(final ChangeDetail result) {
                    if (result != null) {
                        changeScreen.update(result);
                    } else {
                        Gerrit.display(PageLinks.MINE);
                    }
                }

                @Override
                public void onFailure(Throwable caught) {
                    b.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    actionsPanel.add(b);
}
#end_block

#method_before
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.setPatchSetIdToCompareWith(diffBaseId);
                patchTable.display(result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
            hOfdiffAllSideBySide.removeHandler();
            hOfdiffAllUnified.removeHandler();
            addHandlerForDiffButton(result);
        }
    });
}
#method_after
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.display(diffBaseId, result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public void go() {
    // 
    Dispatcher.patch(// 
    getTargetHistoryToken(), // 
    patchKey, // 
    patchIndex, // 
    patchSetDetail, parentPatchTable, // 
    topView);
}
#method_after
@Override
public void go() {
    // 
    Dispatcher.patch(// 
    getTargetHistoryToken(), // 
    base, // 
    patchKey, // 
    patchIndex, // 
    patchSetDetail, parentPatchTable, // 
    topView);
}
#end_block

#method_before
private void update(AccountDiffPreference dp) {
    // Did the user just turn on auto-review?
    if (!reviewed.getValue() && !dp.isManualReview()) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#method_after
private void update(AccountDiffPreference dp) {
    // Did the user just turn on auto-review?
    if (!reviewed.getValue() && prefs.getOld().isManualReview() && !dp.isManualReview()) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean revd = false;
        if (isFirst && !prefs.get().isManualReview()) {
            revd = true;
            setReviewedByCurrentUser(revd);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    revd = p.isReviewedByCurrentUser();
                }
            }
        }
        reviewed.setValue(revd);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#end_block

#method_before
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AddBranch.Factory.class);
            factory(ChangeProjectAccess.Factory.class);
            factory(CreateProjectHandler.Factory.class);
            factory(ChangeProjectSettings.Factory.class);
            factory(DeleteBranches.Factory.class);
            factory(ListBranches.Factory.class);
            factory(VisibleProjects.Factory.class);
            factory(ProjectAccessFactory.Factory.class);
            factory(ProjectDetailFactory.Factory.class);
            factory(RetrieveParentCandidatesHandler.Factory.class);
        }
    });
    rpc(ProjectAdminServiceImpl.class);
}
#method_after
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AddBranch.Factory.class);
            factory(ChangeProjectAccess.Factory.class);
            factory(CreateProjectHandler.Factory.class);
            factory(ChangeProjectSettings.Factory.class);
            factory(DeleteBranches.Factory.class);
            factory(ListBranches.Factory.class);
            factory(VisibleProjects.Factory.class);
            factory(VisibleProjectDetails.Factory.class);
            factory(ProjectAccessFactory.Factory.class);
            factory(ProjectDetailFactory.Factory.class);
            factory(SuggestParentCandidatesHandler.Factory.class);
        }
    });
    rpc(ProjectAdminServiceImpl.class);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    vp = new VerticalPanel();
    addCreateProjectPanel();
    /* popup */
    projectListPopup = new ProjectListPopup(Util.C.projects());
    projectListPopup.addProjectListPopupHandler(new ProjectListPopupHandler() {

        @Override
        public void onClose(ProjectListPopupOnCloseEvent projectListPopupEvent) {
            resetHandlerRegistration();
        }

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            sugestParent.setText(projectListPopupEvent.getProjectName());
        }

        @Override
        public void onMovePointer(ProjectListPopupOnMovePointerEvent projectListPopupEvent) {
            // prevent user input from being overwritten by simply poping up
            if (!projectListPopupEvent.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectListPopupEvent.getProjectName());
            }
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
}
#end_block

#method_before
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    final HorizontalPanel bp = new HorizontalPanel();
    bp.add(create);
    bp.add(browse);
    fp.add(bp);
    vp.add(fp);
    initSuggestedParents();
    add(vp);
}
#method_after
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    fp.add(create);
    VerticalPanel vp = new VerticalPanel();
    vp.add(fp);
    initSuggestedParents();
    vp.add(suggestedParentsTab);
    add(vp);
}
#end_block

#method_before
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            displayPopup();
        }
    });
}
#method_after
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
}
#end_block

#method_before
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final Project k) {
            final Anchor projectLink = new Anchor(k.getName());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).getName());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.getDescription());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    vp.add(suggestedParentsTab);
    Util.PROJECT_SVC.suggestParentCandidates(new AsyncCallback<List<Project>>() {

        @Override
        public void onSuccess(List<Project> result) {
            if (result != null && !result.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(result);
                suggestedParentsTab.finishDisplay();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final Project k) {
            final Anchor projectLink = new Anchor(k.getName());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).getName());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.getDescription());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    Util.PROJECT_SVC.suggestParentCandidates(new GerritCallback<List<Project>>() {

        @Override
        public void onSuccess(List<Project> result) {
            if (result != null && !result.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(result);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#end_block

#method_before
private void addGrid(final VerticalPanel fp) {
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.columnProjectName() + ":");
    grid.setWidget(0, 1, project);
    grid.setText(1, 0, Util.C.headingParentProjectName() + ":");
    grid.setWidget(1, 1, sugestParent);
    fp.add(grid);
}
#method_after
private void addGrid(final VerticalPanel fp) {
    final Grid grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.columnProjectName() + ":");
    grid.setWidget(0, 1, project);
    grid.setText(1, 0, Util.C.headingParentProjectName() + ":");
    grid.setWidget(1, 1, sugestParent);
    fp.add(grid);
}
#end_block

#method_before
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()) {

                @Override
                public void setText(final String t) {
                }
            }.center();
            enableForm(true);
        }
    });
}
#method_after
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()).center();
            enableForm(true);
        }
    });
}
#end_block

#method_before
@Override
public void suggestParentCandidates(AsyncCallback<List<Project>> callback) {
    RetrieveParentCandidatesHandlerFactory.create().to(callback);
}
#method_after
@Override
public void suggestParentCandidates(AsyncCallback<List<Project>> callback) {
    suggestParentCandidatesHandlerFactory.create().to(callback);
}
#end_block

#method_before
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, AsyncCallback<ProjectAccess> cb) {
    ObjectId base = ObjectId.fromString(baseRevision);
    changeProjectAccessFactory.create(projectName, base, sections, msg).to(cb);
}
#method_after
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, AsyncCallback<ProjectAccess> cb) {
    ObjectId base;
    if (baseRevision != null && !baseRevision.isEmpty()) {
        base = ObjectId.fromString(baseRevision);
    } else {
        base = null;
    }
    changeProjectAccessFactory.create(projectName, base, sections, msg).to(cb);
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDelete()) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
public boolean canPublish(final ReviewDb db) throws OrmException {
    return isOwner() && isVisible(db);
}
#method_after
public boolean canPublish(final ReviewDb db) throws OrmException {
    return change.getStatus() == Change.Status.DRAFT && isOwner() && isVisible(db);
}
#end_block

#method_before
public boolean canDelete(final ReviewDb db) throws OrmException {
    return isOwner() && isVisible(db);
}
#method_after
public boolean canDelete(final ReviewDb db) throws OrmException {
    return change.getStatus() == Change.Status.DRAFT && isOwner() && isVisible(db);
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanPublish(control.canDelete(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setCanDeleteDraft(change.getStatus() == Change.Status.DRAFT && control.isOwner());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setCanDeleteDraft(control.canDelete(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case CHANGE_NOT_VISIBLE:
                errMsg += "not permitted to review change";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#method_after
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case PUBLISH_NOT_PERMITTED:
                errMsg += "not permitted to publish change";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#end_block

#method_before
@Override
public ReviewResult call() throws NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    if (!control.isVisible(db) && !control.isOwner()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_NOT_VISIBLE));
    } else {
        db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

            @Override
            public PatchSet update(PatchSet patchset) {
                if (patchset.isDraft()) {
                    patchset.setDraft(false);
                }
                return null;
            }
        });
        final Change change = db.changes().get(changeId);
        if (change.getStatus() == Change.Status.DRAFT) {
            db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus() == Change.Status.DRAFT && change.currentPatchSetId().equals(patchSetId)) {
                        change.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
        }
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    if (!control.canPublish(db)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.PUBLISH_NOT_PERMITTED));
    } else {
        db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

            @Override
            public PatchSet update(PatchSet patchset) {
                if (patchset.isDraft()) {
                    patchset.setDraft(false);
                }
                return null;
            }
        });
        final Change change = db.changes().get(changeId);
        if (change.getStatus() == Change.Status.DRAFT) {
            db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus() == Change.Status.DRAFT && change.currentPatchSetId().equals(patchSetId)) {
                        change.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
        }
    }
    return result;
}
#end_block

#method_before
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            if (!currentUser.getCapabilities().canCreateProject()) {
                String msg = String.format("fatal: %s does not have \"Create Project\" capability.", currentUser.getUserName());
                throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg);
            }
            parseCommandLine();
            if (!suggestParent) {
                // 
                if (projectName == null) {
                    throw new Failure(1, "fatal: Option \"--name (-n)\" is required");
                }
                try {
                    final CreateProjectArgs args = new CreateProjectArgs();
                    args.setProjectName(projectName);
                    args.setOwnerIds(ownerIds);
                    args.setNewParent(newParent);
                    args.setPermissionsOnly(permissionsOnly);
                    args.setProjectDescription(projectDescription);
                    args.setSubmitType(submitType);
                    args.setContributorAgreements(contributorAgreements);
                    args.setSignedOffBy(signedOffBy);
                    args.setContentMerge(contentMerge);
                    args.setChangeIdRequired(requireChangeID);
                    args.setBranch(branch);
                    args.setCreateEmptyCommit(createEmptyCommit);
                    final CreateProject createProject = CreateProjectFactory.create(args);
                    createProject.createProject();
                } catch (ProjectCreationFailedException err) {
                    throw new UnloggedFailure(1, "fatal: " + err.getMessage(), err);
                }
            } else {
                List<Project> parentCandidates = retrieveParentCandidatesFactory.create().getParentCandidates();
                PrintWriter p = toPrintWriter(out);
                for (Project parent : parentCandidates) {
                    p.print(parent.getNameKey() + "\n");
                }
                p.flush();
            }
        }
    });
}
#method_after
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            if (!currentUser.getCapabilities().canCreateProject()) {
                String msg = String.format("fatal: %s does not have \"Create Project\" capability.", currentUser.getUserName());
                throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg);
            }
            PrintWriter p = toPrintWriter(out);
            parseCommandLine();
            try {
                if (!suggestParent) {
                    if (projectName == null) {
                        throw new UnloggedFailure(1, "fatal: Project name is required.");
                    }
                    final CreateProjectArgs args = new CreateProjectArgs();
                    args.setProjectName(projectName);
                    args.ownerIds = ownerIds;
                    args.newParent = newParent;
                    args.permissionsOnly = permissionsOnly;
                    args.projectDescription = projectDescription;
                    args.submitType = submitType;
                    args.contributorAgreements = contributorAgreements;
                    args.signedOffBy = signedOffBy;
                    args.contentMerge = contentMerge;
                    args.changeIdRequired = requireChangeID;
                    args.branch = branch;
                    args.createEmptyCommit = createEmptyCommit;
                    final CreateProject createProject = CreateProjectFactory.create(args);
                    createProject.createProject();
                } else {
                    Set<Project.NameKey> parentCandidates = retrieveParentCandidatesFactory.create().get();
                    for (Project.NameKey parent : parentCandidates) {
                        p.print(parent + "\n");
                    }
                }
            } catch (ProjectCreationFailedException err) {
                throw new UnloggedFailure(1, "fatal: " + err.getMessage(), err);
            } finally {
                p.flush();
            }
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(RetrieveParentCandidates.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(RetrieveParentCandidates.Factory.class);
}
#end_block

#method_before
public void merge() throws MergeException {
    final ProjectState pe = projectCache.get(destBranch.getParentKey());
    if (pe == null) {
        throw new MergeException("No such project: " + destBranch.getParentKey());
    }
    destProject = pe.getProject();
    try {
        schema = schemaFactory.open();
    } catch (OrmException e) {
        throw new MergeException("Cannot open database", e);
    }
    try {
        mergeImpl();
    } finally {
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        submitted = schema.changes().submitted(destBranch).toList();
        preMerge();
        updateBranch();
        updateChangeStatus();
        updateSubscriptions();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#end_block

#method_before
private void openRepository() throws MergeException {
    final String name = destBranch.getParentKey().get();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#method_after
private void openRepository() throws MergeException {
    final Project.NameKey name = destBranch.getParentKey();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name.get() + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#end_block

#method_before
private void openBranch() throws MergeException {
    alreadyAccepted = new HashSet<RevCommit>();
    try {
        branchUpdate = db.updateRef(destBranch.get());
        if (branchUpdate.getOldObjectId() != null) {
            branchTip = (CodeReviewCommit) rw.parseCommit(branchUpdate.getOldObjectId());
            alreadyAccepted.add(branchTip);
        } else {
            branchTip = null;
        }
        for (final Ref r : rw.getRepository().getAllRefs().values()) {
            if (r.getName().startsWith(Constants.R_HEADS) || r.getName().startsWith(Constants.R_TAGS)) {
                try {
                    alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                } catch (IncorrectObjectTypeException iote) {
                // Not a commit? Skip over it.
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Cannot open branch", e);
    }
}
#method_after
private void openBranch() throws MergeException {
    alreadyAccepted = new HashSet<RevCommit>();
    try {
        branchUpdate = db.updateRef(destBranch.get());
        if (branchUpdate.getOldObjectId() != null) {
            branchTip = (CodeReviewCommit) rw.parseCommit(branchUpdate.getOldObjectId());
            alreadyAccepted.add(branchTip);
        } else {
            branchTip = null;
        }
        for (final Ref r : db.getAllRefs().values()) {
            if (r.getName().startsWith(Constants.R_HEADS) || r.getName().startsWith(Constants.R_TAGS)) {
                try {
                    alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                } catch (IncorrectObjectTypeException iote) {
                // Not a commit? Skip over it.
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Cannot open branch", e);
    }
}
#end_block

#method_before
private void mergeOneCommit(final CodeReviewCommit n) throws MergeException {
    final Merger m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            writeMergeCommit(m, n);
        } else {
            failed(n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#method_after
private void mergeOneCommit(final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m;
    if (destProject.isUseContentMerge()) {
        // Settings for this project allow us to try and
        // automatically resolve conflicts within files if needed.
        // Use ResolveMerge and instruct to operate in core.
        m = MergeStrategy.RESOLVE.newMerger(db, true);
    } else {
        // No auto conflict resolving allowed. If any of the
        // affected files was modified, merge will fail.
        m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
    }
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            writeMergeCommit(m, n);
        } else {
            failed(n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#end_block

#method_before
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : merged) {
        PatchSetApproval s = getSubmitter(c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : merged) {
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(merged.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    final Commit mergeCommit = new Commit(db);
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(new ObjectId[] { mergeTip, n });
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = m.getObjectWriter().writeCommit(mergeCommit);
    mergeTip = (CodeReviewCommit) rw.parseCommit(id);
}
#method_after
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeAuthor(merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    mergeTip = (CodeReviewCommit) rw.parseCommit(commit(m, mergeCommit));
}
#end_block

#method_before
private void cherryPickChanges() throws MergeException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#method_after
private void cherryPickChanges() throws MergeException, OrmException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        if (destProject.isUseContentMerge()) {
            // Settings for this project allow us to try and
            // automatically resolve conflicts within files if needed.
            // Use ResolveMerge and instruct to operate in core.
            m = MergeStrategy.RESOLVE.newMerger(db, true);
        } else {
            // No auto conflict resolving allowed. If any of the
            // affected files was modified, merge will fail.
            m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        }
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.getApprovalType(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final Commit mergeCommit = new Commit(db);
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(new ObjectId[] { mergeTip });
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = m.getObjectWriter().writeCommit(mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    schema.patchSets().insert(Collections.singleton(ps));
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    for (PatchSetApproval a : schema.patchSetApprovals().byChange(n.change.getId())) {
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            schema.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (branchTip == null || branchTip != mergeTip) {
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(db, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateChangeStatus() {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private void updateSubscriptions() {
    // Note: The merge is already performed so we shall not throw an exception
    // on failure.
    Transaction txn = null;
    final String gitmodulesFile = ".gitmodules";
    File tmpGitmodulesFile = null;
    try {
        final TreeWalk tw = TreeWalk.forPath(db, gitmodulesFile, mergeTip.getTree());
        if ((tw != null) && (tw.getFileMode(0).getObjectType() == Constants.OBJ_BLOB)) {
            tmpGitmodulesFile = File.createTempFile(gitmodulesFile, ".tmp");
            final byte[] blobData = db.openBlob(tw.getObjectId(0)).getCachedBytes();
            FileOutputStream fos = new FileOutputStream(tmpGitmodulesFile.getCanonicalPath());
            fos.write(blobData);
            fos.close();
            final FileBasedConfig cfg = new FileBasedConfig(tmpGitmodulesFile);
            final String thisServer = getSrvName(urlProvider.get());
            if (thisServer == null) {
                throw new DataFormatException("At parse of " + gitmodulesFile + ": problem retrieving name of this server.");
            }
            txn = schema.beginTransaction();
            schema.subscriptions().delete(schema.subscriptions().getSubscription(destBranch), txn);
            cfg.load();
            for (String id : cfg.getSubsections("submodule")) {
                final String url = cfg.getString("submodule", id, "url");
                final String path = cfg.getString("submodule", id, "path");
                String revision = cfg.getString("submodule", id, "revision");
                if (url != null && url.length() > 0 && path != null && path.length() > 0 && revision != null && revision.length() > 0) {
                    boolean pathIsRelative = url.startsWith("/");
                    String server = null;
                    if (!pathIsRelative)
                        server = getSrvName(url);
                    if ((pathIsRelative) || (server != null && server.equalsIgnoreCase(thisServer))) {
                        if (revision.equals(".")) {
                            revision = destBranch.get();
                        }
                        schema.subscriptions().insert(Collections.singleton(new Subscription(new Subscription.Id(schema.nextSubscriptionId()), new Branch.NameKey(new Project.NameKey(destProject.getName()), destBranch.get()), new Branch.NameKey(new Project.NameKey(path), revision))), txn);
                    }
                }
            }
            txn.commit();
        }
    } catch (OrmException e) {
        log.error("Database problem at update of subscriptions table from " + gitmodulesFile + " file.", e);
    } catch (ConfigInvalidException e) {
        log.error("Problem at update of subscriptions table: " + gitmodulesFile + " config file is invalid.", e);
    } catch (IOException e) {
        log.error("Problem at update of subscriptions table from " + gitmodulesFile + ".", e);
    } catch (DataFormatException e) {
        log.error(e.getMessage(), e);
    } finally {
        if (txn != null) {
            try {
                txn.rollback();
            } catch (OrmException e) {
            }
        }
        if (tmpGitmodulesFile != null) {
            tmpGitmodulesFile.delete();
        }
    }
}
#method_after
private void updateSubscriptions() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        SubmoduleOp subOp = subOpFactory.create(destBranch, mergeTip, rw, db, destProject, submitted, commits);
        try {
            subOp.update();
        } catch (SubmoduleException e) {
            log.error("The gitLinks were not updated according to the subscriptions " + e.getMessage());
        }
    }
}
#end_block

#method_before
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null);
    m.setMessage(body);
    return m;
}
#method_after
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null, c.currentPatchSetId());
    m.setMessage(body);
    return m;
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(c, merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(schema, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()), schema);
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
public Capable canUpload() {
    if (!projectControl.canUploadToAtLeastOneRef()) {
        String reqName = project.getName();
        return new Capable("Upload denied for project '" + reqName + "'");
    }
    if (project.isUseContributorAgreements()) {
        try {
            return verifyActiveContributorAgreement();
        } catch (OrmException e) {
            log.error("Cannot query database for agreements", e);
            return new Capable("Cannot verify contribution agreement");
        }
    } else {
        return Capable.OK;
    }
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    return MagicBranch.checkMagicBranchRefs(repo, project);
}
#end_block

#method_before
public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#method_after
@Override
public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#end_block

#method_before
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (isHead(c) || isTag(c)) {
                // We only schedule heads and tags for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                rp.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                rp.sendMessage("  " + url + c.getChangeId());
            }
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private Account.Id toAccountId(final String nameOrEmail) throws OrmException, NoSuchAccountException {
    final Account a = accountResolver.find(nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#method_after
private Account.Id toAccountId(final String nameOrEmail) throws OrmException, NoSuchAccountException {
    final Account a = accountResolver.findByNameOrEmail(nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    final RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    final RevObject oldObject, newObject;
    try {
        oldObject = rp.getRevWalk().parseAny(cmd.getOldId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getOldId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    try {
        newObject = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (oldObject instanceof RevCommit && newObject instanceof RevCommit && ctl.canForceUpdate()) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    if (rp.getAdvertisedRefs().containsKey(destBranchName)) {
        // We advertised the branch to the client so we know
        // the branch exists. Target this branch for the upload.
        // 
        destBranch = new Branch.NameKey(project.getNameKey(), destBranchName);
    } else {
        // We didn't advertise the branch, because it doesn't exist yet.
        // Allow it anyway if HEAD is a symbolic reference to the name.
        // 
        final String head;
        try {
            head = repo.getFullBranch();
        } catch (IOException e) {
            log.error("Cannot read HEAD symref", e);
            reject(cmd, "internal error");
            return;
        }
        if (head.equals(destBranchName)) {
            destBranch = new Branch.NameKey(project.getNameKey(), destBranchName);
        }
    }
    if (destBranch == null) {
        String n = destBranchName;
        if (n.startsWith(Constants.R_HEADS))
            n = n.substring(Constants.R_HEADS.length());
        reject(cmd, "branch " + n + " not found");
        return;
    }
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        boolean haveHeads = false;
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            if (isHead(r) || isTag(r)) {
                try {
                    final RevCommit h = walk.parseCommit(r.getObjectId());
                    h.add(SIDE_HAVE);
                    walk.markStart(h);
                    haveHeads = true;
                } catch (IOException e) {
                    continue;
                }
            }
        }
        if (haveHeads) {
            boolean isConnected = false;
            RevCommit c;
            while ((c = walk.next()) != null) {
                if (c.hasAll(COMMON)) {
                    isConnected = true;
                    break;
                }
            }
            if (!isConnected) {
                reject(newChange, "no common ancestry");
                return;
            }
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private void requestReplace(final ReceiveCommand cmd, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            try {
                walk.markUninteresting(walk.parseCommit(r.getObjectId()));
            } catch (IOException e) {
                continue;
            }
        }
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                final Change.Key key = new Change.Key(idStr);
                final List<Change> changes = db.changes().byProjectKey(project.getNameKey(), key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // Schedule as a replacement to this one matching change.
                    // 
                    requestReplace(newChange, changes.get(0), c);
                    continue;
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = c.getFullMessage().equals(prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                if (messageEq && parentsEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    rp.sendMessage(// 
                    "(W) " + c.abbreviate(repo, 6).name() + ":" + // 
                    " no files changed, but" + // 
                    (!messageEq ? " message updated" : "") + // 
                    (!messageEq && !parentsEq ? " and" : "") + // 
                    (!parentsEq ? " was rebased" : ""));
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            try {
                walk.markUninteresting(walk.parseCommit(r.getObjectId()));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void warnMalformedMessage(RevCommit c) {
    if (65 < c.getShortMessage().length()) {
        rp.sendMessage("(W) " + c.abbreviate(repo, 6).name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        rp.sendMessage("(W) " + c.abbreviate(repo, 6).name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#method_after
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey();
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            } else {
                log.warn("Replacement of Change-Id " + req.ontoChange + " with commit " + req.newCommit.name() + " did not import the new patch set.");
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private Map<ObjectId, Ref> changeRefsById() {
    if (refsById == null) {
        refsById = new HashMap<ObjectId, Ref>();
        for (final Ref r : repo.getAllRefs().values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#method_after
private Map<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = new HashMap<ObjectId, Ref>();
        for (Ref r : repo.getRefDatabase().getRefs("refs/changes/").values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey() throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byProjectOpenAll(project.getNameKey())) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setReviewDb(db);
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
public final void check(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    if (curr.versionNbr == versionNbr) {
    // Nothing to do, we are at the correct schema.
    // 
    } else {
        upgradeFrom(ui, curr, db);
    }
}
#method_after
public final void check(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db, boolean toTargetVersion) throws OrmException, SQLException {
    if (curr.versionNbr == versionNbr) {
    // Nothing to do, we are at the correct schema.
    // 
    } else {
        upgradeFrom(ui, curr, db, toTargetVersion);
    }
}
#end_block

#method_before
protected void upgradeFrom(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    final JdbcSchema s = (JdbcSchema) db;
    prior.get().check(ui, curr, db);
    ui.message("Upgrading database schema from version " + curr.versionNbr + " to " + versionNbr + " ...");
    preUpdateSchema(db);
    final JdbcExecutor e = new JdbcExecutor(s);
    try {
        s.updateSchema(e);
        migrateData(db, ui);
        final List<String> pruneList = new ArrayList<String>();
        s.pruneSchema(new StatementExecutor() {

            public void execute(String sql) {
                pruneList.add(sql);
            }
        });
        if (!pruneList.isEmpty()) {
            ui.pruneSchema(e, pruneList);
        }
    } finally {
        e.close();
    }
    finish(curr, db);
}
#method_after
protected void upgradeFrom(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db, boolean toTargetVersion) throws OrmException, SQLException {
    final JdbcSchema s = (JdbcSchema) db;
    prior.get().check(ui, curr, db, false);
    ui.message("Upgrading database schema from version " + curr.versionNbr + " to " + versionNbr + " ...");
    preUpdateSchema(db);
    final JdbcExecutor e = new JdbcExecutor(s);
    try {
        s.updateSchema(e);
        migrateData(db, ui);
        if (toTargetVersion) {
            final List<String> pruneList = new ArrayList<String>();
            s.pruneSchema(new StatementExecutor() {

                public void execute(String sql) {
                    pruneList.add(sql);
                }
            });
            if (!pruneList.isEmpty()) {
                ui.pruneSchema(e, pruneList);
            }
        }
    } finally {
        e.close();
    }
    finish(curr, db);
}
#end_block

#method_before
@SuppressWarnings("unused")
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#method_after
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateProjectImpl.Factory.class);
    bind(RetrieveParentCandidates.class).to(RetrieveParentCandidatesImpl.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible());
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    CurrentUser user = control.getCurrentUser();
    for (PatchSet ps : source) {
        if (!ps.isDraft() || control.isDraftVisible(db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#method_after
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    CurrentUser user = control.getCurrentUser();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#end_block

#method_before
private void loadMessages() throws OrmException {
    ResultSet<ChangeMessage> source = db.changeMessages().byChange(changeId);
    List<ChangeMessage> msgList = new ArrayList<ChangeMessage>();
    for (ChangeMessage msg : source) {
        PatchSet.Id id = msg.getPatchSetId();
        if (id != null) {
            PatchSet ps = patchsetsById.get(msg.getPatchSetId());
            if (!ps.isDraft() || control.isDraftVisible(db)) {
                msgList.add(msg);
            }
        } else {
            // Not guaranteed to have a non-null patchset id, so just display it.
            msgList.add(msg);
        }
    }
    detail.setMessages(msgList);
    for (final ChangeMessage m : detail.getMessages()) {
        aic.want(m.getAuthor());
    }
}
#method_after
private void loadMessages() throws OrmException {
    ResultSet<ChangeMessage> source = db.changeMessages().byChange(changeId);
    List<ChangeMessage> msgList = new ArrayList<ChangeMessage>();
    for (ChangeMessage msg : source) {
        PatchSet.Id id = msg.getPatchSetId();
        if (id != null) {
            PatchSet ps = patchsetsById.get(msg.getPatchSetId());
            if (control.isPatchVisible(ps, db)) {
                msgList.add(msg);
            }
        } else {
            // Not guaranteed to have a non-null patchset id, so just display it.
            msgList.add(msg);
        }
    }
    detail.setMessages(msgList);
    for (final ChangeMessage m : detail.getMessages()) {
        aic.want(m.getAuthor());
    }
}
#end_block

#method_before
private void load() throws OrmException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    if (detail.getChange().getStatus().equals(Change.Status.NEW) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException {
    return validate(controlFor(id));
}
#method_after
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException, OrmException {
    return validate(controlFor(id), db.get());
}
#end_block

#method_before
public ChangeControl validateFor(final Change change) throws NoSuchChangeException {
    return validate(controlFor(change));
}
#method_after
public ChangeControl validateFor(final Change change) throws NoSuchChangeException, OrmException {
    return validate(controlFor(change), db.get());
}
#end_block

#method_before
private static ChangeControl validate(final ChangeControl c) throws NoSuchChangeException {
    if (!c.isVisible()) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
private static ChangeControl validate(final ChangeControl c, final ReviewDb db) throws NoSuchChangeException, OrmException {
    if (!c.isVisible(db)) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#end_block

#method_before
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isDraftVisible(db)) {
        return false;
    }
    return isVisible();
}
#method_after
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isDraftVisible(db)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    results.addAll(((ListTerm) template[2]).toJava());
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    @SuppressWarnings("unchecked")
                    final List<? extends Term> termList = ((ListTerm) template[2]).toJava();
                    results.addAll(termList);
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
public boolean isDraftVisible(ReviewDb db) throws OrmException {
    return isOwner() || isReviewer(db);
}
#method_after
private boolean isDraftVisible(ReviewDb db) throws OrmException {
    return isOwner() || isReviewer(db);
}
#end_block

#method_before
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    // Don't permit receive-pack to be executed if a (magic branch)/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    result = checkMagicBranchRef(NEW_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_DRAFT_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_PUBLISH_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    return Capable.OK;
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    return MagicBranch.checkMagicBranchRefs(repo, project);
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!isMagicBranch(c)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (isMagicBranch(cmd)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = getDestBranchName(cmd);
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    if (isDraft(newChange)) {
        change.setStatus(Change.Status.DRAFT);
        ps.setDraft(true);
    }
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    if (isDraft(request.cmd)) {
        ps.setDraft(true);
    }
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    msg.setPatchSetId(ps.getId());
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        change.setStatus(Change.Status.DRAFT);
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (isMagicBranch(cmd) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    msg.setPatchSetId(result.info.getKey());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException {
    return validate(controlFor(id));
}
#method_after
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException, OrmException {
    return validate(controlFor(id), db.get());
}
#end_block

#method_before
public ChangeControl validateFor(final Change change) throws NoSuchChangeException {
    return validate(controlFor(change));
}
#method_after
public ChangeControl validateFor(final Change change) throws NoSuchChangeException, OrmException {
    return validate(controlFor(change), db.get());
}
#end_block

#method_before
private static ChangeControl validate(final ChangeControl c) throws NoSuchChangeException {
    if (!c.isVisible()) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
private static ChangeControl validate(final ChangeControl c, final ReviewDb db) throws NoSuchChangeException, OrmException {
    if (!c.isVisible(db)) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#end_block

#method_before
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isOwner() && !isReviewer(db)) {
        return false;
    }
    return isVisible();
}
#method_after
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isDraftVisible(db)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    if (change.getStatus() == Change.Status.DRAFT) {
        return ruleError("Cannot submit draft changes");
    }
    try {
        if (isDraftPatchSet(patchSetId, db)) {
            return ruleError("Cannot submit draft patch sets");
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSetId, err);
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    results.addAll(((ListTerm) template[2]).toJava());
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isVisible(db)) {
                return ruleError("Patch set " + patchSetId + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (isDraftPatchSet(patchSetId, db)) {
            if (!isVisible(db)) {
                return ruleError("Patch set " + patchSetId + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSetId, err);
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    @SuppressWarnings("unchecked")
                    final List<? extends Term> termList = ((ListTerm) template[2]).toJava();
                    results.addAll(termList);
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
private boolean isDraftPatchSet(PatchSet.Id id, ReviewDb db) throws OrmException {
    PatchSet ps = db.patchSets().get(id);
    if (ps == null) {
        return false;
    }
    return ps.isDraft();
}
#method_after
private boolean isDraftPatchSet(PatchSet.Id id, ReviewDb db) throws OrmException {
    PatchSet ps = db.patchSets().get(id);
    if (ps == null) {
        throw new OrmException("Patch set " + id + " not found");
    }
    return ps.isDraft();
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
        reject(cmd, "For non-fast forward updates, 'Force Push' privilege is needed");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, groupUUID, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            groupId = result.group.getId();
            groupUUID = result.group.getGroupUUID();
            display(result);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, groupUUID, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            groupId = result.group.getId();
            groupUUID = result.group.getGroupUUID();
            display(result);
            enableForm(result.canModify);
            saveName.setVisible(result.canModify);
            saveOwner.setVisible(result.canModify);
            saveDesc.setVisible(result.canModify);
            saveGroupOptions.setVisible(result.canModify);
            delMember.setVisible(result.canModify);
            saveType.setVisible(result.canModify);
            delInclude.setVisible(result.canModify);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupType();
    initMemberList();
    initExternal();
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupOptions();
    initGroupType();
    initMemberList();
    initIncludeList();
    initExternal();
}
#end_block

#method_before
private void initMemberList() {
    addMemberBox = new AddMemberBox();
    addMemberBox.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    members = new MemberTable();
    delMember = new Button(Util.C.buttonDeleteGroupMembers());
    delMember.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            members.deleteChecked();
        }
    });
    memberPanel = new FlowPanel();
    memberPanel.add(new SmallHeading(Util.C.headingMembers()));
    memberPanel.add(addMemberBox);
    memberPanel.add(members);
    memberPanel.add(delMember);
    add(memberPanel);
}
#method_after
private void initMemberList() {
    addMemberBox = new AddMemberBox();
    addMemberBox.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewMember();
        }
    });
    members = new MemberTable();
    delMember = new Button(Util.C.buttonDeleteGroupMembers());
    delMember.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            members.deleteChecked();
        }
    });
    memberPanel = new FlowPanel();
    memberPanel.add(new SmallHeading(Util.C.headingMembers()));
    memberPanel.add(addMemberBox);
    memberPanel.add(members);
    memberPanel.add(delMember);
    add(memberPanel);
}
#end_block

#method_before
private void initExternal() {
    externalName = new Label();
    externalNameFilter = new NpTextBox();
    externalNameFilter.setVisibleLength(30);
    externalNameFilter.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doExternalSearch();
            }
        }
    });
    externalNameSearch = new Button(Gerrit.C.searchButton());
    externalNameSearch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doExternalSearch();
        }
    });
    externalMatches = new Grid();
    externalMatches.setStyleName(Gerrit.RESOURCES.css().infoTable());
    externalMatches.setVisible(false);
    final FlowPanel searchLine = new FlowPanel();
    searchLine.add(externalNameFilter);
    searchLine.add(externalNameSearch);
    externalPanel = new VerticalPanel();
    externalPanel.add(new SmallHeading(Util.C.headingExternalGroup()));
    externalPanel.add(externalName);
    externalPanel.add(searchLine);
    externalPanel.add(externalMatches);
    add(externalPanel);
}
#method_after
private void initExternal() {
    externalName = new Label();
    externalNameFilter = new NpTextBox();
    externalNameFilter.setVisibleLength(30);
    externalNameFilter.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doExternalSearch();
            }
        }
    });
    externalNameSearch = new Button(Gerrit.C.searchButton());
    externalNameSearch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doExternalSearch();
        }
    });
    externalMatches = new Grid();
    externalMatches.setStyleName(Gerrit.RESOURCES.css().infoTable());
    externalMatches.setVisible(false);
    final FlowPanel searchLine = new FlowPanel();
    searchLine.add(externalNameFilter);
    searchLine.add(externalNameSearch);
    externalPanel = new VerticalPanel();
    externalPanel.add(new SmallHeading(Util.C.headingExternalGroup()));
    externalPanel.add(externalName);
    externalPanel.add(searchLine);
    externalPanel.add(externalMatches);
    add(externalPanel);
}
#end_block

#method_before
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#method_after
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    includePanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#end_block

#method_before
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            members.display(result.members);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#method_after
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    visibleToAllCheckBox.setValue(group.isVisibleToAll());
    emailOnlyAuthors.setValue(group.isEmailOnlyAuthors());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            groups = result.groups;
            members.display(result.members);
            includes.display(result.includes);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#end_block

#method_before
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    table.setWidget(row, 1, new CheckBox());
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
private void addGroup(GroupReference ref) {
    if (ref.getUUID() != null) {
        if (value.getRule(ref) == null) {
            PermissionRule newRule = value.getRule(ref, true);
            if (value.isLabel()) {
                newRule.setRange(0, 1);
            }
            rules.getList().add(newRule);
        }
        groupToAdd.setValue(null);
        groupToAdd.setFocus(true);
    } else {
        // If the oracle didn't get to complete a UUID, resolve it now.
        // 
        addRule.setEnabled(false);
        SuggestUtil.SVC.suggestAccountGroup(ref.getName(), 1, new GerritCallback<List<GroupReference>>() {

            @Override
            public void onSuccess(List<GroupReference> result) {
                addRule.setEnabled(true);
                if (result.size() == 1) {
                    addGroup(result.get(0));
                } else {
                    groupToAdd.setFocus(true);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                addRule.setEnabled(true);
                super.onFailure(caught);
            }
        });
    }
}
#method_after
private void addGroup(GroupReference ref) {
    if (ref.getUUID() != null) {
        if (value.getRule(ref) == null) {
            PermissionRule newRule = value.getRule(ref, true);
            if (rangeType != null) {
                int min = rangeType.getMin().getValue();
                int max = rangeType.getMax().getValue();
                newRule.setRange(min, max);
            }
            rules.getList().add(newRule);
        }
        groupToAdd.setValue(null);
        groupToAdd.setFocus(true);
    } else {
        // If the oracle didn't get to complete a UUID, resolve it now.
        // 
        addRule.setEnabled(false);
        SuggestUtil.SVC.suggestAccountGroup(ref.getName(), 1, new GerritCallback<List<GroupReference>>() {

            @Override
            public void onSuccess(List<GroupReference> result) {
                addRule.setEnabled(true);
                if (result.size() == 1) {
                    addGroup(result.get(0));
                } else {
                    groupToAdd.setFocus(true);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                addRule.setEnabled(true);
                super.onFailure(caught);
            }
        });
    }
}
#end_block

#method_before
@Override
public void setValue(Permission value) {
    this.value = value;
    if (value != null && Permission.OWNER.equals(value.getName())) {
        inherit.setEnabled(false);
    } else {
        inherit.setEnabled(!readOnly);
    }
}
#method_after
@Override
public void setValue(Permission value) {
    this.value = value;
    if (value.isLabel()) {
        rangeType = Gerrit.getConfig().getApprovalTypes().byLabel(value.getLabel());
    } else {
        rangeType = null;
    }
    if (value != null && Permission.OWNER.equals(value.getName())) {
        exclusiveGroup.setEnabled(false);
    } else {
        exclusiveGroup.setEnabled(!readOnly);
    }
}
#end_block

#method_before
@Override
public PermissionRuleEditor create(int index) {
    PermissionRuleEditor subEditor = new PermissionRuleEditor(readOnly, section, value);
    ruleContainer.insert(subEditor, index);
    return subEditor;
}
#method_after
@Override
public PermissionRuleEditor create(int index) {
    PermissionRuleEditor subEditor = new PermissionRuleEditor(readOnly, section, value, rangeType);
    ruleContainer.insert(subEditor, index);
    return subEditor;
}
#end_block

#method_before
@UiHandler("addSection")
void onAddSection(ClickEvent event) {
    int index = local.getList().size();
    local.getList().add(new AccessSection("refs/heads/*"));
    local.getEditors().get(index).editRefPattern();
}
#method_after
@UiHandler("addSection")
void onAddSection(ClickEvent event) {
    int index = local.getList().size();
    local.getList().add(new AccessSection("refs/heads/*"));
    AccessSectionEditor editor = local.getEditors().get(index);
    editor.enableEditing();
    editor.editRefPattern();
}
#end_block

#method_before
@Override
public void render(Action object, Appendable appendable) throws IOException {
    appendable.append(render(object));
}
#method_after
@Override
public String render(PermissionRule.Action object) {
    return object != null ? object.toString() : "";
}
#end_block

#method_before
public void suggestAccount(final String query, final Boolean active, final int limit, final AsyncCallback<List<AccountInfo>> callback) {
    run(callback, new Action<List<AccountInfo>>() {

        public List<AccountInfo> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            final LinkedHashMap<Account.Id, AccountInfo> r = new LinkedHashMap<Account.Id, AccountInfo>();
            for (final Account p : db.accounts().suggestByFullName(a, b, n)) {
                addSuggestion(r, p, new AccountInfo(p), active);
            }
            if (r.size() < n) {
                for (final Account p : db.accounts().suggestByPreferredEmail(a, b, n - r.size())) {
                    addSuggestion(r, p, new AccountInfo(p), active);
                }
            }
            if (r.size() < n) {
                for (final AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, n - r.size())) {
                    if (!r.containsKey(e.getAccountId())) {
                        final Account p = accountCache.get(e.getAccountId()).getAccount();
                        final AccountInfo info = new AccountInfo(p);
                        info.setPreferredEmail(e.getEmailAddress());
                        addSuggestion(r, p, info, active);
                    }
                }
            }
            return new ArrayList<AccountInfo>(r.values());
        }
    });
}
#method_after
public void suggestAccount(final String query, final Boolean active, final int limit, final AsyncCallback<List<AccountInfo>> callback) {
    if (suggestAccounts == SuggestAccountsEnum.OFF) {
        callback.onSuccess(Collections.<AccountInfo>emptyList());
        return;
    }
    run(callback, new Action<List<AccountInfo>>() {

        public List<AccountInfo> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            final LinkedHashMap<Account.Id, AccountInfo> r = new LinkedHashMap<Account.Id, AccountInfo>();
            for (final Account p : db.accounts().suggestByFullName(a, b, n)) {
                addSuggestion(r, p, new AccountInfo(p), active);
            }
            if (r.size() < n) {
                for (final Account p : db.accounts().suggestByPreferredEmail(a, b, n - r.size())) {
                    addSuggestion(r, p, new AccountInfo(p), active);
                }
            }
            if (r.size() < n) {
                for (final AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, n - r.size())) {
                    if (!r.containsKey(e.getAccountId())) {
                        final Account p = accountCache.get(e.getAccountId()).getAccount();
                        final AccountInfo info = new AccountInfo(p);
                        info.setPreferredEmail(e.getEmailAddress());
                        addSuggestion(r, p, info, active);
                    }
                }
            }
            return new ArrayList<AccountInfo>(r.values());
        }
    });
}
#end_block

#method_before
private void addSuggestion(Map map, Account account, AccountInfo info, Boolean active) {
    if (active == null || active == account.isActive()) {
        map.put(account.getId(), info);
    }
}
#method_after
private void addSuggestion(Map<Account.Id, AccountInfo> map, Account account, AccountInfo info, Boolean active) {
    if (map.containsKey(account.getId())) {
        return;
    }
    if (active != null && active != account.isActive()) {
        return;
    }
    switch(suggestAccounts) {
        case ALL:
            map.put(account.getId(), info);
            break;
        case SAME_GROUP:
            {
                Set<AccountGroup.UUID> usersGroups = groupsOf(account);
                usersGroups.remove(AccountGroup.ANONYMOUS_USERS);
                usersGroups.remove(AccountGroup.REGISTERED_USERS);
                usersGroups.remove(authConfig.getBatchUsersGroup());
                for (AccountGroup.UUID myGroup : currentUser.get().getEffectiveGroups()) {
                    if (usersGroups.contains(myGroup)) {
                        map.put(account.getId(), info);
                        break;
                    }
                }
                break;
            }
        case OFF:
            break;
        default:
            throw new IllegalStateException("Bad SuggestAccounts " + suggestAccounts);
    }
}
#end_block

#method_before
public void suggestAccountGroup(final String query, final int limit, final AsyncCallback<List<GroupReference>> callback) {
    run(callback, new Action<List<GroupReference>>() {

        public List<GroupReference> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            List<GroupReference> r = new ArrayList<GroupReference>(n);
            for (AccountGroupName c : db.accountGroupNames().suggestByName(a, b, n)) {
                AccountGroup g = groupCache.get(c.getId());
                if (g != null && g.getGroupUUID() != null) {
                    r.add(GroupReference.forGroup(g));
                }
            }
            return r;
        }
    });
}
#method_after
public void suggestAccountGroup(final String query, final int limit, final AsyncCallback<List<GroupReference>> callback) {
    run(callback, new Action<List<GroupReference>>() {

        public List<GroupReference> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            Set<AccountGroup.UUID> memberOf = currentUser.get().getEffectiveGroups();
            List<GroupReference> r = new ArrayList<GroupReference>(n);
            for (AccountGroupName group : db.accountGroupNames().suggestByName(a, b, n)) {
                try {
                    if (memberOf.contains(group.getId()) || groupControlFactory.controlFor(group.getId()).isVisible()) {
                        AccountGroup g = groupCache.get(group.getId());
                        if (g != null && g.getGroupUUID() != null) {
                            r.add(GroupReference.forGroup(g));
                        }
                    }
                } catch (NoSuchGroupException e) {
                    continue;
                }
            }
            return r;
        }
    });
}
#end_block

#method_before
private static Screen core(final String token) {
    String p;
    p = "change,";
    if (token.startsWith(p))
        return new ChangeScreen(Change.Id.parse(skip(p, token)));
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    p = "q,";
    if (token.startsWith(p)) {
        final String s = skip(p, token);
        final int c = s.indexOf(',');
        return new QueryScreen(s.substring(0, c), s.substring(c + 1));
    }
    return new NotFoundScreen();
}
#method_after
private static Screen core(final String token) {
    String p;
    p = "change,";
    if (token.startsWith(p)) {
        final String s = skip(p, token);
        final String q = "patchset=";
        final String[] t = s.split(",", 2);
        if (t.length > 1 && t[1].startsWith(q)) {
            return new ChangeScreen(PatchSet.Id.parse(t[0] + "," + skip(q, t[1])));
        }
        return new ChangeScreen(Change.Id.parse(t[0]));
    }
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    p = "q,";
    if (token.startsWith(p)) {
        final String s = skip(p, token);
        final int c = s.indexOf(',');
        return new QueryScreen(s.substring(0, c), s.substring(c + 1));
    }
    return new NotFoundScreen();
}
#end_block

#method_before
public void addGroupMember(final AccountGroup.Id groupId, final String nameOrEmail, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            final Account a = findAccount(nameOrEmail);
            if (!a.isActive()) {
                throw new Failure(new InactiveAccountException(a.getFullName()));
            }
            if (!control.canAdd(a.getId())) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupMember.Key key = new AccountGroupMember.Key(a.getId(), groupId);
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                db.accountGroupMembersAudit().insert(Collections.singleton(new AccountGroupMemberAudit(m, getAccountId())));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#method_after
public void addGroupMember(final AccountGroup.Id groupId, final String nameOrEmail, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            final Account a = findAccount(nameOrEmail);
            if (!a.isActive()) {
                throw new Failure(new InactiveAccountException(a.getFullName()));
            }
            if (!control.canAddMember(a.getId())) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupMember.Key key = new AccountGroupMember.Key(a.getId(), groupId);
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                db.accountGroupMembersAudit().insert(Collections.singleton(new AccountGroupMemberAudit(m, getAccountId())));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#end_block

#method_before
public void deleteGroupMembers(final AccountGroup.Id groupId, final Set<AccountGroupMember.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupMember.Key k : keys) {
                if (!groupId.equals(k.getAccountGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            for (final AccountGroupMember.Key k : keys) {
                final AccountGroupMember m = db.accountGroupMembers().get(k);
                if (m != null) {
                    if (!control.canRemove(m.getAccountId())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupMemberAudit audit = null;
                    for (AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupMembersAudit().update(Collections.singleton(audit));
                    } else {
                        audit = new AccountGroupMemberAudit(m, me);
                        audit.removedLegacy();
                        db.accountGroupMembersAudit().insert(Collections.singleton(audit));
                    }
                    db.accountGroupMembers().delete(Collections.singleton(m));
                    accountCache.evict(m.getAccountId());
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteGroupMembers(final AccountGroup.Id groupId, final Set<AccountGroupMember.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupMember.Key k : keys) {
                if (!groupId.equals(k.getAccountGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            for (final AccountGroupMember.Key k : keys) {
                final AccountGroupMember m = db.accountGroupMembers().get(k);
                if (m != null) {
                    if (!control.canRemoveMember(m.getAccountId())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupMemberAudit audit = null;
                    for (AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupMembersAudit().update(Collections.singleton(audit));
                    } else {
                        audit = new AccountGroupMemberAudit(m, me);
                        audit.removedLegacy();
                        db.accountGroupMembersAudit().insert(Collections.singleton(audit));
                    }
                    db.accountGroupMembers().delete(Collections.singleton(m));
                    accountCache.evict(m.getAccountId());
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public void setAction(Action action) {
    switch(action) {
        case ALLOW:
            setDeny(false);
            break;
        case DENY:
            setDeny(true);
            break;
        default:
            throw new IllegalArgumentException();
    }
}
#method_after
public void setAction(Action action) {
    if (action == null) {
        throw new NullPointerException("action");
    }
    setDeny(action == Action.DENY);
}
#end_block

#method_before
public int getMin() {
    return min;
}
#method_after
public Integer getMin() {
    return min;
}
#end_block

#method_before
public int getMax() {
    return max;
}
#method_after
public Integer getMax() {
    return max;
}
#end_block

#method_before
@Override
public int compareTo(PermissionRule o) {
    int cmp = deny(this) - deny(o);
    if (cmp == 0)
        cmp = group(this).compareTo(group(o));
    return cmp;
}
#method_after
@Override
public int compareTo(PermissionRule o) {
    int cmp = deny(this) - deny(o);
    if (cmp == 0)
        cmp = range(o) - range(this);
    if (cmp == 0)
        cmp = group(this).compareTo(group(o));
    return cmp;
}
#end_block

#method_before
public String asString(boolean useRange) {
    StringBuilder r = new StringBuilder();
    if (getDeny()) {
        r.append("deny ");
    }
    if (getForce()) {
        r.append("+force ");
    }
    if (useRange) {
        if (getMin() == 0 && getMax() == 1) {
        } else if (getMin() == 1 && getMax() == 1) {
        } else if (getMin() < 0 && getMax() == 0) {
            r.append(getMin());
            r.append(' ');
        } else {
            if (getMin() != getMax()) {
                if (0 <= getMin())
                    r.append('+');
                r.append(getMin());
                r.append("..");
            }
            if (0 <= getMax())
                r.append('+');
            r.append(getMax());
            r.append(' ');
        }
    }
    r.append("group ");
    r.append(getGroup().getName());
    return r.toString();
}
#method_after
public String asString(boolean canUseRange) {
    StringBuilder r = new StringBuilder();
    if (getDeny()) {
        r.append("deny ");
    }
    if (getForce()) {
        r.append("+force ");
    }
    if (canUseRange && (getMin() != 0 || getMax() != 0)) {
        if (0 <= getMin())
            r.append('+');
        r.append(getMin());
        r.append("..");
        if (0 <= getMax())
            r.append('+');
        r.append(getMax());
        r.append(' ');
    }
    r.append("group ");
    r.append(getGroup().getName());
    return r.toString();
}
#end_block

#method_before
public static PermissionRule fromString(String src, boolean useRange) {
    final String orig = src;
    final PermissionRule rule = new PermissionRule();
    src = src.trim();
    if (src.startsWith("deny ")) {
        rule.setDeny(true);
        src = src.substring(5).trim();
    }
    if (src.startsWith("+force ")) {
        rule.setForce(true);
        src = src.substring("+force ".length()).trim();
    }
    if (useRange) {
        if (src.startsWith("group ")) {
            rule.setRange(0, 1);
        } else {
            int sp = src.indexOf(' ');
            String range = src.substring(0, sp);
            if (range.matches("^([+-]\\d+)\\.\\.([+-]\\d)$")) {
                int dotdot = range.indexOf("..");
                int min = parseInt(range.substring(0, dotdot));
                int max = parseInt(range.substring(dotdot + 2));
                rule.setRange(min, max);
            } else if (range.matches("^([+-]\\d)$")) {
                int v = parseInt(range);
                rule.setRange(v, v);
            } else {
                throw new IllegalArgumentException("Invalid range in rule: " + orig);
            }
            src = src.substring(sp + 1).trim();
        }
    }
    if (src.startsWith("group ")) {
        src = src.substring(6).trim();
        GroupReference group = new GroupReference();
        group.setName(src);
        rule.setGroup(group);
    } else {
        throw new IllegalArgumentException("Rule must include group: " + orig);
    }
    return rule;
}
#method_after
public static PermissionRule fromString(String src, boolean mightUseRange) {
    final String orig = src;
    final PermissionRule rule = new PermissionRule();
    src = src.trim();
    if (src.startsWith("deny ")) {
        rule.setDeny(true);
        src = src.substring(5).trim();
    }
    if (src.startsWith("+force ")) {
        rule.setForce(true);
        src = src.substring("+force ".length()).trim();
    }
    if (mightUseRange && !src.startsWith("group ")) {
        int sp = src.indexOf(' ');
        String range = src.substring(0, sp);
        if (range.matches("^([+-]\\d+)\\.\\.([+-]\\d)$")) {
            int dotdot = range.indexOf("..");
            int min = parseInt(range.substring(0, dotdot));
            int max = parseInt(range.substring(dotdot + 2));
            rule.setRange(min, max);
        } else {
            throw new IllegalArgumentException("Invalid range in rule: " + orig);
        }
        src = src.substring(sp + 1).trim();
    }
    if (src.startsWith("group ")) {
        src = src.substring(6).trim();
        GroupReference group = new GroupReference();
        group.setName(src);
        rule.setGroup(group);
    } else {
        throw new IllegalArgumentException("Rule must include group: " + orig);
    }
    return rule;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(rc.getBoolean(RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(rc.getBoolean(RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(rc.getBoolean(RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(rc.getEnum(SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(rc.getBoolean(SUBMIT, null, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_DO_NOT_INHERIT)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setInherit(false);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    boolean useRange = perm.isLabel();
                    for (String ruleString : rc.getStringList(ACCESS, refName, varName)) {
                        PermissionRule rule;
                        try {
                            rule = PermissionRule.fromString(ruleString, useRange);
                        } catch (IllegalArgumentException notRule) {
                            throw new ConfigInvalidException("Invalid rule in " + ACCESS + "." + refName + "." + varName + ": " + notRule.getMessage(), notRule);
                        }
                        GroupReference ref = groupsByName.get(rule.getGroup().getName());
                        if (ref == null) {
                            // The group wasn't mentioned in the groups table, so there is
                            // no valid UUID for it. Pool the reference anyway so at least
                            // all rules in the same file share the same GroupReference.
                            // 
                            ref = rule.getGroup();
                            groupsByName.put(ref.getName(), ref);
                        }
                        rule.setGroup(ref);
                        perm.add(rule);
                    }
                }
            }
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(rc.getBoolean(RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(rc.getBoolean(RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(rc.getBoolean(RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(rc.getEnum(SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(rc.getBoolean(SUBMIT, null, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    boolean useRange = perm.isLabel();
                    for (String ruleString : rc.getStringList(ACCESS, refName, varName)) {
                        PermissionRule rule;
                        try {
                            rule = PermissionRule.fromString(ruleString, useRange);
                        } catch (IllegalArgumentException notRule) {
                            throw new ConfigInvalidException("Invalid rule in " + ACCESS + "." + refName + "." + varName + ": " + notRule.getMessage(), notRule);
                        }
                        GroupReference ref = groupsByName.get(rule.getGroup().getName());
                        if (ref == null) {
                            // The group wasn't mentioned in the groups table, so there is
                            // no valid UUID for it. Pool the reference anyway so at least
                            // all rules in the same file share the same GroupReference.
                            // 
                            ref = rule.getGroup();
                            groupsByName.put(ref.getName(), ref);
                        }
                        rule.setGroup(ref);
                        perm.add(rule);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getRefPattern();
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (!perm.getInherit()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_DO_NOT_INHERIT, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_DO_NOT_INHERIT);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getRefPattern();
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
@Override
public void setValue(AccessSection value) {
    this.value = value;
    this.readOnly = !projectAccess.isOwnerOf(value);
    refPattern.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        rebuildPermissionSelector();
    }
}
#method_after
@Override
public void setValue(AccessSection value) {
    this.value = value;
    this.readOnly = !projectAccess.isOwnerOf(value);
    refPattern.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#end_block

#method_before
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        String varName = Permission.LABEL + t.getCategory().getLabelName();
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    for (String varName : Util.C.permissionNames().keySet()) {
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addDotDotDot());
        permissionSelector.setValue(Util.C.addDotDotDot());
        permissionSelector.setAcceptableValues(perms);
    }
}
#method_after
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        String varName = Permission.LABEL + t.getCategory().getLabelName();
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    for (String varName : Util.C.permissionNames().keySet()) {
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#end_block

#method_before
public boolean isVisible() {
    if (isOwner()) {
        return true;
    } else {
        return (projectControl.visibleForReplication() || canPerform(Permission.READ)) && !isHidden();
    }
}
#method_after
public boolean isVisible() {
    return (projectControl.visibleForReplication() || canPerform(Permission.READ)) && canRead();
}
#end_block

#method_before
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH) && isActive();
}
#method_after
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && isActive();
}
#method_after
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && canWrite();
}
#end_block

#method_before
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT) && isActive();
}
#method_after
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT) && canWrite();
}
#end_block

#method_before
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH) && isActive();
}
#method_after
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canForceUpdate() {
    return (canPushWithForce() || canDelete()) && isActive();
}
#method_after
public boolean canForceUpdate() {
    return (canPushWithForce() || canDelete()) && canWrite();
}
#end_block

#method_before
private boolean canPushWithForce() {
    if (!isActive() || (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner())) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#method_after
private boolean canPushWithForce() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner())) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!isActive()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean canDelete() {
    if (!isActive() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#method_after
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible());
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().isOwner() || control.getRefControl().isActive());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible());
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void load() throws OrmException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    if (detail.getChange().getStatus().equals(Change.Status.NEW) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
public boolean isVisible() {
    return visibleForReplication() || canPerformOnAnyRef(Permission.READ) && !isHidden();
}
#method_after
public boolean isVisible() {
    return (visibleForReplication() || canPerformOnAnyRef(Permission.READ)) && !isHidden();
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, STATE, null, KEY_VALUE, defaultStateValue));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, STATE, null, KEY_VALUE, p.getState(), defaultStateValue);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (isEditable()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            r.append(GWT.getHostPageBaseURL());
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        final StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null && changeDetail.isAllowsAnonymous()) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            String base = GWT.getHostPageBaseURL();
            int p = base.indexOf("://");
            int s = base.indexOf('/', p + 3);
            if (s < 0) {
                s = base.length();
            }
            String host = base.substring(p + 3, s);
            if (host.contains("@")) {
                host = host.substring(host.indexOf('@') + 1);
            }
            r.append(base.substring(0, p + 3));
            r.append(Gerrit.getUserAccount().getUserName());
            r.append('@');
            r.append(host);
            r.append(base.substring(s));
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            changeScreen.update(result);
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#method_after
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b, final boolean redirect) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            if (redirect) {
                Gerrit.display(PageLinks.toChange(result.getChange().getId()));
            } else {
                changeScreen.update(result);
            }
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#end_block

#method_before
public void setParentName(String n) {
    parent = n != null ? new NameKey(n) : null;
}
#method_after
public void setParentName(NameKey n) {
    parent = n;
}
#end_block

#method_before
private void setState(final Project.State newState) {
    int index = -1;
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                index = i;
                break;
            }
        }
        state.setSelectedIndex(index);
    }
}
#method_after
private void setState(final Project.State newState) {
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                state.setSelectedIndex(i);
                break;
            }
        }
    }
}
#end_block

#method_before
public void setCanModifyState(final boolean cmmt) {
    canModifyState = cmmt;
}
#method_after
public void setCanModifyState(final boolean cms) {
    canModifyState = cms;
}
#end_block

#method_before
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            parseCommandLine();
            updateParents();
        }
    });
}
#method_after
@Override
public void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            stdout = toPrintWriter(out);
            try {
                parseCommandLine();
                updateParents();
            } finally {
                stdout.flush();
            }
        }
    });
}
#end_block

#method_before
private void updateParents() throws Failure {
    if (oldParent == null && children.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: child projects have to be specified as arguments or the --old-parent option has to be set");
    }
    if (oldParent == null && !excludedChildren.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: --exclude can only be used together with --old-parent");
    }
    final StringBuilder err = new StringBuilder();
    final Set<Project.NameKey> grandParents = new HashSet<Project.NameKey>();
    Project.NameKey newParentKey;
    grandParents.add(allProjectsName);
    if (newParent != null) {
        newParentKey = newParent.getProject().getNameKey();
        // Catalog all grandparents of the "parent", we want to
        // catch a cycle in the parent pointers before it occurs.
        // 
        Project.NameKey gp = newParent.getProject().getParent();
        while (gp != null && grandParents.add(gp)) {
            final ProjectState s = projectCache.get(gp);
            if (s != null) {
                gp = s.getProject().getParent();
            } else {
                break;
            }
        }
    } else {
        // If no parent was selected, set to NULL to use the default.
        // 
        newParentKey = null;
    }
    final List<Project> childProjects = new ArrayList<Project>();
    for (final ProjectControl pc : children) {
        childProjects.add(pc.getProject());
    }
    if (oldParent != null) {
        final List<Project.NameKey> excluded = new ArrayList<Project.NameKey>(excludedChildren.size() + 1);
        if (newParentKey != null) {
            excluded.add(newParentKey);
        }
        for (final ProjectControl excludedChild : excludedChildren) {
            excluded.add(excludedChild.getProject().getNameKey());
        }
        final ProjectNode oldParentProject = createProjectHierarchyFactory.create().getProjectHierarchy(oldParent.getProject().getNameKey());
        for (final ProjectNode childProject : oldParentProject.getChildren()) {
            if (!excluded.contains(childProject.getProject().getNameKey())) {
                childProjects.add(childProject.getProject());
            }
        }
    }
    for (final Project project : childProjects) {
        final String name = project.getName();
        final Project.NameKey nameKey = project.getNameKey();
        if (allProjectsName.equals(nameKey)) {
            // Don't allow the wild card project to have a parent.
            // 
            err.append("error: Cannot set parent of '" + name + "'\n");
            continue;
        }
        if (grandParents.contains(nameKey) || nameKey.equals(newParentKey)) {
            // Try to avoid creating a cycle in the parent pointers.
            // 
            err.append("error: Cycle exists between '" + name + "' and '" + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "'\n");
            continue;
        }
        try {
            MetaDataUpdate md = metaDataUpdateFactory.create(nameKey);
            try {
                ProjectConfig config = ProjectConfig.read(md);
                config.getProject().setParentName(newParentKey);
                md.setMessage("Inherit access from " + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "\n");
                if (!config.commit(md)) {
                    err.append("error: Could not update project " + name + "\n");
                }
            } finally {
                md.close();
            }
        } catch (RepositoryNotFoundException notFound) {
            err.append("error: Project " + name + " not found\n");
        } catch (IOException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        } catch (ConfigInvalidException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        }
        projectCache.evict(project);
    }
    if (err.length() > 0) {
        while (err.charAt(err.length() - 1) == '\n') {
            err.setLength(err.length() - 1);
        }
        throw new UnloggedFailure(1, err.toString());
    }
}
#method_after
private void updateParents() throws Failure {
    if (oldParent == null && children.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: child projects have to be specified as " + "arguments or the --children-of option has to be set");
    }
    if (oldParent == null && !excludedChildren.isEmpty()) {
        throw new UnloggedFailure(1, "fatal: --exclude can only be used together " + "with --children-of");
    }
    final StringBuilder err = new StringBuilder();
    final Set<Project.NameKey> grandParents = new HashSet<Project.NameKey>();
    grandParents.add(allProjectsName);
    if (newParent != null) {
        newParentKey = newParent.getProject().getNameKey();
        // Catalog all grandparents of the "parent", we want to
        // catch a cycle in the parent pointers before it occurs.
        // 
        Project.NameKey gp = newParent.getProject().getParent();
        while (gp != null && grandParents.add(gp)) {
            final ProjectState s = projectCache.get(gp);
            if (s != null) {
                gp = s.getProject().getParent();
            } else {
                break;
            }
        }
    }
    final List<Project> childProjects = new ArrayList<Project>();
    for (final ProjectControl pc : children) {
        childProjects.add(pc.getProject());
    }
    if (oldParent != null) {
        childProjects.addAll(getChildrenForReparenting(oldParent));
    }
    for (final Project project : childProjects) {
        final String name = project.getName();
        final Project.NameKey nameKey = project.getNameKey();
        if (allProjectsName.equals(nameKey)) {
            // Don't allow the wild card project to have a parent.
            // 
            err.append("error: Cannot set parent of '" + name + "'\n");
            continue;
        }
        if (grandParents.contains(nameKey) || nameKey.equals(newParentKey)) {
            // Try to avoid creating a cycle in the parent pointers.
            // 
            err.append("error: Cycle exists between '" + name + "' and '" + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "'\n");
            continue;
        }
        try {
            MetaDataUpdate md = metaDataUpdateFactory.create(nameKey);
            try {
                ProjectConfig config = ProjectConfig.read(md);
                config.getProject().setParentName(newParentKey);
                md.setMessage("Inherit access from " + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "\n");
                if (!config.commit(md)) {
                    err.append("error: Could not update project " + name + "\n");
                }
            } finally {
                md.close();
            }
        } catch (RepositoryNotFoundException notFound) {
            err.append("error: Project " + name + " not found\n");
        } catch (IOException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        } catch (ConfigInvalidException e) {
            throw new Failure(1, "Cannot update project " + name, e);
        }
        projectCache.evict(project);
    }
    if (err.length() > 0) {
        while (err.charAt(err.length() - 1) == '\n') {
            err.setLength(err.length() - 1);
        }
        throw new UnloggedFailure(1, err.toString());
    }
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException {
    final Project.NameKey projectName = update.getNameKey();
    projectControlFactory.ownerFor(projectName);
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
    try {
        // TODO We really should take advantage of the Git commit DAG and
        // ensure the current version matches the old version the caller read.
        // 
        ProjectConfig config = ProjectConfig.read(md);
        config.getProject().copySettingsFrom(update);
        md.setMessage("Modified project settings\n");
        if (config.commit(md)) {
            mgr.setProjectDescription(projectName, update.getDescription());
            projectCache.evict(config.getProject());
            userCache.get().evict(projectName);
        } else {
            throw new OrmConcurrencyException("Cannot update " + projectName);
        }
    } catch (ConfigInvalidException err) {
        throw new OrmException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new OrmException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException {
    final Project.NameKey projectName = update.getNameKey();
    projectControlFactory.ownerFor(projectName);
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
    try {
        // TODO We really should take advantage of the Git commit DAG and
        // ensure the current version matches the old version the caller read.
        // 
        ProjectConfig config = ProjectConfig.read(md);
        config.getProject().copySettingsFrom(update);
        md.setMessage("Modified project settings\n");
        if (config.commit(md)) {
            mgr.setProjectDescription(projectName, update.getDescription());
            userCache.get().evict(config.getProject());
        } else {
            throw new OrmConcurrencyException("Cannot update " + projectName);
        }
    } catch (ConfigInvalidException err) {
        throw new OrmException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new OrmException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
public void evict(Project.NameKey nameKey) {
    controls.remove(nameKey);
}
#method_after
public void evict(Project project) {
    projectCache.evict(project);
    controls.remove(project.getNameKey());
}
#end_block

#method_before
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getInheritsFrom(), "refs/meta/config"), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(value != null && editing && !value.getOwnerOf().isEmpty());
}
#method_after
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (value.isConfigVisible() && c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setText(c.getLinkName());
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getProjectName(), "refs/meta/config"), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(value != null && editing && !value.getOwnerOf().isEmpty());
}
#end_block

#method_before
public static GitWebType fromName(final String name) {
    final GitWebType type;
    if (name == null || name.isEmpty() || name.equalsIgnoreCase("gitweb")) {
        type = new GitWebType();
        type.setProject("?p=${project}.git;a=summary");
        type.setRevision("?p=${project}.git;a=commit;h=${commit}");
        type.setBranch("?p=${project}.git;a=shortlog;h=${branch}");
        type.setFileHistory("?p=${project}.git;a=history;hb=${branch};f=${file}");
    } else if (name.equalsIgnoreCase("cgit")) {
        type = new GitWebType();
        type.setProject("${project}/summary");
        type.setRevision("${project}/commit/?id=${commit}");
        type.setBranch("${project}/log/?h=${branch}");
        type.setFileHistory("${project}/history/?hb=${branch};f=${file}");
    } else if (name.equalsIgnoreCase("custom")) {
        type = new GitWebType();
    } else {
        type = null;
    }
    return type;
}
#method_after
public static GitWebType fromName(final String name) {
    final GitWebType type;
    if (name == null || name.isEmpty() || name.equalsIgnoreCase("gitweb")) {
        type = new GitWebType();
        type.setLinkName("gitweb");
        type.setProject("?p=${project}.git;a=summary");
        type.setRevision("?p=${project}.git;a=commit;h=${commit}");
        type.setBranch("?p=${project}.git;a=shortlog;h=${branch}");
        type.setFileHistory("?p=${project}.git;a=history;hb=${branch};f=${file}");
    } else if (name.equalsIgnoreCase("cgit")) {
        type = new GitWebType();
        type.setLinkName("cgit");
        type.setProject("${project}/summary");
        type.setRevision("${project}/commit/?id=${commit}");
        type.setBranch("${project}/log/?h=${branch}");
        type.setFileHistory("${project}/log/${file}?h=${branch}");
    } else if (name.equalsIgnoreCase("custom")) {
        type = new GitWebType();
        // The custom name is not defined, let's keep the old style of using GitWeb
        type.setLinkName("gitweb");
    } else if (name.equalsIgnoreCase("disabled")) {
        type = null;
    } else {
        type = null;
    }
    return type;
}
#end_block

#method_before
public String toRevision(final Project.NameKey project, final PatchSet ps) {
    ParamertizedString pattern = new ParamertizedString(type.getRevision());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    p.put("commit", URL.encodeQueryString(ps.getRevision().get()));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toRevision(final Project.NameKey project, final PatchSet ps) {
    ParameterizedString pattern = new ParameterizedString(type.getRevision());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    p.put("commit", URL.encodeQueryString(ps.getRevision().get()));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
public String toProject(final Project.NameKey project) {
    ParamertizedString pattern = new ParamertizedString(type.getProject());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toProject(final Project.NameKey project) {
    ParameterizedString pattern = new ParameterizedString(type.getProject());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(project.get()));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
public String toBranch(final Branch.NameKey branch) {
    ParamertizedString pattern = new ParamertizedString(type.getBranch());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toBranch(final Branch.NameKey branch) {
    ParameterizedString pattern = new ParameterizedString(type.getBranch());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
public String toFileHistory(final Branch.NameKey branch, final String file) {
    ParamertizedString pattern = new ParamertizedString(type.getFileHistory());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    p.put("file", URL.encodeQueryString(file));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toFileHistory(final Branch.NameKey branch, final String file) {
    ParameterizedString pattern = new ParameterizedString(type.getFileHistory());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    p.put("file", URL.encodeQueryString(file));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (AccessSection.isAccessSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    detail.setRevision(config.getRevision().name());
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
        detail.setInheritsFrom(null);
    } else if (config.getProject().getParent() != null) {
        detail.setInheritsFrom(config.getProject().getParent());
    } else {
        detail.setInheritsFrom(allProjectsName);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (AccessSection.isAccessSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    detail.setRevision(config.getRevision().name());
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
        detail.setInheritsFrom(null);
    } else if (config.getProject().getParent() != null) {
        detail.setInheritsFrom(config.getProject().getParent());
    } else {
        detail.setInheritsFrom(allProjectsName);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#end_block

#method_before
@Override
public void myGroups(final AsyncCallback<List<GroupDetail>> callback) {
    run(callback, new Action<List<GroupDetail>>() {

        public List<GroupDetail> run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            List<GroupDetail> groups = new ArrayList<GroupDetail>();
            try {
                for (AccountGroup group : myGroupsFactory.create().call()) {
                    groups.add(groupDetailFactory.create(group.getId()).call());
                }
            } catch (Exception e) {
                throw new Failure(e);
            }
            return groups;
        }
    });
}
#method_after
@Override
public void myGroups(final AsyncCallback<List<GroupDetail>> callback) {
    run(callback, new Action<List<GroupDetail>>() {

        public List<GroupDetail> run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            List<GroupDetail> groupDetails = new ArrayList<GroupDetail>();
            for (AccountGroup group : myGroupsFactory.create().call()) {
                groupDetails.add(groupDetailFactory.create(group.getId()).call());
            }
            return groupDetails;
        }
    });
}
#end_block

#method_before
private void postLoad() {
    if (haveAccount && haveEmails) {
        if (currentEmail != null) {
            boolean found = false;
            for (int i = 0; i < emailPick.getItemCount(); i++) {
                if (currentEmail.equals(emailPick.getValue(i))) {
                    emailPick.setSelectedIndex(i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                emailPick.addItem(currentEmail);
                emailPick.setSelectedIndex(emailPick.getItemCount() - 1);
            }
        }
        if (emailPick.getItemCount() > 0) {
            emailPick.setVisible(true);
            emailPick.setEnabled(true);
            if (canRegisterNewEmail()) {
                final String t = Util.C.buttonOpenRegisterNewEmail();
                emailPick.addItem("... " + t + "  ", t);
            }
        } else {
            emailPick.setVisible(false);
        }
        registerNewEmail.setEnabled(true);
    }
    display();
}
#method_after
private void postLoad() {
    if (haveAccount && haveEmails) {
        updateEmailList();
        registerNewEmail.setEnabled(true);
    }
    display();
}
#end_block

#method_before
private void doRegisterNewEmail() {
    if (!canRegisterNewEmail()) {
        return;
    }
    final AutoCenterDialogBox box = new AutoCenterDialogBox(true, true);
    final VerticalPanel body = new VerticalPanel();
    final NpTextBox inEmail = new NpTextBox();
    inEmail.setVisibleLength(60);
    final Button register = new Button(Util.C.buttonSendRegisterNewEmail());
    final Button cancel = new Button(Util.C.buttonCancel());
    final FormPanel form = new FormPanel();
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
            final String addr = inEmail.getText().trim();
            if (!addr.contains("@")) {
                return;
            }
            inEmail.setEnabled(false);
            register.setEnabled(false);
            Util.ACCOUNT_SEC.registerEmail(addr, new GerritCallback<VoidResult>() {

                public void onSuccess(VoidResult result) {
                    box.hide();
                    switch(Gerrit.getConfig().getAuthType()) {
                        case HTTP:
                        case HTTP_LDAP:
                        case CLIENT_SSL_CERT_LDAP:
                        case OPENID:
                        case LDAP:
                        case LDAP_BIND:
                            break;
                        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                            Gerrit.upgradeUI(PageLinks.SETTINGS_CONTACT);
                            break;
                    }
                }

                @Override
                public void onFailure(final Throwable caught) {
                    inEmail.setEnabled(true);
                    register.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    form.setWidget(body);
    register.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            form.submit();
        }
    });
    cancel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            box.hide();
        }
    });
    final FlowPanel buttons = new FlowPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    buttons.add(register);
    buttons.add(cancel);
    body.add(new HTML(Util.C.descRegisterNewEmail()));
    body.add(inEmail);
    body.add(buttons);
    box.setText(Util.C.titleRegisterNewEmail());
    box.setWidget(form);
    box.center();
    inEmail.setFocus(true);
}
#method_after
private void doRegisterNewEmail() {
    if (!canRegisterNewEmail()) {
        return;
    }
    final AutoCenterDialogBox box = new AutoCenterDialogBox(true, true);
    final VerticalPanel body = new VerticalPanel();
    final NpTextBox inEmail = new NpTextBox();
    inEmail.setVisibleLength(60);
    final Button register = new Button(Util.C.buttonSendRegisterNewEmail());
    final Button cancel = new Button(Util.C.buttonCancel());
    final FormPanel form = new FormPanel();
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
            final String addr = inEmail.getText().trim();
            if (!addr.contains("@")) {
                new ErrorDialog(Util.C.invalidUserEmail()).center();
                return;
            }
            inEmail.setEnabled(false);
            register.setEnabled(false);
            Util.ACCOUNT_SEC.registerEmail(addr, new GerritCallback<Account>() {

                public void onSuccess(Account currentUser) {
                    box.hide();
                    if (Gerrit.getConfig().getAuthType() == AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
                        currentEmail = addr;
                        if (emailPick.getItemCount() == 0) {
                            onSaveSuccess(currentUser);
                        } else {
                            save.setEnabled(true);
                        }
                        updateEmailList();
                    }
                }

                @Override
                public void onFailure(final Throwable caught) {
                    inEmail.setEnabled(true);
                    register.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    form.setWidget(body);
    register.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            form.submit();
        }
    });
    cancel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            box.hide();
        }
    });
    final FlowPanel buttons = new FlowPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    buttons.add(register);
    buttons.add(cancel);
    if (Gerrit.getConfig().getAuthType() != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        body.add(new HTML(Util.C.descRegisterNewEmail()));
    }
    body.add(inEmail);
    body.add(buttons);
    box.setText(Util.C.titleRegisterNewEmail());
    box.setWidget(form);
    box.center();
    inEmail.setFocus(true);
}
#end_block

#method_before
public void registerEmail(final String address, final AsyncCallback<VoidResult> cb) {
    try {
        switch(authConfig.getAuthType()) {
            case OPENID:
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
            case LDAP:
            case LDAP_BIND:
                final RegisterNewEmailSender sender;
                sender = registerNewEmailFactory.create(address);
                sender.send();
                cb.onSuccess(VoidResult.INSTANCE);
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                registerMail(address, cb);
                break;
            default:
                log.error("Unsupported loginType: " + authConfig.getAuthType(), new ProvisionException("Unsupported loginType: " + authConfig.getAuthType()));
                throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
        }
    } catch (EmailException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    } catch (RuntimeException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    }
}
#method_after
public void registerEmail(final String address, final AsyncCallback<Account> cb) {
    if (authConfig.getAuthType() == AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        try {
            accountManager.link(user.get().getAccountId(), AuthRequest.forEmail(address));
            cb.onSuccess(user.get().getAccount());
        } catch (AccountException e) {
            cb.onFailure(e);
        }
    } else {
        try {
            final RegisterNewEmailSender sender;
            sender = registerNewEmailFactory.create(address);
            sender.send();
        } catch (EmailException e) {
            log.error("Cannot send email verification message to " + address, e);
            cb.onFailure(e);
        } catch (RuntimeException e) {
            log.error("Cannot send email verification message to " + address, e);
            cb.onFailure(e);
        }
    }
}
#end_block

#method_before
public void validateEmail(final String token, final AsyncCallback<VoidResult> callback) {
    try {
        final ValidToken t = authConfig.getEmailRegistrationToken().checkToken(token, null);
        if (t == null || t.getData() == null || "".equals(t.getData())) {
            callback.onFailure(new IllegalStateException("Invalid token"));
            return;
        }
        final String newEmail = new String(Base64.decode(t.getData()), "UTF-8");
        registerMail(newEmail, callback);
    } catch (XsrfException e) {
        callback.onFailure(e);
    } catch (UnsupportedEncodingException e) {
        callback.onFailure(e);
    }
}
#method_after
public void validateEmail(final String token, final AsyncCallback<VoidResult> callback) {
    try {
        final ValidToken t = authConfig.getEmailRegistrationToken().checkToken(token, null);
        if (t == null || t.getData() == null || "".equals(t.getData())) {
            callback.onFailure(new IllegalStateException("Invalid token"));
            return;
        }
        final String newEmail = new String(Base64.decode(t.getData()), "UTF-8");
        if (!newEmail.contains("@")) {
            callback.onFailure(new IllegalStateException("Invalid token"));
            return;
        }
        accountManager.link(user.get().getAccountId(), AuthRequest.forEmail(newEmail));
        callback.onSuccess(VoidResult.INSTANCE);
    } catch (XsrfException e) {
        callback.onFailure(e);
    } catch (UnsupportedEncodingException e) {
        callback.onFailure(e);
    } catch (AccountException e) {
        callback.onFailure(e);
    }
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    if (a1.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a1.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    Pattern regex = Pattern.compile(a1.name());
    if (a2.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a2.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    Pattern regexEdit = Pattern.compile(a2.name());
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(env);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    PatchList pl = getPatchList(env, psInfo);
    Repository repo;
    try {
        repo = getRepository(env);
    } catch (RepositoryNotFoundException err) {
        throw new JavaException(this, 1, err);
    }
    final ObjectReader reader = repo.newObjectReader();
    final RevTree aTree;
    final RevTree bTree;
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit bCommit = rw.parseCommit(pl.getNewId());
        if (pl.getOldId() != null) {
            aTree = rw.parseTree(pl.getOldId());
        } else {
            final RevCommit p = bCommit.getParent(0);
            rw.parseHeaders(p);
            aTree = p.getTree();
        }
        bTree = bCommit.getTree();
    } catch (IOException err) {
        throw new JavaException(this, 1, err);
    } finally {
        reader.release();
    }
    for (PatchListEntry entry : pl.getPatches()) {
        String newName = entry.getNewName();
        String oldName = entry.getOldName();
        if (regex.matcher(newName).find() || (oldName != null && regex.matcher(oldName).find())) {
            List<Edit> edits = entry.getEdits();
            if (edits.isEmpty()) {
                continue;
            }
            try {
                Text tA;
                if (oldName != null) {
                    tA = load(aTree, oldName, repo);
                } else {
                    tA = load(aTree, newName, repo);
                }
                Text tB = load(bTree, newName, repo);
                for (Edit edit : edits) {
                    if (tA != Text.EMPTY) {
                        String aDiff = tA.getString(edit.getBeginA(), edit.getEndA(), true);
                        if (regexEdit.matcher(aDiff).find()) {
                            engine.neckCut();
                            return cont;
                        }
                    }
                    if (tB != Text.EMPTY) {
                        String bDiff = tB.getString(edit.getBeginB(), edit.getEndB(), true);
                        if (regexEdit.matcher(bDiff).find()) {
                            engine.neckCut();
                            return cont;
                        }
                    }
                }
            } catch (IOException err) {
                throw new JavaException(this, 1, err);
            }
        }
    }
    return engine.fail();
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Pattern fileRegex = getRegexParameter(a1);
    Pattern editRegex = getRegexParameter(a2);
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo = StoredValues.PATCH_SET_INFO.get(engine);
    PatchList pl = StoredValues.PATCH_LIST.get(engine);
    Repository repo = StoredValues.REPOSITORY.get(engine);
    final ObjectReader reader = repo.newObjectReader();
    final RevTree aTree;
    final RevTree bTree;
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit bCommit = rw.parseCommit(pl.getNewId());
        if (pl.getOldId() != null) {
            aTree = rw.parseTree(pl.getOldId());
        } else {
            // web UI returns no files to match against, just fail.
            return engine.fail();
        }
        bTree = bCommit.getTree();
        for (PatchListEntry entry : pl.getPatches()) {
            String newName = entry.getNewName();
            String oldName = entry.getOldName();
            if (newName.equals("/COMMIT_MSG")) {
                continue;
            }
            if (fileRegex.matcher(newName).find() || (oldName != null && fileRegex.matcher(oldName).find())) {
                List<Edit> edits = entry.getEdits();
                if (edits.isEmpty()) {
                    continue;
                }
                Text tA;
                if (oldName != null) {
                    tA = load(aTree, oldName, reader);
                } else {
                    tA = load(aTree, newName, reader);
                }
                Text tB = load(bTree, newName, reader);
                for (Edit edit : edits) {
                    if (tA != Text.EMPTY) {
                        String aDiff = tA.getString(edit.getBeginA(), edit.getEndA(), true);
                        if (editRegex.matcher(aDiff).find()) {
                            return cont;
                        }
                    }
                    if (tB != Text.EMPTY) {
                        String bDiff = tB.getString(edit.getBeginB(), edit.getEndB(), true);
                        if (editRegex.matcher(bDiff).find()) {
                            return cont;
                        }
                    }
                }
            }
        }
    } catch (IOException err) {
        throw new JavaException(this, 1, err);
    } finally {
        reader.release();
    }
    return engine.fail();
}
#end_block

#method_before
private Text load(final ObjectId tree, final String path, final Repository repo) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
    if (path == null) {
        return Text.EMPTY;
    }
    final TreeWalk tw = TreeWalk.forPath(repo, path, tree);
    if (tw == null) {
        return Text.EMPTY;
    }
    if (tw.getFileMode(0).getObjectType() != Constants.OBJ_BLOB) {
        return Text.EMPTY;
    }
    return new Text(repo.open(tw.getObjectId(0), Constants.OBJ_BLOB));
}
#method_after
private Text load(final ObjectId tree, final String path, final ObjectReader reader) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
    if (path == null) {
        return Text.EMPTY;
    }
    final TreeWalk tw = TreeWalk.forPath(reader, path, tree);
    if (tw == null) {
        return Text.EMPTY;
    }
    if (tw.getFileMode(0).getObjectType() != Constants.OBJ_BLOB) {
        return Text.EMPTY;
    }
    return new Text(reader.open(tw.getObjectId(0), Constants.OBJ_BLOB));
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        try {
            while (parentState != null) {
                if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                    // parent has been seen before, stop walk up inheritance tree
                    break;
                }
                PrologEnvironment parentEnv;
                try {
                    parentEnv = parentState.newPrologEnvironment();
                } catch (CompileException err) {
                    return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
                }
                try {
                    parentEnv.copyStoredValues(childEnv);
                    Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
                    if (filterRule != null) {
                        try {
                            Term resultsTerm = toListTerm(results);
                            results.clear();
                            Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                            results.addAll(((ListTerm) template[2]).toJava());
                        } catch (PrologException err) {
                            return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                        } catch (RuntimeException err) {
                            return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                        }
                    }
                    parentState = parentState.getParentState();
                    childEnv = parentEnv;
                } finally {
                    // childEnv.close() below will handle it.
                    if (childEnv != parentEnv) {
                        parentEnv.close();
                    }
                }
            }
        } finally {
            childEnv.close();
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    results.addAll(((ListTerm) template[2]).toJava());
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
public void copyStoredValues(PrologEnvironment child) {
    storedValues.putAll(child.storedValues);
    child.delegateCleanup(cleanup);
}
#method_after
public void copyStoredValues(PrologEnvironment child) {
    storedValues.putAll(child.storedValues);
    setCleanup(child.cleanup);
}
#end_block

#method_before
public void close() {
    for (Runnable task : cleanup) {
        task.run();
    }
    // ensure cleanup tasks run only once, even if close() is called again
    cleanup.clear();
}
#method_after
public void close() {
    for (final Iterator<Runnable> i = cleanup.iterator(); i.hasNext(); ) {
        try {
            i.next().run();
        } catch (Throwable err) {
            log.error("Failed to execute cleanup for PrologEnvironment", err);
        }
        i.remove();
    }
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    Term submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
    if (submitRule == null) {
        return logRuleError("No user:submit_rule found for " + getProject().getName());
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    } catch (RuntimeException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    }
    ProjectState parentState = projectState.getParentState();
    PrologEnvironment parentEnv;
    PrologEnvironment childEnv = env;
    while (parentState != null) {
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", "locate_filter", new VariableTerm());
        if (filterRule != null) {
            try {
                Term resultsTerm = toListTerm(results);
                results.clear();
                List<Term> filtered = new ArrayList<Term>();
                for (Term[] template : parentEnv.all("gerrit", "filter_results", filterRule, resultsTerm, new VariableTerm())) {
                    results.add(template[2]);
                }
            } catch (PrologException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            } catch (RuntimeException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            }
        }
        parentState = parentState.getParentState();
        childEnv = parentEnv;
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    Term submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
    if (submitRule == null) {
        return logRuleError("No user:submit_rule found for " + getProject().getName());
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    } catch (RuntimeException err) {
        return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
    }
    ProjectState parentState = projectState.getParentState();
    PrologEnvironment childEnv = env;
    Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
    projectsSeen.add(getProject().getNameKey());
    while (parentState != null) {
        if (!projectsSeen.add(parentState.getProject().getNameKey())) {
            // parent has been seen before, stop walk up inheritance tree
            break;
        }
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
        if (filterRule != null) {
            try {
                Term resultsTerm = toListTerm(results);
                results.clear();
                Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                results.addAll(((ListTerm) template[2]).toJava());
            } catch (PrologException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            } catch (RuntimeException err) {
                return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
            }
        }
        parentState = parentState.getParentState();
        childEnv = parentEnv;
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
private Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (Term term : terms) {
        list = new ListTerm(term, list);
    }
    return list;
}
#method_after
private static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#end_block

#method_before
@Override
public ListBranchesResult call() throws NoSuchProjectException {
    final ProjectControl pctl = // 
    projectControlFactory.validateFor(// 
    projectName, ProjectControl.OWNER | ProjectControl.VISIBLE);
    final List<Branch> branches = new ArrayList<Branch>();
    Branch headBranch = null;
    final Set<String> targets = new HashSet<String>();
    final Repository db;
    try {
        db = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException noGitRepository) {
        return new ListBranchesResult(branches, false, true);
    }
    try {
        final Map<String, Ref> all = db.getAllRefs();
        if (!all.containsKey(Constants.HEAD)) {
            // 
            try {
                Ref head = db.getRef(Constants.HEAD);
                if (head != null) {
                    all.put(Constants.HEAD, head);
                }
            } catch (IOException e) {
            // Ignore the failure reading HEAD.
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                targets.add(ref.getTarget().getName());
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                // A symbolic reference to another branch, instead of
                // showing the resolved value, show the name it references.
                // 
                String target = ref.getTarget().getName();
                RefControl targetRefControl = pctl.controlForRef(target);
                if (!targetRefControl.isVisible()) {
                    continue;
                }
                if (target.startsWith(Constants.R_HEADS)) {
                    target = target.substring(Constants.R_HEADS.length());
                }
                Branch b = createBranch(ref.getName());
                b.setRevision(new RevId(target));
                if (Constants.HEAD.equals(ref.getName())) {
                    b.setCanDelete(false);
                    headBranch = b;
                } else {
                    b.setCanDelete(targetRefControl.canDelete());
                    branches.add(b);
                }
                continue;
            }
            RefControl refControl = pctl.controlForRef(ref.getName());
            if ((// 
            ref.getName().startsWith(Constants.R_HEADS) || GitRepositoryManager.REF_CONFIG.equals(ref.getName())) && refControl.isVisible()) {
                final Branch b = createBranch(ref.getName());
                if (ref.getObjectId() != null) {
                    b.setRevision(new RevId(ref.getObjectId().name()));
                }
                b.setCanDelete(!targets.contains(ref.getName()) && refControl.canDelete());
                branches.add(b);
            }
        }
    } finally {
        db.close();
    }
    Collections.sort(branches, new Comparator<Branch>() {

        @Override
        public int compare(final Branch a, final Branch b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (headBranch != null) {
        branches.add(0, headBranch);
    }
    return new ListBranchesResult(branches, pctl.canAddRefs(), false);
}
#method_after
@Override
public ListBranchesResult call() throws NoSuchProjectException {
    final ProjectControl pctl = // 
    projectControlFactory.validateFor(// 
    projectName, ProjectControl.OWNER | ProjectControl.VISIBLE);
    final List<Branch> branches = new ArrayList<Branch>();
    Branch headBranch = null;
    Branch configBranch = null;
    final Set<String> targets = new HashSet<String>();
    final Repository db;
    try {
        db = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException noGitRepository) {
        return new ListBranchesResult(branches, false, true);
    }
    try {
        final Map<String, Ref> all = db.getAllRefs();
        if (!all.containsKey(Constants.HEAD)) {
            // 
            try {
                Ref head = db.getRef(Constants.HEAD);
                if (head != null) {
                    all.put(Constants.HEAD, head);
                }
            } catch (IOException e) {
            // Ignore the failure reading HEAD.
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                targets.add(ref.getTarget().getName());
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                // A symbolic reference to another branch, instead of
                // showing the resolved value, show the name it references.
                // 
                String target = ref.getTarget().getName();
                RefControl targetRefControl = pctl.controlForRef(target);
                if (!targetRefControl.isVisible()) {
                    continue;
                }
                if (target.startsWith(Constants.R_HEADS)) {
                    target = target.substring(Constants.R_HEADS.length());
                }
                Branch b = createBranch(ref.getName());
                b.setRevision(new RevId(target));
                if (Constants.HEAD.equals(ref.getName())) {
                    b.setCanDelete(false);
                    headBranch = b;
                } else {
                    b.setCanDelete(targetRefControl.canDelete());
                    branches.add(b);
                }
                continue;
            }
            final RefControl refControl = pctl.controlForRef(ref.getName());
            if (refControl.isVisible()) {
                if (ref.getName().startsWith(Constants.R_HEADS)) {
                    branches.add(createBranch(ref, refControl, targets));
                } else if (GitRepositoryManager.REF_CONFIG.equals(ref.getName())) {
                    configBranch = createBranch(ref, refControl, targets);
                }
            }
        }
    } finally {
        db.close();
    }
    Collections.sort(branches, new Comparator<Branch>() {

        @Override
        public int compare(final Branch a, final Branch b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (configBranch != null) {
        branches.add(0, configBranch);
    }
    if (headBranch != null) {
        branches.add(0, headBranch);
    }
    return new ListBranchesResult(branches, pctl.canAddRefs(), false);
}
#end_block

#method_before
private Branch createBranch(final String name) {
    return new Branch(new Branch.NameKey(projectName, name));
}
#method_after
private Branch createBranch(final Ref ref, final RefControl refControl, final Set<String> targets) {
    final Branch b = createBranch(ref.getName());
    if (ref.getObjectId() != null) {
        b.setRevision(new RevId(ref.getObjectId().name()));
    }
    b.setCanDelete(!targets.contains(ref.getName()) && refControl.canDelete());
    return b;
}
#end_block

#method_before
void display(final List<Patch> result) {
    all.clear();
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    table.setText(1, 0, PatchUtil.C.patchHeaderOld());
    fmt.setStyleName(1, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(2, 0, PatchUtil.C.patchHeaderNew());
    fmt.setStyleName(2, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(3, 0, Util.C.patchTableColumnComments());
    fmt.setStyleName(3, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(0, 1, "Base");
    fmt.setStyleName(0, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topMostCell());
    fmt.setStyleName(1, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(2, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(3, 1, Gerrit.RESOURCES.css().dataCell());
    installRadio(1, 1, null, screen.idSideA, 0);
    int col = 2;
    for (final Patch k : result) {
        final PatchSet.Id psId = k.getKey().getParentKey();
        table.setText(0, col, Util.M.patchSetHeader(psId.get()));
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().dataCell());
        fmt.addStyleName(0, col, Gerrit.RESOURCES.css().topMostCell());
        installRadio(1, col, psId, screen.idSideA, 0);
        installRadio(2, col, psId, screen.idSideB, 1);
        fmt.setStyleName(3, col, Gerrit.RESOURCES.css().dataCell());
        if (k.getCommentCount() > 0) {
            table.setText(3, col, Util.M.patchTableComments(k.getCommentCount()));
        }
        col++;
    }
}
#method_after
void display(final List<Patch> result) {
    all.clear();
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    table.setText(0, 0, PatchUtil.C.patchHeaderPatchSet());
    fmt.setStyleName(0, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(1, 0, PatchUtil.C.patchHeaderOld());
    fmt.setStyleName(1, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(2, 0, PatchUtil.C.patchHeaderNew());
    fmt.setStyleName(2, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(3, 0, Util.C.patchTableColumnComments());
    fmt.setStyleName(3, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(0, 1, PatchUtil.C.patchBase());
    fmt.setStyleName(0, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topMostCell());
    fmt.setStyleName(1, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(2, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(3, 1, Gerrit.RESOURCES.css().dataCell());
    installRadio(1, 1, null, screen.idSideA, 0);
    int col = 2;
    for (final Patch k : result) {
        final PatchSet.Id psId = k.getKey().getParentKey();
        table.setText(0, col, String.valueOf(psId.get()));
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().patchHistoryTablePatchSetHeader());
        fmt.addStyleName(0, col, Gerrit.RESOURCES.css().dataCell());
        fmt.addStyleName(0, col, Gerrit.RESOURCES.css().topMostCell());
        installRadio(1, col, psId, screen.idSideA, 0);
        installRadio(2, col, psId, screen.idSideB, 1);
        fmt.setStyleName(3, col, Gerrit.RESOURCES.css().dataCell());
        if (k.getCommentCount() > 0) {
            table.setText(3, col, Util.M.patchTableComments(k.getCommentCount()));
        }
        col++;
    }
}
#end_block

#method_before
public void addReviewers(final Change.Id id, final List<String> reviewers, final boolean confirmed, final AsyncCallback<ReviewerResult> callback) {
    addReviewerFactory.create(id, reviewers, confirmed).to(callback);
}
#method_after
public void addReviewers(final Change.Id id, final List<String> reviewers, final boolean confirmed, final AsyncCallback<ReviewerResult> callback) {
    addReviewerHandlerFactory.create(id, reviewers, confirmed).to(callback);
}
#end_block

#method_before
public void removeReviewer(final Change.Id id, final Account.Id reviewerId, final AsyncCallback<ReviewerResult> callback) {
    removeReviewerFactory.create(id, reviewerId).to(callback);
}
#method_after
public void removeReviewer(final Change.Id id, final Account.Id reviewerId, final AsyncCallback<ReviewerResult> callback) {
    removeReviewerHandlerFactory.create(id, reviewerId).to(callback);
}
#end_block

#method_before
public void userApprovals(final Set<Change.Id> cids, final Account.Id aid, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            aicFactory.want(aid);
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(change, ps_id, psas.values());
                    for (final PatchSetApproval ca : db.patchSetApprovals().byPatchSetUser(ps_id, aid)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        psas.put(category, ca);
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#method_after
public void userApprovals(final Set<Change.Id> cids, final Account.Id aid, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            aicFactory.want(aid);
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(cc, ps_id, psas.values());
                    for (final PatchSetApproval ca : db.patchSetApprovals().byPatchSetUser(ps_id, aid)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        psas.put(category, ca);
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#end_block

#method_before
public void strongestApprovals(final Set<Change.Id> cids, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(change, ps_id, psas.values());
                    for (PatchSetApproval ca : db.patchSetApprovals().byPatchSet(ps_id)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        boolean keep = true;
                        if (psas.containsKey(category)) {
                            final short oldValue = psas.get(category).getValue();
                            final short newValue = ca.getValue();
                            keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                        }
                        if (keep) {
                            aicFactory.want(ca.getAccountId());
                            psas.put(category, ca);
                        }
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#method_after
public void strongestApprovals(final Set<Change.Id> cids, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(cc, ps_id, psas.values());
                    for (PatchSetApproval ca : db.patchSetApprovals().byPatchSet(ps_id)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        boolean keep = true;
                        if (psas.containsKey(category)) {
                            final short oldValue = psas.get(category).getValue();
                            final short newValue = ca.getValue();
                            keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                        }
                        if (keep) {
                            aicFactory.want(ca.getAccountId());
                            psas.put(category, ca);
                        }
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#end_block

#method_before
private void displayHeader() {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    for (final ApprovalType t : types) {
        table.setText(0, col, t.getCategory().getName());
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(0, col, Gerrit.RESOURCES.css().rightmost());
    col++;
}
#method_after
private void displayHeader(List<String> labels) {
    table.resizeColumns(2 + labels.size());
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    for (String name : labels) {
        table.setText(0, col, name);
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    fmt.addStyleName(0, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
public void display(final Change change, final Set<ApprovalCategory.Id> need, final List<ApprovalDetail> rows) {
    changeId = change.getId();
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        table.resizeRows(1 + rows.size());
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i), change);
        }
        table.setVisible(true);
    }
    final Element missingList = missing.getElement();
    while (DOM.getChildCount(missingList) > 0) {
        DOM.removeChild(missingList, DOM.getChild(missingList, 0));
    }
    missing.setVisible(false);
    if (need != null) {
        for (final ApprovalType at : types) {
            if (need.contains(at.getCategory().getId())) {
                final Element li = DOM.createElement("li");
                li.setClassName(Gerrit.RESOURCES.css().missingApproval());
                DOM.setInnerText(li, Util.M.needApproval(at.getCategory().getName(), at.getMax().formatValue(), at.getMax().getName()));
                DOM.appendChild(missingList, li);
                missing.setVisible(true);
            }
        }
    }
    addReviewer.setVisible(Gerrit.isSignedIn() && change.getStatus().isOpen());
}
#method_after
void display(ChangeDetail detail) {
    reviewerSuggestOracle.setProject(detail.getChange().getProject());
    List<String> columns = new ArrayList<String>();
    List<ApprovalDetail> rows = detail.getApprovals();
    changeId = detail.getChange().getId();
    final Element missingList = missing.getElement();
    while (DOM.getChildCount(missingList) > 0) {
        DOM.removeChild(missingList, DOM.getChild(missingList, 0));
    }
    missing.setVisible(false);
    if (detail.getSubmitRecords() != null) {
        HashSet<String> reportedMissing = new HashSet<String>();
        HashMap<Account.Id, ApprovalDetail> byUser = new HashMap<Account.Id, ApprovalDetail>();
        for (ApprovalDetail ad : detail.getApprovals()) {
            byUser.put(ad.getAccount(), ad);
        }
        for (SubmitRecord rec : detail.getSubmitRecords()) {
            if (rec.labels == null) {
                continue;
            }
            for (SubmitRecord.Label lbl : rec.labels) {
                if (!columns.contains(lbl.label)) {
                    columns.add(lbl.label);
                }
                switch(lbl.status) {
                    case OK:
                        {
                            ApprovalDetail ad = byUser.get(lbl.appliedBy);
                            if (ad != null) {
                                ad.approved(lbl.label);
                            }
                            break;
                        }
                    case REJECT:
                        {
                            ApprovalDetail ad = byUser.get(lbl.appliedBy);
                            if (ad != null) {
                                ad.rejected(lbl.label);
                            }
                            break;
                        }
                    case NEED:
                    case IMPOSSIBLE:
                        if (reportedMissing.add(lbl.label)) {
                            Element li = DOM.createElement("li");
                            li.setClassName(Gerrit.RESOURCES.css().missingApproval());
                            DOM.setInnerText(li, Util.M.needApproval(lbl.label));
                            DOM.appendChild(missingList, li);
                        }
                        break;
                }
            }
        }
        missing.setVisible(!reportedMissing.isEmpty());
    } else {
        for (ApprovalDetail ad : rows) {
            for (PatchSetApproval psa : ad.getPatchSetApprovals()) {
                ApprovalType legacyType = types.byId(psa.getCategoryId());
                if (legacyType == null) {
                    continue;
                }
                String labelName = legacyType.getCategory().getLabelName();
                if (psa.getValue() == legacyType.getMax().getValue()) {
                    ad.approved(labelName);
                } else if (psa.getValue() == legacyType.getMin().getValue()) {
                    ad.rejected(labelName);
                }
                if (!columns.contains(labelName)) {
                    columns.add(labelName);
                }
            }
            Collections.sort(columns, new Comparator<String>() {

                @Override
                public int compare(String o1, String o2) {
                    ApprovalType a = types.byLabel(o1);
                    ApprovalType b = types.byLabel(o2);
                    int cmp = 0;
                    if (a != null && b != null) {
                        cmp = a.getCategory().getPosition() - b.getCategory().getPosition();
                    }
                    if (cmp == 0) {
                        cmp = o1.compareTo(o2);
                    }
                    return cmp;
                }
            });
        }
    }
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        displayHeader(columns);
        table.resizeRows(1 + rows.size());
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i), detail.getChange(), columns);
        }
        table.setVisible(true);
    }
    addReviewer.setVisible(Gerrit.isSignedIn());
}
#end_block

#method_before
private void doAddReviewer() {
    final String userNameOrEmailOrGroupName = addMemberBox.getText();
    if (userNameOrEmailOrGroupName.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = new ArrayList<String>();
    reviewers.add(userNameOrEmailOrGroupName);
    addReviewers(reviewers, false);
}
#method_after
private void doAddReviewer() {
    final String reviewer = addMemberBox.getText();
    if (reviewer.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = new ArrayList<String>();
    reviewers.add(reviewer);
    addReviewers(reviewers, false);
}
#end_block

#method_before
private void addReviewers(final List<String> reviewers, final boolean confirmed) {
    PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, confirmed, new GerritCallback<ReviewerResult>() {

        public void onSuccess(final ReviewerResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
            final ChangeDetail changeDetail = result.getChange();
            if (changeDetail != null) {
                setAccountInfoCache(changeDetail.getAccounts());
                display(changeDetail.getChange(), changeDetail.getMissingApprovals(), changeDetail.getApprovals());
            }
            if (!result.getErrors().isEmpty()) {
                final SafeHtmlBuilder r = new SafeHtmlBuilder();
                for (final ReviewerResult.Error e : result.getErrors()) {
                    switch(e.getType()) {
                        case ACCOUNT_OR_GROUP_NOT_FOUND:
                            r.append(Util.M.accountOrGroupNotFound(e.getName()));
                            break;
                        case ACCOUNT_INACTIVE:
                            r.append(Util.M.accountInactive(e.getName()));
                            break;
                        case CHANGE_NOT_VISIBLE:
                            r.append(Util.M.changeNotVisibleTo(e.getName()));
                            break;
                        case GROUP_EMPTY:
                            r.append(Util.M.groupIsEmpty(e.getName()));
                            break;
                        case GROUP_HAS_TOO_MANY_MEMBERS:
                            if (result.askForConfirmation() && !confirmed) {
                                StringBuilder message = new StringBuilder();
                                message.append("<b>");
                                message.append(Util.M.groupManyMembersConfirmation(e.getName(), result.getMemberCount()));
                                message.append("</b>");
                                ConfirmationDialog confirmationDialog = new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new HTML(message.toString()), new ConfirmationCallback() {

                                    @Override
                                    public void onOk() {
                                        addReviewers(reviewers, true);
                                    }
                                });
                                confirmationDialog.center();
                                return;
                            } else {
                                r.append(Util.M.groupHasTooManyMembers(e.getName()));
                            }
                            break;
                        case GROUP_NOT_ALLOWED:
                            r.append(Util.M.groupIsNotAllowed(e.getName()));
                            break;
                        default:
                            r.append(e.getName());
                            r.append(" - ");
                            r.append(e.getType());
                            r.br();
                            break;
                    }
                }
                new ErrorDialog(r).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void addReviewers(final List<String> reviewers, final boolean confirmed) {
    PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, confirmed, new GerritCallback<ReviewerResult>() {

        public void onSuccess(final ReviewerResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
            final ChangeDetail changeDetail = result.getChange();
            if (changeDetail != null) {
                setAccountInfoCache(changeDetail.getAccounts());
                display(changeDetail);
            }
            if (!result.getErrors().isEmpty()) {
                final SafeHtmlBuilder r = new SafeHtmlBuilder();
                for (final ReviewerResult.Error e : result.getErrors()) {
                    switch(e.getType()) {
                        case REVIEWER_NOT_FOUND:
                            r.append(Util.M.reviewerNotFound(e.getName()));
                            break;
                        case ACCOUNT_INACTIVE:
                            r.append(Util.M.accountInactive(e.getName()));
                            break;
                        case CHANGE_NOT_VISIBLE:
                            r.append(Util.M.changeNotVisibleTo(e.getName()));
                            break;
                        case GROUP_EMPTY:
                            r.append(Util.M.groupIsEmpty(e.getName()));
                            break;
                        case GROUP_HAS_TOO_MANY_MEMBERS:
                            if (result.askForConfirmation() && !confirmed) {
                                askForConfirmation(e.getName(), result.getMemberCount());
                                return;
                            } else {
                                r.append(Util.M.groupHasTooManyMembers(e.getName()));
                            }
                            break;
                        case GROUP_NOT_ALLOWED:
                            r.append(Util.M.groupIsNotAllowed(e.getName()));
                            break;
                        default:
                            r.append(e.getName());
                            r.append(" - ");
                            r.append(e.getType());
                            r.br();
                            break;
                    }
                }
                new ErrorDialog(r).center();
            }
        }

        private void askForConfirmation(final String groupName, final int memberCount) {
            final StringBuilder message = new StringBuilder();
            message.append("<b>");
            message.append(Util.M.groupManyMembersConfirmation(groupName, memberCount));
            message.append("</b>");
            final ConfirmationDialog confirmationDialog = new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new HTML(message.toString()), new ConfirmationCallback() {

                @Override
                public void onOk() {
                    addReviewers(reviewers, true);
                }
            });
            confirmationDialog.center();
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void displayRow(final int row, final ApprovalDetail ad, final Change change) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> am = ad.getApprovalMap();
    final StringBuilder hint = new StringBuilder();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (final ApprovalType type : types) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        final PatchSetApproval ca = am.get(type.getCategory().getId());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
            col++;
            continue;
        }
        final ApprovalCategoryValue acv = type.getValue(ca);
        if (acv != null) {
            if (hint.length() > 0) {
                hint.append("; ");
            }
            hint.append(acv.getName());
        }
        if (type.isMaxNegative(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (type.isMaxPositive(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    table.setText(row, col, hint.toString());
    fmt.setStyleName(row, col, Gerrit.RESOURCES.css().rightmost());
    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().approvalhint());
    col++;
}
#method_after
private void displayRow(final int row, final ApprovalDetail ad, final Change change, List<String> columns) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : columns) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            ApprovalType legacyType = types.byLabel(labelName);
            if (legacyType == null) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            PatchSetApproval ca = ad.getPatchSetApproval(legacyType.getCategory().getId());
            if (ca == null || ca.getValue() == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
private void doRemove(final ApprovalDetail ad, final PushButton remove) {
    remove.setEnabled(false);
    PatchUtil.DETAIL_SVC.removeReviewer(changeId, ad.getAccount(), new GerritCallback<ReviewerResult>() {

        @Override
        public void onSuccess(ReviewerResult result) {
            if (result.getErrors().isEmpty()) {
                final ChangeDetail r = result.getChange();
                display(r.getChange(), r.getMissingApprovals(), r.getApprovals());
            } else {
                new ErrorDialog(result.getErrors().get(0).toString()).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            remove.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doRemove(final ApprovalDetail ad, final PushButton remove) {
    remove.setEnabled(false);
    PatchUtil.DETAIL_SVC.removeReviewer(changeId, ad.getAccount(), new GerritCallback<ReviewerResult>() {

        @Override
        public void onSuccess(ReviewerResult result) {
            if (result.getErrors().isEmpty()) {
                final ChangeDetail r = result.getChange();
                display(r);
            } else {
                final ReviewerResult.Error resultError = result.getErrors().get(0);
                String message;
                switch(resultError.getType()) {
                    case REMOVE_NOT_PERMITTED:
                        message = Util.C.approvalTableRemoveNotPermitted();
                        break;
                    case COULD_NOT_REMOVE:
                    default:
                        message = Util.C.approvalTableCouldNotRemove();
                }
                new ErrorDialog(message + " " + resultError.getName()).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            remove.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.areg2 = arg2;
    engine.areg3 = arg3;
    engine.areg4 = arg4;
    engine.cont = cont;
    engine.setB0();
    Term a1 = arg1.dereference();
    if (a1.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a1.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(env);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    UserIdentity author = psInfo.getAuthor();
    PatchListCache plCache = env.getInjector().getInstance(PatchListCache.class);
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey projectKey = change.getProject();
    ObjectId a = null;
    ObjectId b = ObjectId.fromString(psInfo.getRevId());
    Whitespace ws = Whitespace.IGNORE_NONE;
    PatchListKey plKey = new PatchListKey(projectKey, a, b, ws);
    // make a modifiable copy of the patches list
    List<PatchListEntry> patches = new ArrayList<PatchListEntry>();
    PatchList pl = plCache.get(plKey);
    for (PatchListEntry entry : pl.getPatches()) {
        patches.add(entry);
    }
    engine.areg1 = arg1;
    engine.areg5 = new JavaObjectTerm(patches);
    return commit_delta_4_top;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.cont = cont;
    engine.setB0();
    Term a1 = arg1.dereference();
    if (a1.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a1.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    Pattern regex = Pattern.compile(a1.name());
    engine.areg1 = new JavaObjectTerm(regex);
    engine.areg2 = arg2;
    engine.areg3 = arg3;
    engine.areg4 = arg4;
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(env);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    PatchListCache plCache = env.getInjector().getInstance(PatchListCache.class);
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey projectKey = change.getProject();
    ObjectId a = null;
    ObjectId b = ObjectId.fromString(psInfo.getRevId());
    Whitespace ws = Whitespace.IGNORE_NONE;
    PatchListKey plKey = new PatchListKey(projectKey, a, b, ws);
    PatchList pl = plCache.get(plKey);
    Iterator<PatchListEntry> iter = pl.getPatches().iterator();
    engine.areg5 = new JavaObjectTerm(iter);
    return engine.jtry5(commit_delta_check, commit_delta_next);
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) {
    Term a1 = engine.areg1;
    Term a2 = engine.areg2;
    Term a3 = engine.areg3;
    Term a4 = engine.areg4;
    Term a5 = engine.areg5;
    a1.dereference();
    a2.dereference();
    a3.dereference();
    a4.dereference();
    a5.dereference();
    String regex = a1.toString();
    List<PatchListEntry> patches = (List<PatchListEntry>) ((JavaObjectTerm) a5).object();
    if (!patches.isEmpty()) {
        PatchListEntry patch = patches.get(0);
        String newName = patch.getNewName();
        String oldName = patch.getOldName();
        Patch.ChangeType changeType = patch.getChangeType();
        if ((oldName != null && oldName.matches(regex)) || newName.matches(regex)) {
            SymbolTerm newSym = SymbolTerm.create(newName);
            SymbolTerm changeSym = SymbolTerm.intern(changeType.toString());
            SymbolTerm oldSym = Prolog.Nil;
            if (oldName != null) {
                oldSym = SymbolTerm.create(oldName);
            }
            if (!a2.unify(newSym, engine.trail)) {
                return engine.fail();
            }
            if (!a3.unify(changeSym, engine.trail)) {
                return engine.fail();
            }
            if (!a4.unify(oldSym, engine.trail)) {
                return engine.fail();
            }
            return engine.cont;
        }
    }
    return engine.fail();
}
#method_after
@Override
public Operation exec(Prolog engine) {
    Term a1 = engine.areg1;
    Term a2 = engine.areg2;
    Term a3 = engine.areg3;
    Term a4 = engine.areg4;
    Term a5 = engine.areg5;
    Pattern regex = (Pattern) ((JavaObjectTerm) a1).object();
    Iterator<PatchListEntry> iter = (Iterator<PatchListEntry>) ((JavaObjectTerm) a5).object();
    if (iter.hasNext()) {
        PatchListEntry patch = iter.next();
        String newName = patch.getNewName();
        String oldName = patch.getOldName();
        Patch.ChangeType changeType = patch.getChangeType();
        if (regex.matcher(newName).matches() || (oldName != null && regex.matcher(oldName).matches())) {
            SymbolTerm changeSym = getTypeSymbol(changeType);
            SymbolTerm newSym = SymbolTerm.create(newName);
            SymbolTerm oldSym = Prolog.Nil;
            if (oldName != null) {
                oldSym = SymbolTerm.create(oldName);
            }
            if (!a2.unify(changeSym, engine.trail)) {
                return engine.fail();
            }
            if (!a3.unify(newSym, engine.trail)) {
                return engine.fail();
            }
            if (!a4.unify(oldSym, engine.trail)) {
                return engine.fail();
            }
            return engine.cont;
        }
    }
    return engine.fail();
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) {
    return engine.trust(commit_delta_modify);
}
#method_after
@Override
public Operation exec(Prolog engine) {
    return engine.trust(commit_delta_empty);
}
#end_block

#method_before
public PatchSet.Id getPatchSetId() {
    return psId;
}
#method_after
public PatchSet.Id getPatchSetId() {
    return patchSetId;
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(final Transport tn) throws IOException {
    final ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = db.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!mirror) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = new HashMap<String, Ref>();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        final ReviewDb meta;
        try {
            meta = schema.open();
        } catch (OrmException e) {
            log.error("Cannot read database to replicate to " + projectName, e);
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(db, pc, meta, true, this.tagCache).filter(local);
        } finally {
            meta.close();
        }
    }
    final List<RemoteRefUpdate> cmds = new ArrayList<RemoteRefUpdate>();
    if (mirror) {
        final Map<String, Ref> remote = listRemote(tn);
        for (final Ref src : local.values()) {
            final RefSpec spec = matchSrc(src.getName());
            if (spec != null) {
                final Ref dst = remote.get(spec.getDestination());
                if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                    // Doesn't exist yet, or isn't the same value, request to push.
                    // 
                    send(cmds, spec, src);
                }
            }
        }
        for (final Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                final RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    // 
                    delete(cmds, spec);
                }
            }
        }
    } else {
        for (final String src : delta) {
            final RefSpec spec = matchSrc(src);
            if (spec != null) {
                // If the ref still exists locally, send it, otherwise delete it.
                // 
                Ref srcRef = local.get(src);
                if (srcRef != null) {
                    send(cmds, spec, srcRef);
                } else {
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> generateUpdates(final Transport tn) throws IOException {
    final ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = db.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!mirror) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = new HashMap<String, Ref>();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        final ReviewDb meta;
        try {
            meta = schema.open();
        } catch (OrmException e) {
            log.error("Cannot read database to replicate to " + projectName, e);
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, db, pc, meta, true).filter(local);
        } finally {
            meta.close();
        }
    }
    final List<RemoteRefUpdate> cmds = new ArrayList<RemoteRefUpdate>();
    if (mirror) {
        final Map<String, Ref> remote = listRemote(tn);
        for (final Ref src : local.values()) {
            final RefSpec spec = matchSrc(src.getName());
            if (spec != null) {
                final Ref dst = remote.get(spec.getDestination());
                if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                    // Doesn't exist yet, or isn't the same value, request to push.
                    // 
                    send(cmds, spec, src);
                }
            }
        }
        for (final Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                final RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    // 
                    delete(cmds, spec);
                }
            }
        }
    } else {
        for (final String src : delta) {
            final RefSpec spec = matchSrc(src);
            if (spec != null) {
                // If the ref still exists locally, send it, otherwise delete it.
                // 
                Ref srcRef = local.get(src);
                if (srcRef != null) {
                    send(cmds, spec, srcRef);
                } else {
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(GitTagCacheImpl.module());
    install(RegExpCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(SecureCredentialsProvider.Factory.class);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(TagCache.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(SecureCredentialsProvider.Factory.class);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        evictTagCache(cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        evictTagCache(cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        evictTagCache(cmd);
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        h.add(SIDE_HAVE);
        walk.markStart(h);
        boolean isConnected = false;
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (c.hasAll(COMMON)) {
                isConnected = true;
                break;
            }
        }
        if (!isConnected) {
            reject(newChange, "no common ancestry");
            return;
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        h.add(SIDE_HAVE);
        walk.markStart(h);
        boolean isConnected = false;
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (c.hasAll(COMMON)) {
                isConnected = true;
                break;
            }
        }
        if (!isConnected) {
            reject(newChange, "no common ancestry");
            return;
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
@Override
public Map<String, Ref> filter(Map<String, Ref> refs) {
    final Set<Change.Id> visibleChanges = visibleChanges();
    final Map<String, Ref> result = new HashMap<String, Ref>();
    final List<Ref> deferredTags = new ArrayList<Ref>();
    for (Ref ref : refs.values()) {
        if (PatchSet.isRef(ref.getName())) {
            // 
            if (visibleChanges.contains(Change.Id.fromRef(ref.getName()))) {
                result.put(ref.getName(), ref);
            }
        } else if (isTag(ref)) {
            // If its a tag, consider it later.
            // 
            deferredTags.add(ref);
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            // 
            result.put(ref.getName(), ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && !result.isEmpty()) {
        Map<Ref, List<Ref>> reachableTags = tagCache.get(db);
        for (Ref tag : reachableTags.keySet()) {
            for (Ref ref : reachableTags.get(tag)) {
                if (projectCtl.controlForRef(ref.getName()).isVisible()) {
                    result.put(tag.getName(), tag);
                    break;
                }
            }
        }
    }
    return result;
}
#method_after
@Override
public Map<String, Ref> filter(Map<String, Ref> refs) {
    final Set<Change.Id> visibleChanges = visibleChanges();
    final Map<String, Ref> result = new HashMap<String, Ref>();
    final List<Ref> deferredTags = new ArrayList<Ref>();
    for (Ref ref : refs.values()) {
        if (PatchSet.isRef(ref.getName())) {
            // 
            if (visibleChanges.contains(Change.Id.fromRef(ref.getName()))) {
                result.put(ref.getName(), ref);
            }
        } else if (isTag(ref)) {
            // 
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            // 
            result.put(ref.getName(), ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && !result.isEmpty()) {
        TagMatcher tags = tagCache.get(projectName).matcher(db, result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, projectControl, db.get(), true, tagCache));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(tagCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#end_block

#method_before
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    ProjectControl pc = getProjectControl(req);
    if (!pc.canRunUploadPack()) {
        throw new ServiceNotAuthorizedException();
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(packConfig);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, pc, db.get(), true, tagCache));
    }
    return up;
}
#method_after
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    ProjectControl pc = getProjectControl(req);
    if (!pc.canRunUploadPack()) {
        throw new ServiceNotAuthorizedException();
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(packConfig);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(tagCache, repo, pc, db.get(), true));
    }
    return up;
}
#end_block

#method_before
private File local(final HttpServletRequest req) {
    final String name = req.getPathInfo();
    if (name.length() < 2 || !name.startsWith("/")) {
        // 
        return null;
    }
    final File p = new File(staticBase, name.substring(1));
    // Ensure that the requested file is *actually* within the static dir base.
    try {
        if (!p.getCanonicalFile().getPath().startsWith(staticBase.getPath() + File.separator))
            return null;
    } catch (IOException e) {
        return null;
    }
    return p.isFile() ? p : null;
}
#method_after
private File local(final HttpServletRequest req) {
    final String name = req.getPathInfo();
    if (name.length() < 2 || !name.startsWith("/") || isUnreasonableName(name)) {
        // 
        return null;
    }
    final File p = new File(staticBase, name.substring(1));
    // Ensure that the requested file is *actually* within the static dir base.
    try {
        if (!p.getCanonicalFile().getPath().startsWith(staticBasePath))
            return null;
    } catch (IOException e) {
        return null;
    }
    return p.isFile() ? p : null;
}
#end_block

#method_before
@Override
public int run() throws Exception {
    dbInjector = createDbInjector(MULTI_USER);
    manager.add(dbInjector);
    manager.start();
    dbInjector.injectMembers(this);
    Project.NameKey project = getNameKey();
    Repository git = gitManager.openRepository(project);
    PrologJar jarMaker = new PrologJar(getSitePath(), git);
    boolean success = jarMaker.run();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    dbInjector = createDbInjector(SINGLE_USER);
    manager.add(dbInjector);
    manager.start();
    dbInjector.createChildInjector(new FactoryModule() {

        @Override
        protected void configure() {
            factory(PrologCompiler.Factory.class);
        }
    }).injectMembers(this);
    LinkedHashSet<Project.NameKey> names = new LinkedHashSet<Project.NameKey>();
    for (String name : projectNames) {
        names.add(new Project.NameKey(name));
    }
    if (all) {
        names.addAll(gitManager.list());
    }
    boolean error = false;
    for (Project.NameKey project : names) {
        Repository git = gitManager.openRepository(project);
        try {
            switch(jarFactory.create(git).call()) {
                case NO_RULES:
                    if (!all || projectNames.contains(project.get())) {
                        System.err.println("error: No rules.pl in " + project.get());
                        error = true;
                    }
                    break;
                case COMPILED:
                    if (!quiet) {
                        System.out.format("Compiled %-60s ... SUCCESS", project.get());
                        System.out.println();
                    }
                    break;
            }
        } catch (CompileException err) {
            if (showStackTrace) {
                err.printStackTrace();
            } else {
                System.err.println("fatal: " + err.getMessage());
            }
            error = true;
        } finally {
            git.close();
        }
    }
    return !error ? 0 : 1;
}
#end_block

#method_before
public URLClassLoader getClassLoader(ObjectId rulesId) {
    // get rules.pl's sha1, if it exists
    String filePath = "";
    File cacheFolder = site.resolve(config.getString("cache", null, "directory"));
    if (cacheFolder != null) {
        filePath = cacheFolder.getPath();
    }
    // read jar from (site)/cache/rules
    // the included jar file should be in format:
    // rules-(rules.pl's sha1).jar
    File jarFile = null;
    if (rulesId != null) {
        jarFile = new File(filePath + "/rules/rules-" + rulesId.getName() + ".jar");
    }
    ClassLoader defaultLoader = getClass().getClassLoader();
    if (cacheFolder != null && jarFile != null && jarFile.exists()) {
        URL url;
        try {
            url = jarFile.toURI().toURL();
        } catch (MalformedURLException e) {
            return null;
        }
        URL[] urls = new URL[] { url };
        return new URLClassLoader(urls, defaultLoader);
    } else {
        return null;
    }
}
#method_after
public synchronized ClassLoader getClassLoader(ObjectId rulesId) {
    if (rulesId == null || rulesDir == null) {
        return null;
    }
    Reference<? extends ClassLoader> ref = classLoaderCache.get(rulesId);
    if (ref != null) {
        ClassLoader cl = ref.get();
        if (cl != null) {
            return cl;
        }
        classLoaderCache.remove(rulesId);
        ref.enqueue();
    }
    cleanCache();
    // read jar from (site)/cache/rules
    // the included jar file should be in format:
    // rules-(rules.pl's sha1).jar
    File jarFile = new File(rulesDir, "rules-" + rulesId.getName() + ".jar");
    if (!jarFile.isFile()) {
        return null;
    }
    ClassLoader defaultLoader = getClass().getClassLoader();
    URL url;
    try {
        url = jarFile.toURI().toURL();
    } catch (MalformedURLException e) {
        log.error("Path to rules jar is broken", e);
        return null;
    }
    ClassLoader urlLoader = new URLClassLoader(new URL[] { url }, defaultLoader);
    LoaderRef lRef = new LoaderRef(rulesId, urlLoader);
    classLoaderCache.put(rulesId, lRef);
    return urlLoader;
}
#end_block

#method_before
private ProjectState newProjectState() {
    final Map<Project.NameKey, ProjectState> all = new HashMap<Project.NameKey, ProjectState>();
    final ProjectCache projectCache = new ProjectCache() {

        @Override
        public ProjectState get(Project.NameKey projectName) {
            return all.get(projectName);
        }

        @Override
        public void evict(Project p) {
        }

        @Override
        public Iterable<Project.NameKey> all() {
            return Collections.emptySet();
        }

        @Override
        public Iterable<Project.NameKey> byName(String prefix) {
            return Collections.emptySet();
        }

        @Override
        public void onCreateProject(Project.NameKey newProjectName) {
        }
    };
    PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager mgr = null;
    Project.NameKey wildProject = new Project.NameKey("All-Projects");
    ProjectControl.AssistedFactory projectControlFactory = null;
    all.put(local.getProject().getNameKey(), new ProjectState(anonymousUser, projectCache, wildProject, projectControlFactory, envFactory, mgr, local, null));
    all.put(parent.getProject().getNameKey(), new ProjectState(anonymousUser, projectCache, wildProject, projectControlFactory, envFactory, mgr, parent, null));
    return all.get(local.getProject().getNameKey());
}
#method_after
private ProjectState newProjectState() {
    PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager mgr = null;
    ProjectControl.AssistedFactory projectControlFactory = null;
    RulesCache rulesCache = null;
    all.put(local.getProject().getNameKey(), new ProjectState(projectCache, allProjectsName, projectControlFactory, envFactory, mgr, rulesCache, local));
    all.put(parent.getProject().getNameKey(), new ProjectState(projectCache, allProjectsName, projectControlFactory, envFactory, mgr, rulesCache, parent));
    return all.get(local.getProject().getNameKey());
}
#end_block

#method_before
public PrologEnvironment newPrologEnvironment() throws CompileException {
    // TODO Replace this with a per-project ClassLoader to isolate rules.
    PrologEnvironment env;
    if (urlLoader != null) {
        env = envFactory.create(urlLoader);
        return env;
    } else {
        env = envFactory.create(getClass().getClassLoader());
    }
    // consult rules.pl at refs/meta/config branch for custom submit rules
    String rules = getConfig().getPrologRules();
    if (rules != null) {
        PushbackReader in = new PushbackReader(new StringReader(rules), Prolog.PUSHBACK_SIZE);
        JavaObjectTerm streamObject = new JavaObjectTerm(in);
        if (!env.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.intern("rules.pl"), streamObject)) {
            throw new CompileException("Cannot consult rules.pl " + getProject().getName() + " " + getConfig().getRevision());
        }
    }
    return env;
}
#method_after
public PrologEnvironment newPrologEnvironment() throws CompileException {
    if (ruleLoader != null) {
        return envFactory.create(ruleLoader);
    }
    PrologEnvironment env = envFactory.create(getClass().getClassLoader());
    // consult rules.pl at refs/meta/config branch for custom submit rules
    String rules = getConfig().getPrologRules();
    if (rules != null) {
        PushbackReader in = new PushbackReader(new StringReader(rules), Prolog.PUSHBACK_SIZE);
        JavaObjectTerm streamObject = new JavaObjectTerm(in);
        if (!env.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.intern("rules.pl"), streamObject)) {
            throw new CompileException("Cannot consult rules.pl " + getProject().getName() + " " + getConfig().getRevision());
        }
    }
    return env;
}
#end_block

#method_before
public Collection<AccessSection> getInheritedAccessSections() {
    if (isWildProject()) {
        return Collections.emptyList();
    }
    List<AccessSection> inherited = new ArrayList<AccessSection>();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    Project.NameKey parent = getProject().getParent();
    while (parent != null && seen.add(parent)) {
        ProjectState s = projectCache.get(parent);
        if (s != null) {
            inherited.addAll(s.getLocalAccessSections());
            parent = s.getProject().getParent();
        } else {
            break;
        }
    }
    // Wild project is the parent, or the root of the tree
    if (parent == null) {
        ProjectState s = projectCache.get(wildProject);
        if (s != null) {
            inherited.addAll(s.getLocalAccessSections());
        }
    }
    return inherited;
}
#method_after
public Collection<AccessSection> getInheritedAccessSections() {
    if (isAllProjects) {
        return Collections.emptyList();
    }
    List<AccessSection> inherited = new ArrayList<AccessSection>();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    Project.NameKey parent = getProject().getParent();
    while (parent != null && seen.add(parent)) {
        ProjectState s = projectCache.get(parent);
        if (s != null) {
            inherited.addAll(s.getLocalAccessSections());
            parent = s.getProject().getParent();
        } else {
            break;
        }
    }
    // The root of the tree is the special "All-Projects" case.
    if (parent == null) {
        inherited.addAll(projectCache.getAllProjects().getLocalAccessSections());
    }
    return inherited;
}
#end_block

#method_before
public Set<AccountGroup.UUID> getOwners() {
    Project.NameKey parentName = getProject().getParent();
    if (!localOwners.isEmpty() || parentName == null || isWildProject()) {
        return localOwners;
    }
    ProjectState parent = projectCache.get(parentName);
    if (parent != null) {
        return parent.getOwners();
    }
    return Collections.emptySet();
}
#method_after
public Set<AccountGroup.UUID> getOwners() {
    Project.NameKey parentName = getProject().getParent();
    if (!localOwners.isEmpty() || parentName == null || isAllProjects) {
        return localOwners;
    }
    ProjectState parent = projectCache.get(parentName);
    if (parent != null) {
        return parent.getOwners();
    }
    return Collections.emptySet();
}
#end_block

#method_before
@Override
protected void onCellSingleClick(final int row, final int column) {
    if (column == 2) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 2) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void appendLineNumber(final SafeHtmlBuilder m, final int idx) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.openAnchor();
    m.append(idx + 1);
    m.closeAnchor();
    m.closeTd();
}
#method_after
private void appendLineNumber(final SafeHtmlBuilder m, final int idx) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.append(idx + 1);
    m.closeTd();
}
#end_block

#method_before
@Override
protected void onCellSingleClick(final int row, int column) {
    if (column == 1 || column == 3) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 3) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, final int lineNumberMinusOne, final PatchLine.Type type, final SafeHtml lineHtml, final boolean trailingEdit, final boolean fullBlock) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.openAnchor();
    m.append(lineNumberMinusOne + 1);
    m.closeAnchor();
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineCONTEXT());
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdd");
            }
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdi");
            }
            break;
    }
    m.append(lineHtml);
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, final int lineNumberMinusOne, final PatchLine.Type type, final SafeHtml lineHtml, final boolean trailingEdit, final boolean fullBlock) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.append(lineNumberMinusOne + 1);
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineCONTEXT());
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdd");
            }
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdi");
            }
            break;
    }
    m.append(lineHtml);
    m.closeTd();
}
#end_block

#method_before
public PrologEnvironment newPrologEnvironment() {
    // TODO Replace this with a per-project ClassLoader to isolate rules.
    return envFactory.create(getClass().getClassLoader());
}
#method_after
public PrologEnvironment newPrologEnvironment() throws CompileException {
    // TODO Replace this with a per-project ClassLoader to isolate rules.
    PrologEnvironment env = envFactory.create(getClass().getClassLoader());
    // consult rules.pl at refs/meta/config branch for custom submit rules
    String rules = getConfig().getPrologRules();
    if (rules != null) {
        PushbackReader in = new PushbackReader(new StringReader(rules), Prolog.PUSHBACK_SIZE);
        JavaObjectTerm streamObject = new JavaObjectTerm(in);
        if (!env.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.makeSymbol("rules.pl"), streamObject)) {
            throw new CompileException("Cannot consult rules.pl " + getProject().getName() + " " + getConfig().getRevision());
        }
    }
    return env;
}
#end_block

#method_before
public boolean canRestore() {
    // Anyone who can abandon the change can restore it
    return canAbandon();
// back
}
#method_after
public boolean canRestore() {
    // Anyone who can abandon the change can restore it back
    return canAbandon();
}
#end_block

#method_before
public CanSubmitResult canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    CanSubmitResult result = canSubmit(patchSetId);
    if (result != CanSubmitResult.OK) {
        return result;
    }
    PrologEnvironment env = getProjectControl().getProjectState().newPrologEnvironment();
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    StructureTerm submitRule = SymbolTerm.makeSymbol("com.google.gerrit.rules.common", "default_submit", 1);
    ObjectStream ruleStream = getProjectControl().getProjectState().getPrologRules();
    if (ruleStream != null) {
        try {
            PushbackReader in = new PushbackReader(new InputStreamReader(ruleStream, Charset.forName("UTF-8")), Prolog.PUSHBACK_SIZE);
            JavaObjectTerm streamObject = new JavaObjectTerm(in);
            if (!env.execute(Prolog.BUILTIN, "consultStream", SymbolTerm.makeSymbol("submitrules"), streamObject)) {
                throw new CompileException("Cannot consult" + streamObject.toString());
            }
            // Replaces default_submit predicate with the submit_rule predicate in
            // the refs/meta/config:submit_rules.pl (if it exists)
            submitRule = SymbolTerm.makeSymbol("user", "submit_rule", 1);
        } catch (CompileException err) {
            log.error("Cannot consult provided submit_rules.pl", err);
        } finally {
            try {
                ruleStream.close();
            } catch (IOException err) {
                log.error("Close of ruleStream failed", err);
            }
        }
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("com.google.gerrit.rules.common", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        log.error("PrologException calling " + submitRule, err);
        return new CanSubmitResult("Error in submit rule");
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule has no solution: " + submitRule);
        return new CanSubmitResult("Error in submit rule (no solution possible)");
    }
    // The last result produced will be an "ok(P)" format if submit is possible.
    // This is always true because can_submit (called above) will cut away all
    // choice points once a solution is found.
    Term last = results.get(results.size() - 1);
    if (last.isStructure() && 1 == last.arity() && "ok".equals(last.name())) {
        Term solution = last.arg(0);
        return CanSubmitResult.OK;
    }
    // For now only process the first result. Later we can examine all of the
    // results and proposes different alternative paths to a submit solution.
    Term first = results.get(0);
    if (!first.isStructure() || 1 != first.arity() || !"not_ready".equals(first.name())) {
        log.error("Unexpected result from can_submit: " + first);
        return new CanSubmitResult("Error in submit rule");
    }
    Term submitRecord = first.arg(0);
    if (!submitRecord.isStructure()) {
        log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
        return new CanSubmitResult("Error in submit rule");
    }
    for (Term state : ((StructureTerm) submitRecord).args()) {
        if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
            log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
            return new CanSubmitResult("Invalid submit rule result");
        }
        String label = state.arg(0).name();
        Term status = state.arg(1);
        if ("ok".equals(status.name())) {
            continue;
        } else if ("reject".equals(status.name())) {
            return new CanSubmitResult("Submit blocked by " + label);
        } else if ("need".equals(status.name())) {
            if (status.isStructure() && status.arg(0).isInteger()) {
                IntegerTerm val = (IntegerTerm) status.arg(0);
                if (1 < val.intValue()) {
                    label += "+" + val.intValue();
                }
            }
            return new CanSubmitResult("Requires " + label);
        } else if ("impossble".equals(status.name())) {
            return new CanSubmitResult("Requires " + label + " (check permissions)");
        } else {
            return new CanSubmitResult("Invalid submit rule result");
        }
    }
    return CanSubmitResult.OK;
}
#method_after
public CanSubmitResult canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    CanSubmitResult result = canSubmit(patchSetId);
    if (result != CanSubmitResult.OK) {
        return result;
    }
    PrologEnvironment env;
    try {
        env = getProjectControl().getProjectState().newPrologEnvironment();
    } catch (CompileException err) {
        log.error("cannot consult rules.pl", err);
        return new CanSubmitResult("Error reading submit rule");
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    Term submitRule = env.once("com.google.gerrit.rules.common", "locate_submit_rule", new VariableTerm());
    if (submitRule == null) {
        log.error("Error in locate_submit_rule: no submit_rule found");
        return new CanSubmitResult("Error in finding submit rule");
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("com.google.gerrit.rules.common", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        log.error("PrologException calling " + submitRule, err);
        return new CanSubmitResult("Error in submit rule");
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule has no solution: " + submitRule);
        return new CanSubmitResult("Error in submit rule (no solution possible)");
    }
    // The last result produced will be an "ok(P)" format if submit is possible.
    // This is always true because can_submit (called above) will cut away all
    // choice points once a solution is found.
    Term last = results.get(results.size() - 1);
    if (last.isStructure() && 1 == last.arity() && "ok".equals(last.name())) {
        Term solution = last.arg(0);
        return CanSubmitResult.OK;
    }
    // For now only process the first result. Later we can examine all of the
    // results and proposes different alternative paths to a submit solution.
    Term first = results.get(0);
    if (!first.isStructure() || 1 != first.arity() || !"not_ready".equals(first.name())) {
        log.error("Unexpected result from can_submit: " + first);
        return new CanSubmitResult("Error in submit rule");
    }
    Term submitRecord = first.arg(0);
    if (!submitRecord.isStructure()) {
        log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
        return new CanSubmitResult("Error in submit rule");
    }
    for (Term state : ((StructureTerm) submitRecord).args()) {
        if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
            log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
            return new CanSubmitResult("Invalid submit rule result");
        }
        String label = state.arg(0).name();
        Term status = state.arg(1);
        if ("ok".equals(status.name())) {
            continue;
        } else if ("reject".equals(status.name())) {
            return new CanSubmitResult("Submit blocked by " + label);
        } else if ("need".equals(status.name())) {
            if (status.isStructure() && status.arg(0).isInteger()) {
                IntegerTerm val = (IntegerTerm) status.arg(0);
                if (1 < val.intValue()) {
                    label += "+" + val.intValue();
                }
            }
            return new CanSubmitResult("Requires " + label);
        } else if ("impossble".equals(status.name())) {
            return new CanSubmitResult("Requires " + label + " (check permissions)");
        } else {
            return new CanSubmitResult("Invalid submit rule result");
        }
    }
    return CanSubmitResult.OK;
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            populateReviewAction();
            if (changeDetail.isCurrentPatchSet(detail)) {
                populateActions(detail);
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            populateReviewAction();
            if (changeDetail.isCurrentPatchSet(detail)) {
                populateActions(detail);
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = (new ListenableAccountDiffPreference()).get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), diffBaseId, diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.setPatchSetIdToCompareWith(diffBaseId);
                patchTable.display(result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#method_after
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), diffBaseId, diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.setPatchSetIdToCompareWith(diffBaseId);
                patchTable.display(result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = (new ListenableAccountDiffPreference()).get();
        }
        Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), diffBaseId, diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#method_after
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), diffBaseId, diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#end_block

#method_before
private void update(AccountDiffPreference dp) {
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        DeferredCommand.addCommand(new Command() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#method_after
private void update(AccountDiffPreference dp) {
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().changeScreen());
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysNavigation.add(new UpToListKeyCommand(0, 'u', Util.C.upToChangeList()));
    keysNavigation.add(new ExpandCollapseDependencySectionKeyCommand(0, 'd', Util.C.expandCollapseDependencies()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new StarKeyCommand(0, 's', Util.C.changeTableStar()));
        keysAction.add(new PublishCommentsKeyCommand(0, 'r', Util.C.keyPublishComments()));
        starChange = new Image(Gerrit.RESOURCES.starOpen());
        starChange.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starChange.setVisible(Gerrit.isSignedIn());
        starChange.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                toggleStar();
            }
        });
        insertTitleWidget(starChange);
    }
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    approvals = new ApprovalTable();
    add(approvals);
    patchesList = new ListBox();
    patchesList.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            final int index = patchesList.getSelectedIndex();
            final String selectedPatchSet = patchesList.getValue(index);
            if (selectedPatchSet.equals("Base")) {
                diffBaseId = null;
            } else {
                diffBaseId = PatchSet.Id.parse(selectedPatchSet);
            }
            if (patchSetsBlock != null) {
                patchSetsBlock.refresh(diffBaseId);
            }
        }
    });
    patchesList.addItem("Base");
    patchesGrid = new Grid(1, 2);
    patchesGrid.setStyleName(Gerrit.RESOURCES.css().selectPatchSetOldVersion());
    patchesGrid.setText(0, 0, Util.C.oldVersionHistory());
    patchesGrid.setWidget(0, 1, patchesList);
    add(patchesGrid);
    includedInPanel = new DisclosurePanel(Util.C.changeScreenIncludedIn());
    includedInTable = new IncludedInTable(changeId);
    includedInPanel.setContent(includedInTable);
    add(includedInPanel);
    dependencies = new ChangeTable() {

        {
            table.setWidth("auto");
        }
    };
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    add(dependenciesPanel);
    patchSetsBlock = new PatchSetsBlock(this);
    add(patchSetsBlock);
    comments = new FlowPanel();
    comments.setStyleName(Gerrit.RESOURCES.css().changeComments());
    add(comments);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().changeScreen());
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysNavigation.add(new UpToListKeyCommand(0, 'u', Util.C.upToChangeList()));
    keysNavigation.add(new ExpandCollapseDependencySectionKeyCommand(0, 'd', Util.C.expandCollapseDependencies()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new StarKeyCommand(0, 's', Util.C.changeTableStar()));
        keysAction.add(new PublishCommentsKeyCommand(0, 'r', Util.C.keyPublishComments()));
        starChange = new Image(Gerrit.RESOURCES.starOpen());
        starChange.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starChange.setVisible(Gerrit.isSignedIn());
        starChange.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                toggleStar();
            }
        });
        insertTitleWidget(starChange);
    }
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    approvals = new ApprovalTable();
    add(approvals);
    includedInPanel = new DisclosurePanel(Util.C.changeScreenIncludedIn());
    includedInTable = new IncludedInTable(changeId);
    includedInPanel.setContent(includedInTable);
    add(includedInPanel);
    dependencies = new ChangeTable() {

        {
            table.setWidth("auto");
        }
    };
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    add(dependenciesPanel);
    patchesList = new ListBox();
    patchesList.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            final int index = patchesList.getSelectedIndex();
            final String selectedPatchSet = patchesList.getValue(index);
            if (index == 0) {
                diffBaseId = null;
            } else {
                diffBaseId = PatchSet.Id.parse(selectedPatchSet);
            }
            if (patchSetsBlock != null) {
                patchSetsBlock.refresh(diffBaseId);
            }
        }
    });
    patchesList.addItem(Util.C.baseDiffItem());
    patchesGrid = new Grid(1, 2);
    patchesGrid.setStyleName(Gerrit.RESOURCES.css().selectPatchSetOldVersion());
    patchesGrid.setText(0, 0, Util.C.oldVersionHistory());
    patchesGrid.setWidget(0, 1, patchesList);
    add(patchesGrid);
    patchSetsBlock = new PatchSetsBlock(this);
    add(patchSetsBlock);
    comments = new FlowPanel();
    comments.setStyleName(Gerrit.RESOURCES.css().changeComments());
    add(comments);
}
#end_block

#method_before
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getKey(), detail.getChange().getSubject());
    if (starChange != null) {
        setStarred(detail.isStarred());
    }
    if (Status.MERGED == detail.getChange().getStatus()) {
        includedInPanel.setVisible(true);
        includedInPanel.addOpenHandler(includedInTable);
    } else {
        includedInPanel.setVisible(false);
    }
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getChange(), detail.getMissingApprovals(), detail.getApprovals());
    for (PatchSet pId : detail.getPatchSets()) {
        if (patchesList != null) {
            patchesList.addItem(Util.M.patchSetHeader(pId.getPatchSetId()), pId.getId().toString());
        }
    }
    if (diffBaseId != null) {
        if (patchesList != null) {
            int index = -1;
            for (int i = 0; i < patchesList.getItemCount(); i++) {
                if (!patchesList.getValue(i).equals("Base")) {
                    if (diffBaseId.equals(PatchSet.Id.parse(patchesList.getValue(i)))) {
                        index = i;
                        break;
                    }
                }
            }
            patchesList.setSelectedIndex(index);
        }
    }
    patchSetsBlock.display(detail, diffBaseId);
    if (openPatchSetId != null) {
        patchSetsBlock.activate(openPatchSetId);
    }
    addComments(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
}
#method_after
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getKey(), detail.getChange().getSubject());
    if (starChange != null) {
        setStarred(detail.isStarred());
    }
    if (Status.MERGED == detail.getChange().getStatus()) {
        includedInPanel.setVisible(true);
        includedInPanel.addOpenHandler(includedInTable);
    } else {
        includedInPanel.setVisible(false);
    }
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getChange(), detail.getMissingApprovals(), detail.getApprovals());
    for (PatchSet pId : detail.getPatchSets()) {
        if (patchesList != null) {
            patchesList.addItem(Util.M.patchSetHeader(pId.getPatchSetId()), pId.getId().toString());
        }
    }
    if (diffBaseId != null && patchesList != null) {
        patchesList.setSelectedIndex(diffBaseId.get());
    }
    patchSetsBlock.display(detail, diffBaseId);
    if (openPatchSetId != null) {
        patchSetsBlock.activate(openPatchSetId);
    }
    addComments(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
}
#end_block

#method_before
public void display(PatchSetDetail detail) {
    this.detail = detail;
    this.patchList = detail.getPatches();
    myTable = null;
    final DisplayCommand cmd = new DisplayCommand(patchList, patchSetIdToCompareWith);
    if (cmd.execute()) {
        cmd.initMeter();
        DeferredCommand.addCommand(cmd);
    } else {
        cmd.showTable();
    }
}
#method_after
public void display(PatchSetDetail detail) {
    this.detail = detail;
    this.patchList = detail.getPatches();
    myTable = null;
    final DisplayCommand cmd = new DisplayCommand(patchList, patchSetIdToCompareWith);
    if (cmd.execute()) {
        cmd.initMeter();
        Scheduler.get().scheduleIncremental(cmd);
    } else {
        cmd.showTable();
    }
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    Grant grant = (Grant) o;
    return group.equals(grant.group) && pattern.equals(grant.pattern);
}
#method_after
@Override
public boolean equals(Object o) {
    if (o == null)
        return false;
    Grant grant = (Grant) o;
    return group.equals(grant.group) && pattern.equals(grant.pattern);
}
#end_block

#method_before
public Set<AccountGroup.Id> getOwners() {
    return owners;
}
#method_after
public Set<AccountGroup.Id> getOwners() {
    if (!localOwners.isEmpty() || isSpecialWildProject() || project.getParent() == null) {
        return localOwners;
    }
    final ProjectState parent = projectCache.get(project.getParent());
    if (parent != null) {
        return parent.getOwners();
    }
    return Collections.emptySet();
}
#end_block

#method_before
private List<PatchSetInfo.ParentInfo> toParentInfos(final RevCommit[] parents, final RevWalk walk) throws IOException, MissingObjectException {
    List<PatchSetInfo.ParentInfo> pInfos = new ArrayList<PatchSetInfo.ParentInfo>();
    for (RevCommit parent : parents) {
        if (parent != null && walk != null) {
            walk.parseBody(parent);
            RevId pRevId = new RevId(parent.getId().name());
            String pCommitMsg = parent.getShortMessage();
            pInfos.add(new PatchSetInfo.ParentInfo(pRevId, pCommitMsg));
        }
    }
    return pInfos;
}
#method_after
private List<PatchSetInfo.ParentInfo> toParentInfos(final RevCommit[] parents, final RevWalk walk) throws IOException, MissingObjectException {
    List<PatchSetInfo.ParentInfo> pInfos = new ArrayList<PatchSetInfo.ParentInfo>(parents.length);
    for (RevCommit parent : parents) {
        walk.parseBody(parent);
        RevId rev = new RevId(parent.getId().name());
        String msg = parent.getShortMessage();
        pInfos.add(new PatchSetInfo.ParentInfo(rev, msg));
    }
    return pInfos;
}
#end_block

#method_before
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel("Initial Commit"));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(parent.shortMessage));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#method_after
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(parent.shortMessage));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private Capable verifyActiveContributorAgreement() throws OrmException {
    AbstractAgreement bestAgreement = null;
    ContributorAgreement bestCla = null;
    OUTER: for (AccountGroup.UUID groupUUID : currentUser.getEffectiveGroups()) {
        AccountGroup group = groupCache.get(groupUUID);
        if (group == null) {
            continue;
        }
        final List<AccountGroupAgreement> temp = db.accountGroupAgreements().byGroup(group.getId()).toList();
        Collections.reverse(temp);
        for (final AccountGroupAgreement a : temp) {
            final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
            if (cla == null) {
                continue;
            }
            bestAgreement = a;
            bestCla = cla;
            break OUTER;
        }
    }
    if (bestAgreement == null) {
        final List<AccountAgreement> temp = db.accountAgreements().byAccount(currentUser.getAccountId()).toList();
        Collections.reverse(temp);
        for (final AccountAgreement a : temp) {
            final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
            if (cla == null) {
                continue;
            }
            bestAgreement = a;
            bestCla = cla;
            break;
        }
    }
    if (bestCla != null && !bestCla.isActive()) {
        final StringBuilder msg = new StringBuilder();
        msg.append(bestCla.getShortName());
        msg.append(" contributor agreement is expired.\n");
        if (canonicalWebUrl != null) {
            msg.append("\nPlease complete a new agreement");
            msg.append(":\n\n  ");
            msg.append(canonicalWebUrl);
            msg.append("#");
            msg.append(PageLinks.SETTINGS_AGREEMENTS);
            msg.append("\n");
        }
        msg.append("\n");
        return new Capable(msg.toString());
    }
    if (bestCla != null && bestCla.isRequireContactInformation()) {
        boolean fail = false;
        fail |= missing(currentUser.getAccount().getFullName());
        fail |= missing(currentUser.getAccount().getPreferredEmail());
        fail |= !currentUser.getAccount().isContactFiled();
        if (fail) {
            final StringBuilder msg = new StringBuilder();
            msg.append(bestCla.getShortName());
            msg.append(" contributor agreement requires");
            msg.append(" current contact information.\n");
            if (canonicalWebUrl != null) {
                msg.append("\nPlease review your contact information");
                msg.append(":\n\n  ");
                msg.append(canonicalWebUrl);
                msg.append("#");
                msg.append(PageLinks.SETTINGS_CONTACT);
                msg.append("\n");
            }
            msg.append("\n");
            return new Capable(msg.toString());
        }
    }
    if (bestAgreement != null) {
        switch(bestAgreement.getStatus()) {
            case VERIFIED:
                return Capable.OK;
            case REJECTED:
                return new Capable(bestCla.getShortName() + " contributor agreement was rejected." + "\n       (rejected on " + bestAgreement.getReviewedOn() + ")\n");
            case NEW:
                return new Capable(bestCla.getShortName() + " contributor agreement is still pending review.\n");
        }
    }
    final StringBuilder msg = new StringBuilder();
    msg.append(" A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#method_after
private Capable verifyActiveContributorAgreement() throws OrmException {
    AbstractAgreement bestAgreement = null;
    ContributorAgreement bestCla = null;
    OUTER: for (AccountGroup.Id groupId : currentUser.getEffectiveGroups()) {
        final List<AccountGroupAgreement> temp = db.accountGroupAgreements().byGroup(groupId).toList();
        Collections.reverse(temp);
        for (final AccountGroupAgreement a : temp) {
            final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
            if (cla == null) {
                continue;
            }
            bestAgreement = a;
            bestCla = cla;
            break OUTER;
        }
    }
    if (bestAgreement == null) {
        final List<AccountAgreement> temp = db.accountAgreements().byAccount(currentUser.getAccountId()).toList();
        Collections.reverse(temp);
        for (final AccountAgreement a : temp) {
            final ContributorAgreement cla = db.contributorAgreements().get(a.getAgreementId());
            if (cla == null) {
                continue;
            }
            bestAgreement = a;
            bestCla = cla;
            break;
        }
    }
    if (bestCla != null && !bestCla.isActive()) {
        final StringBuilder msg = new StringBuilder();
        msg.append(bestCla.getShortName());
        msg.append(" contributor agreement is expired.\n");
        if (canonicalWebUrl != null) {
            msg.append("\nPlease complete a new agreement");
            msg.append(":\n\n  ");
            msg.append(canonicalWebUrl);
            msg.append("#");
            msg.append(PageLinks.SETTINGS_AGREEMENTS);
            msg.append("\n");
        }
        msg.append("\n");
        return new Capable(msg.toString());
    }
    if (bestCla != null && bestCla.isRequireContactInformation()) {
        boolean fail = false;
        fail |= missing(currentUser.getAccount().getFullName());
        fail |= missing(currentUser.getAccount().getPreferredEmail());
        fail |= !currentUser.getAccount().isContactFiled();
        if (fail) {
            final StringBuilder msg = new StringBuilder();
            msg.append(bestCla.getShortName());
            msg.append(" contributor agreement requires");
            msg.append(" current contact information.\n");
            if (canonicalWebUrl != null) {
                msg.append("\nPlease review your contact information");
                msg.append(":\n\n  ");
                msg.append(canonicalWebUrl);
                msg.append("#");
                msg.append(PageLinks.SETTINGS_CONTACT);
                msg.append("\n");
            }
            msg.append("\n");
            return new Capable(msg.toString());
        }
    }
    if (bestAgreement != null) {
        switch(bestAgreement.getStatus()) {
            case VERIFIED:
                return Capable.OK;
            case REJECTED:
                return new Capable(bestCla.getShortName() + " contributor agreement was rejected." + "\n       (rejected on " + bestAgreement.getReviewedOn() + ")\n");
            case NEW:
                return new Capable(bestCla.getShortName() + " contributor agreement is still pending review.\n");
        }
    }
    final StringBuilder msg = new StringBuilder();
    msg.append(" A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        Ref targetRef = repo.getRef(destBranchName);
        boolean haveHeads = false;
        if (targetRef == null)
            for (final Ref r : rp.getAdvertisedRefs().values()) {
                if (isHead(r) || isTag(r) || isConfig(r)) {
                    try {
                        markWalk(walk, SIDE_HAVE, r);
                        haveHeads = true;
                    } catch (IOException e) {
                        continue;
                    }
                }
            }
        else {
            markWalk(walk, SIDE_HAVE, targetRef);
            haveHeads = true;
        }
        if (haveHeads) {
            boolean isConnected = false;
            RevCommit c;
            while ((c = walk.next()) != null) {
                if (c.hasAll(COMMON)) {
                    isConnected = true;
                    break;
                }
            }
            if (!isConnected) {
                reject(newChange, "no common ancestry");
                return;
            }
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        h.add(SIDE_HAVE);
        walk.markStart(h);
        boolean isConnected = false;
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (c.hasAll(COMMON)) {
                isConnected = true;
                break;
            }
        }
        if (!isConnected) {
            reject(newChange, "no common ancestry");
            return;
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                final Change.Key key = new Change.Key(idStr);
                final List<Change> changes = db.changes().byProjectKey(project.getNameKey(), key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.byId(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID()) {
            reject(cmd, "missing Change-Id in commit message");
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey();
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey() throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byProjectOpenAll(project.getNameKey())) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#end_block

#method_before
void create(List<CodeReviewCommit> commits, PersonIdent author) throws MergeException {
    try {
        this.commits = commits;
        this.author = author;
        setBase();
        setOurs();
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        RefUpdate refUpdate = createRefUpdate(oursCommit, baseCommit);
        for (; ; ) {
            Result result = refUpdate.update();
            if (result == Result.LOCK_FAILURE) {
                if (--remainingLockFailureCalls > 0) {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } else {
                    throw new MergeException("Couldn't create code review notes. Failed to lock the ref: " + REFS_NOTES_SUBMITTED);
                }
            } else if (result == Result.REJECTED) {
                RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
                NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
                // TODO: NoteMapMerger.merge(base, ours,
                NoteMap merged = null;
                // theirs);
                RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits", theirsCommit, oursCommit);
                refUpdate = createRefUpdate(mergeCommit, theirsCommit);
                remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
            } else if (result == Result.IO_FAILURE) {
                throw new MergeException("Couldn't create code review notes because of IO_FAILURE");
            } else {
                break;
            }
        }
    } catch (IOException e) {
        throw new MergeException("Couldn't create code review notes", e);
    } catch (InterruptedException e) {
        throw new MergeException("Couldn't create code review notes", e);
    }
}
#method_after
public void create(List<CodeReviewCommit> commits, PersonIdent author) throws CodeReviewNoteCreationException {
    try {
        this.commits = commits;
        this.author = author;
        setBase();
        setOurs();
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        RefUpdate refUpdate = createRefUpdate(oursCommit, baseCommit);
        for (; ; ) {
            Result result = refUpdate.update();
            if (result == Result.LOCK_FAILURE) {
                if (--remainingLockFailureCalls > 0) {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } else {
                    throw new CodeReviewNoteCreationException("Failed to lock the ref: " + REFS_NOTES_REVIEW);
                }
            } else if (result == Result.REJECTED) {
                RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
                NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
                NoteMapMerger merger = new NoteMapMerger(db);
                NoteMap merged = merger.merge(base, ours, theirs);
                RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
                refUpdate = createRefUpdate(mergeCommit, theirsCommit);
                remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
            } else if (result == Result.IO_FAILURE) {
                throw new CodeReviewNoteCreationException("Couldn't create code review notes because of IO_FAILURE");
            } else {
                break;
            }
        }
    } catch (IOException e) {
        throw new CodeReviewNoteCreationException(e);
    } catch (InterruptedException e) {
        throw new CodeReviewNoteCreationException(e);
    } finally {
        reader.release();
        inserter.release();
        revWalk.release();
    }
}
#end_block

#method_before
private void setBase() throws IOException {
    Ref notesBranch = db.getRef(REFS_NOTES_SUBMITTED);
    if (notesBranch != null) {
        baseCommit = revWalk.parseCommit(notesBranch.getObjectId());
        base = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    }
}
#method_after
private void setBase() throws IOException {
    Ref notesBranch = db.getRef(REFS_NOTES_REVIEW);
    if (notesBranch != null) {
        baseCommit = revWalk.parseCommit(notesBranch.getObjectId());
        base = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    }
}
#end_block

#method_before
private void setOurs() throws IOException {
    if (baseCommit != null) {
        ours = NoteMap.read(db.newObjectReader(), baseCommit);
    } else {
        ours = NoteMap.newEmptyMap();
    }
    StringBuilder message = new StringBuilder("Submitted the following changes:");
    for (CodeReviewCommit c : commits) {
        if (ours.contains(c)) {
            throw new IllegalStateException("Review summary note already exists for commit: " + c + ". Merging of notes not yet supported");
        }
        ObjectId id = inserter.insert(Constants.OBJ_BLOB, createNoteContent(c));
        inserter.flush();
        RevBlob blob = revWalk.lookupBlob(id);
        ours.set(c, blob);
        message.append(" ");
        message.append(c.change.getId());
    }
    if (baseCommit != null) {
        oursCommit = createCommit(ours, author, message.toString(), baseCommit);
    } else {
        oursCommit = createCommit(ours, author, message.toString());
    }
}
#method_after
private void setOurs() throws IOException, CodeReviewNoteCreationException {
    if (baseCommit != null) {
        ours = NoteMap.read(db.newObjectReader(), baseCommit);
    } else {
        ours = NoteMap.newEmptyMap();
    }
    StringBuilder message = new StringBuilder("Update notes for submitted changes\n\n");
    for (CodeReviewCommit c : commits) {
        ObjectId noteContent = createNoteContent(c);
        if (ours.contains(c)) {
            // merge the existing and the new note as if they are both new
            // means: base == null
            // there is not really a common ancestry for these two note revisions
            // use the same NoteMerger that is used from the NoteMapMerger
            DefaultNoteMerger noteMerger = new DefaultNoteMerger();
            Note newNote = new Note(c, noteContent);
            noteContent = noteMerger.merge(null, newNote, base.getNote(c), reader, inserter).getData();
        }
        ours.set(c, noteContent);
        message.append("* ").append(c.getShortMessage()).append("\n");
    }
    if (baseCommit != null) {
        oursCommit = createCommit(ours, author, message.toString(), baseCommit);
    } else {
        oursCommit = createCommit(ours, author, message.toString());
    }
}
#end_block

#method_before
private byte[] createNoteContent(CodeReviewCommit commit) throws UnsupportedEncodingException {
    try {
        ReviewNoteHeaderFormatter formatter = new ReviewNoteHeaderFormatter();
        formatter.appendChangeId(commit.change.getId());
        ResultSet<PatchSetApproval> approvals = schema.patchSetApprovals().byPatchSet(commit.patchsetId);
        PatchSetApproval submit = null;
        for (PatchSetApproval a : approvals) {
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                submit = a;
            } else {
                formatter.appendApproval(schema.approvalCategories().get(a.getCategoryId()), a.getValue(), schema.accounts().get(a.getAccountId()));
            }
        }
        formatter.appendBranch(schema.projects().get(commit.change.getProject()), commit.change.getDest());
        formatter.appendSubmittedBy(schema.accounts().get(submit.getAccountId()));
        formatter.appendSubmittedOn(submit.getGranted());
        return formatter.toString().getBytes("UTF-8");
    } catch (OrmException e) {
        throw new RuntimeException(e);
    }
}
#method_after
private ObjectId createNoteContent(CodeReviewCommit commit) throws CodeReviewNoteCreationException, IOException {
    try {
        ReviewNoteHeaderFormatter formatter = new ReviewNoteHeaderFormatter(author.getTimeZone());
        final List<String> idList = commit.getFooterLines(CHANGE_ID);
        if (idList.isEmpty())
            formatter.appendChangeId(commit.change.getKey());
        ResultSet<PatchSetApproval> approvals = schema.patchSetApprovals().byPatchSet(commit.patchsetId);
        PatchSetApproval submit = null;
        for (PatchSetApproval a : approvals) {
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                submit = a;
            } else {
                formatter.appendApproval(approvalTypes.getApprovalType(a.getCategoryId()).getCategory(), a.getValue(), accountCache.get(a.getAccountId()).getAccount());
            }
        }
        formatter.appendSubmittedBy(accountCache.get(submit.getAccountId()).getAccount());
        formatter.appendSubmittedAt(submit.getGranted());
        formatter.appendReviewedOn(canonicalWebUrl, commit.change.getId());
        formatter.appendProject(commit.change.getProject().get());
        formatter.appendBranch(commit.change.getDest());
        return inserter.insert(Constants.OBJ_BLOB, formatter.toString().getBytes("UTF-8"));
    } catch (OrmException e) {
        throw new CodeReviewNoteCreationException(commit, e);
    }
}
#end_block

#method_before
private RevCommit createCommit(NoteMap map, PersonIdent author, String message, RevCommit... parents) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    ObjectInserter inserter = db.newObjectInserter();
    CommitBuilder b = new CommitBuilder();
    b.setTreeId(map.writeTree(inserter));
    b.setAuthor(author);
    b.setCommitter(gerritIdent);
    if (parents.length > 0) {
        b.setParentIds(parents);
    }
    b.setMessage(message);
    return revWalk.parseCommit(inserter.insert(b));
}
#method_after
private RevCommit createCommit(NoteMap map, PersonIdent author, String message, RevCommit... parents) throws IOException {
    CommitBuilder b = new CommitBuilder();
    b.setTreeId(map.writeTree(inserter));
    b.setAuthor(author);
    b.setCommitter(gerritIdent);
    if (parents.length > 0) {
        b.setParentIds(parents);
    }
    b.setMessage(message);
    ObjectId commitId = inserter.insert(b);
    inserter.flush();
    return revWalk.parseCommit(commitId);
}
#end_block

#method_before
private RefUpdate createRefUpdate(ObjectId newObjectId, ObjectId expectedOldObjectId) throws IOException {
    RefUpdate refUpdate = db.updateRef(REFS_NOTES_SUBMITTED);
    refUpdate.setNewObjectId(newObjectId);
    if (expectedOldObjectId == null) {
        refUpdate.setExpectedOldObjectId(ObjectId.zeroId());
    } else {
        refUpdate.setExpectedOldObjectId(expectedOldObjectId);
    }
    return refUpdate;
}
#method_after
private RefUpdate createRefUpdate(ObjectId newObjectId, ObjectId expectedOldObjectId) throws IOException {
    RefUpdate refUpdate = db.updateRef(REFS_NOTES_REVIEW);
    refUpdate.setNewObjectId(newObjectId);
    if (expectedOldObjectId == null) {
        refUpdate.setExpectedOldObjectId(ObjectId.zeroId());
    } else {
        refUpdate.setExpectedOldObjectId(expectedOldObjectId);
    }
    return refUpdate;
}
#end_block

#method_before
private void openRepository() throws MergeException {
    final String name = destBranch.getParentKey().get();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#method_after
private void openRepository() throws MergeException {
    final Project.NameKey name = destBranch.getParentKey();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name.get() + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#end_block

#method_before
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = new CreateCodeReviewNotes(schema, db, myIdent);
    codeReviewNotes.create(merged, computeAuthor(merged));
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), CreateCodeReviewNotes.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false, false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#method_after
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
public void appendChangeId(Change.Id changeId) {
    sb.append("Change-Id: ").append(changeId).append("\n");
}
#method_after
void appendChangeId(Change.Key changeKey) {
    sb.append("Change-Id: ").append(changeKey.get()).append("\n");
}
#end_block

#method_before
public void appendApproval(ApprovalCategory category, short value, Account user) {
    sb.append(category.getName());
    sb.append(value < 0 ? "-" : "+").append(value).append(": ");
    appendUserData(user);
    sb.append("\n");
}
#method_after
void appendApproval(ApprovalCategory category, short value, Account user) {
    // TODO: use category.getLabel() when available
    sb.append(category.getName().replace(' ', '-'));
    sb.append(value < 0 ? "-" : "+").append(Math.abs(value)).append(": ");
    appendUserData(user);
    sb.append("\n");
}
#end_block

#method_before
private void appendUserData(Account user) {
    sb.append(user.getFullName()).append(" <").append(user.getPreferredEmail()).append(">");
}
#method_after
private void appendUserData(Account user) {
    boolean needSpace = false;
    boolean wroteData = false;
    if (user.getFullName() != null && !user.getFullName().isEmpty()) {
        sb.append(user.getFullName());
        needSpace = true;
        wroteData = true;
    }
    if (user.getPreferredEmail() != null && !user.getPreferredEmail().isEmpty()) {
        if (needSpace) {
            sb.append(" ");
        }
        sb.append("<").append(user.getPreferredEmail()).append(">");
        wroteData = true;
    }
    if (!wroteData) {
        sb.append("Anonymous Coward #").append(user.getId());
    }
}
#end_block

#method_before
public void appendBranch(Project project, Branch.NameKey branch) {
    sb.append("Branch: ").append(project.getName()).append(" ").append(branch.get()).append("\n");
}
#method_after
void appendBranch(Branch.NameKey branch) {
    sb.append("Branch: ").append(branch.get()).append("\n");
}
#end_block

#method_before
public void appendSubmittedBy(Account user) {
    sb.append("Submitted-by: ");
    appendUserData(user);
    sb.append("\n");
}
#method_after
void appendSubmittedBy(Account user) {
    sb.append("Submitted-by: ");
    appendUserData(user);
    sb.append("\n");
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            display(result);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            enableForm(result.canModify);
            saveName.setVisible(result.canModify);
            saveOwner.setVisible(result.canModify);
            saveDesc.setVisible(result.canModify);
            saveGroupOptions.setVisible(result.canModify);
            delMember.setVisible(result.canModify);
            members.setEnabled(result.canModify);
            saveType.setVisible(result.canModify);
            display(result);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupType();
    initGroupNotifications();
    Label spacer = new Label("");
    spacer.setHeight("15px");
    add(spacer);
    initMemberList();
    initExternal();
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupOptions();
    initGroupType();
    initMemberList();
    initExternal();
}
#end_block

#method_before
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    onlyAuthors.setValue(group.isEmailOnlyAuthors());
    onlyAuthors.setEnabled(true);
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            members.display(result.members);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#method_after
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    visibleToAllCheckBox.setValue(group.isVisibleToAll());
    visibleToAllCheckBox.setEnabled(true);
    emailOnlyAuthors.setValue(group.isEmailOnlyAuthors());
    emailOnlyAuthors.setEnabled(true);
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            members.display(result.members);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#end_block

#method_before
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    table.setWidget(row, 1, new CheckBox());
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            initOptionList();
            parseCommandLine();
            boolean ok = true;
            for (final PatchSet.Id patchSetId : patchSetIds) {
                try {
                    approveOne(patchSetId);
                } catch (UnloggedFailure e) {
                    ok = false;
                    writeError("error: " + e.getMessage() + "\n");
                } catch (Exception e) {
                    ok = false;
                    writeError("fatal: internal server error while approving " + patchSetId + "\n");
                    log.error("internal error while approving " + patchSetId, e);
                }
            }
            if (!ok) {
                throw new UnloggedFailure(1, "one or more approvals failed;" + " review output above");
            }
        }
    });
}
#method_after
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            initOptionList();
            parseCommandLine();
            if (abandonChange) {
                if (restoreChange) {
                    throw error("abandon and restore actions are mutually exclusive");
                }
                if (submitChange) {
                    throw error("abandon and submit actions are mutually exclusive");
                }
            }
            boolean ok = true;
            for (final PatchSet.Id patchSetId : patchSetIds) {
                try {
                    approveOne(patchSetId);
                } catch (UnloggedFailure e) {
                    ok = false;
                    writeError("error: " + e.getMessage() + "\n");
                } catch (Exception e) {
                    ok = false;
                    writeError("fatal: internal server error while approving " + patchSetId + "\n");
                    log.error("internal error while approving " + patchSetId, e);
                }
            }
            if (!ok) {
                throw new UnloggedFailure(1, "one or more approvals failed;" + " review output above");
            }
            if (!toSubmit.isEmpty()) {
                final Set<Branch.NameKey> toMerge = new HashSet<Branch.NameKey>();
                try {
                    for (PatchSet.Id patchSetId : toSubmit) {
                        ChangeUtil.submit(opFactory, patchSetId, currentUser, db, new MergeQueue() {

                            @Override
                            public void merge(MergeOp.Factory mof, Branch.NameKey branch) {
                                toMerge.add(branch);
                            }

                            @Override
                            public void schedule(Branch.NameKey branch) {
                                toMerge.add(branch);
                            }

                            @Override
                            public void recheckAfter(Branch.NameKey branch, long delay, TimeUnit delayUnit) {
                                toMerge.add(branch);
                            }
                        });
                    }
                    for (Branch.NameKey branch : toMerge) {
                        merger.merge(opFactory, branch);
                    }
                } catch (OrmException updateError) {
                    throw new Failure(1, "one or more submits failed", updateError);
                }
            }
        }
    });
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    publishCommentsFactory.create(patchSetId, changeComment, aps).call();
    if (submitChange) {
        CanSubmitResult result = changeControl.canSubmit(patchSetId, db, approvalTypes, functionStateFactory);
        if (result == CanSubmitResult.OK) {
            ChangeUtil.submit(opFactory, patchSetId, currentUser, db, merger);
        } else {
            throw error(result.getMessage());
        }
    }
    if (abandonChange) {
        if (changeControl.canAbandon()) {
            ChangeUtil.abandon(patchSetId, changeId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
        } else {
            throw error("User does not have the privileges to abandon this change");
        }
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    publishCommentsFactory.create(patchSetId, changeComment, aps).call();
    if (abandonChange) {
        if (changeControl.canAbandon()) {
            ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
        } else {
            throw error("Not permitted to abandon change");
        }
    }
    if (restoreChange) {
        if (changeControl.canRestore()) {
            ChangeUtil.restore(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
        } else {
            throw error("Not permitted to restore change");
        }
        if (submitChange) {
            changeControl = changeControlFactory.validateFor(changeId);
        }
    }
    if (submitChange) {
        CanSubmitResult result = changeControl.canSubmit(patchSetId, db, approvalTypes, functionStateFactory);
        if (result == CanSubmitResult.OK) {
            toSubmit.add(patchSetId);
        } else {
            throw error(result.getMessage());
        }
    }
}
#end_block

#method_before
public static void abandon(final PatchSet.Id patchSetId, final Change.Id changeId, final IdentifiedUser user, final String message, final ReviewDb db, final AbandonedSender.Factory abandonedSenderFactory, final ChangeHookRunner hooks) throws NoSuchChangeException, EmailException, OrmException {
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    final Change change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.ABANDONED);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change != null) {
        db.changeMessages().insert(Collections.singleton(cmsg));
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        for (PatchSetApproval a : approvals) {
            a.cache(change);
        }
        db.patchSetApprovals().update(approvals);
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    hooks.doChangeAbandonedHook(change, user.getAccount(), message);
}
#method_after
public static void abandon(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final AbandonedSender.Factory abandonedSenderFactory, final ChangeHookRunner hooks) throws NoSuchChangeException, EmailException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    final Change change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.ABANDONED);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change != null) {
        db.changeMessages().insert(Collections.singleton(cmsg));
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        for (PatchSetApproval a : approvals) {
            a.cache(change);
        }
        db.patchSetApprovals().update(approvals);
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    hooks.doChangeAbandonedHook(change, user.getAccount(), message);
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.abandon(patchSetId, changeId, currentUser, message, db, abandonedSenderFactory, hooks);
    return changeDetailFactory.create(changeId).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.abandon(patchSetId, currentUser, message, db, abandonedSenderFactory, hooks);
    return changeDetailFactory.create(changeId).call();
}
#end_block

#method_before
private void update() {
    if (colWidth.getIntValue() == 0) {
        new ErrorDialog("The number of columns cannot be zero").center();
        return;
    }
    AccountDiffPreference dp = new AccountDiffPreference(getValue());
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    listenablePrefs.set(dp);
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#method_after
private void update() {
    if (colWidth.getIntValue() <= 0) {
        new ErrorDialog(PatchUtil.C.illegalNumberOfColumns()).center();
        return;
    }
    AccountDiffPreference dp = new AccountDiffPreference(getValue());
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    listenablePrefs.set(dp);
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    {
        nameBox = new NpTextBox();
        nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
        nameBox.setVisibleLength(50);
        nameBox.setText(Util.C.defaultProjectName());
        nameBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
        nameBox.addFocusHandler(new FocusHandler() {

            @Override
            public void onFocus(FocusEvent event) {
                if (Util.C.defaultProjectName().equals(nameBox.getText())) {
                    nameBox.setText("");
                    nameBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        nameBox.addBlurHandler(new BlurHandler() {

            @Override
            public void onBlur(BlurEvent event) {
                if ("".equals(nameBox.getText())) {
                    nameBox.setText(Util.C.defaultProjectName());
                    nameBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        nameBox.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                submitOnSelection = false;
                if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                    if (nameTxt.isSuggestionListShowing()) {
                        submitOnSelection = true;
                    } else {
                        doAddNew();
                    }
                }
            }
        });
        nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

            @Override
            public void onSelection(SelectionEvent<Suggestion> event) {
                if (submitOnSelection) {
                    submitOnSelection = false;
                    doAddNew();
                }
            }
        });
        filterTxt = new NpTextBox();
        filterTxt.setVisibleLength(50);
        filterTxt.setText(Util.C.defaultFilter());
        filterTxt.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
        filterTxt.addFocusHandler(new FocusHandler() {

            @Override
            public void onFocus(FocusEvent event) {
                if (Util.C.defaultFilter().equals(filterTxt.getText())) {
                    filterTxt.setText("");
                    filterTxt.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        filterTxt.addBlurHandler(new BlurHandler() {

            @Override
            public void onBlur(BlurEvent event) {
                if ("".equals(filterTxt.getText())) {
                    filterTxt.setText(Util.C.defaultFilter());
                    filterTxt.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        filterTxt.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                    doAddNew();
                }
            }
        });
        projects = new ProjectTable();
        addNew = new Button(Util.C.buttonWatchProject());
        addNew.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                doAddNew();
            }
        });
        final Grid grid = new Grid(2, 2);
        grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
        grid.setText(0, 0, Util.C.watchedProjectName());
        grid.setWidget(0, 1, nameTxt);
        grid.setText(1, 0, Util.C.watchedProjectFilter());
        grid.setWidget(1, 1, filterTxt);
        final CellFormatter fmt = grid.getCellFormatter();
        fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
        fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
        fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
        fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
        fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
        DisclosurePanel unwatched = new DisclosurePanel(Util.C.unwatchedProjects());
        unwatched.setContent(projects);
        final Grid grid2 = new Grid(1, 2);
        final FlowPanel fp2 = new FlowPanel();
        fp2.add(addNew);
        grid2.setWidget(0, 0, fp2);
        grid2.setWidget(0, 1, unwatched);
        final CellFormatter fmt2 = grid2.getCellFormatter();
        fmt2.setAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT, HasVerticalAlignment.ALIGN_TOP);
        final FlowPanel fp = new FlowPanel();
        fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
        fp.add(grid);
        fp.add(grid2);
        add(fp);
    }
    watches = new WatchTable();
    add(watches);
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watches.deleteChecked();
        }
    });
    add(delSel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    final Grid grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popupPosition = new PopupPanel.PositionCallback() {

        public void setPosition(int offsetWidth, int offsetHeight) {
            if (preferredPopupWidth == -1) {
                preferredPopupWidth = offsetWidth;
            }
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), watchesTab.getAbsoluteLeft() + watchesTab.getOffsetWidth());
            if (top + offsetHeight > Window.getClientHeight()) {
                top = Window.getClientHeight() - offsetHeight;
            }
            if (left + offsetWidth > Window.getClientWidth()) {
                left = Window.getClientWidth() - offsetWidth;
            }
            if (top < 0) {
                sp.setHeight((sp.getOffsetHeight() + top) + "px");
                top = 0;
            }
            if (left < 0) {
                sp.setWidth((sp.getOffsetWidth() + left) + "px");
                left = 0;
            }
            popup.setPopupPosition(left, top);
        }
    };
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.ACCOUNT_SVC.myProjectWatch(new ScreenLoadCallback<List<AccountProjectWatchInfo>>(this) {

        public void preDisplay(final List<AccountProjectWatchInfo> result) {
            watchedProjects = result;
            watches.display(result);
            displayUnwatchedProjects();
        }
    });
    Util.PROJECT_SVC.visibleProjects(new ScreenLoadCallback<List<Project>>(this) {

        @Override
        protected void preDisplay(final List<Project> result) {
            allProjects = new ArrayList(result);
            // unneeded fake "--all projects--" entry
            allProjects.remove(0);
            displayUnwatchedProjects();
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    populateWatches();
}
#end_block

#method_before
void doAddNew() {
    final String projectName = nameTxt.getText();
    if (projectName == null || projectName.length() == 0 || Util.C.defaultProjectName().equals(projectName)) {
        return;
    }
    String filter = filterTxt.getText();
    if (filter == null || filter.isEmpty() || filter.equals(Util.C.defaultFilter())) {
        filter = null;
    }
    addNew.setEnabled(false);
    nameBox.setEnabled(false);
    filterTxt.setEnabled(false);
    Util.ACCOUNT_SVC.addProjectWatch(projectName, filter, new GerritCallback<AccountProjectWatchInfo>() {

        public void onSuccess(final AccountProjectWatchInfo result) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            nameTxt.setText("");
            watches.insertWatch(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
protected void doAddNew() {
    final String projectName = nameTxt.getText();
    if ("".equals(projectName)) {
        return;
    }
    String filter = filterTxt.getText();
    if (filter == null || filter.isEmpty() || filter.equals(Util.C.defaultFilter())) {
        filter = null;
    }
    addNew.setEnabled(false);
    nameBox.setEnabled(false);
    filterTxt.setEnabled(false);
    Util.ACCOUNT_SVC.addProjectWatch(projectName, filter, new GerritCallback<AccountProjectWatchInfo>() {

        public void onSuccess(final AccountProjectWatchInfo result) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            nameTxt.setText("");
            watchesTab.insertWatch(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    saveProject = new Button(Util.C.buttonSaveChanges());
    saveProject.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doSave();
        }
    });
    initDescription();
    initSubmitType();
    initAgreements();
    add(saveProject);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    saveProject = new Button(Util.C.buttonSaveChanges());
    saveProject.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doSave();
        }
    });
    initDescription();
    initProjectOptions();
    initAgreements();
    add(saveProject);
}
#end_block

#method_before
private void initAgreements() {
    final ValueChangeHandler<Boolean> onChangeSave = new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            saveProject.setEnabled(true);
        }
    };
    agreementsPanel = new VerticalPanel();
    agreementsPanel.add(new SmallHeading(Util.C.headingAgreements()));
    useContributorAgreements = new CheckBox(Util.C.useContributorAgreements());
    useContributorAgreements.addValueChangeHandler(onChangeSave);
    agreementsPanel.add(useContributorAgreements);
    useSignedOffBy = new CheckBox(Util.C.useSignedOffBy(), true);
    useSignedOffBy.addValueChangeHandler(onChangeSave);
    agreementsPanel.add(useSignedOffBy);
    requireChangeID = new CheckBox(Util.C.requireChangeID(), true);
    requireChangeID.addValueChangeHandler(onChangeSave);
    agreementsPanel.add(requireChangeID);
    add(agreementsPanel);
}
#method_after
private void initAgreements() {
    final ValueChangeHandler<Boolean> onChangeSave = new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            saveProject.setEnabled(true);
        }
    };
    agreementsPanel = new VerticalPanel();
    agreementsPanel.add(new SmallHeading(Util.C.headingAgreements()));
    useContributorAgreements = new CheckBox(Util.C.useContributorAgreements());
    useContributorAgreements.addValueChangeHandler(onChangeSave);
    agreementsPanel.add(useContributorAgreements);
    useSignedOffBy = new CheckBox(Util.C.useSignedOffBy(), true);
    useSignedOffBy.addValueChangeHandler(onChangeSave);
    agreementsPanel.add(useSignedOffBy);
    add(agreementsPanel);
}
#end_block

#method_before
void display(final ProjectDetail result) {
    project = result.project;
    final boolean isall = Gerrit.getConfig().getWildProject().equals(project.getNameKey());
    submitTypePanel.setVisible(!isall);
    agreementsPanel.setVisible(!isall);
    useContributorAgreements.setVisible(Gerrit.getConfig().isUseContributorAgreements());
    descTxt.setText(project.getDescription());
    useContributorAgreements.setValue(project.isUseContributorAgreements());
    useSignedOffBy.setValue(project.isUseSignedOffBy());
    requireChangeID.setValue(project.isRequireChangeID());
    setSubmitType(project.getSubmitType());
}
#method_after
void display(final ProjectDetail result) {
    project = result.project;
    final boolean isall = Gerrit.getConfig().getWildProject().equals(project.getNameKey());
    projectOptionsPanel.setVisible(!isall);
    agreementsPanel.setVisible(!isall);
    useContributorAgreements.setVisible(Gerrit.getConfig().isUseContributorAgreements());
    descTxt.setText(project.getDescription());
    useContributorAgreements.setValue(project.isUseContributorAgreements());
    useSignedOffBy.setValue(project.isUseSignedOffBy());
    requireChangeID.setValue(project.isRequireChangeID());
    setSubmitType(project.getSubmitType());
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    if (project.isRequireChangeID()) {
        // If the project wants Change-ID line, verify we
        // have it and it's legal.
        // 
        final List<String> idList = c.getFooterLines(CHANGE_ID);
        if (idList.isEmpty()) {
            reject(cmd, "missing Change-Id in commit message ");
            return false;
        }
        if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message ");
            return false;
        }
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    if (project.isRequireChangeID()) {
        final List<String> idList = c.getFooterLines(CHANGE_ID);
        if (idList.isEmpty()) {
            reject(cmd, "missing Change-Id in commit message ");
            return false;
        }
        if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message ");
            return false;
        }
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public void run() throws Exception {
    ui.header("Gerrit Code Review %s", version());
    if (site.isNew) {
        if (!ui.yesno(true, "Create '%s'", site.site_path.getCanonicalPath())) {
            throw die("aborted by user");
        }
        if (!site.site_path.isDirectory() && !site.site_path.mkdirs()) {
            throw die("Cannot make directory " + site.site_path);
        }
        flags.deleteOnFailure = true;
    }
    mkdir(site.bin_dir);
    mkdir(site.etc_dir);
    mkdir(site.lib_dir);
    mkdir(site.logs_dir);
    mkdir(site.mail_dir);
    mkdir(site.static_dir);
    for (InitStep step : steps) {
        step.run();
    }
    savePublic(flags.cfg);
    saveSecure(flags.sec);
    if (!site.replication_config.exists()) {
        site.replication_config.createNewFile();
    }
    extract(site.gerrit_sh, Init.class, "gerrit.sh");
    chmod(0755, site.gerrit_sh);
    extractMailExample("Abandoned.vm");
    extractMailExample("MergeFail.vm");
    if (!ui.isBatch()) {
        System.err.println();
    }
}
#method_after
public void run() throws Exception {
    ui.header("Gerrit Code Review %s", version());
    if (site.isNew) {
        if (!ui.yesno(true, "Create '%s'", site.site_path.getCanonicalPath())) {
            throw die("aborted by user");
        }
        if (!site.site_path.isDirectory() && !site.site_path.mkdirs()) {
            throw die("Cannot make directory " + site.site_path);
        }
        flags.deleteOnFailure = true;
    }
    mkdir(site.bin_dir);
    mkdir(site.etc_dir);
    mkdir(site.lib_dir);
    mkdir(site.logs_dir);
    mkdir(site.mail_dir);
    mkdir(site.static_dir);
    for (InitStep step : steps) {
        step.run();
    }
    savePublic(flags.cfg);
    saveSecure(flags.sec);
    if (!site.replication_config.exists()) {
        site.replication_config.createNewFile();
    }
    extract(site.gerrit_sh, Init.class, "gerrit.sh");
    chmod(0755, site.gerrit_sh);
    extractMailExample("Abandoned.vm");
    extractMailExample("ChangeFooter.vm");
    extractMailExample("ChangeSubject.vm");
    extractMailExample("Comment.vm");
    extractMailExample("Merged.vm");
    extractMailExample("MergeFail.vm");
    if (!ui.isBatch()) {
        System.err.println();
    }
}
#end_block

#method_before
private void extractMailExample(String orig) throws Exception {
    File ex = new File(site.mail_dir, "/" + orig + ".example");
    extract(ex, OutgoingEmail.class, orig);
    chmod(0444, ex);
}
#method_after
private void extractMailExample(String orig) throws Exception {
    File ex = new File(site.mail_dir, orig + ".example");
    extract(ex, OutgoingEmail.class, orig);
    chmod(0444, ex);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    ccExistingReviewers();
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    ccExistingReviewers();
}
#end_block

#method_before
@Override
protected void formatChange() {
    appendText(velocifyFile("MergeFail.vm"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(velocifyFile("MergeFail.vm"));
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    bccWatchesNotifyAllComments();
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    bccWatchesNotifyAllComments();
}
#end_block

#method_before
@Override
protected void formatChange() {
    appendText(velocifyFile("Abandoned.vm"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(velocifyFile("Abandoned.vm"));
}
#end_block

#method_before
protected void format() {
    formatChange();
    if (getChangeUrl() != null) {
        openFooter();
        appendText("To view visit ");
        appendText(getChangeUrl());
        appendText("\n");
    }
    if (getSettingsUrl() != null) {
        openFooter();
        appendText("To unsubscribe, visit ");
        appendText(getSettingsUrl());
        appendText("\n");
    }
    if (inFooter) {
        appendText("\n");
    } else {
        openFooter();
    }
    appendText("Gerrit-MessageType: " + messageClass + "\n");
    appendText("Gerrit-Project: " + projectName + "\n");
    appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
    appendText("Gerrit-Owner: " + getNameEmailFor(change.getOwner()) + "\n");
    try {
        HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
        for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
            reviewers.add(p.getAccountId());
        }
        TreeSet<String> names = new TreeSet<String>();
        for (Account.Id who : reviewers) {
            names.add(getNameEmailFor(who));
        }
        for (String name : names) {
            appendText("Gerrit-Reviewer: " + name + "\n");
        }
    } catch (OrmException e) {
    }
}
#method_after
protected void format() throws EmailException {
    formatChange();
    if (getChangeUrl() != null) {
        openFooter();
        appendText("To view visit ");
        appendText(getChangeUrl());
        appendText("\n");
    }
    if (getSettingsUrl() != null) {
        openFooter();
        appendText("To unsubscribe, visit ");
        appendText(getSettingsUrl());
        appendText("\n");
    }
    if (inFooter) {
        appendText("\n");
    } else {
        openFooter();
    }
    appendText("Gerrit-MessageType: " + messageClass + "\n");
    appendText("Gerrit-Project: " + projectName + "\n");
    appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
    appendText("Gerrit-Owner: " + getNameEmailFor(change.getOwner()) + "\n");
    try {
        HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
        for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
            reviewers.add(p.getAccountId());
        }
        TreeSet<String> names = new TreeSet<String>();
        for (Account.Id who : reviewers) {
            names.add(getNameEmailFor(who));
        }
        for (String name : names) {
            appendText("Gerrit-Reviewer: " + name + "\n");
        }
    } catch (OrmException e) {
    }
}
#end_block

#method_before
protected void init() {
    super.init();
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    if (patchSet == null) {
        try {
            patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
        } catch (PatchSetInfoNotAvailableException err) {
            patchSetInfo = null;
        }
    }
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setListIdHeader();
    setChangeUrlHeader();
    setCommitIdHeader();
    inFooter = false;
}
#method_after
protected void init() {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    if (patchSet == null) {
        try {
            patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
        } catch (PatchSetInfoNotAvailableException err) {
            patchSetInfo = null;
        }
    }
    super.init();
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setListIdHeader();
    setChangeUrlHeader();
    setCommitIdHeader();
    inFooter = false;
}
#end_block

#method_before
private String getSettingsUrl() {
    if (getGerritUrl() != null) {
        final StringBuilder r = new StringBuilder();
        r.append(getGerritUrl());
        r.append("settings");
        return r.toString();
    }
    return null;
}
#method_after
public String getSettingsUrl() {
    if (getGerritUrl() != null) {
        final StringBuilder r = new StringBuilder();
        r.append(getGerritUrl());
        r.append("settings");
        return r.toString();
    }
    return null;
}
#end_block

#method_before
protected void setVHeader(final String name, final String value) {
    setHeader(name, velocify(value));
}
#method_after
protected void setVHeader(final String name, final String value) throws EmailException {
    setHeader(name, velocify(value));
}
#end_block

#method_before
private void add(final RecipientType rt, final UserIdentity who) {
    if (who != null && who.getAccount() != null) {
        add(rt, who.getAccount());
    }
}
#method_after
protected void add(final RecipientType rt, final UserIdentity who) {
    if (who != null && who.getAccount() != null) {
        add(rt, who.getAccount());
    }
}
#end_block

#method_before
private Address toAddress(final Account.Id id) {
    final Account a = args.accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#method_after
private Address toAddress(final Account.Id id) {
    final Account a = args.accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (!a.isActive() || e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#end_block

#method_before
protected void setupVelocityContext() {
    String rl = "resource.loader";
    String pkg = "org.apache.velocity.runtime.resource.loader";
    Properties p = new Properties();
    p.setProperty(rl, "file, class");
    p.setProperty("file." + rl + ".class", pkg + ".FileResourceLoader");
    p.setProperty("file." + rl + ".path", args.site.mail_dir.getAbsolutePath());
    p.setProperty("class." + rl + ".class", pkg + ".ClasspathResourceLoader");
    p.setProperty(org.apache.velocity.runtime.RuntimeConstants.RUNTIME_LOG, args.site.logs_dir.getAbsolutePath() + java.io.File.separator + "velocity_log");
    try {
        Velocity.init(p);
    } catch (Exception e) {
    }
    velocityContext = new VelocityContext();
    velocityContext.put("email", this);
    velocityContext.put("messageClass", messageClass);
    velocityContext.put("StringUtils", StringUtils.class);
}
#method_after
protected void setupVelocityContext() {
    velocityContext = new VelocityContext();
    velocityContext.put("email", this);
    velocityContext.put("messageClass", messageClass);
    velocityContext.put("StringUtils", StringUtils.class);
}
#end_block

#method_before
protected String velocify(String tpl) {
    try {
        StringWriter w = new StringWriter();
        Velocity.evaluate(velocityContext, w, "OutgoingEmail", tpl);
        return w.toString();
    } catch (Exception e) {
        return tpl.toString();
    }
}
#method_after
protected String velocify(String tpl) throws EmailException {
    try {
        StringWriter w = new StringWriter();
        Velocity.evaluate(velocityContext, w, "OutgoingEmail", tpl);
        return w.toString();
    } catch (Exception e) {
        throw new EmailException("Velocity template " + tpl.toString(), e);
    }
}
#end_block

#method_before
protected String velocifyFile(String name) {
    Exception eo;
    StringWriter w = new StringWriter();
    try {
        Velocity.mergeTemplate(name, velocityContext, w);
        return w.toString();
    } catch (ResourceNotFoundException e) {
        try {
            String pkg = "com/google/gerrit/server/mail/";
            Velocity.mergeTemplate(pkg + name, velocityContext, w);
            return w.toString();
        } catch (Exception e2) {
            eo = e;
        }
    } catch (Exception e) {
        eo = e;
    }
    return "Velocity exception in template " + name + ".\n" + eo.toString();
}
#method_after
protected String velocifyFile(String name) throws EmailException {
    try {
        StringWriter w = new StringWriter();
        Velocity.mergeTemplate(name, velocityContext, w);
        return w.toString();
    } catch (ResourceNotFoundException e) {
        try {
            StringWriter w = new StringWriter();
            String pkg = "com/google/gerrit/server/mail/";
            Velocity.mergeTemplate(pkg + name, velocityContext, w);
            return w.toString();
        } catch (Exception e2) {
            throw new EmailException("Velocity WAR template" + name + ".\n", e2);
        }
    } catch (Exception e) {
        throw new EmailException("Velocity template " + name + ".\n", e);
    }
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else if (!Pattern.compile("refs/.*").matcher(refPattern.replace("*", ".*")).matches()) {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    boolean exclusive = refPattern.startsWith("-");
    if (exclusive) {
        refPattern = refPattern.substring(1);
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (refPattern.startsWith(RefRight.REGEX_PREFIX)) {
        String example = RefControl.shortestExample(refPattern);
        if (!example.startsWith(Constants.R_REFS)) {
            refPattern = RefRight.REGEX_PREFIX + Constants.R_HEADS + refPattern.substring(RefRight.REGEX_PREFIX.length());
            example = RefControl.shortestExample(refPattern);
        }
        if (!Repository.isValidRefName(example)) {
            throw new InvalidNameException();
        }
    } else {
        if (!refPattern.startsWith(Constants.R_REFS)) {
            refPattern = Constants.R_HEADS + refPattern;
        }
        if (refPattern.endsWith("/*")) {
            final String prefix = refPattern.substring(0, refPattern.length() - 2);
            if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
                throw new InvalidNameException();
            }
        } else {
            if (!Repository.isValidRefName(refPattern)) {
                throw new InvalidNameException();
            }
        }
    }
    if (exclusive) {
        refPattern = "-" + refPattern;
    }
    if (!projectControl.controlForRef(refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
public boolean isOwner() {
    if (canPerform(OWN, (short) 1)) {
        return true;
    }
    // 
    if (!RefRight.ALL.equals(getRefName()) && getProjectControl().isOwner()) {
        return true;
    }
    return false;
}
#method_after
public boolean isOwner() {
    if (canPerform(OWN, (short) 1)) {
        return true;
    }
    // 
    if (getRefName().equals(RefRight.ALL.substring(0, RefRight.ALL.length() - 1)) && getProjectControl().isOwner()) {
        return true;
    }
    return false;
}
#end_block

#method_before
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    for (RefRight right : filterMostSpecific(allRights)) {
        if (groups.contains(right.getAccountGroupId())) {
            val = Math.max(right.getMaxValue(), val);
        }
    }
    return val >= level;
}
#method_after
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    SortedMap<String, RefRightsForPattern> perPatternRights = sortedRightsByPattern(allRights);
    for (RefRightsForPattern right : perPatternRights.values()) {
        val = Math.max(val, right.allowedValueForRef(groups));
        if (val >= level || right.containsExclusive()) {
            return val >= level;
        }
    }
    return val >= level;
}
#end_block

#method_before
public static boolean matches(String refName, String refPattern) {
    return Pattern.matches(refPattern.replace("*", "(.*)"), refName);
}
#method_after
public static boolean matches(String refName, String refPattern) {
    if (refPattern.startsWith(RefRight.REGEX_PREFIX)) {
        return Pattern.matches(refPattern, refName);
    }
    if (refPattern.endsWith("/*")) {
        String prefix = refPattern.substring(0, refPattern.length() - 1);
        return refName.startsWith(prefix);
    } else {
        return refName.equals(refPattern);
    }
}
#end_block

#method_before
private void createGroup() throws OrmException {
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    AccountGroup group = new AccountGroup(nameKey, groupId);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    db.accountGroups().insert(Collections.singleton(group));
    AccountGroupName groupName = new AccountGroupName(group);
    db.accountGroupNames().insert(Collections.singleton(groupName));
    List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (String userName : initialMembers) {
        AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, userName);
        Account.Id accountId = db.accountExternalIds().get(key).getAccountId();
        AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
}
#method_after
private void createGroup() throws OrmException, UnloggedFailure {
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    AccountGroup group = new AccountGroup(nameKey, groupId);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    AccountGroupName gn = new AccountGroupName(group);
    // used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw die("group '" + groupName + "' already exists");
    }
    db.accountGroups().insert(Collections.singleton(group));
    List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (Account.Id accountId : initialMembers) {
        AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
}
#end_block

#method_before
public void addProjectWatch(final String projectName, final String fileMatch, final AsyncCallback<AccountProjectWatchInfo> callback) {
    run(callback, new Action<AccountProjectWatchInfo>() {

        public AccountProjectWatchInfo run(ReviewDb db) throws OrmException, NoSuchProjectException {
            final Project.NameKey nameKey = new Project.NameKey(projectName);
            final ProjectControl ctl = projectControlFactory.validateFor(nameKey);
            final AccountProjectWatch watch = new AccountProjectWatch(new AccountProjectWatch.Key(((IdentifiedUser) ctl.getCurrentUser()).getAccountId(), nameKey, fileMatch));
            db.accountProjectWatches().insert(Collections.singleton(watch));
            return new AccountProjectWatchInfo(watch, ctl.getProject());
        }
    });
}
#method_after
public void addProjectWatch(final String projectName, final String filter, final AsyncCallback<AccountProjectWatchInfo> callback) {
    run(callback, new Action<AccountProjectWatchInfo>() {

        public AccountProjectWatchInfo run(ReviewDb db) throws OrmException, NoSuchProjectException, InvalidQueryException {
            final Project.NameKey nameKey = new Project.NameKey(projectName);
            final ProjectControl ctl = projectControlFactory.validateFor(nameKey);
            if (filter != null) {
                try {
                    ChangeQueryBuilder builder = queryBuilder.create(currentUser.get());
                    builder.setAllowFile(true);
                    builder.parse(filter);
                } catch (QueryParseException badFilter) {
                    throw new InvalidQueryException(badFilter.getMessage(), filter);
                }
            }
            AccountProjectWatch watch = new AccountProjectWatch(new AccountProjectWatch.Key(((IdentifiedUser) ctl.getCurrentUser()).getAccountId(), nameKey, filter));
            try {
                db.accountProjectWatches().insert(Collections.singleton(watch));
            } catch (OrmDuplicateKeyException alreadyHave) {
                watch = db.accountProjectWatches().get(watch.getKey());
            }
            return new AccountProjectWatchInfo(watch, ctl.getProject());
        }
    });
}
#end_block

#method_before
public void send() throws EmailException {
    if (!emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    if (shouldSendMessage()) {
        if (fromId != null) {
            // If we are impersonating a user, make sure they receive a CC of
            // this message so they can always review and audit what we sent
            // on their behalf to others.
            // 
            add(RecipientType.CC, fromId);
        }
        if (change != null) {
            if (getChangeUrl() != null) {
                openFooter();
                appendText("To view visit ");
                appendText(getChangeUrl());
                appendText("\n");
            }
            if (getSettingsUrl() != null) {
                openFooter();
                appendText("To unsubscribe, visit ");
                appendText(getSettingsUrl());
                appendText("\n");
            }
            if (inFooter) {
                appendText("\n");
            } else {
                openFooter();
            }
            appendText("Gerrit-MessageType: " + messageClass + "\n");
            appendText("Gerrit-Project: " + projectName + "\n");
            appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
        }
        if (headers.get("Message-ID").isEmpty()) {
            final StringBuilder rndid = new StringBuilder();
            rndid.append("<");
            rndid.append(System.currentTimeMillis());
            rndid.append("-");
            rndid.append(Integer.toString(RNG.nextInt(999999), 36));
            rndid.append("@");
            rndid.append(SystemReader.getInstance().getHostname());
            rndid.append(">");
            setHeader("Message-ID", rndid.toString());
        }
        emailSender.send(smtpFromAddress, smtpRcptTo, headers, body.toString());
    }
}
#method_after
public void send() throws EmailException {
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            if (fromUser.getGeneralPreferences().isCopySelfOnEmails()) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                final String fromEmail = fromUser.getPreferredEmail();
                for (Iterator<Address> i = smtpRcptTo.iterator(); i.hasNext(); ) {
                    if (i.next().email.equals(fromEmail)) {
                        i.remove();
                    }
                }
                for (EmailHeader hdr : headers.values()) {
                    if (hdr instanceof AddressList) {
                        ((AddressList) hdr).remove(fromEmail);
                    }
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        if (change != null) {
            if (getChangeUrl() != null) {
                openFooter();
                appendText("To view visit ");
                appendText(getChangeUrl());
                appendText("\n");
            }
            if (getSettingsUrl() != null) {
                openFooter();
                appendText("To unsubscribe, visit ");
                appendText(getSettingsUrl());
                appendText("\n");
            }
            if (inFooter) {
                appendText("\n");
            } else {
                openFooter();
            }
            appendText("Gerrit-MessageType: " + messageClass + "\n");
            appendText("Gerrit-Project: " + projectName + "\n");
            appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
            appendText("Gerrit-Owner: " + getNameEmailFor(change.getOwner()) + "\n");
            try {
                HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
                for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
                    reviewers.add(p.getAccountId());
                }
                TreeSet<String> names = new TreeSet<String>();
                for (Account.Id who : reviewers) {
                    names.add(getNameEmailFor(who));
                }
                for (String name : names) {
                    appendText("Gerrit-Reviewer: " + name + "\n");
                }
            } catch (OrmException e) {
            }
        }
        if (headers.get("Message-ID").isEmpty()) {
            final StringBuilder rndid = new StringBuilder();
            rndid.append("<");
            rndid.append(System.currentTimeMillis());
            rndid.append("-");
            rndid.append(Integer.toString(RNG.nextInt(999999), 36));
            rndid.append("@");
            rndid.append(SystemReader.getInstance().getHostname());
            rndid.append(">");
            setHeader("Message-ID", rndid.toString());
        }
        args.emailSender.send(smtpFromAddress, smtpRcptTo, headers, body.toString());
    }
}
#end_block

#method_before
protected void init() {
    if (change != null && projectCache != null) {
        projectState = projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    smtpFromAddress = fromAddressGenerator.from(fromId);
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    } else {
        setHeader("Date", new Date());
    }
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    if (change != null) {
        setChangeSubjectHeader();
    }
    setHeader("Message-ID", "");
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.email.equals(a.email)) {
            setHeader("Reply-To", a.email);
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    if (change != null) {
        setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
        setListIdHeader();
        setChangeUrlHeader();
        setCommitIdHeader();
    }
    body = new StringBuilder();
    inFooter = false;
    if (fromId != null && fromAddressGenerator.isGenericAddress(fromId)) {
        final Account account = accountCache.get(fromId).getAccount();
        final String name = account.getFullName();
        final String email = account.getPreferredEmail();
        if ((name != null && !name.isEmpty()) || (email != null && !email.isEmpty())) {
            body.append("From");
            if (name != null && !name.isEmpty()) {
                body.append(" ").append(name);
            }
            if (email != null && !email.isEmpty()) {
                body.append(" <").append(email).append(">");
            }
            body.append(":\n\n");
        }
    }
    if (change != null && db != null) {
        if (patchSet == null) {
            try {
                patchSet = db.patchSets().get(change.currentPatchSetId());
            } catch (OrmException err) {
                patchSet = null;
            }
        }
        if (patchSet != null && patchSetInfo == null) {
            try {
                patchSetInfo = patchSetInfoFactory.get(patchSet.getId());
            } catch (PatchSetInfoNotAvailableException err) {
                patchSetInfo = null;
            }
        }
    }
}
#method_after
protected void init() {
    if (change != null && args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    } else {
        setHeader("Date", new Date());
    }
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    if (change != null) {
        setChangeSubjectHeader();
    }
    setHeader("Message-ID", "");
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.email.equals(a.email)) {
            setHeader("Reply-To", a.email);
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    if (change != null) {
        setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
        setListIdHeader();
        setChangeUrlHeader();
        setCommitIdHeader();
    }
    body = new StringBuilder();
    inFooter = false;
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        final Account account = args.accountCache.get(fromId).getAccount();
        final String name = account.getFullName();
        final String email = account.getPreferredEmail();
        if ((name != null && !name.isEmpty()) || (email != null && !email.isEmpty())) {
            body.append("From");
            if (name != null && !name.isEmpty()) {
                body.append(" ").append(name);
            }
            if (email != null && !email.isEmpty()) {
                body.append(" <").append(email).append(">");
            }
            body.append(":\n\n");
        }
    }
    if (change != null) {
        if (patchSet == null) {
            try {
                patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
            } catch (OrmException err) {
                patchSet = null;
            }
        }
        if (patchSet != null && patchSetInfo == null) {
            try {
                patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
            } catch (PatchSetInfoNotAvailableException err) {
                patchSetInfo = null;
            }
        }
    }
}
#end_block

#method_before
protected String getGerritUrl() {
    return urlProvider.get();
}
#method_after
protected String getGerritUrl() {
    return args.urlProvider.get();
}
#end_block

#method_before
protected PatchList getPatchList() {
    if (patchSet != null) {
        return patchListCache.get(change, patchSet);
    }
    return null;
}
#method_after
protected PatchList getPatchList() {
    if (patchSet != null) {
        return args.patchListCache.get(change, patchSet);
    }
    return null;
}
#end_block

#method_before
protected String getNameFor(final Account.Id accountId) {
    if (accountId == null) {
        return "Anonymous Coward";
    }
    final Account userAccount = accountCache.get(accountId).getAccount();
    String name = userAccount.getFullName();
    if (name == null) {
        name = userAccount.getPreferredEmail();
    }
    if (name == null) {
        name = "Anonymous Coward #" + accountId;
    }
    return name;
}
#method_after
protected String getNameFor(final Account.Id accountId) {
    if (accountId == null) {
        return "Anonymous Coward";
    }
    final Account userAccount = args.accountCache.get(accountId).getAccount();
    String name = userAccount.getFullName();
    if (name == null) {
        name = userAccount.getPreferredEmail();
    }
    if (name == null) {
        name = "Anonymous Coward #" + accountId;
    }
    return name;
}
#end_block

#method_before
protected boolean shouldSendMessage() {
    if (body.length() == 0) {
        // 
        return false;
    }
    if (rcptTo.isEmpty()) {
        // 
        return false;
    }
    if (rcptTo.size() == 1 && rcptTo.contains(fromId)) {
        // 
        return false;
    }
    return true;
}
#method_after
protected boolean shouldSendMessage() {
    if (body.length() == 0) {
        // 
        return false;
    }
    if (smtpRcptTo.isEmpty()) {
        // 
        return false;
    }
    if (rcptTo.size() == 1 && rcptTo.contains(fromId)) {
        // 
        return false;
    }
    return true;
}
#end_block

#method_before
protected Set<AccountGroup.Id> getProjectOwners() {
    final ProjectState r;
    r = projectCache.get(change.getProject());
    return r != null ? r.getOwners() : Collections.<AccountGroup.Id>emptySet();
}
#method_after
protected Set<AccountGroup.Id> getProjectOwners() {
    final ProjectState r;
    r = args.projectCache.get(change.getProject());
    return r != null ? r.getOwners() : Collections.<AccountGroup.Id>emptySet();
}
#end_block

#method_before
protected void bccStarredBy() {
    if (db != null) {
        try {
            // 
            for (StarredChange w : db.starredChanges().byChange(change.getId())) {
                add(RecipientType.BCC, w.getAccountId());
            }
        } catch (OrmException err) {
        // Just don't BCC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        }
    }
}
#method_after
protected void bccStarredBy() {
    try {
        // 
        for (StarredChange w : args.db.get().starredChanges().byChange(change.getId())) {
            add(RecipientType.BCC, w.getAccountId());
        }
    } catch (OrmException err) {
    // Just don't BCC everyone. Better to send a partial message to those
    // we already have queued up then to fail deliver entirely to people
    // who have a lower interest in the change.
    }
}
#end_block

#method_before
protected void bccWatchesNotifyAllComments(List<String> specificFileName) {
    if (db != null) {
        if (specificFileName == null) {
            final List<Patch> patches = getPatches(patchSet.getId());
            specificFileName = getPatchesFileNames(patches);
        }
        try {
            // BCC anyone else who has interest in this project's changes
            // 
            final ProjectState ps = getProjectState();
            if (ps != null) {
                for (final AccountProjectWatch w : db.accountProjectWatches().notifyAllComments(ps.getProject().getNameKey())) {
                    if (canAddRecipient(w, specificFileName)) {
                        add(RecipientType.BCC, w.getAccountId());
                    }
                }
            }
        } catch (OrmException err) {
        // Just don't CC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        }
    }
}
#method_after
protected void bccWatchesNotifyAllComments() {
    try {
        // 
        for (final AccountProjectWatch w : getWatches()) {
            if (w.isNotifyAllComments()) {
                add(RecipientType.BCC, w.getAccountId());
            }
        }
    } catch (OrmException err) {
    // Just don't CC everyone. Better to send a partial message to those
    // we already have queued up then to fail deliver entirely to people
    // who have a lower interest in the change.
    }
}
#end_block

#method_before
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        smtpRcptTo.add(addr);
        switch(rt) {
            case TO:
                ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                break;
            case CC:
                ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                break;
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
private void add(List<AccountProjectWatch> matching, AccountProjectWatch w) throws OrmException {
    IdentifiedUser user = args.identifiedUserFactory.create(args.db, w.getAccountId());
    ChangeQueryBuilder qb = args.queryBuilder.create(user);
    Predicate<ChangeData> p = qb.is_visible();
    if (w.getFilter() != null) {
        try {
            qb.setAllowFile(true);
            p = Predicate.and(qb.parse(w.getFilter()), p);
            p = args.queryRewriter.get().rewrite(p);
            if (p.match(changeData)) {
                matching.add(w);
            }
        } catch (QueryParseException e) {
        // Ignore broken filter expressions.
        }
    } else if (p.match(changeData)) {
        matching.add(w);
    }
}
#end_block

#method_before
private void ccApprovals(final boolean includeZero) {
    if (db != null) {
        try {
            // 
            for (PatchSetApproval ap : db.patchSetApprovals().byChange(change.getId())) {
                if (!includeZero && ap.getValue() == 0) {
                    continue;
                }
                add(RecipientType.CC, ap.getAccountId());
            }
        } catch (OrmException err) {
        }
    }
}
#method_after
private void ccApprovals(final boolean includeZero) {
    try {
        // 
        for (PatchSetApproval ap : args.db.get().patchSetApprovals().byChange(change.getId())) {
            if (!includeZero && ap.getValue() == 0) {
                continue;
            }
            add(RecipientType.CC, ap.getAccountId());
        }
    } catch (OrmException err) {
    }
}
#end_block

#method_before
private boolean isVisibleTo(final Account.Id to) {
    return projectState == null || change == null || projectState.controlFor(identifiedUserFactory.create(to)).controlFor(change).isVisible();
}
#method_after
private boolean isVisibleTo(final Account.Id to) {
    return projectState == null || change == null || projectState.controlFor(args.identifiedUserFactory.create(to)).controlFor(change).isVisible();
}
#end_block

#method_before
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        smtpRcptTo.add(addr);
        switch(rt) {
            case TO:
                ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                break;
            case CC:
                ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                break;
        }
    }
}
#method_after
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        if (args.emailSender.canEmail(addr.email)) {
            smtpRcptTo.add(addr);
            switch(rt) {
                case TO:
                    ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                    break;
                case CC:
                    ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                    break;
            }
        } else {
            log.warn("Not emailing " + addr.email + " (prohibited by allowrcpt)");
        }
    }
}
#end_block

#method_before
private Address toAddress(final Account.Id id) {
    final Account a = accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#method_after
private Address toAddress(final Account.Id id) {
    final Account a = args.accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#end_block

#method_before
public void setPatchLineComments(final List<PatchLineComment> plc) {
    inlineComments = plc;
}
#method_after
public void setPatchLineComments(final List<PatchLineComment> plc) {
    inlineComments = plc;
    Set<String> paths = new HashSet<String>();
    for (PatchLineComment c : plc) {
        Patch.Key p = c.getKey().getParentKey();
        paths.add(p.getFileName());
    }
    changeData.setCurrentFilePaths(paths);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    final List<String> inlineCommentsFiles = new ArrayList<String>();
    for (final PatchLineComment c : inlineComments) {
        final String fileName = c.getKey().getParentKey().getFileName();
        inlineCommentsFiles.add(fileName);
    }
    bccWatchesNotifyAllComments(inlineCommentsFiles);
}
#method_after
@Override
protected void init() {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    bccWatchesNotifyAllComments();
}
#end_block

#method_before
private Repository getRepository() {
    try {
        return server.openRepository(projectName);
    } catch (RepositoryNotFoundException e) {
        return null;
    }
}
#method_after
private Repository getRepository() {
    try {
        return args.server.openRepository(projectName);
    } catch (RepositoryNotFoundException e) {
        return null;
    }
}
#end_block

#method_before
public void setContext(final int ctx) {
    assert 0 <= ctx || ctx == AccountGeneralPreferences.WHOLE_FILE_CONTEXT;
    context = ctx;
}
#method_after
public void setContext(final int ctx) {
    assert 0 <= ctx || ctx == AccountDiffPreference.WHOLE_FILE_CONTEXT;
    context = ctx;
}
#end_block

#method_before
@Override
public void myDiffPreferences(AsyncCallback<AccountDiffPreference> callback) {
    run(callback, new Action<AccountDiffPreference>() {

        @Override
        public AccountDiffPreference run(ReviewDb db) throws OrmException, Failure, NoSuchProjectException, NoSuchGroupException {
            return db.accountDiffPreferences().get(currentUser.get().getAccountId());
        }
    });
}
#method_after
@Override
public void myDiffPreferences(AsyncCallback<AccountDiffPreference> callback) {
    run(callback, new Action<AccountDiffPreference>() {

        @Override
        public AccountDiffPreference run(ReviewDb db) throws OrmException {
            return currentUser.get().getAccountDiffPreference();
        }
    });
}
#end_block

#method_before
@Override
public void changeDiffPreferences(final AccountDiffPreference diffPref, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure, NoSuchProjectException, NoSuchGroupException {
            Id accountId = getAccountId();
            diffPref.setAccountId(accountId);
            final AccountDiffPreference p = db.accountDiffPreferences().get(accountId);
            if (p == null) {
                db.accountDiffPreferences().insert(Collections.singleton(diffPref));
            } else {
                db.accountDiffPreferences().update(Collections.singleton(diffPref));
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
@Override
public void changeDiffPreferences(final AccountDiffPreference diffPref, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException {
            Account.Id accountId = getAccountId();
            if (!diffPref.getAccountId().equals(getAccountId())) {
                throw new IllegalArgumentException("diffPref.getAccountId() " + diffPref.getAccountId() + " doesn't match" + " the accountId of the signed in user " + getAccountId());
            }
            db.accountDiffPreferences().upsert(Collections.singleton(diffPref));
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public char getIgnoreWhitespace() {
    return ignoreWhitespace;
}
#method_after
public Whitespace getIgnoreWhitespace() {
    return Whitespace.forCode(ignoreWhitespace);
}
#end_block

#method_before
public void setIgnoreWhitespace(char ignoreWhitespace) {
    this.ignoreWhitespace = ignoreWhitespace;
}
#method_after
public void setIgnoreWhitespace(Whitespace ignoreWhitespace) {
    this.ignoreWhitespace = ignoreWhitespace.getCode();
}
#end_block

#method_before
public void setEnabled(final boolean on) {
    for (Widget w : (HasWidgets) getWidget()) {
        if (w instanceof FocusWidget) {
            ((FocusWidget) w).setEnabled(on);
        }
    }
    toggleEnabledStatus(on);
}
#method_after
public void setEnabled(final boolean on) {
    if (on) {
        setEnabledCounter++;
    } else {
        setEnabledCounter--;
    }
    if (on && setEnabledCounter == 0 || !on) {
        for (Widget w : (HasWidgets) getWidget()) {
            if (w instanceof FocusWidget) {
                ((FocusWidget) w).setEnabled(on);
            }
        }
        toggleEnabledStatus(on);
    }
    ;
}
#end_block

#method_before
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        final PrettySettings p = getValue().getPrettySettings();
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
        showFullFile.setValue(getValue().getContext() == WHOLE_FILE_CONTEXT);
    } else {
        syntaxHighlighting.setValue(false);
        showFullFile.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#method_after
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        final PrettySettings p = getValue().getPrettySettings();
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    toggleEnabledStatus(update.isEnabled());
}
#end_block

#method_before
private void toggleEnabledStatus(final boolean on) {
    intralineDifference.setEnabled(on & enableIntralineDifference);
    syntaxHighlighting.setEnabled(on & enableSmallFileFeatures);
    showFullFile.setEnabled(on & enableSmallFileFeatures);
    final String title = enableSmallFileFeatures ? null : PatchUtil.C.disabledOnLargeFiles();
    syntaxHighlighting.setTitle(title);
    showFullFile.setTitle(title);
}
#method_after
private void toggleEnabledStatus(final boolean on) {
    intralineDifference.setEnabled(on & enableIntralineDifference);
    syntaxHighlighting.setEnabled(on & enableSmallFileFeatures);
    final String title = enableSmallFileFeatures ? null : PatchUtil.C.disabledOnLargeFiles();
    syntaxHighlighting.setTitle(title);
}
#end_block

#method_before
public void setValue(final PatchScriptSettings s) {
    final PrettySettings p = s.getPrettySettings();
    setIgnoreWhitespace(s.getWhitespace());
    if (enableSmallFileFeatures) {
        showFullFile.setValue(s.getContext() == WHOLE_FILE_CONTEXT);
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
    } else {
        showFullFile.setValue(false);
        syntaxHighlighting.setValue(false);
    }
    tabWidth.setIntValue(p.getTabSize());
    colWidth.setIntValue(p.getLineLength());
    intralineDifference.setValue(p.isIntralineDifference());
    whitespaceErrors.setValue(p.isShowWhiteSpaceErrors());
    showTabs.setValue(p.isShowTabs());
    value = s;
}
#method_after
public void setValue(final PatchScriptSettings s) {
    final PrettySettings p = s.getPrettySettings();
    setIgnoreWhitespace(s.getWhitespace());
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(p.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    setContext(s.getContext());
    tabWidth.setIntValue(p.getTabSize());
    colWidth.setIntValue(p.getLineLength());
    intralineDifference.setValue(p.isIntralineDifference());
    whitespaceErrors.setValue(p.isShowWhiteSpaceErrors());
    showTabs.setValue(p.isShowTabs());
    value = s;
}
#end_block

#method_before
@UiHandler("update")
void onUpdate(ClickEvent event) {
    update();
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#method_after
@UiHandler("update")
void onUpdate(ClickEvent event) {
    update();
}
#end_block

#method_before
private void update() {
    PatchScriptSettings s = new PatchScriptSettings(getValue());
    PrettySettings p = s.getPrettySettings();
    s.setWhitespace(getIgnoreWhitespace());
    if (showFullFile.getValue()) {
        s.setContext(WHOLE_FILE_CONTEXT);
    } else if (Gerrit.isSignedIn()) {
        final Account u = Gerrit.getUserAccount();
        final AccountGeneralPreferences pref = u.getGeneralPreferences();
        if (pref.getDefaultContext() == WHOLE_FILE_CONTEXT) {
            s.setContext(DEFAULT_CONTEXT);
        } else {
            s.setContext(pref.getDefaultContext());
        }
    } else {
        s.setContext(DEFAULT_CONTEXT);
    }
    p.setTabSize(tabWidth.getIntValue());
    p.setLineLength(colWidth.getIntValue());
    p.setSyntaxHighlighting(syntaxHighlighting.getValue());
    p.setIntralineDifference(intralineDifference.getValue());
    p.setShowWhiteSpaceErrors(whitespaceErrors.getValue());
    p.setShowTabs(showTabs.getValue());
    value = s;
    fireEvent(new ValueChangeEvent<PatchScriptSettings>(s) {
    });
}
#method_after
private void update() {
    PatchScriptSettings s = new PatchScriptSettings(getValue());
    PrettySettings p = s.getPrettySettings();
    s.setWhitespace(getIgnoreWhitespace());
    s.setContext(getContext());
    p.setTabSize(tabWidth.getIntValue());
    p.setLineLength(colWidth.getIntValue());
    p.setSyntaxHighlighting(syntaxHighlighting.getValue());
    p.setIntralineDifference(intralineDifference.getValue());
    p.setShowWhiteSpaceErrors(whitespaceErrors.getValue());
    p.setShowTabs(showTabs.getValue());
    value = s;
    fireEvent(new ValueChangeEvent<PatchScriptSettings>(s) {
    });
    if (Gerrit.isSignedIn()) {
        persistDiffPreferences();
    }
}
#end_block

#method_before
private void persistDiffPreferences() {
    AccountDiffPreference diffPref = new AccountDiffPreference();
    diffPref.setIgnoreWhitespace(getIgnoreWhitespace().getCode());
    diffPref.setTabSize(tabWidth.getIntValue());
    diffPref.setLineLength(colWidth.getIntValue());
    diffPref.setSyntaxHighlighting(syntaxHighlighting.getValue());
    diffPref.setShowWhitespaceErrors(whitespaceErrors.getValue());
    diffPref.setIntralineDifference(intralineDifference.getValue());
    diffPref.setShowTabs(showTabs.getValue());
    Util.ACCOUNT_SVC.changeDiffPreferences(diffPref, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
        }
    });
}
#method_after
private void persistDiffPreferences() {
    setEnabled(false);
    final AccountDiffPreference diffPref = new AccountDiffPreference(Gerrit.getUserAccount().getId());
    diffPref.setIgnoreWhitespace(getIgnoreWhitespace());
    diffPref.setTabSize(tabWidth.getIntValue());
    diffPref.setLineLength(colWidth.getIntValue());
    diffPref.setSyntaxHighlighting(syntaxHighlighting.getValue());
    diffPref.setShowWhitespaceErrors(whitespaceErrors.getValue());
    diffPref.setIntralineDifference(intralineDifference.getValue());
    diffPref.setShowTabs(showTabs.getValue());
    diffPref.setContext(getContext());
    Util.ACCOUNT_SVC.changeDiffPreferences(diffPref, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            Gerrit.setAccountDiffPreference(diffPref);
            setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            setEnabled(true);
        }
    });
}
#end_block

#method_before
private boolean isWatched(Change c) {
    Set<Project.NameKey> watchedProjects = currentUser.get().getWatchedProjects();
    return watchedProjects.contains(c.getProject()) || watchedProjects.contains(systemConfigProvider.get().wildProjectName);
}
#method_after
private boolean isWatched(Change c) {
    Set<Project.NameKey> watchedProjects = currentUser.get().getWatchedProjects();
    return watchedProjects.contains(c.getProject()) || watchedProjects.contains(wildProject);
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.ALL_OPEN);
    addLink(m, C.menuAllMerged(), PageLinks.ALL_MERGED);
    addLink(m, C.menuAllAbandoned(), PageLinks.ALL_ABANDONED);
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menyMyDrafts(), PageLinks.MINE_DRAFTS);
        addLink(m, C.menuMyWatchedChanges(), PageLinks.MINE_WATCHED);
        addLink(m, C.menuMyStarredChanges(), PageLinks.MINE_STARRED);
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuGroups(), PageLinks.ADMIN_GROUPS);
        addLink(m, C.menuProjects(), PageLinks.ADMIN_PROJECTS);
        menuLeft.add(m, C.menuAdmin());
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        menuRight.add(anchor(C.menuSignOut(), "logout"));
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", "become"));
                break;
        }
    }
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.ALL_OPEN);
    addLink(m, C.menuAllMerged(), PageLinks.ALL_MERGED);
    addLink(m, C.menuAllAbandoned(), PageLinks.ALL_ABANDONED);
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.MINE_DRAFTS);
        addLink(m, C.menuMyWatchedChanges(), PageLinks.MINE_WATCHED);
        addLink(m, C.menuMyStarredChanges(), PageLinks.MINE_STARRED);
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuGroups(), PageLinks.ADMIN_GROUPS);
        addLink(m, C.menuProjects(), PageLinks.ADMIN_PROJECTS);
        menuLeft.add(m, C.menuAdmin());
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        menuRight.add(anchor(C.menuSignOut(), "logout"));
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", "become"));
                break;
        }
    }
}
#end_block

#method_before
@Override
public Set<NameKey> getWatchedProjects() {
    if (watchedProjects == null) {
        if (dbProvider == null) {
            throw new OutOfScopeException("Not in request scoped user");
        }
        final Set<Project.NameKey> h = new HashSet<Project.NameKey>();
        try {
            for (AccountProjectWatch projectWatch : dbProvider.get().accountProjectWatches().byAccount(getAccountId()).toList()) {
                h.add(projectWatch.getProjectNameKey());
            }
        } catch (ProvisionException e) {
            log.warn("Cannot query project watches of a user", e);
        } catch (OrmException e) {
            log.warn("Cannot query project watches of a user", e);
        }
        watchedProjects = Collections.unmodifiableSet(h);
    }
    return watchedProjects;
}
#method_after
@Override
public Set<Project.NameKey> getWatchedProjects() {
    if (watchedProjects == null) {
        if (dbProvider == null) {
            throw new OutOfScopeException("Not in request scoped user");
        }
        final Set<Project.NameKey> h = new HashSet<Project.NameKey>();
        try {
            for (AccountProjectWatch projectWatch : dbProvider.get().accountProjectWatches().byAccount(getAccountId())) {
                h.add(projectWatch.getProjectNameKey());
            }
        } catch (OrmException e) {
            log.warn("Cannot query project watches of a user", e);
        }
        watchedProjects = Collections.unmodifiableSet(h);
    }
    return watchedProjects;
}
#end_block

#method_before
static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            final String cacheName = CACHE_NAME;
            final TypeLiteral<Cache<ActiveSession.Key, ActiveSession>> type = new TypeLiteral<Cache<ActiveSession.Key, ActiveSession>>() {
            };
            // 
            core(type, cacheName).memoryLimit(// reasonable default for many sites
            1024).maxAge(12, // expire sessions if they are inactive
            HOURS).evictionPolicy(// keep most recently used
            EvictionPolicy.LRU);
            bind(WebSession.class).in(RequestScoped.class);
        }
    };
}
#method_after
static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            final TypeLiteral<Cache<ActiveSession.Key, ActiveSession>> type = new TypeLiteral<Cache<ActiveSession.Key, ActiveSession>>() {
            };
            // 
            core(type, CACHE_NAME).memoryLimit(// reasonable default for many sites
            1024).maxAge(12, // expire sessions if they are inactive
            HOURS).evictionPolicy(// keep most recently used
            EvictionPolicy.LRU);
            bind(WebSession.class).in(RequestScoped.class);
            bind(WebSession.KeyGenerator.class).in(SINGLETON);
        }
    };
}
#end_block

#method_before
static long now() {
    return System.currentTimeMillis();
}
#method_after
private static long now() {
    return System.currentTimeMillis();
}
#end_block

#method_before
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (session != null) {
        destroy(key);
        key = null;
        session = null;
    }
    key = createKey(id);
    session = createSession(key, id, rememberMe, identity, null);
    saveCookie();
}
#method_after
public void login(final AuthResult res, final boolean rememberMe) throws OrmException {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (session != null) {
        destroy(key);
        key = null;
        session = null;
    }
    key = createKey(id);
    session = createSession(key, id, rememberMe, identity, null);
    saveCookie();
}
#end_block

#method_before
void setUserAccountId(Account.Id id) {
    key = new ActiveSession.Key("id:" + id);
    session = new ActiveSession(key, id, 0, false, null, "");
}
#method_after
void setUserAccountId(Account.Id id) {
    key = new ActiveSession.Key("id:" + id);
    session = new ActiveSession(key, id, new Timestamp(0), false, null, "");
}
#end_block

#method_before
public void logout() {
    if (session != null) {
        destroy(key);
        key = null;
        session = null;
        saveCookie();
    }
}
#method_after
public void logout() {
    if (session != null) {
        try {
            destroy(key);
        } catch (OrmException e) {
            log.error("Could not remove session key from cache", e);
        }
        key = null;
        session = null;
        saveCookie();
    }
}
#end_block

#method_before
ActiveSession.Key createKey(final Account.Id who) {
    try {
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        buf = new ByteArrayOutputStream(3 + nonceLen);
        writeVarInt32(buf, who.get());
        writeBytes(buf, rnd);
        return new ActiveSession.Key(CookieBase64.encode(buf.toByteArray()));
    } catch (IOException e) {
        throw new RuntimeException("Cannot produce new account cookie", e);
    }
}
#method_after
private ActiveSession.Key createKey(final Account.Id who) {
    try {
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        buf = new ByteArrayOutputStream(3 + nonceLen);
        writeVarInt32(buf, who.get());
        writeBytes(buf, rnd);
        return new ActiveSession.Key(CookieBase64.encode(buf.toByteArray()));
    } catch (IOException e) {
        throw new RuntimeException("Cannot produce new account cookie", e);
    }
}
#end_block

#method_before
ActiveSession createSession(final ActiveSession.Key key, final ActiveSession session) {
    final Account.Id who = session.getAccountId();
    final boolean remember = session.isPersistentCookie();
    final AccountExternalId.Key lastLogin = session.getExternalId();
    final String xsrfToken = session.getXsrfToken();
    return createSession(key, who, remember, lastLogin, xsrfToken);
}
#method_after
private ActiveSession createSession(final ActiveSession.Key key, final ActiveSession session) throws OrmException {
    final Account.Id who = session.getAccountId();
    final boolean remember = session.isPersistentCookie();
    final AccountExternalId.Key lastLogin = session.getExternalId();
    final String xsrfToken = session.getXsrfToken();
    return createSession(key, who, remember, lastLogin, xsrfToken);
}
#end_block

#method_before
ActiveSession createSession(final ActiveSession.Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = cache.getTimeToLive(MILLISECONDS) >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long refreshCookieAt = now() + refresh;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    ActiveSession session = new ActiveSession(key, who, refreshCookieAt, remember, lastLogin, xsrfToken);
    cache.put(key, session);
    return session;
}
#method_after
private ActiveSession createSession(final ActiveSession.Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) throws OrmException {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = cache.getTimeToLive(MILLISECONDS) >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long refreshCookieAt = now() + refresh;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final ByteArrayOutputStream buf;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    ActiveSession session = new ActiveSession(key, who, new Timestamp(refreshCookieAt), remember, lastLogin, xsrfToken);
    put(session);
    return session;
}
#end_block

#method_before
int getCookieAge(final ActiveSession session) {
    if (session.isPersistentCookie()) {
        // 
        return (int) cache.getTimeToLive(SECONDS);
    } else {
        // 
        return -1;
    }
}
#method_after
private int getCookieAge(final ActiveSession session) {
    if (session.isPersistentCookie()) {
        // 
        return (int) cache.getTimeToLive(SECONDS);
    } else {
        // 
        return -1;
    }
}
#end_block

#method_before
ActiveSession get(final ActiveSession.Key key) {
    return cache.get(key);
}
#method_after
private ActiveSession get(final ActiveSession.Key key) throws OrmException {
    ActiveSession as = cache.get(key);
    final ActiveSessionAccess activeSessions = schema.activeSessions();
    if (as == null) {
        as = activeSessions.get(key);
        if (as == null) {
            return null;
        } else {
            if (expiredFromCache(as)) {
                destroy(key);
                return null;
            } else if (needsCacheRefresh(as)) {
                as.updateLastSeen();
                put(as);
            }
            return as;
        }
    } else {
        if (needsCacheRefresh(as)) {
            as.updateLastSeen();
            put(as);
        }
        return as;
    }
}
#end_block

#method_before
void destroy(final ActiveSession.Key key) {
    cache.remove(key);
}
#method_after
private void destroy(final ActiveSession.Key key) throws OrmException {
    schema.activeSessions().deleteKeys(Arrays.asList(key));
    cache.remove(key);
}
#end_block

#method_before
public long getRefreshCookieAt() {
    return refreshCookieAt;
}
#method_after
public Timestamp getRefreshCookieAt() {
    return refreshCookieAt;
}
#end_block

#method_before
public void setRefreshCookieAt(long refreshCookieAt) {
    this.refreshCookieAt = refreshCookieAt;
}
#method_after
public void setRefreshCookieAt(Timestamp refreshCookieAt) {
    this.refreshCookieAt = refreshCookieAt;
}
#end_block

#method_before
public boolean needsCookieRefresh() {
    return refreshCookieAt <= System.currentTimeMillis();
}
#method_after
public boolean needsCookieRefresh() {
    return refreshCookieAt.before(now());
}
#end_block

#method_before
private void publishApprovals() throws OrmException {
    ChangeUtil.updated(change);
    final Set<ApprovalCategory.Id> dirty = new HashSet<ApprovalCategory.Id>();
    final List<PatchSetApproval> ins = new ArrayList<PatchSetApproval>();
    final List<PatchSetApproval> upd = new ArrayList<PatchSetApproval>();
    final List<ApprovalCategoryValue.Id> ignore = new ArrayList<ApprovalCategoryValue.Id>();
    final Collection<PatchSetApproval> all = db.patchSetApprovals().byPatchSet(patchSetId).toList();
    final Map<ApprovalCategory.Id, PatchSetApproval> mine = mine(all);
    // 
    for (final ApprovalCategoryValue.Id want : approvals) {
        PatchSetApproval a = mine.get(want.getParentKey());
        if (a == null) {
            if (want.get() != 0) {
                a = new PatchSetApproval(new PatchSetApproval.Key(patchSetId, user.getAccountId(), want.getParentKey()), want.get());
                a.cache(change);
                ins.add(a);
                all.add(a);
                mine.put(a.getCategoryId(), a);
                dirty.add(a.getCategoryId());
            } else {
                ignore.add(want);
            }
        }
    }
    // Normalize all of the items the user is changing.
    // 
    final FunctionState functionState = functionStateFactory.create(change, patchSetId, all);
    for (final ApprovalCategoryValue.Id want : approvals) {
        if (ignore.indexOf(want) == -1) {
            final PatchSetApproval a = mine.get(want.getParentKey());
            final short o = a.getValue();
            a.setValue(want.get());
            a.cache(change);
            functionState.normalize(types.getApprovalType(a.getCategoryId()), a);
            if (o != a.getValue()) {
                // Value changed, ensure we update the database.
                // 
                a.setGranted();
                dirty.add(a.getCategoryId());
            }
            if (!ins.contains(a)) {
                upd.add(a);
            }
        }
    }
    // Format a message explaining the actions taken.
    // 
    final StringBuilder msgbuf = new StringBuilder();
    for (final ApprovalType at : types.getApprovalTypes()) {
        if (dirty.contains(at.getCategory().getId())) {
            final PatchSetApproval a = mine.get(at.getCategory().getId());
            final ApprovalCategoryValue val = at.getValue(a);
            if (msgbuf.length() > 0) {
                msgbuf.append("; ");
            }
            if (val != null && val.getName() != null && !val.getName().isEmpty()) {
                msgbuf.append(val.getName());
            } else {
                msgbuf.append(at.getCategory().getName());
                msgbuf.append(" ");
                if (a.getValue() > 0)
                    msgbuf.append('+');
                msgbuf.append(a.getValue());
            }
        }
    }
    // 
    for (PatchSetApproval a : all) {
        if (!user.getAccountId().equals(a.getAccountId())) {
            a.cache(change);
            upd.add(a);
        }
    }
    db.patchSetApprovals().update(upd);
    db.patchSetApprovals().insert(ins);
    summarizeInlineComments(msgbuf);
    message(msgbuf.toString());
}
#method_after
private void publishApprovals() throws OrmException {
    ChangeUtil.updated(change);
    final Set<ApprovalCategory.Id> dirty = new HashSet<ApprovalCategory.Id>();
    final List<PatchSetApproval> ins = new ArrayList<PatchSetApproval>();
    final List<PatchSetApproval> upd = new ArrayList<PatchSetApproval>();
    final Collection<PatchSetApproval> all = db.patchSetApprovals().byPatchSet(patchSetId).toList();
    final Map<ApprovalCategory.Id, PatchSetApproval> mine = mine(all);
    // 
    for (final ApprovalCategoryValue.Id want : approvals) {
        PatchSetApproval a = mine.get(want.getParentKey());
        if (a == null) {
            a = new PatchSetApproval(new // 
            PatchSetApproval.Key(patchSetId, user.getAccountId(), want.getParentKey()), want.get());
            a.cache(change);
            ins.add(a);
            all.add(a);
            mine.put(a.getCategoryId(), a);
            dirty.add(a.getCategoryId());
        }
    }
    // Normalize all of the items the user is changing.
    // 
    final FunctionState functionState = functionStateFactory.create(change, patchSetId, all);
    for (final ApprovalCategoryValue.Id want : approvals) {
        final PatchSetApproval a = mine.get(want.getParentKey());
        final short o = a.getValue();
        a.setValue(want.get());
        a.cache(change);
        functionState.normalize(types.getApprovalType(a.getCategoryId()), a);
        if (o != a.getValue()) {
            // Value changed, ensure we update the database.
            // 
            a.setGranted();
            dirty.add(a.getCategoryId());
        }
        if (!ins.contains(a)) {
            upd.add(a);
        }
    }
    // Format a message explaining the actions taken.
    // 
    final StringBuilder msgbuf = new StringBuilder();
    for (final ApprovalType at : types.getApprovalTypes()) {
        if (dirty.contains(at.getCategory().getId())) {
            final PatchSetApproval a = mine.get(at.getCategory().getId());
            if (a.getValue() == 0 && ins.contains(a)) {
                // Don't say "no score" for an initial entry.
                continue;
            }
            final ApprovalCategoryValue val = at.getValue(a);
            if (msgbuf.length() > 0) {
                msgbuf.append("; ");
            }
            if (val != null && val.getName() != null && !val.getName().isEmpty()) {
                msgbuf.append(val.getName());
            } else {
                msgbuf.append(at.getCategory().getName());
                msgbuf.append(" ");
                if (a.getValue() > 0)
                    msgbuf.append('+');
                msgbuf.append(a.getValue());
            }
        }
    }
    // 
    for (PatchSetApproval a : all) {
        if (!user.getAccountId().equals(a.getAccountId())) {
            a.cache(change);
            upd.add(a);
        }
    }
    db.patchSetApprovals().update(upd);
    db.patchSetApprovals().insert(ins);
    message(msgbuf.toString());
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ApproveCommand.class);
    command(gerrit, "create-account").to(AdminCreateAccount.class);
    command(gerrit, "create-project").to(CreateProject.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "replicate").to(AdminReplicate.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
    command(gerrit, "submit").to(SubmitCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    command(gerrit, "approve").to(ReviewCommand.class);
    command(gerrit, "create-account").to(AdminCreateAccount.class);
    command(gerrit, "create-project").to(CreateProject.class);
    command(gerrit, "gsql").to(AdminQueryShell.class);
    command(gerrit, "receive-pack").to(Receive.class);
    command(gerrit, "replicate").to(AdminReplicate.class);
    command(gerrit, "set-project-parent").to(AdminSetParent.class);
    command(gerrit, "review").to(ReviewCommand.class);
}
#end_block

#method_before
private void applyRightFloor(final PatchSetApproval a) {
    final IdentifiedUser user = userFactory.create(a.getAccountId());
    RefControl rc = controlFor(user);
    // Find the maximal range actually granted to the user.
    // 
    short minAllowed = 0, maxAllowed = 0;
    for (final RefRight r : rc.getAllRights(a.getCategoryId())) {
        final AccountGroup.Id grp = r.getAccountGroupId();
        if (user.getEffectiveGroups().contains(grp)) {
            minAllowed = (short) Math.min(minAllowed, r.getMinValue());
            maxAllowed = (short) Math.max(maxAllowed, r.getMaxValue());
        }
    }
    // 
    if (a.getValue() < minAllowed) {
        a.setValue(minAllowed);
    } else if (a.getValue() > maxAllowed) {
        a.setValue(maxAllowed);
    }
}
#method_after
private void applyRightFloor(final PatchSetApproval a) {
    final IdentifiedUser user = userFactory.create(a.getAccountId());
    RefControl rc = controlFor(user);
    // Find the maximal range actually granted to the user.
    // 
    short minAllowed = 0, maxAllowed = 0;
    for (final RefRight r : rc.getApplicableRights(a.getCategoryId())) {
        final AccountGroup.Id grp = r.getAccountGroupId();
        if (user.getEffectiveGroups().contains(grp)) {
            minAllowed = (short) Math.min(minAllowed, r.getMinValue());
            maxAllowed = (short) Math.max(maxAllowed, r.getMaxValue());
        }
    }
    // 
    if (a.getValue() < minAllowed) {
        a.setValue(minAllowed);
    } else if (a.getValue() > maxAllowed) {
        a.setValue(maxAllowed);
    }
}
#end_block

#method_before
private void initRights(final Panel body) {
    final FlowPanel addPanel = new FlowPanel();
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(5, 2);
    catBox = new ListBox();
    rangeMinBox = new ListBox();
    rangeMaxBox = new ListBox();
    catBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            updateCategorySelection();
        }
    });
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        final ApprovalCategory c = at.getCategory();
        catBox.addItem(c.getName(), c.getId().get());
    }
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getActionTypes()) {
        final ApprovalCategory c = at.getCategory();
        if (Gerrit.getConfig().getWildProject().equals(projectName) && ApprovalCategory.OWN.equals(c.getId())) {
            // 
            continue;
        }
        catBox.addItem(c.getName(), c.getId().get());
    }
    addGrid.setText(0, 0, Util.C.columnApprovalCategory() + ":");
    addGrid.setWidget(0, 1, catBox);
    nameTxtBox = new NpTextBox();
    nameTxt = new SuggestBox(new AccountGroupSuggestOracle(), nameTxtBox);
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setText(Util.C.defaultAccountGroupName());
    nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
    nameTxtBox.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            if (Util.C.defaultAccountGroupName().equals(nameTxtBox.getText())) {
                nameTxtBox.setText("");
                nameTxtBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addBlurHandler(new BlurHandler() {

        @Override
        public void onBlur(BlurEvent event) {
            if ("".equals(nameTxtBox.getText())) {
                nameTxtBox.setText(Util.C.defaultAccountGroupName());
                nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    addGrid.setText(1, 0, Util.C.columnGroupName() + ":");
    addGrid.setWidget(1, 1, nameTxt);
    referenceTxt = new NpTextBox();
    referenceTxt.setVisibleLength(50);
    referenceTxt.setText("");
    referenceTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(2, 0, Util.C.columnRefName() + ":");
    addGrid.setWidget(2, 1, referenceTxt);
    addGrid.setText(3, 0, Util.C.columnRightRange() + ":");
    addGrid.setWidget(3, 1, rangeMinBox);
    addGrid.setText(4, 0, "");
    addGrid.setWidget(4, 1, rangeMaxBox);
    addRight = new Button(Util.C.buttonAddProjectRight());
    addRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewRight();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addRight);
    rights = new RightsTable();
    delRight = new Button(Util.C.buttonDeleteGroupMembers());
    delRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            rights.deleteChecked();
        }
    });
    body.add(new SmallHeading(Util.C.headingAccessRights()));
    body.add(rights);
    body.add(delRight);
    body.add(addPanel);
    if (catBox.getItemCount() > 0) {
        catBox.setSelectedIndex(0);
        updateCategorySelection();
    }
}
#method_after
private void initRights(final Panel body) {
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(5, 2);
    catBox = new ListBox();
    rangeMinBox = new ListBox();
    rangeMaxBox = new ListBox();
    catBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            updateCategorySelection();
        }
    });
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        final ApprovalCategory c = at.getCategory();
        catBox.addItem(c.getName(), c.getId().get());
    }
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getActionTypes()) {
        final ApprovalCategory c = at.getCategory();
        if (Gerrit.getConfig().getWildProject().equals(projectName) && ApprovalCategory.OWN.equals(c.getId())) {
            // 
            continue;
        }
        catBox.addItem(c.getName(), c.getId().get());
    }
    addGrid.setText(0, 0, Util.C.columnApprovalCategory() + ":");
    addGrid.setWidget(0, 1, catBox);
    nameTxtBox = new NpTextBox();
    nameTxt = new SuggestBox(new AccountGroupSuggestOracle(), nameTxtBox);
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setText(Util.C.defaultAccountGroupName());
    nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
    nameTxtBox.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            if (Util.C.defaultAccountGroupName().equals(nameTxtBox.getText())) {
                nameTxtBox.setText("");
                nameTxtBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addBlurHandler(new BlurHandler() {

        @Override
        public void onBlur(BlurEvent event) {
            if ("".equals(nameTxtBox.getText())) {
                nameTxtBox.setText(Util.C.defaultAccountGroupName());
                nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    addGrid.setText(1, 0, Util.C.columnGroupName() + ":");
    addGrid.setWidget(1, 1, nameTxt);
    referenceTxt = new NpTextBox();
    referenceTxt.setVisibleLength(50);
    referenceTxt.setText("");
    referenceTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(2, 0, Util.C.columnRefName() + ":");
    addGrid.setWidget(2, 1, referenceTxt);
    addGrid.setText(3, 0, Util.C.columnRightRange() + ":");
    addGrid.setWidget(3, 1, rangeMinBox);
    addGrid.setText(4, 0, "");
    addGrid.setWidget(4, 1, rangeMaxBox);
    addRight = new Button(Util.C.buttonAddProjectRight());
    addRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewRight();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addRight);
    rights = new RightsTable();
    delRight = new Button(Util.C.buttonDeleteGroupMembers());
    delRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            final HashSet<RefRight.Key> refRightIds = rights.getRefRightIdsChecked();
            doDeleteRefRights(refRightIds);
        }
    });
    body.add(new SmallHeading(Util.C.headingAccessRights()));
    body.add(rights);
    body.add(delRight);
    body.add(addPanel);
    if (catBox.getItemCount() > 0) {
        catBox.setSelectedIndex(0);
        updateCategorySelection();
    }
}
#end_block

#method_before
void display(final ProjectDetail result) {
    final Project project = result.project;
    final Project.NameKey wildKey = Gerrit.getConfig().getWildProject();
    final boolean isWild = wildKey.equals(project.getNameKey());
    Project.NameKey parent = project.getParent();
    if (parent == null) {
        parent = wildKey;
    }
    parentPanel.setVisible(!isWild);
    parentName.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectAdminScreen.ACCESS_TAB));
    parentName.setText(parent.get());
    rights.display(result.groups, result.rights);
}
#method_after
void display(final ProjectDetail result) {
    final Project project = result.project;
    final Project.NameKey wildKey = Gerrit.getConfig().getWildProject();
    final boolean isWild = wildKey.equals(project.getNameKey());
    Project.NameKey parent = project.getParent();
    if (parent == null) {
        parent = wildKey;
    }
    parentPanel.setVisible(!isWild);
    parentName.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectAdminScreen.ACCESS_TAB));
    parentName.setText(parent.get());
    rights.display(result.groups, result.rights);
    addPanel.setVisible(result.canModifyAccess);
    delRight.setVisible(rights.getCanDelete());
}
#end_block

#method_before
private void doAddNewRight() {
    int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    ApprovalCategoryValue min, max;
    if (idx < 0) {
        return;
    }
    at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    if (at == null) {
        return;
    }
    idx = rangeMinBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    min = at.getValue(Short.parseShort(rangeMinBox.getValue(idx)));
    if (min == null) {
        return;
    }
    idx = rangeMaxBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    max = at.getValue(Short.parseShort(rangeMaxBox.getValue(idx)));
    if (max == null) {
        return;
    }
    final String groupName = nameTxt.getText();
    if ("".equals(groupName) || Util.C.defaultAccountGroupName().equals(groupName)) {
        return;
    }
    final String refPattern = referenceTxt.getText();
    if (min.getValue() > max.getValue()) {
        // If the user selects it backwards in the web UI, help them out
        // by reversing the order to what we would expect.
        // 
        final ApprovalCategoryValue newMin = max;
        final ApprovalCategoryValue newMax = min;
        min = newMin;
        max = newMax;
    }
    addRight.setEnabled(false);
    Util.PROJECT_SVC.addRight(projectName, at.getCategory().getId(), groupName, refPattern, min.getValue(), max.getValue(), new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            addRight.setEnabled(true);
            nameTxt.setText("");
            referenceTxt.setText("");
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addRight.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddNewRight() {
    int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    ApprovalCategoryValue min, max;
    if (idx < 0) {
        return;
    }
    at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    if (at == null) {
        return;
    }
    idx = rangeMinBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    min = at.getValue(Short.parseShort(rangeMinBox.getValue(idx)));
    if (min == null) {
        return;
    }
    if (at.getCategory().isRange()) {
        idx = rangeMaxBox.getSelectedIndex();
        if (idx < 0) {
            return;
        }
        max = at.getValue(Short.parseShort(rangeMaxBox.getValue(idx)));
        if (max == null) {
            return;
        }
    } else {
        // If its not a range, the maximum box was disabled.  Use the min
        // value as the max, and select the min from the category values.
        // 
        max = min;
        min = at.getMin();
        for (ApprovalCategoryValue v : at.getValues()) {
            if (0 <= v.getValue() && v.getValue() <= max.getValue()) {
                min = v;
                break;
            }
        }
    }
    final String groupName = nameTxt.getText();
    if ("".equals(groupName) || Util.C.defaultAccountGroupName().equals(groupName)) {
        return;
    }
    final String refPattern = referenceTxt.getText();
    if (min.getValue() > max.getValue()) {
        // If the user selects it backwards in the web UI, help them out
        // by reversing the order to what we would expect.
        // 
        final ApprovalCategoryValue newMin = max;
        final ApprovalCategoryValue newMax = min;
        min = newMin;
        max = newMax;
    }
    addRight.setEnabled(false);
    Util.PROJECT_SVC.addRight(projectName, at.getCategory().getId(), groupName, refPattern, min.getValue(), max.getValue(), new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            addRight.setEnabled(true);
            nameTxt.setText("");
            referenceTxt.setText("");
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addRight.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    addRight.setEnabled(true);
}
#method_after
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    rangeMaxBox.setVisible(at.getCategory().isRange());
    addRight.setEnabled(true);
}
#end_block

#method_before
void display(final Map<AccountGroup.Id, AccountGroup> groups, final List<InheritedRefRight> refRights) {
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final InheritedRefRight r : refRights) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, groups, r);
    }
}
#method_after
void display(final Map<AccountGroup.Id, AccountGroup> groups, final List<InheritedRefRight> refRights) {
    canDelete = false;
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final InheritedRefRight r : refRights) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, groups, r);
    }
}
#end_block

#method_before
void populate(final int row, final Map<AccountGroup.Id, AccountGroup> groups, final InheritedRefRight r) {
    final GerritConfig config = Gerrit.getConfig();
    final RefRight right = r.getRight();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(right.getApprovalCategoryId());
    final AccountGroup group = groups.get(right.getAccountGroupId());
    if (r.isInherited()) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
    }
    if (ar != null) {
        table.setText(row, 2, ar.getCategory().getName());
    } else {
        table.setText(row, 2, right.getApprovalCategoryId().get());
    }
    if (group != null) {
        table.setText(row, 3, group.getName());
    } else {
        table.setText(row, 3, Util.M.deletedGroup(right.getAccountGroupId().get()));
    }
    table.setText(row, 4, right.getRefPatternForDisplay());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(right.getMinValue()) : null;
        max = ar != null ? ar.getValue(right.getMaxValue()) : null;
        formatValue(m, right.getMinValue(), min);
        if (right.getMinValue() != right.getMaxValue()) {
            m.br();
            formatValue(m, right.getMaxValue(), max);
        }
        SafeHtml.set(table, row, 5, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, right);
}
#method_after
void populate(final int row, final Map<AccountGroup.Id, AccountGroup> groups, final InheritedRefRight r) {
    final GerritConfig config = Gerrit.getConfig();
    final RefRight right = r.getRight();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(right.getApprovalCategoryId());
    final AccountGroup group = groups.get(right.getAccountGroupId());
    if (r.isInherited() || !r.isOwner()) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    }
    if (ar != null) {
        table.setText(row, 2, ar.getCategory().getName());
    } else {
        table.setText(row, 2, right.getApprovalCategoryId().get());
    }
    if (group != null) {
        table.setText(row, 3, group.getName());
    } else {
        table.setText(row, 3, Util.M.deletedGroup(right.getAccountGroupId().get()));
    }
    table.setText(row, 4, right.getRefPatternForDisplay());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(right.getMinValue()) : null;
        max = ar != null ? ar.getValue(right.getMaxValue()) : null;
        if (ar != null && ar.getCategory().isRange()) {
            formatValue(m, right.getMinValue(), min);
            m.br();
        }
        formatValue(m, right.getMaxValue(), max);
        SafeHtml.set(table, row, 5, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, right);
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (refPattern.startsWith("-")) {
        if (!refPattern.startsWith("-" + Constants.R_REFS)) {
            refPattern = "-" + Constants.R_HEADS + refPattern;
        }
    } else if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    checkPatternFormat(refPattern);
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    boolean exclusive = refPattern.startsWith("-");
    if (exclusive) {
        refPattern = refPattern.substring(1);
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (exclusive) {
        refPattern = "-" + refPattern;
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
public boolean isVisible() {
    return canPerform(READ, (short) 1);
}
#method_after
public boolean isVisible() {
    return getProjectControl().visibleForReplication() || canPerform(READ, (short) 1);
}
#end_block

#method_before
public int allowedValueForRef(Set<AccountGroup.Id> groups) {
    int val = Integer.MIN_VALUE;
    for (RefRight right : rights) {
        if (groups.contains(right.getAccountGroupId())) {
            if ((val < 0 && right.getMaxValue() > 0)) {
                // If one of the user's groups had denied them access, but
                // this group grants them access, prefer the grant over
                // the denial. We have to break the tie somehow and we
                // prefer being "more open" to being "more closed".
                // 
                val = right.getMaxValue();
            } else {
                // Otherwise we use the largest value we can get.
                // 
                val = Math.max(right.getMaxValue(), val);
            }
        }
    }
    return val;
}
#method_after
public int allowedValueForRef(Set<AccountGroup.Id> groups) {
    int val = Integer.MIN_VALUE;
    for (RefRight right : rights) {
        if (groups.contains(right.getAccountGroupId())) {
            val = Math.max(right.getMaxValue(), val);
        }
    }
    return val;
}
#end_block

#method_before
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    SortedMap<String, RefRightsForPattern> perPatternRights = sortedRightsByPattern(allRights);
    for (String pattern : perPatternRights.keySet()) {
        val = Math.max(val, perPatternRights.get(pattern).allowedValueForRef(groups));
        if (val >= level || perPatternRights.get(pattern).containsExclusive()) {
            return val >= level;
        }
    }
    return val >= level;
}
#method_after
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    SortedMap<String, RefRightsForPattern> perPatternRights = sortedRightsByPattern(allRights);
    for (RefRightsForPattern right : perPatternRights.values()) {
        val = Math.max(val, right.allowedValueForRef(groups));
        if (val >= level || right.containsExclusive()) {
            return val >= level;
        }
    }
    return val >= level;
}
#end_block

#method_before
public static SortedMap<String, RefRightsForPattern> sortedRightsByPattern(List<RefRight> actionRights) {
    SortedMap<String, RefRightsForPattern> rights = new TreeMap<String, RefRightsForPattern>(DESCENDING_SORT);
    for (RefRight right : actionRights) {
        if (rights.containsKey(right.getRefPattern())) {
            rights.get(right.getRefPattern()).addRight(right);
        } else {
            RefRightsForPattern patternRights = new RefRightsForPattern();
            patternRights.addRight(right);
            rights.put(right.getRefPattern(), patternRights);
        }
    }
    return rights;
}
#method_after
private static SortedMap<String, RefRightsForPattern> sortedRightsByPattern(List<RefRight> actionRights) {
    SortedMap<String, RefRightsForPattern> rights = new TreeMap<String, RefRightsForPattern>(DESCENDING_SORT);
    for (RefRight actionRight : actionRights) {
        RefRightsForPattern patternRights = rights.get(actionRight.getRefPattern());
        if (patternRights == null) {
            patternRights = new RefRightsForPattern();
            rights.put(actionRight.getRefPattern(), patternRights);
        }
        patternRights.addRight(actionRight);
    }
    return rights;
}
#end_block

#method_before
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet) {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    event.change = getChangeAttribute(change);
    event.patchSet = getPatchSetAttribute(patchSet);
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(patchsetCreatedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-number");
    args.add(event.change.number);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--commit");
    args.add(event.patchSet.revision);
    args.add("--patchset");
    args.add(event.patchSet.number);
    runHook(getRepo(change), args);
}
#method_after
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet) {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    event.change = getChangeAttribute(change);
    event.patchSet = getPatchSetAttribute(patchSet);
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(patchsetCreatedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-url");
    args.add(event.change.url);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--commit");
    args.add(event.patchSet.revision);
    args.add("--patchset");
    args.add(event.patchSet.number);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals) {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = getChangeAttribute(change);
    event.author = getAccountAttribute(account);
    event.patchSet = getPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(commentAddedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-number");
    args.add(event.change.number);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--author");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet.revision);
    args.add("--comment");
    args.add(comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        args.add("--" + approval.getKey().get());
        args.add(Short.toString(approval.getValue().get()));
    }
    runHook(getRepo(change), args);
}
#method_after
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals) {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = getChangeAttribute(change);
    event.author = getAccountAttribute(account);
    event.patchSet = getPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(commentAddedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-url");
    args.add(event.change.url);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--author");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet.revision);
    args.add("--comment");
    args.add(comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        args.add("--" + approval.getKey().get());
        args.add(Short.toString(approval.getValue().get()));
    }
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet) {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = getChangeAttribute(change);
    event.submitter = getAccountAttribute(account);
    event.patchSet = getPatchSetAttribute(patchSet);
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeMergedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-number");
    args.add(event.change.number);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--submitter");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet.revision);
    runHook(getRepo(change), args);
}
#method_after
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet) {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = getChangeAttribute(change);
    event.submitter = getAccountAttribute(account);
    event.patchSet = getPatchSetAttribute(patchSet);
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeMergedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-url");
    args.add(event.change.url);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--submitter");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet.revision);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doChangeAbandonedHook(final Change change, final Account account, final String reason) {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = getChangeAttribute(change);
    event.abandoner = getAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeAbandonedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-number");
    args.add(event.change.number);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--abandoner");
    args.add(getDisplayName(account));
    args.add("--reason");
    args.add(reason == null ? "" : reason);
    runHook(getRepo(change), args);
}
#method_after
public void doChangeAbandonedHook(final Change change, final Account account, final String reason) {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = getChangeAttribute(change);
    event.abandoner = getAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeAbandonedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change.id);
    args.add("--change-url");
    args.add(event.change.url);
    args.add("--project");
    args.add(event.change.project);
    args.add("--branch");
    args.add(event.change.branch);
    args.add("--abandoner");
    args.add(getDisplayName(account));
    args.add("--reason");
    args.add(reason == null ? "" : reason);
    runHook(getRepo(change), args);
}
#end_block

#method_before
private void display() throws Failure {
    final PrintWriter stdout = toPrintWriter(out);
    TreeMap<String, TreeNode> treeMap = null;
    if (showTree) {
        treeMap = new TreeMap<String, TreeNode>();
    }
    try {
        for (final Project p : db.projects().all()) {
            if (p.getNameKey().equals(wildProject)) {
                // 
                continue;
            }
            final ProjectState e = projectCache.get(p.getNameKey());
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (!showTree) {
                if (!pctl.isVisible()) {
                    // 
                    continue;
                }
                if (showBranch != null) {
                    final Ref ref = getBranchRef(p.getNameKey());
                    if (ref == null || ref.getObjectId() == null || !pctl.controlForRef(ref.getLeaf().getName()).isVisible()) {
                        // 
                        continue;
                    }
                    stdout.print(ref.getObjectId().name());
                    stdout.print(' ');
                }
                stdout.print(p.getName());
                stdout.println();
            } else {
                TreeNode node = new TreeNode(p, pctl.isVisible());
                treeMap.put(p.getName(), node);
            }
        }
        if (showTree && treeMap.size() > 0) {
            final List<TreeNode> sortedNodes = new ArrayList<TreeNode>();
            // 
            for (final TreeNode key : treeMap.values()) {
                final String parentName = key.getParentName();
                if (parentName != null) {
                    final TreeNode node = (TreeNode) treeMap.get((String) parentName);
                    node.addChild(key);
                } else {
                    sortedNodes.add(key);
                }
            }
            // Builds a fake root node, which contains the sorted projects.
            // 
            final TreeNode fakeRoot = new TreeNode(null, sortedNodes, false);
            printElement(stdout, fakeRoot, -1, false, sortedNodes.get(sortedNodes.size() - 1));
        }
    } catch (OrmException e) {
        throw new Failure(1, "fatal: database error", e);
    } finally {
        stdout.flush();
    }
}
#method_after
private void display() throws Failure {
    if (showTree && (showBranch != null)) {
        throw new UnloggedFailure(1, "fatal: --tree and --show-branch options are not compatible.");
    }
    final PrintWriter stdout = toPrintWriter(out);
    TreeMap<String, TreeNode> treeMap = null;
    if (showTree) {
        treeMap = new TreeMap<String, TreeNode>();
    }
    try {
        for (final Project p : db.projects().all()) {
            if (p.getNameKey().equals(wildProject)) {
                // 
                continue;
            }
            final ProjectState e = projectCache.get(p.getNameKey());
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (!showTree) {
                if (!pctl.isVisible()) {
                    // 
                    continue;
                }
                if (showBranch != null) {
                    final Ref ref = getBranchRef(p.getNameKey());
                    if (ref == null || ref.getObjectId() == null || !pctl.controlForRef(ref.getLeaf().getName()).isVisible()) {
                        // 
                        continue;
                    }
                    stdout.print(ref.getObjectId().name());
                    stdout.print(' ');
                }
                stdout.print(p.getName() + "\n");
            } else {
                treeMap.put(p.getName(), new TreeNode(p, pctl.isVisible()));
            }
        }
        if (showTree && treeMap.size() > 0) {
            final List<TreeNode> sortedNodes = new ArrayList<TreeNode>();
            // 
            for (final TreeNode key : treeMap.values()) {
                final String parentName = key.getParentName();
                if (parentName != null) {
                    final TreeNode node = treeMap.get((String) parentName);
                    if (node != null) {
                        node.addChild(key);
                    } else {
                        sortedNodes.add(key);
                    }
                } else {
                    sortedNodes.add(key);
                }
            }
            // Builds a fake root node, which contains the sorted projects.
            // 
            final TreeNode fakeRoot = new TreeNode(null, sortedNodes, false);
            printElement(stdout, fakeRoot, -1, false, sortedNodes.get(sortedNodes.size() - 1));
            stdout.flush();
        }
    } catch (OrmException e) {
        throw new Failure(1, "fatal: database error", e);
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
private void printElement(final PrintWriter stdout, TreeNode node, int level, boolean isLast, final TreeNode lastParentNode) {
    // 
    if (node.getProject() != null) {
        // 
        if (!currentTabSeparator.equals(" ")) {
            final String nodeProject = node.getProject().getName();
            final String lastParentProject = lastParentNode.getProject().getName();
            if (nodeProject.equals(lastParentProject)) {
                currentTabSeparator = " ";
            }
        }
        if (level > 0) {
            stdout.print(String.format("%-" + 4 * level + "s", currentTabSeparator));
        }
        final String prefix = isLast ? LAST_NODE_PREFIX : NODE_PREFIX;
        String printout;
        if (node.isVisible()) {
            printout = prefix + node.getProject().getName();
        } else {
            printout = prefix + NOT_VISIBLE_PROJECT;
        }
        stdout.println(printout);
        stdout.flush();
    }
    if (node.isLeaf()) {
        return;
    } else {
        final List<TreeNode> children = node.getChildren();
        ++level;
        for (TreeNode treeNode : children) {
            final boolean isLastIndex = children.indexOf(treeNode) == children.size() - 1;
            printElement(stdout, treeNode, level, isLastIndex, lastParentNode);
        }
    }
}
#method_after
private void printElement(final PrintWriter stdout, TreeNode node, int level, boolean isLast, final TreeNode lastParentNode) {
    // 
    if (node.getProject() != null) {
        // 
        if (!currentTabSeparator.equals(" ")) {
            final String nodeProject = node.getProject().getName();
            final String lastParentProject = lastParentNode.getProject().getName();
            if (nodeProject.equals(lastParentProject)) {
                currentTabSeparator = " ";
            }
        }
        if (level > 0) {
            stdout.print(String.format("%-" + 4 * level + "s", currentTabSeparator));
        }
        final String prefix = isLast ? LAST_NODE_PREFIX : NODE_PREFIX;
        String printout;
        if (node.isVisible()) {
            printout = prefix + node.getProject().getName();
        } else {
            printout = prefix + NOT_VISIBLE_PROJECT;
        }
        stdout.print(printout + "\n");
    }
    if (node.isLeaf()) {
        return;
    } else {
        final List<TreeNode> children = node.getChildren();
        ++level;
        for (TreeNode treeNode : children) {
            final boolean isLastIndex = children.indexOf(treeNode) == children.size() - 1;
            printElement(stdout, treeNode, level, isLastIndex, lastParentNode);
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    enableForm(false);
    super.onLoad();
    Util.PROJECT_SVC.listBranches(projectName, new GerritCallback<List<Branch>>() {

        public void onSuccess(final List<Branch> result) {
            Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() {

                public void onSuccess(final ProjectDetail projectDetail) {
                    com.google.gerrit.client.account.Util.ACCOUNT_SEC.myGroups(new GerritCallback<List<AccountGroup>>() {

                        public void onSuccess(List<AccountGroup> myGroups) {
                            boolean userHasOwnRight = Util.hasOwnRight(projectDetail, myGroups);
                            enableForm(true);
                            branches.display(result, userHasOwnRight);
                            addPanel.setVisible(userHasOwnRight);
                            delBranch.setVisible(userHasOwnRight);
                        }
                    });
                }
            });
        }
    });
}
#method_after
@Override
protected void onLoad() {
    enableForm(false);
    super.onLoad();
    Util.PROJECT_SVC.listBranches(projectName, new GerritCallback<ListBranchesResult>() {

        public void onSuccess(final ListBranchesResult result) {
            enableForm(true);
            display(result.getBranches());
            addPanel.setVisible(result.getCanAdd());
        }
    });
}
#end_block

#method_before
private void doAddNewBranch() {
    String branchName = nameTxtBox.getText();
    if ("".equals(branchName) || Util.C.defaultBranchName().equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    String rev = irevTxtBox.getText();
    if ("".equals(rev) || Util.C.defaultRevisionSpec().equals(rev)) {
        irevTxtBox.setText("HEAD");
        DeferredCommand.addCommand(new Command() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    if (!branchName.startsWith(Branch.R_REFS)) {
        branchName = Branch.R_HEADS + branchName;
    }
    addBranch.setEnabled(false);
    Util.PROJECT_SVC.addBranch(projectName, branchName, rev, new GerritCallback<List<Branch>>() {

        public void onSuccess(final List<Branch> result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            branches.display(result, true);
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (caught instanceof InvalidNameException || caught instanceof RemoteJsonException && caught.getMessage().equals(InvalidNameException.MESSAGE)) {
                nameTxtBox.selectAll();
                nameTxtBox.setFocus(true);
            } else if (caught instanceof InvalidRevisionException || caught instanceof RemoteJsonException && caught.getMessage().equals(InvalidRevisionException.MESSAGE)) {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
            addBranch.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddNewBranch() {
    String branchName = nameTxtBox.getText();
    if ("".equals(branchName) || Util.C.defaultBranchName().equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    String rev = irevTxtBox.getText();
    if ("".equals(rev) || Util.C.defaultRevisionSpec().equals(rev)) {
        irevTxtBox.setText("HEAD");
        DeferredCommand.addCommand(new Command() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    if (!branchName.startsWith(Branch.R_REFS)) {
        branchName = Branch.R_HEADS + branchName;
    }
    addBranch.setEnabled(false);
    Util.PROJECT_SVC.addBranch(projectName, branchName, rev, new GerritCallback<ListBranchesResult>() {

        public void onSuccess(final ListBranchesResult result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            display(result.getBranches());
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (caught instanceof InvalidNameException || caught instanceof RemoteJsonException && caught.getMessage().equals(InvalidNameException.MESSAGE)) {
                nameTxtBox.selectAll();
                nameTxtBox.setFocus(true);
            } else if (caught instanceof InvalidRevisionException || caught instanceof RemoteJsonException && caught.getMessage().equals(InvalidRevisionException.MESSAGE)) {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
            addBranch.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
void display(final List<Branch> result, final boolean canEdit) {
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final Branch k : result) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, k, canEdit);
    }
}
#method_after
void display(final List<Branch> result) {
    canDelete = false;
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final Branch k : result) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, k);
    }
}
#end_block

#method_before
void populate(final int row, final Branch k, final boolean canEdit) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (canEdit) {
        table.setWidget(row, 1, new CheckBox());
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor("(gitweb)", false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    if (c != null) {
        fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    }
    setRowItem(row, k);
}
#method_after
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor("(gitweb)", false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    if (c != null) {
        fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    }
    setRowItem(row, k);
}
#end_block

#method_before
@Override
public void deleteRight(final Project.NameKey projectName, final Set<RefRight.Key> toRemove, final AsyncCallback<VoidResult> callback) {
    deleteRefRightsFactory.create(projectName, toRemove).to(callback);
}
#method_after
@Override
public void deleteRight(final Project.NameKey projectName, final Set<RefRight.Key> toRemove, final AsyncCallback<ProjectDetail> callback) {
    deleteRefRightsFactory.create(projectName, toRemove).to(callback);
}
#end_block

#method_before
@Override
public void listBranches(final Project.NameKey projectName, final AsyncCallback<List<Branch>> callback) {
    listBranchesFactory.create(projectName).to(callback);
}
#method_after
@Override
public void listBranches(final Project.NameKey projectName, final AsyncCallback<ListBranchesResult> callback) {
    listBranchesFactory.create(projectName).to(callback);
}
#end_block

#method_before
@Override
public void addBranch(final Project.NameKey projectName, final String branchName, final String startingRevision, final AsyncCallback<List<Branch>> callback) {
    addBranchFactory.create(projectName, branchName, startingRevision).to(callback);
}
#method_after
@Override
public void addBranch(final Project.NameKey projectName, final String branchName, final String startingRevision, final AsyncCallback<ListBranchesResult> callback) {
    addBranchFactory.create(projectName, branchName, startingRevision).to(callback);
}
#end_block

#method_before
@Override
protected void onLoad() {
    enableForm(false);
    saveProject.setEnabled(false);
    super.onLoad();
    refresh();
}
#method_after
@Override
protected void onLoad() {
    enableForm(false, false, false);
    saveProject.setEnabled(false);
    super.onLoad();
    refresh();
}
#end_block

#method_before
private void refresh() {
    Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            com.google.gerrit.client.account.Util.ACCOUNT_SEC.myGroups(new GerritCallback<List<AccountGroup>>() {

                public void onSuccess(List<AccountGroup> myGroups) {
                    boolean userHasOwnRight = Util.hasOwnRight(result, myGroups);
                    enableForm(userHasOwnRight);
                    saveProject.setVisible(userHasOwnRight);
                    saveProject.setEnabled(false);
                    display(result);
                }
            });
        }
    });
}
#method_after
private void refresh() {
    Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType);
            saveProject.setVisible(result.canModifyAgreements || result.canModifyDescription || result.canModifyMergeType);
            saveProject.setEnabled(false);
            display(result);
        }
    });
}
#end_block

#method_before
private void enableForm(final boolean on) {
    submitType.setEnabled(on);
    descTxt.setEnabled(on);
    useContributorAgreements.setEnabled(on);
    useSignedOffBy.setEnabled(on);
    saveProject.setEnabled(on);
}
#method_after
private void enableForm(final boolean canModifyAgreements, final boolean canModifyDescription, final boolean canModifyMergeType) {
    submitType.setEnabled(canModifyMergeType);
    descTxt.setEnabled(canModifyDescription);
    useContributorAgreements.setEnabled(canModifyAgreements);
    useSignedOffBy.setEnabled(canModifyAgreements);
    saveProject.setEnabled(canModifyAgreements || canModifyDescription || canModifyMergeType);
}
#end_block

#method_before
private void doSave() {
    project.setDescription(descTxt.getText().trim());
    project.setUseContributorAgreements(useContributorAgreements.getValue());
    project.setUseSignedOffBy(useSignedOffBy.getValue());
    if (submitType.getSelectedIndex() >= 0) {
        project.setSubmitType(Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())));
    }
    enableForm(false);
    saveProject.setEnabled(false);
    Util.PROJECT_SVC.changeProjectSettings(project, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(true);
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            refresh();
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    project.setDescription(descTxt.getText().trim());
    project.setUseContributorAgreements(useContributorAgreements.getValue());
    project.setUseSignedOffBy(useSignedOffBy.getValue());
    if (submitType.getSelectedIndex() >= 0) {
        project.setSubmitType(Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())));
    }
    enableForm(false, false, false);
    saveProject.setEnabled(false);
    Util.PROJECT_SVC.changeProjectSettings(project, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType);
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            refresh();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
protected void onLoad() {
    enableForm(false);
    super.onLoad();
    Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            com.google.gerrit.client.account.Util.ACCOUNT_SEC.myGroups(new GerritCallback<List<AccountGroup>>() {

                public void onSuccess(List<AccountGroup> myGroups) {
                    boolean hasOwnRights = Util.hasOwnRight(result, myGroups);
                    enableForm(true);
                    display(result, !hasOwnRights);
                    addPanel.setVisible(hasOwnRights);
                    delRight.setVisible(hasOwnRights);
                }
            });
        }
    });
}
#method_after
@Override
protected void onLoad() {
    enableForm(false);
    super.onLoad();
    Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            enableForm(true);
            display(result);
        }
    });
}
#end_block

#method_before
private void initRights(final Panel body) {
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(5, 2);
    catBox = new ListBox();
    rangeMinBox = new ListBox();
    rangeMaxBox = new ListBox();
    catBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            updateCategorySelection();
        }
    });
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        final ApprovalCategory c = at.getCategory();
        catBox.addItem(c.getName(), c.getId().get());
    }
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getActionTypes()) {
        final ApprovalCategory c = at.getCategory();
        if (Gerrit.getConfig().getWildProject().equals(projectName) && ApprovalCategory.OWN.equals(c.getId())) {
            // 
            continue;
        }
        catBox.addItem(c.getName(), c.getId().get());
    }
    addGrid.setText(0, 0, Util.C.columnApprovalCategory() + ":");
    addGrid.setWidget(0, 1, catBox);
    nameTxtBox = new NpTextBox();
    nameTxt = new SuggestBox(new AccountGroupSuggestOracle(), nameTxtBox);
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setText(Util.C.defaultAccountGroupName());
    nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
    nameTxtBox.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            if (Util.C.defaultAccountGroupName().equals(nameTxtBox.getText())) {
                nameTxtBox.setText("");
                nameTxtBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addBlurHandler(new BlurHandler() {

        @Override
        public void onBlur(BlurEvent event) {
            if ("".equals(nameTxtBox.getText())) {
                nameTxtBox.setText(Util.C.defaultAccountGroupName());
                nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.columnGroupName() + ":");
    addGrid.setWidget(1, 1, nameTxt);
    referenceTxt = new NpTextBox();
    referenceTxt.setVisibleLength(50);
    referenceTxt.setText("");
    referenceTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(2, 0, Util.C.columnRefName() + ":");
    addGrid.setWidget(2, 1, referenceTxt);
    addGrid.setText(3, 0, Util.C.columnRightRange() + ":");
    addGrid.setWidget(3, 1, rangeMinBox);
    addGrid.setText(4, 0, "");
    addGrid.setWidget(4, 1, rangeMaxBox);
    addRight = new Button(Util.C.buttonAddProjectRight());
    addRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewRight();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addRight);
    rights = new RightsTable();
    delRight = new Button(Util.C.buttonDeleteGroupMembers());
    delRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            rights.deleteChecked();
        }
    });
    body.add(new SmallHeading(Util.C.headingAccessRights()));
    body.add(rights);
    body.add(delRight);
    body.add(addPanel);
    if (catBox.getItemCount() > 0) {
        catBox.setSelectedIndex(0);
        updateCategorySelection();
    }
}
#method_after
private void initRights(final Panel body) {
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(5, 2);
    catBox = new ListBox();
    rangeMinBox = new ListBox();
    rangeMaxBox = new ListBox();
    catBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            updateCategorySelection();
        }
    });
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        final ApprovalCategory c = at.getCategory();
        catBox.addItem(c.getName(), c.getId().get());
    }
    for (final ApprovalType at : Gerrit.getConfig().getApprovalTypes().getActionTypes()) {
        final ApprovalCategory c = at.getCategory();
        if (Gerrit.getConfig().getWildProject().equals(projectName) && ApprovalCategory.OWN.equals(c.getId())) {
            // 
            continue;
        }
        catBox.addItem(c.getName(), c.getId().get());
    }
    addGrid.setText(0, 0, Util.C.columnApprovalCategory() + ":");
    addGrid.setWidget(0, 1, catBox);
    nameTxtBox = new NpTextBox();
    nameTxt = new SuggestBox(new AccountGroupSuggestOracle(), nameTxtBox);
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setText(Util.C.defaultAccountGroupName());
    nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
    nameTxtBox.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            if (Util.C.defaultAccountGroupName().equals(nameTxtBox.getText())) {
                nameTxtBox.setText("");
                nameTxtBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    nameTxtBox.addBlurHandler(new BlurHandler() {

        @Override
        public void onBlur(BlurEvent event) {
            if ("".equals(nameTxtBox.getText())) {
                nameTxtBox.setText(Util.C.defaultAccountGroupName());
                nameTxtBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
            }
        }
    });
    addGrid.setText(1, 0, Util.C.columnGroupName() + ":");
    addGrid.setWidget(1, 1, nameTxt);
    referenceTxt = new NpTextBox();
    referenceTxt.setVisibleLength(50);
    referenceTxt.setText("");
    referenceTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doAddNewRight();
            }
        }
    });
    addGrid.setText(2, 0, Util.C.columnRefName() + ":");
    addGrid.setWidget(2, 1, referenceTxt);
    addGrid.setText(3, 0, Util.C.columnRightRange() + ":");
    addGrid.setWidget(3, 1, rangeMinBox);
    addGrid.setText(4, 0, "");
    addGrid.setWidget(4, 1, rangeMaxBox);
    addRight = new Button(Util.C.buttonAddProjectRight());
    addRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewRight();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addRight);
    rights = new RightsTable();
    delRight = new Button(Util.C.buttonDeleteGroupMembers());
    delRight.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            final HashSet<RefRight.Key> refRightIds = rights.getRefRightIdsChecked();
            doDeleteRefRights(refRightIds);
        }
    });
    body.add(new SmallHeading(Util.C.headingAccessRights()));
    body.add(rights);
    body.add(delRight);
    body.add(addPanel);
    if (catBox.getItemCount() > 0) {
        catBox.setSelectedIndex(0);
        updateCategorySelection();
    }
}
#end_block

#method_before
void display(final ProjectDetail result, final boolean readOnly) {
    rights.display(result.groups, result.rights, readOnly);
}
#method_after
void display(final ProjectDetail result) {
    final Project project = result.project;
    final Project.NameKey wildKey = Gerrit.getConfig().getWildProject();
    final boolean isWild = wildKey.equals(project.getNameKey());
    Project.NameKey parent = project.getParent();
    if (parent == null) {
        parent = wildKey;
    }
    parentPanel.setVisible(!isWild);
    parentName.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectAdminScreen.ACCESS_TAB));
    parentName.setText(parent.get());
    rights.display(result.groups, result.rights);
    addPanel.setVisible(result.canModifyAccess);
    delRight.setVisible(rights.getCanDelete());
}
#end_block

#method_before
private void doAddNewRight() {
    int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    ApprovalCategoryValue min, max;
    if (idx < 0) {
        return;
    }
    at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    if (at == null) {
        return;
    }
    idx = rangeMinBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    min = at.getValue(Short.parseShort(rangeMinBox.getValue(idx)));
    if (min == null) {
        return;
    }
    idx = rangeMaxBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    max = at.getValue(Short.parseShort(rangeMaxBox.getValue(idx)));
    if (max == null) {
        return;
    }
    final String groupName = nameTxt.getText();
    if ("".equals(groupName) || Util.C.defaultAccountGroupName().equals(groupName)) {
        return;
    }
    final String refPattern = referenceTxt.getText();
    if (min.getValue() > max.getValue()) {
        // If the user selects it backwards in the web UI, help them out
        // by reversing the order to what we would expect.
        // 
        final ApprovalCategoryValue newMin = max;
        final ApprovalCategoryValue newMax = min;
        min = newMin;
        max = newMax;
    }
    addRight.setEnabled(false);
    Util.PROJECT_SVC.addRight(projectName, at.getCategory().getId(), groupName, refPattern, min.getValue(), max.getValue(), new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            addRight.setEnabled(true);
            nameTxt.setText("");
            referenceTxt.setText("");
            display(result, false);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addRight.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddNewRight() {
    int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    ApprovalCategoryValue min, max;
    if (idx < 0) {
        return;
    }
    at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    if (at == null) {
        return;
    }
    idx = rangeMinBox.getSelectedIndex();
    if (idx < 0) {
        return;
    }
    min = at.getValue(Short.parseShort(rangeMinBox.getValue(idx)));
    if (min == null) {
        return;
    }
    if (at.getCategory().isRange()) {
        idx = rangeMaxBox.getSelectedIndex();
        if (idx < 0) {
            return;
        }
        max = at.getValue(Short.parseShort(rangeMaxBox.getValue(idx)));
        if (max == null) {
            return;
        }
    } else {
        // If its not a range, the maximum box was disabled.  Use the min
        // value as the max, and select the min from the category values.
        // 
        max = min;
        min = at.getMin();
        for (ApprovalCategoryValue v : at.getValues()) {
            if (0 <= v.getValue() && v.getValue() <= max.getValue()) {
                min = v;
                break;
            }
        }
    }
    final String groupName = nameTxt.getText();
    if ("".equals(groupName) || Util.C.defaultAccountGroupName().equals(groupName)) {
        return;
    }
    final String refPattern = referenceTxt.getText();
    if (min.getValue() > max.getValue()) {
        // If the user selects it backwards in the web UI, help them out
        // by reversing the order to what we would expect.
        // 
        final ApprovalCategoryValue newMin = max;
        final ApprovalCategoryValue newMax = min;
        min = newMin;
        max = newMax;
    }
    addRight.setEnabled(false);
    Util.PROJECT_SVC.addRight(projectName, at.getCategory().getId(), groupName, refPattern, min.getValue(), max.getValue(), new GerritCallback<ProjectDetail>() {

        public void onSuccess(final ProjectDetail result) {
            addRight.setEnabled(true);
            nameTxt.setText("");
            referenceTxt.setText("");
            display(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addRight.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    // TODO Support per-branch READ access.
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        referenceTxt.setText("");
        referenceTxt.setEnabled(false);
    } else {
        referenceTxt.setEnabled(true);
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    addRight.setEnabled(true);
}
#method_after
private void updateCategorySelection() {
    final int idx = catBox.getSelectedIndex();
    final ApprovalType at;
    if (idx >= 0) {
        at = Gerrit.getConfig().getApprovalTypes().getApprovalType(new ApprovalCategory.Id(catBox.getValue(idx)));
    } else {
        at = null;
    }
    if (at == null || at.getValues().isEmpty()) {
        rangeMinBox.setEnabled(false);
        rangeMaxBox.setEnabled(false);
        referenceTxt.setEnabled(false);
        addRight.setEnabled(false);
        return;
    }
    int curIndex = 0, minIndex = -1, maxIndex = -1;
    rangeMinBox.clear();
    rangeMaxBox.clear();
    for (final ApprovalCategoryValue v : at.getValues()) {
        final String vStr = String.valueOf(v.getValue());
        String nStr = vStr + ": " + v.getName();
        if (v.getValue() > 0) {
            nStr = "+" + nStr;
        }
        rangeMinBox.addItem(nStr, vStr);
        rangeMaxBox.addItem(nStr, vStr);
        if (v.getValue() < 0) {
            minIndex = curIndex;
        }
        if (maxIndex < 0 && v.getValue() > 0) {
            maxIndex = curIndex;
        }
        curIndex++;
    }
    if (ApprovalCategory.READ.equals(at.getCategory().getId())) {
        // Special case; for READ the most logical range is just
        // +1 READ, so assume that as the default for both.
        minIndex = maxIndex;
    }
    rangeMinBox.setSelectedIndex(minIndex >= 0 ? minIndex : 0);
    rangeMaxBox.setSelectedIndex(maxIndex >= 0 ? maxIndex : curIndex - 1);
    rangeMaxBox.setVisible(at.getCategory().isRange());
    addRight.setEnabled(true);
}
#end_block

#method_before
void display(final Map<AccountGroup.Id, AccountGroup> groups, final List<RefRight> refRights, final boolean readOnly) {
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final RefRight r : refRights) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, groups, r, readOnly);
    }
}
#method_after
void display(final Map<AccountGroup.Id, AccountGroup> groups, final List<InheritedRefRight> refRights) {
    canDelete = false;
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (final InheritedRefRight r : refRights) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, groups, r);
    }
}
#end_block

#method_before
void populate(final int row, final Map<AccountGroup.Id, AccountGroup> groups, final RefRight r, final boolean readOnly) {
    final GerritConfig config = Gerrit.getConfig();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(r.getApprovalCategoryId());
    final AccountGroup group = groups.get(r.getAccountGroupId());
    if (readOnly || (!projectName.equals(Gerrit.getConfig().getWildProject()) && Gerrit.getConfig().getWildProject().equals(r.getProjectNameKey()))) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
    }
    if (ar != null) {
        table.setText(row, 2, ar.getCategory().getName());
    } else {
        table.setText(row, 2, r.getApprovalCategoryId().get());
    }
    if (group != null) {
        table.setText(row, 3, group.getName());
    } else {
        table.setText(row, 3, Util.M.deletedGroup(r.getAccountGroupId().get()));
    }
    table.setText(row, 4, r.getRefPattern());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(r.getMinValue()) : null;
        max = ar != null ? ar.getValue(r.getMaxValue()) : null;
        formatValue(m, r.getMinValue(), min);
        if (r.getMinValue() != r.getMaxValue()) {
            m.br();
            formatValue(m, r.getMaxValue(), max);
        }
        SafeHtml.set(table, row, 5, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, r);
}
#method_after
void populate(final int row, final Map<AccountGroup.Id, AccountGroup> groups, final InheritedRefRight r) {
    final GerritConfig config = Gerrit.getConfig();
    final RefRight right = r.getRight();
    final ApprovalType ar = config.getApprovalTypes().getApprovalType(right.getApprovalCategoryId());
    final AccountGroup group = groups.get(right.getAccountGroupId());
    if (r.isInherited() || !r.isOwner()) {
        table.setText(row, 1, "");
    } else {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    }
    if (ar != null) {
        table.setText(row, 2, ar.getCategory().getName());
    } else {
        table.setText(row, 2, right.getApprovalCategoryId().get());
    }
    if (group != null) {
        table.setText(row, 3, group.getName());
    } else {
        table.setText(row, 3, Util.M.deletedGroup(right.getAccountGroupId().get()));
    }
    table.setText(row, 4, right.getRefPattern());
    {
        final SafeHtmlBuilder m = new SafeHtmlBuilder();
        final ApprovalCategoryValue min, max;
        min = ar != null ? ar.getValue(right.getMinValue()) : null;
        max = ar != null ? ar.getValue(right.getMaxValue()) : null;
        if (ar != null && ar.getCategory().isRange()) {
            formatValue(m, right.getMinValue(), min);
            m.br();
        }
        formatValue(m, right.getMaxValue(), max);
        SafeHtml.set(table, row, 5, m);
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 5, Gerrit.RESOURCES.css().projectAdminApprovalCategoryRangeLine());
    setRowItem(row, right);
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = "refs/heads/*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = "refs/heads/*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = "refs/tags/*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = "refs/*";
        } else {
            // Assume project wide for the default.
            refPattern = "refs/*";
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evict(projectControl.getProject());
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evict(projectControl.getProject());
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException {
    final UploadPack up = new UploadPack(repo);
    up.setRefFilter(this);
    up.upload(in, out, err);
}
#method_after
@Override
protected void runImpl() throws IOException {
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, projectControl, db));
    }
    up.upload(in, out, err);
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        checkVisibility(cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#end_block

#method_before
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    final LdapSchema schema = getSchema(ctx);
    final Set<String> groupDNs = new HashSet<String>();
    if (!schema.groupMemberQueryList.isEmpty()) {
        final HashMap<String, String> params = new HashMap<String, String>();
        if (schema.groupNeedsAccount) {
            if (account == null) {
                account = findAccount(schema, ctx, username);
            }
            for (String name : schema.groupMemberQueryList.get(0).getParameters()) {
                params.put(name, account.get(name));
            }
        }
        params.put(USERNAME, username);
    }
    if (schema.accountMemberField != null) {
        if (account == null) {
            account = findAccount(schema, ctx, username);
        }
        final Attribute groupAtt = account.getAll(schema.accountMemberField);
        if (groupAtt != null) {
            final NamingEnumeration<?> groups = groupAtt.getAll();
            while (groups.hasMore()) {
                final String nextDN = (String) groups.next();
                recursivelyExpandGroups(groupDNs, schema, ctx, nextDN);
            }
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (String dn : groupDNs) {
        for (AccountGroup group : groupCache.get(new AccountGroup.ExternalNameKey(dn))) {
            if (group.getType() == AccountGroup.Type.LDAP) {
                actual.add(group.getId());
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#method_after
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    final LdapSchema schema = getSchema(ctx);
    final Set<String> groupDNs = new HashSet<String>();
    if (!schema.groupMemberQueryList.isEmpty()) {
        final HashMap<String, String> params = new HashMap<String, String>();
        if (schema.groupNeedsAccount) {
            if (account == null) {
                account = findAccount(schema, ctx, username);
            }
            for (String name : schema.groupMemberQueryList.get(0).getParameters()) {
                params.put(name, account.get(name));
            }
        }
        params.put(USERNAME, username);
        for (LdapQuery groupMemberQuery : schema.groupMemberQueryList) {
            for (LdapQuery.Result r : groupMemberQuery.query(ctx, params)) {
                recursivelyExpandGroups(groupDNs, schema, ctx, r.getDN());
            }
        }
    }
    if (schema.accountMemberField != null) {
        if (account == null) {
            account = findAccount(schema, ctx, username);
        }
        final Attribute groupAtt = account.getAll(schema.accountMemberField);
        if (groupAtt != null) {
            final NamingEnumeration<?> groups = groupAtt.getAll();
            while (groups.hasMore()) {
                final String nextDN = (String) groups.next();
                recursivelyExpandGroups(groupDNs, schema, ctx, nextDN);
            }
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (String dn : groupDNs) {
        for (AccountGroup group : groupCache.get(new AccountGroup.ExternalNameKey(dn))) {
            if (group.getType() == AccountGroup.Type.LDAP) {
                actual.add(group.getId());
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#end_block

#method_before
@Override
public void authenticate(String username, final String password, final AsyncCallback<LoginResult> callback) {
    LoginResult result = new LoginResult();
    if (// 
    username == null || "".equals(username) || password == null || "".equals(password)) {
        result.success = false;
        callback.onSuccess(result);
        return;
    }
    username = username.trim().toLowerCase();
    final AuthRequest req = AuthRequest.forUser(username);
    req.setPassword(password);
    final AuthResult res;
    try {
        res = accountManager.authenticate(req);
    } catch (AccountException e) {
        result.success = false;
        callback.onSuccess(result);
        return;
    }
    result.success = true;
    result.isNew = res.isNew();
    webSession.get().login(res, false);
    callback.onSuccess(result);
}
#method_after
@Override
public void authenticate(String username, final String password, final AsyncCallback<LoginResult> callback) {
    LoginResult result = new LoginResult();
    if (// 
    username == null || "".equals(username.trim()) || password == null || "".equals(password)) {
        result.success = false;
        callback.onSuccess(result);
        return;
    }
    username = username.trim();
    final AuthRequest req = AuthRequest.forUser(username);
    req.setPassword(password);
    final AuthResult res;
    try {
        res = accountManager.authenticate(req);
    } catch (AccountException e) {
        result.success = false;
        callback.onSuccess(result);
        return;
    }
    result.success = true;
    result.isNew = res.isNew();
    webSession.get().login(res, false);
    callback.onSuccess(result);
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, "flush-caches").to(AdminFlushCaches.class);
    command(gerrit, "ls-projects").to(ListProjects.class);
    command(gerrit, "show-caches").to(AdminShowCaches.class);
    command(gerrit, "show-connections").to(AdminShowConnections.class);
    command(gerrit, "show-queue").to(AdminShowQueue.class);
    command(gerrit, "stream-changes").to(StreamChangeEvents.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(AdminShowCaches.class);
    command("kill").to(AdminKill.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, "flush-caches").to(AdminFlushCaches.class);
    command(gerrit, "ls-projects").to(ListProjects.class);
    command(gerrit, "show-caches").to(AdminShowCaches.class);
    command(gerrit, "show-connections").to(AdminShowConnections.class);
    command(gerrit, "show-queue").to(AdminShowQueue.class);
    command(gerrit, "stream-events").to(StreamEvents.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(AdminShowCaches.class);
    command("kill").to(AdminKill.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
}
#end_block

#method_before
public void addChangeListener(ChangeListener listener) {
    listeners.add(listener);
}
#method_after
public void addChangeListener(ChangeListener listener, IdentifiedUser user) {
    listeners.put(listener, new ChangeListenerHolder(listener, user));
}
#end_block

#method_before
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet) {
    for (ChangeListener listener : listeners) {
        listener.onPatchsetCreated(change, patchSet);
    }
    final List<String> args = new ArrayList<String>();
    args.add(patchsetCreatedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--commit");
    args.add(patchSet.getRevision().get());
    args.add("--patchset");
    args.add(Integer.toString(patchSet.getPatchSetId()));
    runHook(getRepo(change), args);
}
#method_after
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet) {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.commit = patchSet.getRevision().get();
    event.patchSet = Integer.toString(patchSet.getPatchSetId());
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(patchsetCreatedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--commit");
    args.add(event.commit);
    args.add("--patchset");
    args.add(event.patchSet);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals) {
    for (ChangeListener listener : listeners) {
        listener.onCommentAdded(change, patchSet, account, approvals, comment);
    }
    final List<String> args = new ArrayList<String>();
    args.add(commentAddedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--author");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(patchSet.getRevision().get());
    args.add("--comment");
    args.add(comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        args.add("--" + approval.getKey().get());
        args.add(Short.toString(approval.getValue().get()));
    }
    runHook(getRepo(change), args);
}
#method_after
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals) {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.author = getAuthorAttribute(account);
    event.revision = patchSet.getRevision().get();
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            ApprovalAttribute a = new ApprovalAttribute();
            a.type = approval.getKey().get();
            a.value = Short.toString(approval.getValue().get());
            event.approvals[i++] = a;
        }
    }
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(commentAddedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--author");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.revision);
    args.add("--comment");
    args.add(comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        args.add("--" + approval.getKey().get());
        args.add(Short.toString(approval.getValue().get()));
    }
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet) {
    for (ChangeListener listener : listeners) {
        listener.onChangeMerged(change, account, patchSet);
    }
    final List<String> args = new ArrayList<String>();
    args.add(changeMergedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--submitter");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(patchSet.getRevision().get());
    runHook(getRepo(change), args);
}
#method_after
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet) {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.submitter = getAuthorAttribute(account);
    event.patchSet = patchSet.getRevision().get();
    event.description = change.getSubject();
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeMergedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--submitter");
    args.add(getDisplayName(account));
    args.add("--commit");
    args.add(event.patchSet);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public void doChangeAbandonedHook(final Change change, final Account account, final String reason) {
    for (ChangeListener listener : listeners) {
        listener.onChangeAbandoned(change, account, reason);
    }
    final List<String> args = new ArrayList<String>();
    args.add(changeAbandonedHook.getAbsolutePath());
    args.add("--change");
    args.add(change.getKey().get());
    args.add("--project");
    args.add(change.getProject().get());
    args.add("--branch");
    args.add(change.getDest().getShortName());
    args.add("--abandoner");
    args.add(getDisplayName(account));
    args.add("--reason");
    args.add(reason == null ? "" : reason);
    runHook(getRepo(change), args);
}
#method_after
public void doChangeAbandonedHook(final Change change, final Account account, final String reason) {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.project = change.getProject().get();
    event.branch = change.getDest().getShortName();
    event.change = change.getKey().get();
    event.author = getAuthorAttribute(account);
    event.reason = reason;
    fireEvent(change, event);
    final List<String> args = new ArrayList<String>();
    args.add(changeAbandonedHook.getAbsolutePath());
    args.add("--change");
    args.add(event.change);
    args.add("--project");
    args.add(event.project);
    args.add("--branch");
    args.add(event.branch);
    args.add("--abandoner");
    args.add(getDisplayName(account));
    args.add("--reason");
    args.add(reason == null ? "" : reason);
    runHook(getRepo(change), args);
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    // Get the LDAP authentication username and password
    // from the user's input.
    // 
    final String authUsername = who.getLocalUser();
    final String authPassword = who.getPassword();
    // 
    if (this.username == null) {
        this.username = authUsername;
        this.password = authPassword;
    }
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, authUsername);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                authenticate(m.getDN(), authPassword);
            }
            who.setDisplayName(apply(accountFullName, m));
            who.setUserName(apply(accountSshUserName, m));
            if (accountEmailAddress != null) {
                who.setEmailAddress(apply(accountEmailAddress, m));
            } else if (emailExpander.canExpand(authUsername)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(authUsername));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(authUsername, queryForGroups(ctx, authUsername, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#method_after
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = authenticate(username, who.getPassword());
        } else {
            ctx = open();
        }
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(accountFullName, m));
            who.setUserName(apply(accountSshUserName, m));
            if (accountEmailAddress != null) {
                who.setEmailAddress(apply(accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
private void authenticate(String dn, String password) throws AccountException {
    final Properties env = createContextProperties();
    env.put(Context.SECURITY_AUTHENTICATION, "simple");
    env.put(Context.SECURITY_PRINCIPAL, dn);
    env.put(Context.SECURITY_CREDENTIALS, password != null ? password : "");
    try {
        new InitialDirContext(env).close();
    } catch (NamingException e) {
        throw new AccountException("Incorrect username or password", e);
    }
}
#method_after
private DirContext authenticate(String dn, String password) throws AccountException {
    final Properties env = createContextProperties();
    env.put(Context.SECURITY_AUTHENTICATION, "simple");
    env.put(Context.SECURITY_PRINCIPAL, dn);
    env.put(Context.SECURITY_CREDENTIALS, password != null ? password : "");
    try {
        return new InitialDirContext(env);
    } catch (NamingException e) {
        throw new AccountException("Incorrect username or password", e);
    }
}
#end_block

#method_before
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#method_after
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false, false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final PatchSet.Id merged = c.currentPatchSetId();
    PatchSetApproval submitter = null;
    for (int attempts = 0; attempts < 10; attempts++) {
        c.setStatus(Change.Status.MERGED);
        ChangeUtil.updated(c);
        try {
            final Transaction txn = schema.beginTransaction();
            // Flatten out all existing approvals based upon the current
            // permissions. Once the change is closed the approvals are
            // not updated at presentation view time, so we need to make.
            // sure they are accurate now. This way if permissions get
            // modified in the future, historical records stay accurate.
            // 
            final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(c.getId()).toList();
            final FunctionState fs = functionState.create(c, merged, approvals);
            for (ApprovalType at : approvalTypes.getApprovalTypes()) {
                CategoryFunction.forCategory(at.getCategory()).run(at, fs);
            }
            for (PatchSetApproval a : approvals) {
                if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                    if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                        submitter = a;
                    }
                }
                a.cache(c);
            }
            schema.patchSetApprovals().update(approvals, txn);
            if (msg != null) {
                if (submitter != null && msg.getAuthor() == null) {
                    msg.setAuthor(submitter.getAccountId());
                }
                schema.changeMessages().insert(Collections.singleton(msg), txn);
            }
            schema.changes().update(Collections.singleton(c), txn);
            txn.commit();
            break;
        } catch (OrmException e) {
            final Change.Id id = c.getId();
            try {
                c = schema.changes().get(id);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
            } catch (OrmException e2) {
                log.error("Cannot set change " + id + " to merged " + merged, e2);
            }
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        ChangeHookRunner.get().doChangeMergedHook(c, schema.accounts().get(submitter.getAccountId()), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(c, merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, boolean makeNew) {
    for (int attempts = 0; attempts < 10; attempts++) {
        if (makeNew) {
            c.setStatus(Change.Status.NEW);
        }
        ChangeUtil.updated(c);
        try {
            final Transaction txn = schema.beginTransaction();
            schema.changes().update(Collections.singleton(c), txn);
            if (msg != null) {
                schema.changeMessages().insert(Collections.singleton(msg), txn);
            }
            txn.commit();
            break;
        } catch (OrmException e) {
            try {
                c = schema.changes().get(c.getId());
                if (c.getStatus().isClosed()) {
                    // 
                    break;
                }
            } catch (OrmException e2) {
            }
        }
    }
    try {
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Transaction txn = db.beginTransaction();
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    final PatchSet ps = new PatchSet(change.newPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    final PatchSetImporter imp = importFactory.create(db, c, ps, true);
    imp.setTransaction(txn);
    imp.run();
    change.setCurrentPatchSet(imp.getPatchSetInfo());
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change), txn);
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = imp.getPatchSetInfo().getAuthor() != null ? imp.getPatchSetInfo().getAuthor().getAccount() : null;
        final Account.Id committerId = imp.getPatchSetInfo().getCommitter() != null ? imp.getPatchSetInfo().getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db, txn);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db, txn);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db, txn);
            }
        }
    }
    txn.commit();
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, imp.getPatchSetInfo());
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeHookRunner.get().doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    if (!validCommitter(request.cmd, c)) {
        return null;
    }
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result;
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    result = db.run(new OrmRunnable<ReplaceResult, ReviewDb>() {

        public ReplaceResult run(final ReviewDb db, final Transaction txn, final boolean isRetry) throws OrmException {
            final Change change = db.changes().get(request.ontoChange);
            if (change == null) {
                reject(request.cmd, "change " + request.ontoChange + " not found");
                return null;
            }
            if (change.getStatus().isClosed()) {
                reject(request.cmd, "change " + request.ontoChange + " closed");
                return null;
            }
            final PatchSet.Id priorPatchSet = change.currentPatchSetId();
            for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
                if (ps.getRevision() == null) {
                    reject(request.cmd, "change state corrupt");
                    return null;
                }
                final String revIdStr = ps.getRevision().get();
                final ObjectId commitId;
                try {
                    commitId = ObjectId.fromString(revIdStr);
                } catch (IllegalArgumentException e) {
                    log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
                    reject(request.cmd, "change state corrupt");
                    return null;
                }
                try {
                    final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
                    // 
                    if (rp.getRevWalk().isMergedInto(prior, c)) {
                        reject(request.cmd, "squash commits first");
                        return null;
                    }
                    // 
                    if (c == prior) {
                        reject(request.cmd, "commit already exists");
                        return null;
                    }
                    // 
                    if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                        rp.getRevWalk().parseBody(prior);
                        final boolean messageEq = c.getFullMessage().equals(prior.getFullMessage());
                        final boolean parentsEq = parentsEqual(c, prior);
                        if (messageEq && parentsEq) {
                            reject(request.cmd, "no changes made");
                            return null;
                        } else {
                            err.write(Constants.encode(// 
                            "warning: " + change.getKey().abbreviate() + // 
                            ": " + // 
                            " no files changed, but" + // 
                            (!messageEq ? " message updated" : "") + // 
                            (!messageEq && !parentsEq ? " and" : "") + // 
                            (!parentsEq ? " was rebased" : "") + // 
                            "\n"));
                        }
                    }
                } catch (IOException e) {
                    log.error("Change " + change.getId() + " missing " + revIdStr, e);
                    reject(request.cmd, "change state corrupt");
                    return null;
                }
            }
            final PatchSet ps = new PatchSet(change.newPatchSetId());
            ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
            ps.setUploader(currentUser.getAccountId());
            final PatchSetImporter imp = importFactory.create(db, c, ps, true);
            imp.setTransaction(txn);
            imp.run();
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            final ReplaceResult result = new ReplaceResult();
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
            result.change = change;
            result.patchSet = ps;
            result.info = imp.getPatchSetInfo();
            final Account.Id authorId = imp.getPatchSetInfo().getAuthor() != null ? imp.getPatchSetInfo().getAuthor().getAccount() : null;
            final Account.Id committerId = imp.getPatchSetInfo().getCommitter() != null ? imp.getPatchSetInfo().getCommitter().getAccount() : null;
            boolean haveAuthor = false;
            boolean haveCommitter = false;
            final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
            oldReviewers.clear();
            oldCC.clear();
            for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
                haveApprovals.add(a.getAccountId());
                if (a.getValue() != 0) {
                    oldReviewers.add(a.getAccountId());
                } else {
                    oldCC.add(a.getAccountId());
                }
                final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)), txn);
                }
                if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                    haveAuthor = true;
                }
                if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                    haveCommitter = true;
                }
            }
            final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
            msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
            db.changeMessages().insert(Collections.singleton(msg), txn);
            result.msg = msg;
            if (result.mergedIntoRef != null) {
                // Change was already submitted to a branch, close it.
                // 
                markChangeMergedByPush(db, txn, result);
            } else {
                // Change should be new, so it can go through review again.
                // 
                change.setStatus(Change.Status.NEW);
                change.setCurrentPatchSet(imp.getPatchSetInfo());
                ChangeUtil.updated(change);
                db.changes().update(Collections.singleton(change), txn);
            }
            final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
            if (allTypes.size() > 0) {
                final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
                if (authorId != null && haveApprovals.add(authorId)) {
                    insertDummyApproval(result, authorId, catId, db, txn);
                }
                if (committerId != null && haveApprovals.add(committerId)) {
                    insertDummyApproval(result, committerId, catId, db, txn);
                }
                for (final Account.Id reviewer : reviewers) {
                    if (haveApprovals.add(reviewer)) {
                        insertDummyApproval(result, reviewer, catId, db, txn);
                    }
                }
            }
            return result;
        }
    });
    if (result != null) {
        final PatchSet ps = result.patchSet;
        final RefUpdate ru = repo.updateRef(ps.getRefName());
        ru.setNewObjectId(c);
        ru.disableRefLog();
        if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(project.getNameKey(), ru.getName());
        request.cmd.setResult(ReceiveCommand.Result.OK);
        try {
            final ReplacePatchSetSender cm;
            cm = replacePatchSetFactory.create(result.change);
            cm.setFrom(me);
            cm.setPatchSet(ps, result.info);
            cm.setChangeMessage(result.msg);
            cm.setReviewDb(db);
            cm.addReviewers(reviewers);
            cm.addExtraCC(cc);
            cm.addReviewers(oldReviewers);
            cm.addExtraCC(oldCC);
            cm.send();
        } catch (EmailException e) {
            log.error("Cannot send email for new patch set " + ps.getId(), e);
        }
        ChangeHookRunner.get().doPatchsetCreatedHook(result.change, ps);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    if (!validCommitter(request.cmd, c)) {
        return null;
    }
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = c.getFullMessage().equals(prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                if (messageEq && parentsEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    err.write(Constants.encode(// 
                    "warning: " + change.getKey().abbreviate() + // 
                    ": " + // 
                    " no files changed, but" + // 
                    (!messageEq ? " message updated" : "") + // 
                    (!messageEq && !parentsEq ? " and" : "") + // 
                    (!parentsEq ? " was rebased" : "") + // 
                    "\n"));
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void insertDummyApproval(final Change change, final PatchSet.Id psId, final Account.Id forAccount, final ApprovalCategory.Id catId, final ReviewDb db, final Transaction txn) throws OrmException {
    final PatchSetApproval ca = new PatchSetApproval(new PatchSetApproval.Key(psId, forAccount, catId), (short) 0);
    ca.cache(change);
    db.patchSetApprovals().insert(Collections.singleton(ca), txn);
}
#method_after
private void insertDummyApproval(final ReplaceResult result, final Account.Id forAccount, final ApprovalCategory.Id catId, final ReviewDb db) throws OrmException {
    insertDummyApproval(result.change, result.patchSet.getId(), forAccount, catId, db);
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final ReplaceResult result = db.run(new OrmRunnable<ReplaceResult, ReviewDb>() {

        @Override
        public ReplaceResult run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
            final Change change = db.changes().get(cid);
            final PatchSet ps = db.patchSets().get(psi);
            if (change == null || ps == null) {
                log.warn(project.getName() + " " + psi + " is missing");
                return null;
            }
            if (change.getStatus() == Change.Status.MERGED) {
                // 
                return null;
            }
            final ReplaceResult result = new ReplaceResult();
            result.change = change;
            result.patchSet = ps;
            result.info = patchSetInfoFactory.get(commit, psi);
            result.mergedIntoRef = refName;
            markChangeMergedByPush(db, txn, result);
            return result;
        }
    });
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final Transaction txn, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.patchSetApprovals().update(approvals, txn);
    db.changeMessages().insert(Collections.singleton(msg), txn);
    db.changes().update(Collections.singleton(change), txn);
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setReviewDb(db);
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        ChangeHookRunner.get().doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setReviewDb(db);
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, PatchSetInfoNotAvailableException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    final Change change = changeControl.getChange();
    if (change.getStatus().isClosed()) {
        throw error("change " + changeId + " is closed");
    }
    final Transaction txn = db.beginTransaction();
    final StringBuffer msgBuf = new StringBuffer();
    msgBuf.append("Patch Set ");
    msgBuf.append(patchSetId.get());
    msgBuf.append(": ");
    String verified = "";
    String approved = "";
    for (ApproveOption co : optionList) {
        final ApprovalCategory.Id category = co.getCategoryId();
        PatchSetApproval.Key psaKey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), category);
        PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
        Short score = co.value();
        if (score != null) {
            addApproval(psaKey, score, change, co, txn);
        } else {
            if (psa == null) {
                score = 0;
                addApproval(psaKey, score, change, co, txn);
            } else {
                score = psa.getValue();
            }
        }
        String message = db.approvalCategoryValues().get(new ApprovalCategoryValue.Id(category, score)).getName();
        msgBuf.append(" " + message + ";");
        if (category.get().equalsIgnoreCase("VRIF")) {
            verified = Short.toString(score);
        } else if (category.get().equalsIgnoreCase("CVRW")) {
            approved = Short.toString(score);
        }
    }
    msgBuf.deleteCharAt(msgBuf.length() - 1);
    msgBuf.append("\n\n");
    if (changeComment != null) {
        msgBuf.append(changeComment);
    }
    String uuid = ChangeUtil.messageUUID(db);
    ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(changeId, uuid), currentUser.getAccountId());
    cm.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(cm), txn);
    ChangeUtil.updated(change);
    db.changes().update(Collections.singleton(change), txn);
    txn.commit();
    ChangeHookRunner.get().doCommentAddedHook(change, currentUser.getAccount(), verified, approved, changeComment);
    sendMail(change, change.currentPatchSetId(), cm);
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, PatchSetInfoNotAvailableException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    final Change change = changeControl.getChange();
    if (change.getStatus().isClosed()) {
        throw error("change " + changeId + " is closed");
    }
    final StringBuffer msgBuf = new StringBuffer();
    msgBuf.append("Patch Set ");
    msgBuf.append(patchSetId.get());
    msgBuf.append(": ");
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvalsMap = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (ApproveOption co : optionList) {
        final ApprovalCategory.Id category = co.getCategoryId();
        PatchSetApproval.Key psaKey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), category);
        PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
        Short score = co.value();
        if (score != null) {
            addApproval(psaKey, score, change, co);
        } else {
            if (psa == null) {
                score = 0;
                addApproval(psaKey, score, change, co);
            } else {
                score = psa.getValue();
            }
        }
        final ApprovalCategoryValue.Id val = new ApprovalCategoryValue.Id(category, score);
        String message = db.approvalCategoryValues().get(val).getName();
        msgBuf.append(" " + message + ";");
        approvalsMap.put(category, val);
    }
    msgBuf.deleteCharAt(msgBuf.length() - 1);
    msgBuf.append("\n\n");
    if (changeComment != null) {
        msgBuf.append(changeComment);
    }
    String uuid = ChangeUtil.messageUUID(db);
    ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(changeId, uuid), currentUser.getAccountId());
    cm.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(cm));
    ChangeUtil.touch(change, db);
    sendMail(change, change.currentPatchSetId(), cm);
    hooks.doCommentAddedHook(change, currentUser.getAccount(), changeComment, approvalsMap);
}
#end_block

#method_before
private void addApproval(final PatchSetApproval.Key psaKey, final Short score, final Change c, final ApproveOption co, final Transaction txn) throws OrmException, UnloggedFailure {
    PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
    boolean insert = false;
    if (psa == null) {
        insert = true;
        psa = new PatchSetApproval(psaKey, score);
    }
    final List<PatchSetApproval> approvals = Collections.emptyList();
    final FunctionState fs = functionStateFactory.create(c, psaKey.getParentKey(), approvals);
    psa.setValue(score);
    fs.normalize(approvalTypes.getApprovalType(psa.getCategoryId()), psa);
    if (score != psa.getValue()) {
        throw error(co.name() + "=" + co.value() + " not permitted");
    }
    psa.setGranted();
    if (insert) {
        db.patchSetApprovals().insert(Collections.singleton(psa), txn);
    } else {
        db.patchSetApprovals().update(Collections.singleton(psa), txn);
    }
}
#method_after
private void addApproval(final PatchSetApproval.Key psaKey, final Short score, final Change c, final ApproveOption co) throws OrmException, UnloggedFailure {
    final PatchSetApproval psa = new PatchSetApproval(psaKey, score);
    final List<PatchSetApproval> approvals = Collections.emptyList();
    final FunctionState fs = functionStateFactory.create(c, psaKey.getParentKey(), approvals);
    psa.setValue(score);
    fs.normalize(approvalTypes.getApprovalType(psa.getCategoryId()), psa);
    if (score != psa.getValue()) {
        throw error(co.name() + "=" + co.value() + " not permitted");
    }
    psa.setGranted();
    db.patchSetApprovals().upsert(Collections.singleton(psa));
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    Boolean dbSuccess = db.run(new OrmRunnable<Boolean, ReviewDb>() {

        public Boolean run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
            return doAbandonChange(message, change, patchSetId, cmsg, db, txn);
        }
    });
    if (dbSuccess) {
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(currentUser.getAccountId());
        cm.setReviewDb(db);
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    ChangeHookRunner.get().doChangeAbandonedHook(change, currentUser.getAccount(), message);
    return changeDetailFactory.create(changeId).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.ABANDONED);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change != null) {
        db.changeMessages().insert(Collections.singleton(cmsg));
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        for (PatchSetApproval a : approvals) {
            a.cache(change);
        }
        db.patchSetApprovals().update(approvals);
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(currentUser.getAccountId());
        cm.setReviewDb(db);
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    hooks.doChangeAbandonedHook(change, currentUser.getAccount(), message);
    return changeDetailFactory.create(changeId).call();
}
#end_block

#method_before
private void generateProxyCallCreator(final TreeLogger logger, final SourceWriter w) throws UnableToCompleteException {
    // TODO: implement annotation for json-rpc versions selection
    String callName = getJsonCallClassName(logger);
    w.println();
    w.println("@Override");
    w.print("protected <T> ");
    w.print(callName);
    w.print("<T> newJsonCall(final AbstractJsonProxy proxy, ");
    w.print("final String methodName, final String reqData, ");
    w.println("final ResultDeserializer<T> ser, final AsyncCallback<T> cb) {");
    w.indent();
    w.print("return new ");
    w.print(callName);
    w.println("<T>(proxy, methodName, reqData, ser, cb);");
    w.outdent();
    w.println("}");
}
#method_after
private void generateProxyCallCreator(final TreeLogger logger, final SourceWriter w) throws UnableToCompleteException {
    String callName = getJsonCallClassName(logger);
    w.println();
    w.println("@Override");
    w.print("protected <T> ");
    w.print(callName);
    w.print("<T> newJsonCall(final AbstractJsonProxy proxy, ");
    w.print("final String methodName, final String reqData, ");
    w.println("final ResultDeserializer<T> ser, final AsyncCallback<T> cb) {");
    w.indent();
    w.print("return new ");
    w.print(callName);
    w.println("<T>(proxy, methodName, reqData, ser, cb);");
    w.outdent();
    w.println("}");
}
#end_block

#method_before
private void generateProxyMethod(final TreeLogger logger, final JMethod method, final SourceWriter w) {
    final JParameter[] params = method.getParameters();
    final JParameter callback = params[params.length - 1];
    final JClassType resultType = callback.getType().isParameterized().getTypeArgs()[0];
    final String[] serializerFields = new String[params.length];
    final HostPageCache hpc = method.getAnnotation(HostPageCache.class);
    w.println();
    for (int i = 0; i < params.length - 1; i++) {
        final JType pType = params[i].getType();
        if (SerializerCreator.needsTypeParameter(pType)) {
            serializerFields[i] = "serializer_" + instanceField++;
            w.print("private static final ");
            if (pType.isArray() != null)
                w.print(serializerCreator.serializerFor(pType));
            else
                w.print(JsonSerializer.class.getName());
            w.print(" ");
            w.print(serializerFields[i]);
            w.print(" = ");
            serializerCreator.generateSerializerReference(pType, w);
            w.println(";");
        }
    }
    if (resultType.isParameterized() != null) {
        serializerFields[params.length - 1] = "serializer_" + instanceField++;
        w.print("private static final ");
        w.print(ResultDeserializer.class.getName());
        w.print(" ");
        w.print(serializerFields[params.length - 1]);
        w.print(" = ");
        serializerCreator.generateSerializerReference(resultType, w);
        w.println(";");
    }
    w.print("public ");
    w.print(method.getReturnType().getQualifiedSourceName());
    w.print(" ");
    w.print(method.getName());
    w.print("(");
    boolean needsComma = false;
    final NameFactory nameFactory = new NameFactory();
    for (int i = 0; i < params.length; i++) {
        final JParameter param = params[i];
        if (needsComma) {
            w.print(", ");
        } else {
            needsComma = true;
        }
        final JType paramType = param.getType().getErasedType();
        w.print(paramType.getQualifiedSourceName());
        w.print(" ");
        nameFactory.addName(param.getName());
        w.print(param.getName());
    }
    w.println(") {");
    w.indent();
    if (returnsCallbackHandle(method)) {
        w.print("return new ");
        w.print(CallbackHandle.class.getName());
        w.print("(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.println(");");
        w.outdent();
        w.println("}");
        return;
    }
    if (hpc != null) {
        final String objName = nameFactory.createName("cached");
        w.print("final JavaScriptObject " + objName + " = ");
        w.print(AbstractJsonProxy.class.getName());
        w.print(".");
        w.print(hpc.once() ? "hostPageCacheGetOnce" : "hostPageCacheGetMany");
        w.println("(\"" + hpc.name() + "\");");
        w.println("if (" + objName + " != null) {");
        w.indent();
        w.print(JsonUtil.class.getName());
        w.print(".invoke(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.print(", " + objName);
        w.println(");");
        w.println("return;");
        w.outdent();
        w.println("}");
    }
    final String reqDataStr;
    if (params.length == 1) {
        reqDataStr = "\"\"";
    } else {
        final String reqData = nameFactory.createName("reqData");
        w.println("final StringBuilder " + reqData + " = new StringBuilder();");
        needsComma = false;
        for (int i = 0; i < params.length - 1; i++) {
            if (needsComma) {
                w.println(reqData + ".append(\",\");");
            } else {
                needsComma = true;
            }
            final JType pType = params[i].getType();
            final String pName = params[i].getName();
            if (pType == JPrimitiveType.CHAR || SerializerCreator.isBoxedCharacter(pType)) {
                w.println(reqData + ".append(\"\\\"\");");
                w.println(reqData + ".append(" + JsonSerializer.class.getSimpleName() + ".escapeChar(" + pName + "));");
                w.println(reqData + ".append(\"\\\"\");");
            } else if ((SerializerCreator.isJsonPrimitive(pType) || SerializerCreator.isBoxedPrimitive(pType)) && !SerializerCreator.isJsonString(pType)) {
                w.println(reqData + ".append(" + pName + ");");
            } else {
                w.println("if (" + pName + " != null) {");
                w.indent();
                if (SerializerCreator.needsTypeParameter(pType)) {
                    w.print(serializerFields[i]);
                } else {
                    serializerCreator.generateSerializerReference(pType, w);
                }
                w.println(".printJson(" + reqData + ", " + pName + ");");
                w.outdent();
                w.println("} else {");
                w.indent();
                w.println(reqData + ".append(" + JsonSerializer.class.getName() + ".JS_NULL);");
                w.outdent();
                w.println("}");
            }
        }
        reqDataStr = reqData + ".toString()";
    }
    w.print("doInvoke(");
    w.print("\"" + method.getName() + "\"");
    w.print(", " + reqDataStr);
    w.print(", ");
    if (resultType.isParameterized() != null) {
        w.print(serializerFields[params.length - 1]);
    } else {
        deserializerCreator.generateDeserializerReference(resultType, w);
    }
    w.print(", " + callback.getName());
    w.println(");");
    w.outdent();
    w.println("}");
}
#method_after
private void generateProxyMethod(final TreeLogger logger, final JMethod method, final SourceWriter w) {
    final JParameter[] params = method.getParameters();
    final JParameter callback = params[params.length - 1];
    final JClassType resultType = callback.getType().isParameterized().getTypeArgs()[0];
    final String[] serializerFields = new String[params.length];
    final HostPageCache hpc = method.getAnnotation(HostPageCache.class);
    w.println();
    for (int i = 0; i < params.length - 1; i++) {
        final JType pType = params[i].getType();
        if (SerializerCreator.needsTypeParameter(pType)) {
            serializerFields[i] = "serializer_" + instanceField++;
            w.print("private static final ");
            if (pType.isArray() != null)
                w.print(serializerCreator.serializerFor(pType));
            else
                w.print(JsonSerializer.class.getName());
            w.print(" ");
            w.print(serializerFields[i]);
            w.print(" = ");
            serializerCreator.generateSerializerReference(pType, w);
            w.println(";");
        }
    }
    if (resultType.isParameterized() != null) {
        serializerFields[params.length - 1] = "serializer_" + instanceField++;
        w.print("private static final ");
        w.print(ResultDeserializer.class.getName());
        w.print(" ");
        w.print(serializerFields[params.length - 1]);
        w.print(" = ");
        serializerCreator.generateSerializerReference(resultType, w);
        w.println(";");
    }
    w.print("public ");
    w.print(method.getReturnType().getQualifiedSourceName());
    w.print(" ");
    w.print(method.getName());
    w.print("(");
    boolean needsComma = false;
    final NameFactory nameFactory = new NameFactory();
    for (int i = 0; i < params.length; i++) {
        final JParameter param = params[i];
        if (needsComma) {
            w.print(", ");
        } else {
            needsComma = true;
        }
        final JType paramType = param.getType().getErasedType();
        w.print(paramType.getQualifiedSourceName());
        w.print(" ");
        nameFactory.addName(param.getName());
        w.print(param.getName());
    }
    w.println(") {");
    w.indent();
    if (returnsCallbackHandle(method)) {
        w.print("return new ");
        w.print(CallbackHandle.class.getName());
        w.print("(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.println(");");
        w.outdent();
        w.println("}");
        return;
    }
    if (hpc != null) {
        final String objName = nameFactory.createName("cached");
        w.print("final JavaScriptObject " + objName + " = ");
        w.print(AbstractJsonProxy.class.getName());
        w.print(".");
        w.print(hpc.once() ? "hostPageCacheGetOnce" : "hostPageCacheGetMany");
        w.println("(\"" + hpc.name() + "\");");
        w.println("if (" + objName + " != null) {");
        w.indent();
        w.print(JsonUtil.class.getName());
        w.print(".invoke(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.print(", " + objName);
        w.println(");");
        w.println("return;");
        w.outdent();
        w.println("}");
    }
    final String reqDataStr;
    if (params.length == 1) {
        reqDataStr = "\"[]\"";
    } else {
        final String reqData = nameFactory.createName("reqData");
        w.println("final StringBuilder " + reqData + " = new StringBuilder();");
        needsComma = false;
        w.println(reqData + ".append('[');");
        for (int i = 0; i < params.length - 1; i++) {
            if (needsComma) {
                w.println(reqData + ".append(\",\");");
            } else {
                needsComma = true;
            }
            final JType pType = params[i].getType();
            final String pName = params[i].getName();
            if (pType == JPrimitiveType.CHAR || SerializerCreator.isBoxedCharacter(pType)) {
                w.println(reqData + ".append(\"\\\"\");");
                w.println(reqData + ".append(" + JsonSerializer.class.getSimpleName() + ".escapeChar(" + pName + "));");
                w.println(reqData + ".append(\"\\\"\");");
            } else if ((SerializerCreator.isJsonPrimitive(pType) || SerializerCreator.isBoxedPrimitive(pType)) && !SerializerCreator.isJsonString(pType)) {
                w.println(reqData + ".append(" + pName + ");");
            } else {
                w.println("if (" + pName + " != null) {");
                w.indent();
                if (SerializerCreator.needsTypeParameter(pType)) {
                    w.print(serializerFields[i]);
                } else {
                    serializerCreator.generateSerializerReference(pType, w);
                }
                w.println(".printJson(" + reqData + ", " + pName + ");");
                w.outdent();
                w.println("} else {");
                w.indent();
                w.println(reqData + ".append(" + JsonSerializer.class.getName() + ".JS_NULL);");
                w.outdent();
                w.println("}");
            }
        }
        w.println(reqData + ".append(']');");
        reqDataStr = reqData + ".toString()";
    }
    w.print("doInvoke(");
    w.print("\"" + method.getName() + "\"");
    w.print(", " + reqDataStr);
    w.print(", ");
    if (resultType.isParameterized() != null) {
        w.print(serializerFields[params.length - 1]);
    } else {
        deserializerCreator.generateDeserializerReference(resultType, w);
    }
    w.print(", " + callback.getName());
    w.println(");");
    w.outdent();
    w.println("}");
}
#end_block

#method_before
@Override
void send() {
    final StringBuilder body = new StringBuilder();
    body.append("{\"version\":\"1.1\",\"method\":\"");
    body.append(methodName);
    body.append("\",\"params\":[");
    body.append(requestParams);
    body.append("]");
    final String xsrfKey = proxy.getXsrfManager().getToken(proxy);
    if (xsrfKey != null) {
        body.append(",\"xsrfKey\":");
        body.append(JsonSerializer.escapeString(xsrfKey));
    }
    body.append("}");
    final RequestBuilder rb;
    rb = new RequestBuilder(RequestBuilder.POST, proxy.url);
    rb.setHeader("Content-Type", JsonUtil.JSON_REQ_CT);
    rb.setHeader("Accept", JsonUtil.JSON_TYPE);
    rb.setCallback(this);
    rb.setRequestData(body.toString());
    send(rb);
}
#method_after
@Override
void send() {
    final StringBuilder body = new StringBuilder();
    body.append("{\"version\":\"1.1\",\"method\":\"");
    body.append(methodName);
    body.append("\",\"params\":");
    body.append(requestParams);
    final String xsrfKey = proxy.getXsrfManager().getToken(proxy);
    if (xsrfKey != null) {
        body.append(",\"xsrfKey\":");
        body.append(JsonSerializer.escapeString(xsrfKey));
    }
    body.append("}");
    final RequestBuilder rb;
    rb = new RequestBuilder(RequestBuilder.POST, proxy.url);
    rb.setHeader("Content-Type", JsonUtil.JSON_REQ_CT);
    rb.setHeader("Accept", JsonUtil.JSON_TYPE);
    rb.setCallback(this);
    rb.setRequestData(body.toString());
    send(rb);
}
#end_block

#method_before
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (rsp.getStatusCode() == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(rsp.getStatusCode(), rsp.getStatusText()));
    }
}
#method_after
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#end_block

#method_before
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    // FIXME: implement version 2.0
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (rsp.getStatusCode() == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(rsp.getStatusCode(), rsp.getStatusText()));
    }
}
#method_after
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            // TODO: define status code for the invalid XSRF msg for 2.0 (-32099 ?)
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("data")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#end_block

#method_before
public void display(final Change chg, final PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    SafeHtml msg = new SafeHtmlBuilder().append(info.getMessage());
    msg = msg.linkify();
    msg.setFindReplaceList(Gerrit.getConfig().getCommentLinks());
    msg = msg.runFindReplaceList();
    msg = new SafeHtmlBuilder().openElement("p").append(msg).closeElement("p");
    msg = msg.replaceAll("\n\n", "</p><p>");
    msg = msg.replaceAll("\n", "<br />");
    SafeHtml.set(description, msg);
}
#method_after
public void display(final Change chg, final PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    SafeHtml msg = new SafeHtmlBuilder().append(info.getMessage());
    msg = msg.linkify();
    msg = msg.replaceAll(Gerrit.getConfig().getCommentLinks());
    msg = new SafeHtmlBuilder().openElement("p").append(msg).closeElement("p");
    msg = msg.replaceAll("\n\n", "</p><p>");
    msg = msg.replaceAll("\n", "<br />");
    SafeHtml.set(description, msg);
}
#end_block

#method_before
protected void setMessageText(String message) {
    if (message == null) {
        message = "";
    } else {
        message = message.trim();
    }
    messageSummary.setText(summarize(message));
    SafeHtml msg = new SafeHtmlBuilder().append(message);
    msg.setFindReplaceList(Gerrit.getConfig().getCommentLinks());
    SafeHtml.set(messageText, msg.wikify().runFindReplaceList());
}
#method_after
protected void setMessageText(String message) {
    if (message == null) {
        message = "";
    } else {
        message = message.trim();
    }
    messageSummary.setText(summarize(message));
    SafeHtml.set(messageText, new SafeHtmlBuilder().append(message).wikify().replaceAll(Gerrit.getConfig().getCommentLinks()));
}
#end_block

#method_before
private GerritConfig create() {
    final GerritConfig config = new GerritConfig();
    config.setCanonicalUrl(canonicalWebUrl);
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setUseRepoDownload(cfg.getBoolean("repo", null, "showdownloadcommand", false));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setApprovalTypes(approvalTypes);
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled()) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    final String gitwebUrl = cfg.getString("gitweb", null, "url");
    if (gitwebUrl != null) {
        config.setGitwebLink(new GitwebLink(gitwebUrl));
    }
    config.setSshdAddress(sshInfo != null ? sshInfo.getSshdAddress() : null);
    ArrayList<String> commentLinkNames = new ArrayList<String>(cfg.getSubsections("CommentLink"));
    ArrayList<RegexFindReplace> commentLinks = new ArrayList<RegexFindReplace>(commentLinkNames.size());
    for (String commentLinkName : commentLinkNames) {
        String match = cfg.getString("CommentLink", commentLinkName, "match");
        String link = cfg.getString("CommentLink", commentLinkName, "link");
        commentLinks.add(new RegexFindReplace(match, link));
    }
    config.setCommentLinks(commentLinks);
    return config;
}
#method_after
private GerritConfig create() {
    final GerritConfig config = new GerritConfig();
    config.setCanonicalUrl(canonicalWebUrl);
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setUseRepoDownload(cfg.getBoolean("repo", null, "showdownloadcommand", false));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setApprovalTypes(approvalTypes);
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled()) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    final String gitwebUrl = cfg.getString("gitweb", null, "url");
    if (gitwebUrl != null) {
        config.setGitwebLink(new GitwebLink(gitwebUrl));
    }
    config.setSshdAddress(sshInfo != null ? sshInfo.getSshdAddress() : null);
    ArrayList<String> commentLinkNames = new ArrayList<String>(cfg.getSubsections("CommentLink"));
    ArrayList<RegexFindReplace> commentLinks = new ArrayList<RegexFindReplace>(commentLinkNames.size());
    for (String commentLinkName : commentLinkNames) {
        String match = cfg.getString("commentlink", commentLinkName, "match");
        String link = "<a href=\"" + cfg.getString("commentlink", commentLinkName, "link") + "\">$&</a>";
        commentLinks.add(new RegexFindReplace(match, link));
    }
    config.setCommentLinks(commentLinks);
    return config;
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            who.setDisplayName(m.get(accountFullName));
            who.setSshUserName(m.get(accountSshUserName));
            if (accountEmailAddress != null) {
                who.setEmailAddress(m.get(accountEmailAddress));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#method_after
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(accountFullName, m));
            who.setSshUserName(apply(accountSshUserName, m));
            if (accountEmailAddress != null) {
                who.setEmailAddress(apply(accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    final HashMap<String, String> params = new HashMap<String, String>();
    params.put(USERNAME, username);
    if (groupNeedsAccount) {
        if (account == null) {
            account = findAccount(ctx, username);
        }
        for (final String name : groupMemberQueryList.get(0).getParameters()) {
            params.put(name, account.get(name));
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (LdapQuery groupMemberQuery : groupMemberQueryList) {
        for (LdapQuery.Result r : groupMemberQuery.query(ctx, params)) {
            NamingEnumeration groups = r.getAll(memberField).getAll();
            while (groups.hasMore()) {
                final String name = String.valueOf(groups.next());
                final AccountGroup group = groupCache.lookup(name);
                if (group != null && isLdapGroup(group)) {
                    actual.add(group.getId());
                }
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#method_after
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    if (account == null) {
        account = findAccount(ctx, username);
    }
    final HashMap<String, String> params = new HashMap<String, String>();
    params.put(USERNAME, username);
    if (groupNeedsAccount) {
        for (final String name : groupMemberQueryList.get(0).getParameters()) {
            params.put(name, account.get(name));
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (LdapQuery groupMemberQuery : groupMemberQueryList) {
        for (LdapQuery.Result r : groupMemberQuery.query(ctx, params)) {
            final String name = r.get(groupName);
            final AccountGroup group = groupCache.lookup(name);
            if (group != null && isLdapGroup(group)) {
                actual.add(group.getId());
            }
        }
    }
    NamingEnumeration groups = account.getAll(accountMemberField).getAll();
    while (groups.hasMore()) {
        final String dn = (String) groups.next();
        for (String cn : groupsFor(ctx, dn)) {
            AccountGroup group = groupCache.lookup(cn);
            if (null != group && isLdapGroup(group)) {
                actual.add(group.getId());
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#end_block

#method_before
@Override
public List<RealmProperty> getProperties(final AccountGroup group) {
    if (!isLdapGroup(group)) {
        return Collections.emptyList();
    }
    try {
        final DirContext ctx = open();
        try {
            final Map<String, String> params = new HashMap<String, String>();
            params.put(GROUPNAME, group.getName());
            final List<RealmProperty> props = new ArrayList<RealmProperty>();
            final List<LdapQuery.Result> q = new ArrayList<LdapQuery.Result>();
            for (LdapQuery groupByNameQuery : groupByNameQueryList) {
                q.addAll(groupByNameQuery.query(ctx, params));
            }
            switch(q.size()) {
                case 0:
                    log.warn("Group \"" + group.getName() + "\" not found in LDAP.");
                    props.add(new RealmProperty("error", "NOT FOUND"));
                    break;
                case 1:
                    for (final String name : q.get(0).keySet()) {
                        props.add(new RealmProperty(name, q.get(0).get(name)));
                    }
                    Collections.sort(props, new Comparator<RealmProperty>() {

                        @Override
                        public int compare(final RealmProperty a, final RealmProperty b) {
                            int sort = classOf(a) - classOf(b);
                            if (sort == 0)
                                sort = a.getName().compareTo(b.getName());
                            return sort;
                        }

                        private int classOf(final RealmProperty p) {
                            final String n = p.getName();
                            if ("dn".equals(n) || "distinguishedName".equals(n))
                                return 0;
                            if ("cn".equals(n))
                                return 1;
                            return 5000;
                        }
                    });
                    break;
                default:
                    log.warn("Group \"" + group.getName() + "\" has multiple matches in LDAP: " + q);
                    props.add(new RealmProperty("error", "MULTIPLE MATCHES"));
                    break;
            }
            return props;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP directory for group " + group.getName(), e);
        return Collections.emptyList();
    }
}
#method_after
@Override
public List<RealmProperty> getProperties(final AccountGroup group) {
    if (!isLdapGroup(group)) {
        return Collections.emptyList();
    }
    try {
        final DirContext ctx = open();
        try {
            final Map<String, String> params = new HashMap<String, String>();
            params.put(GROUPNAME, group.getName());
            final List<RealmProperty> props = new ArrayList<RealmProperty>();
            final List<LdapQuery.Result> q = new ArrayList<LdapQuery.Result>();
            for (LdapQuery groupByNameQuery : groupByNameQueryList) {
                q.addAll(groupByNameQuery.query(ctx, params));
            }
            switch(q.size()) {
                case 0:
                    log.warn("Group \"" + group.getName() + "\" not found in LDAP.");
                    props.add(new RealmProperty("error", "NOT FOUND"));
                    break;
                case 1:
                    for (final String name : q.get(0).map().keySet()) {
                        props.add(new RealmProperty(name, q.get(0).get(name)));
                    }
                    Collections.sort(props, new Comparator<RealmProperty>() {

                        @Override
                        public int compare(final RealmProperty a, final RealmProperty b) {
                            int sort = classOf(a) - classOf(b);
                            if (sort == 0)
                                sort = a.getName().compareTo(b.getName());
                            return sort;
                        }

                        private int classOf(final RealmProperty p) {
                            final String n = p.getName();
                            if ("dn".equals(n) || "distinguishedName".equals(n))
                                return 0;
                            if ("cn".equals(n))
                                return 1;
                            return 5000;
                        }
                    });
                    break;
                default:
                    log.warn("Group \"" + group.getName() + "\" has multiple matches in LDAP: " + q);
                    props.add(new RealmProperty("error", "MULTIPLE MATCHES"));
                    break;
            }
            return props;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP directory for group " + group.getName(), e);
        return Collections.emptyList();
    }
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            who.setDisplayName(m.get(accountFullName));
            who.setSshUserName(m.get(accountSshUserName));
            if (accountEmailAddress != null) {
                who.setEmailAddress(m.get(accountEmailAddress));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#method_after
private void authenticate(String dn, String password) throws AccountException {
    final Properties env = new Properties();
    env.put(Context.INITIAL_CONTEXT_FACTORY, LDAP);
    env.put(Context.PROVIDER_URL, server);
    env.put(Context.SECURITY_PRINCIPAL, dn);
    env.put(Context.SECURITY_CREDENTIALS, password != null ? password : "");
    try {
        new InitialDirContext(env).close();
    } catch (NamingException e) {
        throw new AccountException("Incorrect username or password", e);
    }
}
#end_block

#method_before
@Override
public String toString() {
    String data = "";
    try {
        String.valueOf(atts.get("dn").get(0));
    } catch (NamingException e) {
    }
    return data;
}
#method_after
@Override
public String toString() {
    try {
        return getDN();
    } catch (NamingException e) {
        return "";
    }
}
#end_block

#method_before
public Account.Id getId() {
    return accountId;
}
#method_after
public Account.Id getId() {
    return oldAccountId;
}
#end_block

#method_before
public Account.Id getAccountId() {
    return accountId;
}
#method_after
public Account.Id getAccountId() {
    return oldAccountId;
}
#end_block

#method_before
@Override
public void changeSshUserName(final String newName, final AsyncCallback<VoidResult> callback) {
    if (!realm.allowsEdit(Account.FieldName.SSH_USER_NAME)) {
        callback.onFailure(new NameAlreadyUsedException());
        return;
    }
    run(callback, new Action<VoidResult>() {

        @Override
        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            final Account me = db.accounts().get(getAccountId());
            if (me == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (newName != null && !sshUserNamePattern.matcher(newName).matches()) {
                throw new Failure(new InvalidSshUserNameException());
            }
            final Account other;
            if (newName != null) {
                other = db.accounts().bySshUserName(newName);
            } else {
                other = null;
            }
            if (other != null) {
                if (other.getId().equals(me.getId())) {
                    return VoidResult.INSTANCE;
                } else {
                    throw new Failure(new NameAlreadyUsedException());
                }
            }
            final String oldName = me.getSshUserName();
            me.setSshUserName(newName);
            db.accounts().update(Collections.singleton(me));
            uncacheSshKeys(oldName);
            uncacheSshKeys(newName);
            accountCache.evict(me.getId());
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
@Override
public void changeSshUserName(final String newName, final AsyncCallback<VoidResult> callback) {
    if (!realm.allowsEdit(Account.FieldName.SSH_USER_NAME)) {
        callback.onFailure(new NameAlreadyUsedException());
        return;
    }
    run(callback, new Action<VoidResult>() {

        @Override
        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            final Account me = db.accounts().get(getAccountId());
            if (me == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (newName != null && !SSH_USER_NAME_PATTERN.matcher(newName).matches()) {
                throw new Failure(new InvalidSshUserNameException());
            }
            final Account other;
            if (newName != null) {
                other = db.accounts().bySshUserName(newName);
            } else {
                other = null;
            }
            if (other != null) {
                if (other.getId().equals(me.getId())) {
                    return VoidResult.INSTANCE;
                } else {
                    throw new Failure(new NameAlreadyUsedException());
                }
            }
            final String oldName = me.getSshUserName();
            me.setSshUserName(newName);
            db.accounts().update(Collections.singleton(me));
            uncacheSshKeys(oldName);
            uncacheSshKeys(newName);
            accountCache.evict(me.getId());
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public void strongestApprovals(final Change.Id id, final AsyncCallback<ApprovalDetail> callback) {
    run(callback, new Action<ApprovalDetail>() {

        public ApprovalDetail run(ReviewDb db) throws OrmException {
            final List<PatchSet> last_pset = db.patchSets().lastChange(id).toList();
            if (last_pset.isEmpty()) {
                return null;
            }
            final PatchSet.Id ps_id = last_pset.get(0).getId();
            final Map<ApprovalCategory.Id, PatchSetApproval> have = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
            for (PatchSetApproval a : db.patchSetApprovals().byPatchSet(ps_id)) {
                boolean keep = true;
                if (have.containsKey(a.getCategoryId())) {
                    final short oldValue = have.get(a.getCategoryId()).getValue();
                    final short newValue = a.getValue();
                    keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                }
                if (keep) {
                    have.put(a.getCategoryId(), a);
                }
            }
            final ApprovalDetail ad = new ApprovalDetail(getAccountId());
            for (PatchSetApproval a : have.values()) {
                ad.add(a);
            }
            return ad;
        }
    });
}
#method_after
public void strongestApprovals(final Set<Change.Id> cids, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(change, ps_id, psas.values());
                    for (PatchSetApproval ca : db.patchSetApprovals().byPatchSet(ps_id)) {
                        fs.normalize(approvalTypes.getApprovalType(ca.getCategoryId()), ca);
                        boolean keep = true;
                        if (psas.containsKey(ca.getCategoryId())) {
                            final short oldValue = psas.get(ca.getCategoryId()).getValue();
                            final short newValue = ca.getValue();
                            keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                        }
                        if (keep) {
                            aicFactory.want(ca.getAccountId());
                            psas.put(ca.getCategoryId(), ca);
                        }
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /* The user has no access to see this change, so we
             * simply do not provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable(true);
    byOwner = new ChangeTable.Section("", ChangeTable.ApprovalViewType.STRONGEST);
    forReview = new ChangeTable.Section("", ChangeTable.ApprovalViewType.MINE);
    closed = new ChangeTable.Section("", ChangeTable.ApprovalViewType.STRONGEST);
    table.addSection(byOwner);
    table.addSection(forReview);
    table.addSection(closed);
    add(table);
    table.setSavePointerId(Link.toAccountDashboard(ownerId));
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable(true);
    byOwner = new ChangeTable.Section("", ApprovalViewType.STRONGEST, null);
    forReview = new ChangeTable.Section("", ApprovalViewType.USER, ownerId);
    closed = new ChangeTable.Section("", ApprovalViewType.STRONGEST, null);
    table.addSection(byOwner);
    table.addSection(forReview);
    table.addSection(closed);
    add(table);
    table.setSavePointerId(Link.toAccountDashboard(ownerId));
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, S_ICON_CELL);
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, S_DATA_CELL);
    }
    fmt.addStyleName(row, C_ID, S_C_ID);
    fmt.addStyleName(row, C_SUBJECT, S_C_SUBJECT);
    fmt.addStyleName(row, C_PROJECT, S_C_PROJECT);
    fmt.addStyleName(row, C_BRANCH, S_C_PROJECT);
    fmt.addStyleName(row, C_LAST_UPDATE, S_C_LAST_UPDATE);
    for (int i = BASE_COLUMNS; i < columns; i++) {
        fmt.addStyleName(row, i, "approvalscore");
    }
}
#method_after
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, S_ICON_CELL);
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, S_DATA_CELL);
    }
    fmt.addStyleName(row, C_ID, S_C_ID);
    fmt.addStyleName(row, C_SUBJECT, S_C_SUBJECT);
    fmt.addStyleName(row, C_PROJECT, S_C_PROJECT);
    fmt.addStyleName(row, C_BRANCH, S_C_PROJECT);
    fmt.addStyleName(row, C_LAST_UPDATE, S_C_LAST_UPDATE);
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, final ApprovalViewType viewType) {
    final String idstr = c.getKey().abbreviate();
    table.setWidget(row, C_ARROW, null);
    if (Gerrit.isSignedIn()) {
        setStar(row, c);
    }
    table.setWidget(row, C_ID, new TableChangeLink(idstr, c));
    String s = c.getSubject();
    if (s.length() > 80) {
        s = s.substring(0, 80);
    }
    if (c.getStatus() != null && c.getStatus() != Change.Status.NEW) {
        s += " (" + c.getStatus().name() + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(s, c));
    table.setWidget(row, C_OWNER, link(c.getOwner()));
    table.setWidget(row, C_PROJECT, new ProjectOpenLink(c.getProject().getKey()));
    table.setText(row, C_BRANCH, c.getBranch());
    table.setText(row, C_LAST_UPDATE, mediumFormat(c.getLastUpdatedOn()));
    switch(viewType) {
        case NONE:
            break;
        case MINE:
            PatchUtil.DETAIL_SVC.myApprovals(c.getId(), approvalFormatter(row));
            break;
        case STRONGEST:
            PatchUtil.DETAIL_SVC.strongestApprovals(c.getId(), approvalFormatter(row));
            break;
    }
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c) {
    final String idstr = c.getKey().abbreviate();
    table.setWidget(row, C_ARROW, null);
    if (Gerrit.isSignedIn()) {
        setStar(row, c);
    }
    table.setWidget(row, C_ID, new TableChangeLink(idstr, c));
    String s = c.getSubject();
    if (s.length() > 80) {
        s = s.substring(0, 80);
    }
    if (c.getStatus() != null && c.getStatus() != Change.Status.NEW) {
        s += " (" + c.getStatus().name() + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(s, c));
    table.setWidget(row, C_OWNER, link(c.getOwner()));
    table.setWidget(row, C_PROJECT, new ProjectOpenLink(c.getProject().getKey()));
    table.setText(row, C_BRANCH, c.getBranch());
    table.setText(row, C_LAST_UPDATE, mediumFormat(c.getLastUpdatedOn()));
    setRowItem(row, c);
}
#end_block

#method_before
GerritCallback<ApprovalDetail> approvalFormatter(final int row) {
    return new GerritCallback<ApprovalDetail>() {

        @Override
        public void onSuccess(final ApprovalDetail detail) {
            final CellFormatter fmt = table.getCellFormatter();
            final Map<ApprovalCategory.Id, PatchSetApproval> am = detail.getApprovalMap();
            int col = BASE_COLUMNS;
            for (final ApprovalType type : approvalTypes) {
                final PatchSetApproval ca = am.get(type.getCategory().getId());
                if (ca == null || ca.getValue() == 0) {
                    table.clearCell(row, col);
                } else if (type.isMaxNegative(ca)) {
                    table.setWidget(row, col, Gerrit.ICONS.redNot().createImage());
                } else if (type.isMaxPositive(ca)) {
                    table.setWidget(row, col, Gerrit.ICONS.greenCheck().createImage());
                } else {
                    String vstr = String.valueOf(ca.getValue());
                    if (ca.getValue() > 0) {
                        vstr = "+" + vstr;
                        fmt.removeStyleName(row, col, "negscore");
                        fmt.addStyleName(row, col, "posscore");
                    } else {
                        fmt.addStyleName(row, col, "negscore");
                        fmt.removeStyleName(row, col, "posscore");
                    }
                    table.setText(row, col, vstr);
                }
                col++;
            }
        }
    };
}
#method_after
GerritCallback<ApprovalSummarySet> approvalFormatter(final int dataBegin, final int rows) {
    return new GerritCallback<ApprovalSummarySet>() {

        @Override
        public void onSuccess(final ApprovalSummarySet as) {
            Map<Change.Id, ApprovalSummary> ids = as.getSummaryMap();
            AccountInfoCache aic = as.getAccountInfoCache();
            for (int row = dataBegin; row < dataBegin + rows; row++) {
                final ChangeInfo c = getRowItem(row);
                if (ids.containsKey(c.getId())) {
                    displayApprovals(row, ids.get(c.getId()), aic);
                }
            }
        }
    };
}
#end_block

#method_before
public void display(final List<ChangeInfo> changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    }
    if (sz == 0) {
        if (hadData) {
            parent.insertNoneRow(dataBegin);
        }
    } else {
        if (!hadData) {
            parent.removeRow(dataBegin);
        }
        while (rows < sz) {
            parent.insertChangeRow(dataBegin + rows);
            rows++;
        }
        for (int i = 0; i < sz; i++) {
            parent.populateChangeRow(dataBegin + i, changeList.get(i), viewType);
        }
    }
}
#method_after
public void display(final List<ChangeInfo> changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    }
    if (sz == 0) {
        if (hadData) {
            parent.insertNoneRow(dataBegin);
        }
    } else {
        Set<Change.Id> cids = new HashSet<Change.Id>();
        if (!hadData) {
            parent.removeRow(dataBegin);
        }
        while (rows < sz) {
            parent.insertChangeRow(dataBegin + rows);
            rows++;
        }
        for (int i = 0; i < sz; i++) {
            ChangeInfo c = changeList.get(i);
            parent.populateChangeRow(dataBegin + i, c);
            cids.add(c.getId());
        }
        switch(viewType) {
            case NONE:
                break;
            case USER:
                PatchUtil.DETAIL_SVC.userApprovals(cids, ownerId, parent.approvalFormatter(dataBegin, rows));
                break;
            case STRONGEST:
                PatchUtil.DETAIL_SVC.strongestApprovals(cids, parent.approvalFormatter(dataBegin, rows));
                break;
        }
    }
}
#end_block

#method_before
protected final CmdLineParser newCmdLineParserInstance(final Object bean) {
    Field f = null;
    ApproveCmdLineParser parser = new ApproveCmdLineParser(bean);
    try {
        f = CmdOption.class.getField("value");
        for (CmdOption c : optionList) {
            parser.addOption(new FieldSetter(c, f), c);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return parser;
}
#method_after
protected final CmdLineParser newCmdLineParserInstance(final Object bean) {
    CmdLineParser parser = new CmdLineParser(bean);
    for (CmdOption c : optionList) {
        parser.addOption(c, c);
    }
    return parser;
}
#end_block

#method_before
@Override
public final void start() throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            getApprovalNames();
            parseCommandLine();
            PrintWriter p = toPrintWriter(out);
            validateParameters();
            try {
                final Transaction txn = db.beginTransaction();
                final Change.Id cid = new Change.Id(changeId);
                final Change c = db.changes().get(cid);
                StringBuffer sb = new StringBuffer();
                sb.append("Patch Set: ");
                sb.append(c.currentPatchSetId().get());
                sb.append(" ");
                for (CmdOption co : optionList) {
                    String message = "";
                    Short score = co.value();
                    ApprovalCategory.Id category = new ApprovalCategory.Id(co.approvalKey());
                    if (co.value() != null) {
                        addApproval(c, category, co.value(), txn);
                    } else {
                        PatchSetApproval.Key psaKey = new PatchSetApproval.Key(c.currentPatchSetId(), currentUser.getAccountId(), category);
                        PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
                        if (psa == null) {
                            score = null;
                        } else {
                            score = psa.getValue();
                        }
                    }
                    if (score != null) {
                        message = db.approvalCategoryValues().get(new ApprovalCategoryValue.Id(category, score)).getName();
                    }
                    sb.append(" " + message + ";");
                }
                sb.deleteCharAt(sb.length() - 1);
                sb.append("\n\n");
                if (changeComment != null) {
                    sb.append(changeComment);
                }
                String uuid = ChangeUtil.messageUUID(db);
                ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(cid, uuid), currentUser.getAccountId());
                cm.setMessage(sb.toString());
                db.changeMessages().insert(Collections.singleton(cm), txn);
                ChangeUtil.updated(c);
                db.changes().update(Collections.singleton(c), txn);
                txn.commit();
                sendMail(c, c.currentPatchSetId(), cm);
                p.print(sb.toString() + "\n");
                p.flush();
            } catch (OrmException e) {
                throw new Failure(CMD_ERR, "Error accessing the database\n" + "Detailed message:\n" + e.getMessage());
            } catch (EmailException e) {
                throw new Failure(CMD_ERR, "Error when trying to send email\n" + "Detailed message:\n" + e.getMessage());
            } catch (Exception e) {
                throw new Failure(CMD_ERR, "Received an error\n" + "Detailed message:\n" + e.getMessage());
            }
        }
    });
}
#method_after
@Override
public final void start() throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            getApprovalNames();
            parseCommandLine();
            final Transaction txn = db.beginTransaction();
            final PatchSet ps = db.patchSets().get(patchSetId);
            if (ps == null) {
                throw new UnloggedFailure(CMD_ERR, "Invalid patchset id");
            }
            final Change.Id cid = ps.getId().getParentKey();
            final ChangeControl control = changeControlFactory.validateFor(cid);
            final Change c = control.getChange();
            if (c.getStatus().isClosed()) {
                throw new UnloggedFailure(CMD_ERR, "Change is closed.");
            }
            StringBuffer sb = new StringBuffer();
            sb.append("Patch Set ");
            sb.append(patchSetId.get());
            sb.append(": ");
            for (CmdOption co : optionList) {
                ApprovalCategory.Id category = new ApprovalCategory.Id(co.approvalKey());
                PatchSetApproval.Key psaKey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), category);
                PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
                Short score = co.value();
                if (score != null) {
                    addApproval(psaKey, score, c, co, txn);
                } else {
                    if (psa == null) {
                        score = 0;
                        addApproval(psaKey, score, c, co, txn);
                    } else {
                        score = psa.getValue();
                    }
                }
                String message = db.approvalCategoryValues().get(new ApprovalCategoryValue.Id(category, score)).getName();
                sb.append(" " + message + ";");
            }
            sb.deleteCharAt(sb.length() - 1);
            sb.append("\n\n");
            if (changeComment != null) {
                sb.append(changeComment);
            }
            String uuid = ChangeUtil.messageUUID(db);
            ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(cid, uuid), currentUser.getAccountId());
            cm.setMessage(sb.toString());
            db.changeMessages().insert(Collections.singleton(cm), txn);
            ChangeUtil.updated(c);
            db.changes().update(Collections.singleton(c), txn);
            txn.commit();
            sendMail(c, c.currentPatchSetId(), cm);
        }
    });
}
#end_block

#method_before
private void addApproval(final Change c, final ApprovalCategory.Id cat, final short score, final Transaction txn) throws OrmException {
    PatchSetApproval.Key psaKey = new PatchSetApproval.Key(c.currentPatchSetId(), currentUser.getAccountId(), cat);
    PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
    if (psa == null) {
        psa = new PatchSetApproval(psaKey, score);
        db.patchSetApprovals().insert(Collections.singleton(psa), txn);
    } else {
        psa.setGranted();
        psa.setValue(score);
        db.patchSetApprovals().update(Collections.singleton(psa), txn);
    }
}
#method_after
private void addApproval(final PatchSetApproval.Key psaKey, final Short score, final Change c, final CmdOption co, final Transaction txn) throws OrmException, UnloggedFailure {
    PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
    boolean insert = false;
    if (psa == null) {
        insert = true;
        psa = new PatchSetApproval(psaKey, score);
    }
    final List<PatchSetApproval> approvals = Collections.emptyList();
    final FunctionState fs = functionStateFactory.create(c, patchSetId, approvals);
    psa.setValue(score);
    fs.normalize(approvalTypes.getApprovalType(psa.getCategoryId()), psa);
    if (score != psa.getValue()) {
        throw new UnloggedFailure(CMD_ERR, co.name() + "=" + co.value() + " not permitted");
    }
    psa.setGranted();
    if (insert) {
        db.patchSetApprovals().insert(Collections.singleton(psa), txn);
    } else {
        db.patchSetApprovals().update(Collections.singleton(psa), txn);
    }
}
#end_block

#method_before
private void getApprovalNames() throws OrmException {
    SortedMap<Short, String> acvMap = new TreeMap<Short, String>();
    optionList = new ArrayList<CmdOption>();
    ResultSet<ApprovalCategory> rs = db.approvalCategories().all();
    for (ApprovalCategory c : rs) {
        if (c.getFunctionName().equals("MaxWithBlock")) {
            ResultSet<ApprovalCategoryValue> acvrs = db.approvalCategoryValues().byCategory(c.getId());
            short min = Short.MAX_VALUE;
            short max = Short.MIN_VALUE;
            String usage = "";
            for (ApprovalCategoryValue acv : acvrs) {
                if (min > acv.getValue()) {
                    min = acv.getValue();
                }
                if (max < acv.getValue()) {
                    max = acv.getValue();
                }
                acvMap.put(acv.getValue(), acv.getName());
            }
            usage += "Score for " + c.getName() + "\n";
            // This is to make sure that the values are in sorted order.
            Iterator<Short> i = acvMap.keySet().iterator();
            while (i.hasNext()) {
                Short key = i.next();
                usage += String.format("%4d", key) + "  -  " + acvMap.get(key) + "\n";
            }
            optionList.add(new CmdOption("--" + c.getName().toLowerCase().replace(' ', '-'), usage, c.getId().get(), min, max, c.getName()));
            usage = "";
            acvMap.clear();
        }
    }
}
#method_after
private void getApprovalNames() throws OrmException {
    optionList = new ArrayList<CmdOption>();
    for (ApprovalType type : approvalTypes.getApprovalTypes()) {
        String usage = "";
        final ApprovalCategory category = type.getCategory();
        usage = "Score for " + category.getName() + "\n";
        for (ApprovalCategoryValue v : type.getValues()) {
            usage += String.format("%4d", v.getValue()) + "  -  " + v.getName() + "\n";
        }
        optionList.add(new CmdOption("--" + category.getName().toLowerCase().replace(' ', '-'), usage, category.getId().get(), type.getMin().getValue(), type.getMax().getValue(), category.getName()));
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either side,
    // expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null);
    add(historyPanel);
    initDisplayControls();
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    contentPanel = new FlowPanel();
    contentPanel.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(createNextPrevLinks());
    // This must be done after calling createNextPrevLinks(), which initializes these fields
    if (previousFileLink != null) {
        installLinkShortCut(previousFileLink, SHORTCUT_PREVIOUS_FILE, PatchUtil.C.previousFileHelp());
    }
    if (nextFileLink != null) {
        installLinkShortCut(nextFileLink, SHORTCUT_NEXT_FILE, PatchUtil.C.nextFileHelp());
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either side,
    // expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null);
    add(historyPanel);
    initDisplayControls();
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    contentPanel = new FlowPanel();
    contentPanel.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(createNextPrevLinks());
    // This must be done after calling createNextPrevLinks(), which initializes these fields
    if (previousFileLink != null) {
        installLinkShortCut(previousFileLink, SHORTCUT_PREVIOUS_FILE, PatchUtil.C.previousFileHelp());
    }
    if (nextFileLink != null) {
        installLinkShortCut(nextFileLink, SHORTCUT_NEXT_FILE, PatchUtil.C.nextFileHelp());
    }
}
#end_block

#method_before
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                if (caught instanceof RemoteJsonException && !isFirst) {
                    historyTable.enableAll(true);
                    showPatch(false);
                } else {
                    super.onFailure(caught);
                }
            }
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#method_after
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#end_block

#method_before
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        if (contentTable instanceof SideBySideTable && script.getEdits().isEmpty() && !script.getPatchHeader().isEmpty()) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#method_after
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        // True if there are differences between the two patch sets
        boolean hasEdits = !script.getEdits().isEmpty();
        // True if this change is a mode change or a pure rename/copy
        boolean hasMeta = !script.getPatchHeader().isEmpty();
        boolean hasDifferences = hasEdits || hasMeta;
        boolean pureMetaChange = !hasEdits && hasMeta;
        if (contentTable instanceof SideBySideTable && pureMetaChange) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        if (hasDifferences) {
            contentTable.display(patchKey, idSideA, idSideB, script);
            contentTable.display(comments);
            contentTable.finishDisplay();
        }
        showPatch(hasDifferences);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#end_block

#method_before
private ResultSet<Change> searchQuery(final ReviewDb db, String query, final int limit, final String key, final Comparator<Change> cmp) throws OrmException {
    final HashSet<Change.Id> want = new HashSet<Change.Id>();
    query = query.trim();
    if (query.matches("^[1-9][0-9]*$")) {
        want.add(Change.Id.parse(query));
    } else if (query.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$")) {
        final RevId id = new RevId(query);
        final ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        for (PatchSet p : patches) {
            want.add(p.getId().getParentKey());
        }
    }
    if (want.isEmpty()) {
        return new ListResultSet<Change>(Collections.<Change>emptyList());
    }
    List<Change> result = new ArrayList<Change>();
    final ResultSet<Change> rs = db.changes().get(want);
    if (cmp == QUERY_PREV) {
        for (Change c : rs) {
            if (c.getSortKey().compareTo(key) > 0) {
                result.add(c);
            }
        }
    } else /* cmp == QUERY_NEXT */
    {
        for (Change c : rs) {
            if (c.getSortKey().compareTo(key) < 0) {
                result.add(c);
            }
        }
    }
    Collections.sort(result, cmp);
    if (limit < result.size()) {
        // GWT emulation unfortunately lacks subList(int,int).
        // 
        final List<Change> r = new ArrayList<Change>(limit);
        for (int i = 0; i < limit; i++) {
            r.add(result.get(i));
        }
        result = r;
    }
    return new ListResultSet<Change>(result);
}
#method_after
private ResultSet<Change> searchQuery(final ReviewDb db, String query, final int limit, final String key, final Comparator<Change> cmp) throws OrmException {
    List<Change> result = new ArrayList<Change>();
    final HashSet<Change.Id> want = new HashSet<Change.Id>();
    query = query.trim();
    if (query.matches("^[1-9][0-9]*$")) {
        want.add(Change.Id.parse(query));
    } else if (query.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$")) {
        final RevId id = new RevId(query);
        final ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        for (PatchSet p : patches) {
            want.add(p.getId().getParentKey());
        }
    } else if (query.contains("owner:")) {
        String[] parsedQuery = query.split(":");
        if (parsedQuery.length > 1) {
            filterBySortKey(result, changesCreatedBy(db, parsedQuery[1]), cmp, key);
        }
    } else if (query.contains("reviewer:")) {
        String[] parsedQuery = query.split(":");
        if (parsedQuery.length > 1) {
            want.addAll(changesReviewedBy(db, parsedQuery[1]));
        }
    }
    if (result.isEmpty() && want.isEmpty()) {
        return new ListResultSet<Change>(Collections.<Change>emptyList());
    }
    filterBySortKey(result, db.changes().get(want), cmp, key);
    Collections.sort(result, cmp);
    if (limit < result.size()) {
        // GWT emulation unfortunately lacks subList(int,int).
        // 
        final List<Change> r = new ArrayList<Change>(limit);
        for (int i = 0; i < limit; i++) {
            r.add(result.get(i));
        }
        result = r;
    }
    return new ListResultSet<Change>(result);
}
#end_block

#method_before
public void changesCreatedBy(final String userName, final AsyncCallback<SingleListChangeInfo> callback) {
    run(callback, new UserNameAction(userName) {

        @Override
        void process(ReviewDb db, AccountInfoCacheFactory ac, Account account, Map<Id, Change> resultChanges) throws OrmException {
            final Set<Change> changes = createdBy(db, account.getId());
            ac.want(account.getId());
            for (Change change : changes) {
                resultChanges.put(change.getId(), change);
            }
        }
    });
}
#method_after
private List<Change> changesCreatedBy(final ReviewDb db, final String userName) throws OrmException {
    final List<Change> resultChanges = new ArrayList<Change>();
    for (Account.Id account : getAccountSources(db, userName)) {
        for (Change change : db.changes().byOwnerOpen(account)) {
            resultChanges.add(change);
        }
        for (Change change : db.changes().byOwnerClosedAll(account)) {
            resultChanges.add(change);
        }
    }
    return resultChanges;
}
#end_block

#method_before
// 
// UserNameAction
// ///
public void changesReviewedBy(final String userName, final AsyncCallback<SingleListChangeInfo> callback) {
    run(callback, new UserNameAction(userName) {

        @Override
        void process(ReviewDb db, AccountInfoCacheFactory ac, Account account, Map<Id, Change> outResultChanges) throws OrmException {
            ChangeApprovalAccess changes = db.changeApprovals();
            ChangeAccess changeAccess = db.changes();
            Iterator<ChangeApproval> changeIterator = changes.reviewedByUser(account.getId()).iterator();
            while (changeIterator.hasNext()) {
                ChangeApproval approval = changeIterator.next();
                Change change = changeAccess.get(approval.getChangeId());
                // This will return null if the change was submitted
                if (change != null) {
                    outResultChanges.put(change.getId(), change);
                }
            }
        }
    });
}
#method_after
private Set<Change.Id> changesReviewedBy(final ReviewDb db, final String userName) throws OrmException {
    final Set<Change.Id> resultChanges = new HashSet<Change.Id>();
    for (Account.Id account : getAccountSources(db, userName)) {
        for (ChangeApproval a : db.changeApprovals().openByUser(account)) {
            resultChanges.add(a.getChangeId());
        }
        for (ChangeApproval a : db.changeApprovals().closedByUserAll(account)) {
            resultChanges.add(a.getChangeId());
        }
    }
    return resultChanges;
}
#end_block

#method_before
private void populateAbandonAction() {
    final Button b = new Button(Util.C.buttonAbandonChangeBegin());
    b.addClickListener(new ClickListener() {

        public void onClick(Widget sender) {
            b.setEnabled(false);
            new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<Object>() {

                public void onSuccess(Object result) {
                    actionsPanel.remove(b);
                    fireOnSuggestRefresh();
                }

                public void onFailure(Throwable caught) {
                    b.setEnabled(true);
                }
            }).center();
        }
    });
    actionsPanel.add(b);
}
#method_after
private void populateAbandonAction() {
    final Button b = new Button(Util.C.buttonAbandonChangeBegin());
    b.addClickListener(new ClickListener() {

        public void onClick(Widget sender) {
            new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<Object>() {

                public void onSuccess(Object result) {
                    actionsPanel.remove(b);
                    fireOnSuggestRefresh();
                }

                public void onFailure(Throwable caught) {
                }
            }).center();
        }
    });
    actionsPanel.add(b);
}
#end_block

#method_before
public void changeDetail(final Change.Id id, final AsyncCallback<ChangeDetail> callback) {
    run(callback, new Action<ChangeDetail>() {

        public ChangeDetail run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(id);
            final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
            final Project proj = db.projects().get(change.getDest().getParentKey());
            if (change == null || patch == null || proj == null) {
                throw new Failure(new NoSuchEntityException());
            }
            assertCanRead(change);
            final boolean anon;
            boolean canAbandon = false;
            if (me == null) {
                // Safe assumption, this wouldn't be allowed if it wasn't.
                // 
                anon = true;
            } else {
                // Ask if the anonymous user can read this project; even if
                // we can that doesn't mean the anonymous user could.
                // 
                anon = canRead(null, change.getDest().getParentKey());
                // The change owner, current patchset uploader, Gerrit administrator,
                // and project administrator can mark the change as abandoned.
                // 
                canAbandon = me.equals(change.getOwner()) || me.equals(patch.getUploader()) || Common.getGroupCache().isAdministrator(me) || Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId());
            }
            final ChangeDetail d = new ChangeDetail();
            d.load(db, new AccountInfoCacheFactory(db), change, anon, canAbandon);
            return d;
        }
    });
}
#method_after
public void changeDetail(final Change.Id id, final AsyncCallback<ChangeDetail> callback) {
    run(callback, new Action<ChangeDetail>() {

        public ChangeDetail run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(id);
            if (change == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
            final ProjectCache.Entry projEnt = Common.getProjectCache().get(change.getDest().getParentKey());
            if (patch == null || projEnt == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final Project proj = projEnt.getProject();
            assertCanRead(change);
            final boolean anon;
            boolean canAbandon = false;
            if (me == null) {
                // Safe assumption, this wouldn't be allowed if it wasn't.
                // 
                anon = true;
            } else {
                // Ask if the anonymous user can read this project; even if
                // we can that doesn't mean the anonymous user could.
                // 
                anon = canRead(null, change.getDest().getParentKey());
                // The change owner, current patchset uploader, Gerrit administrator,
                // and project administrator can mark the change as abandoned.
                // 
                canAbandon = me.equals(change.getOwner()) || me.equals(patch.getUploader()) || Common.getGroupCache().isAdministrator(me) || Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId());
            }
            final ChangeDetail d = new ChangeDetail();
            d.load(db, new AccountInfoCacheFactory(db), change, anon, canAbandon);
            return d;
        }
    });
}
#end_block

#method_before
public void abandonChange(final String message, final PatchSet.Id patchSetId, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(patchSetId.getParentKey());
            final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
            final Project proj = db.projects().get(change.getDest().getParentKey());
            if (me == null || change == null || patch == null || proj == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (!me.equals(change.getOwner()) && !me.equals(patch.getUploader()) && !Common.getGroupCache().isAdministrator(me) && !Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId())) {
                // The user doesn't have permission to abandon the change
                throw new Failure(new NoSuchEntityException());
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me);
            final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
            if (message != null && message.length() > 0) {
                msgBuf.append("\n\n");
                msgBuf.append(message);
            }
            cmsg.setMessage(msgBuf.toString());
            db.run(new OrmRunnable<VoidResult, ReviewDb>() {

                public VoidResult run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doAbandonChange(message, change, cmsg, db, txn);
                }
            });
            // Email the reviewers
            try {
                final ChangeMail cm = new ChangeMail(server, change);
                cm.setFrom(Common.getAccountId());
                cm.setReviewDb(db);
                cm.setChangeMessage(cmsg);
                cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                cm.sendAbandoned();
            } catch (MessagingException e) {
                log.error("Cannot send abandon change email for change " + change.getChangeId(), e);
                throw new Failure(e);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void abandonChange(final PatchSet.Id patchSetId, final String message, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(patchSetId.getParentKey());
            if (change == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final PatchSet patch = db.patchSets().get(patchSetId);
            final ProjectCache.Entry projEnt = Common.getProjectCache().get(change.getDest().getParentKey());
            if (me == null || patch == null || projEnt == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final Project proj = projEnt.getProject();
            if (!me.equals(change.getOwner()) && !me.equals(patch.getUploader()) && !Common.getGroupCache().isAdministrator(me) && !Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId())) {
                // The user doesn't have permission to abandon the change
                throw new Failure(new NoSuchEntityException());
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me);
            final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
            if (message != null && message.length() > 0) {
                msgBuf.append("\n\n");
                msgBuf.append(message);
            }
            cmsg.setMessage(msgBuf.toString());
            Boolean dbSuccess = db.run(new OrmRunnable<Boolean, ReviewDb>() {

                public Boolean run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doAbandonChange(message, change, patchSetId, cmsg, db, txn);
                }
            });
            if (dbSuccess) {
                // Email the reviewers
                try {
                    final ChangeMail cm = new ChangeMail(server, change);
                    cm.setFrom(me);
                    cm.setReviewDb(db);
                    cm.setChangeMessage(cmsg);
                    cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                    cm.sendAbandoned();
                } catch (MessagingException e) {
                    log.error("Cannot send abandon change email for change " + change.getChangeId(), e);
                    throw new Failure(e);
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
private VoidResult doAbandonChange(final String message, final Change change, final ChangeMessage cm, final ReviewDb db, final Transaction txn) throws OrmException {
    if (change.getStatus() == Change.Status.NEW) {
        change.setStatus(Change.Status.ABANDONED);
        ChangeUtil.updated(change);
    }
    db.changeMessages().insert(Collections.singleton(cm), txn);
    db.changes().update(Collections.singleton(change), txn);
    return VoidResult.INSTANCE;
}
#method_after
private Boolean doAbandonChange(final String message, final Change change, final PatchSet.Id psid, final ChangeMessage cm, final ReviewDb db, final Transaction txn) throws OrmException {
    // changed while the user was typing an abandon message
    if (change.getStatus() == Change.Status.NEW && change.currentPatchSetId().equals(psid)) {
        change.setStatus(Change.Status.ABANDONED);
        ChangeUtil.updated(change);
        final List<ChangeApproval> approvals = db.changeApprovals().byChange(change.getId()).toList();
        for (ChangeApproval a : approvals) {
            a.cache(change);
        }
        db.changeApprovals().update(approvals, txn);
        db.changeMessages().insert(Collections.singleton(cm), txn);
        db.changes().update(Collections.singleton(change), txn);
        return Boolean.TRUE;
    }
    return Boolean.FALSE;
}
#end_block

#method_before
private void initUI() {
    addStyleName("gerrit-ChangeScreen");
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    dependencies = new ChangeTable();
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    approvals = new ApprovalTable(changeId);
    approvalsPanel = new DisclosurePanel(Util.C.changeScreenApprovals());
    approvalsPanel.setContent(wrap(approvals));
    dependenciesPanel.setWidth("95%");
    add(approvalsPanel);
    patchSetPanels = new FlowPanel();
    add(patchSetPanels);
    messagesContent = new FlowPanel();
    messagesContent.setStyleName("gerrit-ChangeMessages");
    messagesPanel = new DisclosurePanel(Util.C.changeScreenMessages());
    messagesPanel.setContent(messagesContent);
    add(messagesPanel);
}
#method_after
private void initUI() {
    addStyleName("gerrit-ChangeScreen");
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    dependencies = new ChangeTable();
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    approvals = new ApprovalTable();
    approvalsPanel = new DisclosurePanel(Util.C.changeScreenApprovals());
    approvalsPanel.setContent(wrap(approvals));
    dependenciesPanel.setWidth("95%");
    add(approvalsPanel);
    patchSetPanels = new FlowPanel();
    add(patchSetPanels);
    messagesContent = new FlowPanel();
    messagesContent.setStyleName("gerrit-ChangeMessages");
    messagesPanel = new DisclosurePanel(Util.C.changeScreenMessages());
    messagesPanel.setContent(messagesContent);
    add(messagesPanel);
}
#end_block

#method_before
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getSubject());
    refreshOnSignIn = !detail.getChange().getStatus().isClosed();
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getMissingApprovals(), detail.getApprovals());
    addPatchSets(detail);
    addMessages(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    approvalsPanel.setOpen(true);
}
#method_after
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getSubject());
    refreshOnSignIn = !detail.getChange().getStatus().isClosed();
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getChange(), detail.getMissingApprovals(), detail.getApprovals());
    addPatchSets(detail);
    addMessages(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    approvalsPanel.setOpen(true);
}
#end_block

#method_before
public void sendRequestReview() throws MessagingException {
    if (begin("requestReview")) {
        final Account a = Common.getAccountCache().get(fromId);
        if (a == null) {
            body.append("A Gerrit user");
        } else {
            final String e = a.getFullName();
            body.append(e);
        }
        body.append(" has requested that you review a change\n\n");
        if (changeUrl() != null) {
            openFooter();
            body.append("To respond visit ");
            body.append(changeUrl());
            body.append("\n");
        }
        initInReplyToChange();
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
        if (fromId != null) {
            add(RecipientType.CC, fromId);
        }
        send();
    }
}
#method_after
public void sendRequestReview() throws MessagingException {
    if (begin("requestReview")) {
        final Account a = Common.getAccountCache().get(fromId);
        if (a == null || a.getFullName() == null || a.getFullName().length() == 0) {
            body.append("A Gerrit user");
        } else {
            body.append(a.getFullName());
        }
        body.append(" has requested that you review a change:\n\n");
        body.append(change.getChangeId());
        body.append(" - ");
        body.append(change.getSubject());
        body.append("\n\n");
        if (changeUrl() != null) {
            openFooter();
            body.append("To respond visit ");
            body.append(changeUrl());
            body.append("\n");
        }
        initInReplyToChange();
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
        if (fromId != null) {
            add(RecipientType.CC, fromId);
        }
        send();
    }
}
#end_block

#method_before
private String changeMessageThreadId() {
    final StringBuilder r = new StringBuilder();
    r.append('<');
    r.append("gerrit");
    r.append('.');
    r.append(change.getCreatedOn().getTime());
    r.append('.');
    r.append(change.getChangeId());
    if (fromId != null) {
        r.append('.');
        r.append(fromId.get());
    }
    r.append('@');
    r.append(gerritHost());
    r.append('>');
    return r.toString();
}
#method_after
private String changeMessageThreadId() {
    final StringBuilder r = new StringBuilder();
    r.append('<');
    r.append("gerrit");
    r.append('.');
    r.append(change.getCreatedOn().getTime());
    r.append('.');
    r.append(change.getChangeId());
    r.append('@');
    r.append(gerritHost());
    r.append('>');
    return r.toString();
}
#end_block

#method_before
public void display(final Set<ApprovalCategory.Id> need, final List<ApprovalDetail> rows) {
    final int oldcnt = table.getRowCount();
    table.resizeRows(1 + rows.size());
    if (oldcnt < 1 + rows.size()) {
        for (int row = oldcnt; row < 1 + rows.size(); row++) {
            applyEdgeStyles(row);
            applyScoreStyles(row);
        }
    }
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        table.setVisible(true);
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i));
        }
    }
    missing.clear();
    missing.setVisible(false);
    if (need != null) {
        for (final ApprovalType at : types) {
            if (need.contains(at.getCategory().getId())) {
                final Label l = new Label(Util.M.needApproval(at.getCategory().getName()));
                l.setStyleName("gerrit-Change-MissingApproval");
                missing.add(l);
                missing.setVisible(true);
            }
        }
    }
    addReviewer.clear();
    if (need != null && Gerrit.isSignedIn()) {
        final Label l = new Label(Util.C.approvalTableAddReviewer());
        l.setStyleName("gerrit-Change-AddReviewer");
        addReviewer.add(l);
        addReviewer.add(addMemberBox);
    }
}
#method_after
public void display(final Change change, final Set<ApprovalCategory.Id> need, final List<ApprovalDetail> rows) {
    changeId = change.getId();
    final int oldcnt = table.getRowCount();
    table.resizeRows(1 + rows.size());
    if (oldcnt < 1 + rows.size()) {
        for (int row = oldcnt; row < 1 + rows.size(); row++) {
            applyEdgeStyles(row);
            applyScoreStyles(row);
        }
    }
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        table.setVisible(true);
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i));
        }
    }
    missing.clear();
    missing.setVisible(false);
    if (need != null) {
        for (final ApprovalType at : types) {
            if (need.contains(at.getCategory().getId())) {
                final Label l = new Label(Util.M.needApproval(at.getCategory().getName()));
                l.setStyleName("gerrit-Change-MissingApproval");
                missing.add(l);
                missing.setVisible(true);
            }
        }
    }
    changeIsOpen = change.getStatus().isOpen();
    addReviewer.setVisible(Gerrit.isSignedIn() && changeIsOpen);
}
#end_block

#method_before
private void doAddReviewer() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail == null || nameEmail.length() == 0 || com.google.gerrit.client.admin.Util.C.defaultAccountName().equals(nameEmail)) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = Arrays.asList(nameEmail.split(";"));
    Util.DETAIL_SVC.addReviewers(reviewers, changeId, new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddReviewer() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = new ArrayList<String>();
    reviewers.add(nameEmail);
    PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

