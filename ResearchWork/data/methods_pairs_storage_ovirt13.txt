987
#method_before
@Override
public Response iscsiLogin(Action action) {
    validateParameters(action, "iscsi.address", "iscsi.target");
    StorageServerConnections cnx = new StorageServerConnections();
    IscsiDetails iscsiDetails = action.getIscsi();
    cnx.setConnection(iscsiDetails.getAddress());
    cnx.setIqn(iscsiDetails.getTarget());
    cnx.setStorageType(StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        cnx.setPort(iscsiDetails.getPort().toString());
    } else {
        cnx.setPort(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetPortal()) {
        cnx.setPortal(iscsiDetails.getPortal().toString());
    }
    if (iscsiDetails.isSetUsername()) {
        cnx.setUserName(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        cnx.setPassword(iscsiDetails.getPassword());
    }
    StorageServerConnectionParametersBase connectionParms = new StorageServerConnectionParametersBase(cnx, guid, false);
    return doAction(ActionType.ConnectStorageToVds, connectionParms, action);
}
#method_after
@Override
public Response iscsiLogin(Action action) {
    validateParameters(action, "iscsi.address", "iscsi.target");
    StorageServerConnections cnx = new StorageServerConnections();
    IscsiDetails iscsiDetails = action.getIscsi();
    cnx.setConnection(iscsiDetails.getAddress());
    cnx.setIqn(iscsiDetails.getTarget());
    cnx.setStorageType(StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        cnx.setPort(iscsiDetails.getPort().toString());
    } else {
        cnx.setPort(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetPortal()) {
        cnx.setPortal(iscsiDetails.getPortal());
    }
    if (iscsiDetails.isSetUsername()) {
        cnx.setUserName(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        cnx.setPassword(iscsiDetails.getPassword());
    }
    StorageServerConnectionParametersBase connectionParms = new StorageServerConnectionParametersBase(cnx, guid, false);
    return doAction(ActionType.ConnectStorageToVds, connectionParms, action);
}
#end_block

#method_before
void logRenamedEntity() {
    if (getCurrentUser() != null && this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogable logable = new AuditLogableImpl();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#method_after
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogable logable = new AuditLogableImpl();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            if (getCurrentUser() != null) {
                logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            }
            renameable.setEntityId(logable);
            auditLog(logable, getCurrentUser() != null ? AuditLogType.ENTITY_RENAMED : AuditLogType.ENTITY_RENAMED_INTERNALLY);
        }
    }
}
#end_block

#method_before
public AnsibleReturnValue runCommand(AnsibleCommandBuilder command, int timeout, Pair<String, String>... envVars) throws IOException, InterruptedException {
    log.trace("Enter AnsibleExecutor::runCommand");
    AnsibleReturnValue returnValue = new AnsibleReturnValue(AnsibleReturnCode.ERROR);
    Path inventoryFile = null;
    try {
        // Create a temporary inventory file if user didn't specified it:
        inventoryFile = createInventoryFile(command);
        // Build the command:
        log.info("Executing Ansible command: {}", command);
        List<String> ansibleCommand = command.build();
        ProcessBuilder ansibleProcessBuilder = new ProcessBuilder().command(ansibleCommand).directory(command.playbookDir().toFile());
        // Set environment variables:
        ansibleProcessBuilder.environment().put("ANSIBLE_CONFIG", Paths.get(command.playbookDir().toString(), "ansible.cfg").toString());
        if (command.enableLogging()) {
            ansibleProcessBuilder.environment().put("ANSIBLE_LOG_PATH", command.logFile().toString());
        }
        for (Pair<String, String> envVar : envVars) {
            ansibleProcessBuilder.environment().put(envVar.getFirst(), envVar.getSecond());
        }
        // Execute the command:
        Process ansibleProcess = ansibleProcessBuilder.start();
        ansibleProcess.waitFor(timeout, TimeUnit.MINUTES);
        returnValue.setAnsibleReturnCode(AnsibleReturnCode.values()[ansibleProcess.exitValue()]);
        returnValue.setStdout(IOUtils.toString(ansibleProcess.getInputStream()));
        ansibleProcess.destroy();
    } finally {
        log.info("Ansible playbook command has exited with value: {}", returnValue.getAnsibleReturnCode());
        removeFile(inventoryFile);
    }
    log.trace("Exit AnsibleExecutor::runCommand");
    return returnValue;
}
#method_after
public AnsibleReturnValue runCommand(AnsibleCommandBuilder command) throws IOException, InterruptedException {
    return runCommand(command, ANSIBLE_PLAYBOOK_TIMEOUT);
}
#end_block

#method_before
@Override
public String toString() {
    return StringUtils.join(build(), " ");
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    // Env vars:
    sb.append(envVars.entrySet().stream().map(entry -> entry.getKey() + "=" + entry.getValue()).collect(Collectors.joining(" ")));
    // Command:
    sb.append(" ");
    sb.append(build());
    sb.append(" ");
    // Log file
    sb.append(String.format("[Logfile: %1$s]", logFile()));
    return sb.toString();
}
#end_block

#method_before
protected void updateInternal() {
    if (!(getContainer().isNewStorage() || getContainer().isStorageActive())) {
        return;
    }
    VDS host = getContainer().getHost().getSelectedItem();
    if (host == null) {
        proposeDiscover();
        return;
    }
    final Collection<EntityModel<?>> prevSelected = Linq.findSelectedItems((Collection<EntityModel<?>>) getSelectedItem());
    clearItems();
    initializeItems(null, null);
    final SanStorageModelBase model = this;
    AsyncQuery<QueryReturnValue> asyncQuery = new AsyncQuery<>(response -> {
        if (response.getSucceeded()) {
            boolean isInMaintenance = false;
            Set<String> metadata = null;
            if (!model.getContainer().isNewStorage()) {
                isInMaintenance = model.getContainer().getStorage().getStatus() == StorageDomainStatus.Maintenance;
                metadata = model.getMetadataDevices();
            }
            model.applyData(isInMaintenance, metadata, (ArrayList<LUNs>) response.getReturnValue(), false, prevSelected);
            // $NON-NLS-1$
            model.setGetLUNsFailure("");
        } else {
            model.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
        }
    }, true);
    Frontend.getInstance().runQuery(QueryType.GetDeviceList, new GetDeviceListQueryParameters(host.getId(), getType(), false, null, false), asyncQuery);
}
#method_after
protected void updateInternal() {
    if (!(getContainer().isNewStorage() || getContainer().isStorageActive())) {
        return;
    }
    VDS host = getContainer().getHost().getSelectedItem();
    if (host == null) {
        proposeDiscover();
        return;
    }
    final Collection<EntityModel<?>> prevSelected = Linq.findSelectedItems((Collection<EntityModel<?>>) getSelectedItem());
    clearItems();
    initializeItems(null, null);
    final SanStorageModelBase model = this;
    AsyncQuery<QueryReturnValue> asyncQuery = new AsyncQuery<>(response -> {
        if (response.getSucceeded()) {
            setValuesForMaintenance(model);
            model.applyData((ArrayList<LUNs>) response.getReturnValue(), false, prevSelected, isInMaintenance, metadata);
            // $NON-NLS-1$
            model.setGetLUNsFailure("");
        } else {
            model.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
        }
    }, true);
    Frontend.getInstance().runQuery(QueryType.GetDeviceList, new GetDeviceListQueryParameters(host.getId(), getType(), false, null, false), asyncQuery);
}
#end_block

#method_before
public void applyData(boolean isInMaintenance, Set<String> metadataDevices, List<LUNs> source, boolean isIncluded, Collection<EntityModel<?>> selectedItems) {
    ArrayList<LunModel> newItems = new ArrayList<>();
    for (LUNs a : source) {
        if (a.getLunType() == getType() || a.getLunType() == StorageType.UNKNOWN) {
            ArrayList<SanTargetModel> targets = createTargetModelList(a);
            LunModel lunModel = new LunModel();
            lunModel.setLunId(a.getLUNId());
            lunModel.setVendorId(a.getVendorId());
            lunModel.setProductId(a.getProductId());
            lunModel.setSerial(a.getSerial());
            lunModel.setMultipathing(a.getPathCount());
            lunModel.setTargets(targets);
            lunModel.setSize(a.getDeviceSize());
            lunModel.setAdditionalAvailableSize(getAdditionalAvailableSize(a));
            lunModel.setAdditionalAvailableSizeSelected(false);
            lunModel.setRemoveLunSelected(false);
            lunModel.setIsAccessible(a.getAccessible());
            lunModel.setStatus(a.getStatus());
            lunModel.setIsIncluded(isIncluded);
            lunModel.setIsSelected(containsLun(lunModel, selectedItems, isIncluded));
            lunModel.setEntity(a);
            // Add LunModel
            newItems.add(lunModel);
            // Update isGrayedOut and grayedOutReason properties
            updateGrayedOut(isInMaintenance, metadataDevices, lunModel);
            // Remember included LUNs to prevent their removal while updating items.
            if (isIncluded) {
                includedLUNs.add(lunModel);
            }
        }
    }
    initializeItems(newItems, null);
    proposeDiscover();
}
#method_after
public void applyData(List<LUNs> source, boolean isIncluded, Collection<EntityModel<?>> selectedItems, boolean isInMaintenance, Set<String> metadataDevices) {
    ArrayList<LunModel> newItems = new ArrayList<>();
    for (LUNs a : source) {
        if (a.getLunType() == getType() || a.getLunType() == StorageType.UNKNOWN) {
            ArrayList<SanTargetModel> targets = createTargetModelList(a);
            LunModel lunModel = new LunModel();
            lunModel.setLunId(a.getLUNId());
            lunModel.setVendorId(a.getVendorId());
            lunModel.setProductId(a.getProductId());
            lunModel.setSerial(a.getSerial());
            lunModel.setMultipathing(a.getPathCount());
            lunModel.setTargets(targets);
            lunModel.setSize(a.getDeviceSize());
            lunModel.setAdditionalAvailableSize(getAdditionalAvailableSize(a));
            lunModel.setAdditionalAvailableSizeSelected(false);
            lunModel.setRemoveLunSelected(false);
            lunModel.setIsAccessible(a.getAccessible());
            lunModel.setStatus(a.getStatus());
            lunModel.setIsIncluded(isIncluded);
            lunModel.setIsSelected(containsLun(lunModel, selectedItems, isIncluded));
            lunModel.setEntity(a);
            // Add LunModel
            newItems.add(lunModel);
            // Update isGrayedOut and grayedOutReason properties
            updateGrayedOut(isInMaintenance, metadataDevices, lunModel);
            // Remember included LUNs to prevent their removal while updating items.
            if (isIncluded) {
                includedLUNs.add(lunModel);
            }
        }
    }
    initializeItems(newItems, null);
    proposeDiscover();
}
#end_block

#method_before
private void postPrepareSanStorageForEdit(final SanStorageModelBase model, boolean isStorageActive, StorageDomain storage) {
    model.setStorageDomain(storage);
    VDS host = getContainer().getHost().getSelectedItem();
    if (Objects.equals(previousGetLunsByVGIdHost, host) && isStorageActive) {
        return;
    }
    previousGetLunsByVGIdHost = host;
    Guid hostId = host != null && isStorageActive ? host.getId() : null;
    boolean isInMaintenance = false;
    Set<String> metadata = null;
    if (!model.getContainer().isNewStorage()) {
        isInMaintenance = model.getContainer().getStorage().getStatus() == StorageDomainStatus.Maintenance;
        metadata = model.getMetadataDevices();
    }
    boolean finalIsInMaintenance = isInMaintenance;
    Set<String> finalMetadata = metadata;
    AsyncDataProvider.getInstance().getLunsByVgId(new AsyncQuery<>(lunList -> model.applyData(finalIsInMaintenance, finalMetadata, lunList, true, Linq.findSelectedItems((Collection<EntityModel<?>>) getSelectedItem()))), storage.getStorage(), hostId);
}
#method_after
private void postPrepareSanStorageForEdit(final SanStorageModelBase model, boolean isStorageActive, StorageDomain storage) {
    model.setStorageDomain(storage);
    VDS host = getContainer().getHost().getSelectedItem();
    if (Objects.equals(previousGetLunsByVGIdHost, host) && isStorageActive) {
        return;
    }
    previousGetLunsByVGIdHost = host;
    Guid hostId = host != null && isStorageActive ? host.getId() : null;
    setValuesForMaintenance(model);
    AsyncDataProvider.getInstance().getLunsByVgId(new AsyncQuery<>(lunList -> model.applyData(lunList, true, Linq.findSelectedItems((Collection<EntityModel<?>>) getSelectedItem()), isInMaintenance, metadata)), storage.getStorage(), hostId);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VM vm = getOvaInfoUsingAnsible();
    setReturnValue(vm);
    getQueryReturnValue().setSucceeded(vm != null);
}
#method_after
@Override
protected void executeQueryCommand() {
    String stdout = runAnsibleQueryOvaInfoPlaybook();
    String ovf = parseOvfFromStdout(stdout);
    boolean originOvirt = ovf.contains("xmlns:ovirt");
    VM vm = null;
    try {
        vm = readVmFromOva(ovf);
    } catch (Exception e) {
        if (originOvirt) {
            log.debug("failed to parse a given ovf configuration: \n" + ovf, e);
            getQueryReturnValue().setExceptionString("failed to parse a given ovf configuration " + e.getMessage());
        }
    }
    if (!originOvirt && vm == null) {
        // If we fail to parse an OVF that resides within an OVA generated by others,
        // let's try the old-way, using the minimal parsing of OVF in VDSM
        vm = getVmInfoFromOvaFile();
    }
    if (originOvirt && vm != null) {
        vm.setOrigin(OriginType.OVIRT);
    }
    setReturnValue(vm);
    getQueryReturnValue().setSucceeded(vm != null);
}
#end_block

#method_before
private Object getVmInfoFromOvaFile() {
    return runVdsCommand(VDSCommandType.GetOvaInfo, buildGetOvaInfoParameters()).getReturnValue();
}
#method_after
private VM getVmInfoFromOvaFile() {
    return (VM) runVdsCommand(VDSCommandType.GetOvaInfo, buildGetOvaInfoParameters()).getReturnValue();
}
#end_block

#method_before
private String runAnsibleQueryOvaInfoPlaybook() {
    AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(vdsStaticDao.get(getParameters().getVdsId()).getHostName()).variables(new Pair<>("ovirt_query_ova_path", getParameters().getPath())).enableLogging(false).playbook(AnsibleConstants.QUERY_OVA_PLAYBOOK);
    boolean succeeded = false;
    AnsibleReturnValue ansibleReturnValue = null;
    try {
        ansibleReturnValue = ansibleExecutor.runCommand(command);
        succeeded = ansibleReturnValue.getAnsibleReturnCode() == AnsibleReturnCode.OK;
    } catch (IOException | InterruptedException e) {
        log.debug("Failed to query OVA info", e);
        return null;
    }
    if (!succeeded) {
        log.error("Failed to query OVA info. Error: {}", command.logFile());
        return null;
    }
    return ansibleReturnValue.getStdout();
}
#method_after
private String runAnsibleQueryOvaInfoPlaybook() {
    AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(vdsStaticDao.get(getParameters().getVdsId()).getHostName()).variables(new Pair<>("ovirt_query_ova_path", getParameters().getPath())).enableLogging(false).playbook(AnsibleConstants.QUERY_OVA_PLAYBOOK);
    boolean succeeded = false;
    AnsibleReturnValue ansibleReturnValue = null;
    try {
        ansibleReturnValue = ansibleExecutor.runCommand(command);
        succeeded = ansibleReturnValue.getAnsibleReturnCode() == AnsibleReturnCode.OK;
    } catch (IOException | InterruptedException e) {
        log.debug("Failed to query OVA info", e);
    }
    if (!succeeded) {
        log.error("Failed to query OVA info");
        throw new EngineException(EngineError.GeneralException, "Failed to query OVA info");
    }
    return ansibleReturnValue.getStdout();
}
#end_block

#method_before
private String parseOvfFromStdout(String stdout) {
    if (stdout == null) {
        return null;
    }
    Matcher m = OVF_PATTERN.matcher(stdout);
    if (m.matches() && m.groupCount() > 0) {
        String ovf = m.group(1);
        ovf = ovf.replaceAll("\\\\\"", "\"");
        log.info(ovf);
        return ovf;
    }
    log.error("Failed to parse OVF from:\n{}", stdout);
    return null;
}
#method_after
private String parseOvfFromStdout(String stdout) {
    if (stdout == null) {
        return null;
    }
    Matcher m = OVF_PATTERN.matcher(stdout);
    if (m.matches() && m.groupCount() > 0) {
        String ovf = m.group(1);
        ovf = ovf.replaceAll("\\\\\"", "\"");
        log.info("Retrieved the following OVF from OVA '{}':\n {}", getParameters().getPath(), ovf);
        return ovf;
    }
    log.error("Failed to parse OVF from:\n{}", stdout);
    throw new EngineException(EngineError.GeneralException, "Failed to parse OVF from OVA");
}
#end_block

#method_before
private VM readVmFromOva(String ovf) {
    if (ovf == null) {
        return null;
    }
    try {
        return ovfHelper.readVmFromOva(ovf);
    } catch (OvfReaderException e) {
        log.debug("failed to parse a given ovf configuration: \n" + ovf, e);
        getQueryReturnValue().setExceptionString("failed to parse a given ovf configuration " + e.getMessage());
        return null;
    }
}
#method_after
private VM readVmFromOva(String ovf) throws OvfReaderException {
    return ovf != null ? ovfHelper.readVmFromOva(ovf) : null;
}
#end_block

#method_before
private void processHeartbeat() {
    int incoming = this.policy.getIncomingHeartbeat() / 2;
    if (!this.isInInit() && getHeartbeatTime() > incoming && this.half) {
        log.info("There was no massege from " + getHostname() + " for " + incoming + " milliseconds");
        this.half = false;
    }
    if (!this.isInInit() && this.policy.isIncomingHeartbeat() && this.isIncomingHeartbeatExeeded()) {
        log.info("Heartbeat exceeded for " + getHostname() + " last message was " + getHeartbeatTime() + " milliseconds ago.");
        this.disconnect("Heartbeat exceeded");
    }
}
#method_after
private void processHeartbeat() {
    int incoming = this.policy.getIncomingHeartbeat() / 2;
    if (!this.isInInit() && getHeartbeatTime() > incoming && this.half) {
        log.info("No heartbeat message arrived from host '{}' for {} ms.", getHostname(), incoming);
        this.half = false;
    }
    if (!this.isInInit() && this.policy.isIncomingHeartbeat() && this.isIncomingHeartbeatExeeded()) {
        log.error("Heartbeat exceeded for host '{}', last response arrived {} ms ago.", getHostname(), getHeartbeatTime());
        this.disconnect("Heartbeat exceeded");
    }
}
#end_block

#method_before
public void handleMultipathHealthReport(VDS vds, Map<String, Object> struct) {
    if (struct.containsKey(VdsProperties.MULTIPATH_HEALTH)) {
        Map<String, Object> multipathHealthMap = (Map<String, Object>) struct.get(VdsProperties.MULTIPATH_HEALTH);
        try {
            String json = JsonHelper.mapToJson(multipathHealthMap);
            MessageDigest digest = MessageDigest.getInstance("SHA1");
            digest.update(json.getBytes("UTF-8"));
            byte[] hash = digest.digest();
            byte[] previousHash = multipathHealthHash.get(vds.getId());
            if (Arrays.equals(hash, previousHash)) {
                return;
            }
            multipathHealthHash.put(vds.getId(), hash);
            log.info("Multipath health report for host {}: {}", vds.getName(), json);
        } catch (Exception e) {
            log.error("failed building multipath events: {}", e.getMessage());
            log.debug("Exception", e);
            return;
        }
        if (multipathHealthMap.isEmpty()) {
            AuditLogable logable = createAuditLogableForHost(vds);
            auditLogDirector.log(logable, AuditLogType.NO_FAULTY_MULTIPATHS_ON_HOST);
            return;
        }
        List<String> mpathNoValidPaths = new ArrayList<>();
        List<String> mpathFailedPaths = new ArrayList<>();
        for (Map.Entry<String, ?> value : multipathHealthMap.entrySet()) {
            String deviceGuid = value.getKey();
            Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
            Integer validPathsCount = (Integer) internalValue.get(VdsProperties.MULTIPATH_VALID_PATHS);
            if (validPathsCount.equals(0)) {
                mpathNoValidPaths.add(deviceGuid);
            } else {
                mpathFailedPaths.add(deviceGuid);
            }
        }
        createAuditLog(mpathNoValidPaths, AuditLogType.MULTIPATH_DEVICES_WITHOUT_VALID_PATHS_ON_HOST, vds);
        createAuditLog(mpathFailedPaths, AuditLogType.FAULTY_MULTIPATHS_ON_HOST, vds);
    }
}
#method_after
public void handleMultipathHealthReport(VDS vds, Map<String, Object> statsMap) {
    if (!statsMap.containsKey(VdsProperties.MULTIPATH_HEALTH)) {
        return;
    }
    Map<String, Object> multipathHealthMap = (Map<String, Object>) statsMap.get(VdsProperties.MULTIPATH_HEALTH);
    // The following mechanism avoids to have the same events generated
    // when there was no changes in the health report.
    // Note that the EventFloodRegulator is solving the problem of not
    // emitting the same event reoccuring in the time frame of AuditLogTimeInterval.
    // In this case, using the EventFloodRegulator would filter events that are needed.
    // For example, having an event of NO_FAULTY_MULTIPATHS_ON_HOST, then
    // an event of FAULTY_MULTIPATHS_ON_HOST, and again NO_FAULTY_MULTIPATHS_ON_HOST.
    // The last event would have been filtered out.
    byte[] hash;
    String json;
    try {
        json = JsonHelper.mapToJson(new TreeMap<>(multipathHealthMap));
        MessageDigest digest = MessageDigest.getInstance("SHA1");
        digest.update(json.getBytes("UTF-8"));
        hash = digest.digest();
    } catch (Exception e) {
        log.error("failed building multipath events: {}", e.getMessage());
        log.debug("Exception", e);
        return;
    }
    byte[] previousHash = multipathHealthHash.get(vds.getId());
    if (Arrays.equals(hash, previousHash)) {
        // No changes in the report
        return;
    }
    multipathHealthHash.put(vds.getId(), hash);
    log.debug("Multipath health report for host {}: {}", vds.getName(), json);
    if (multipathHealthMap.isEmpty()) {
        AuditLogable logable = createAuditLogableForHost(vds);
        auditLogDirector.log(logable, AuditLogType.NO_FAULTY_MULTIPATHS_ON_HOST);
        return;
    }
    Map<Boolean, List<String>> multipathHealthMapPartition = multipathHealthMap.entrySet().stream().collect(Collectors.partitioningBy(entry -> {
        Map<String, Object> internalValue = (Map<String, Object>) entry.getValue();
        return (Integer) internalValue.get(VdsProperties.MULTIPATH_VALID_PATHS) > 0;
    }, Collectors.mapping(Map.Entry::getKey, Collectors.toList())));
    createAuditLog(multipathHealthMapPartition.get(Boolean.FALSE), AuditLogType.MULTIPATH_DEVICES_WITHOUT_VALID_PATHS_ON_HOST, vds);
    createAuditLog(multipathHealthMapPartition.get(Boolean.TRUE), AuditLogType.FAULTY_MULTIPATHS_ON_HOST, vds);
}
#end_block

#method_before
private void createAuditLog(List<String> guids, AuditLogType type, VDS vds) {
    if (guids.isEmpty()) {
        return;
    }
    AuditLogable logable = createAuditLogableForHost(vds);
    logable.addCustomValue("MpathGuids", guids.stream().sorted().collect(Collectors.joining(", ")));
    auditLogDirector.log(logable, type);
}
#method_after
private void createAuditLog(List<String> guids, AuditLogType type, VDS vds) {
    if (guids.isEmpty()) {
        return;
    }
    AuditLogable logable = createAuditLogableForHost(vds);
    logable.addCustomValue("MpathGuids", String.join(", ", guids));
    auditLogDirector.log(logable, type);
}
#end_block

#method_before
@Test
public void testEmptyHealthReport() {
    VDS vds = new VDS();
    Map<String, Object> struct = new HashMap();
    struct.put(VdsProperties.MULTIPATH_HEALTH, new HashMap());
    multipathHealthHandler.handleMultipathHealthReport(vds, struct);
    verify(auditLogDirector, times(1)).log(any(), logTypeCaptor.capture());
    assertTrue(logTypeCaptor.getAllValues().contains(AuditLogType.NO_FAULTY_MULTIPATHS_ON_HOST));
}
#method_after
@Test
public void testEmptyHealthReport() {
    VDS vds = new VDS();
    Map<String, Object> struct = new HashMap<>();
    struct.put(VdsProperties.MULTIPATH_HEALTH, new HashMap<>());
    multipathHealthHandler.handleMultipathHealthReport(vds, struct);
    verify(auditLogDirector, times(1)).log(any(), logTypeCaptor.capture());
    assertTrue(logTypeCaptor.getAllValues().contains(AuditLogType.NO_FAULTY_MULTIPATHS_ON_HOST));
}
#end_block

#method_before
@Test
public void testEmptyHealthReportSeveral() {
    VDS vds = new VDS();
    Map<String, Object> struct = new HashMap();
    struct.put(VdsProperties.MULTIPATH_HEALTH, new HashMap());
    multipathHealthHandler.handleMultipathHealthReport(vds, struct);
    multipathHealthHandler.handleMultipathHealthReport(vds, struct);
    multipathHealthHandler.handleMultipathHealthReport(vds, struct);
    verify(auditLogDirector, times(1)).log(any(), logTypeCaptor.capture());
    assertTrue(logTypeCaptor.getAllValues().contains(AuditLogType.NO_FAULTY_MULTIPATHS_ON_HOST));
}
#method_after
@Test
public void testEmptyHealthReportSeveral() {
    VDS vds = new VDS();
    Map<String, Object> struct = new HashMap<>();
    struct.put(VdsProperties.MULTIPATH_HEALTH, new HashMap<>());
    multipathHealthHandler.handleMultipathHealthReport(vds, struct);
    multipathHealthHandler.handleMultipathHealthReport(vds, struct);
    multipathHealthHandler.handleMultipathHealthReport(vds, struct);
    verify(auditLogDirector, times(1)).log(any(), logTypeCaptor.capture());
    assertTrue(logTypeCaptor.getAllValues().contains(AuditLogType.NO_FAULTY_MULTIPATHS_ON_HOST));
}
#end_block

#method_before
@Test
public void testNoHealthReport() {
    VDS vds = new VDS();
    Map<String, Object> struct = new HashMap();
    multipathHealthHandler.handleMultipathHealthReport(vds, struct);
    verify(auditLogDirector, never()).log(any(), logTypeCaptor.capture());
}
#method_after
@Test
public void testNoHealthReport() {
    VDS vds = new VDS();
    Map<String, Object> struct = new HashMap<>();
    multipathHealthHandler.handleMultipathHealthReport(vds, struct);
    verify(auditLogDirector, never()).log(any(), logTypeCaptor.capture());
}
#end_block

#method_before
private Map<String, Object> generateFaultyMultipathReport() {
    Map<String, Object> struct = new HashMap();
    Map<String, Object> report = new HashMap();
    struct.put(VdsProperties.MULTIPATH_HEALTH, report);
    Map<String, Object> guid1Report = new HashMap();
    report.put("guid-1", guid1Report);
    guid1Report.put(VdsProperties.MULTIPATH_VALID_PATHS, 1);
    return struct;
}
#method_after
private Map<String, Object> generateFaultyMultipathReport() {
    Map<String, Object> struct = new HashMap<>();
    Map<String, Object> report = new HashMap<>();
    struct.put(VdsProperties.MULTIPATH_HEALTH, report);
    Map<String, Object> guid1Report = new HashMap<>();
    report.put("guid-1", guid1Report);
    guid1Report.put(VdsProperties.MULTIPATH_VALID_PATHS, 1);
    return struct;
}
#end_block

#method_before
@Test
public void testMultipathNoValidPathReport() {
    VDS vds = new VDS();
    Map<String, Object> struct = new HashMap();
    Map<String, Object> report = new HashMap();
    struct.put(VdsProperties.MULTIPATH_HEALTH, report);
    Map<String, Object> guid1Report = new HashMap();
    report.put("guid-1", guid1Report);
    guid1Report.put(VdsProperties.MULTIPATH_VALID_PATHS, 0);
    multipathHealthHandler.handleMultipathHealthReport(vds, struct);
    verify(auditLogDirector, times(1)).log(any(), logTypeCaptor.capture());
    assertTrue(logTypeCaptor.getAllValues().contains(AuditLogType.MULTIPATH_DEVICES_WITHOUT_VALID_PATHS_ON_HOST));
}
#method_after
@Test
public void testMultipathNoValidPathReport() {
    VDS vds = new VDS();
    Map<String, Object> struct = new HashMap<>();
    Map<String, Object> report = new HashMap<>();
    struct.put(VdsProperties.MULTIPATH_HEALTH, report);
    Map<String, Object> guid1Report = new HashMap<>();
    report.put("guid-1", guid1Report);
    guid1Report.put(VdsProperties.MULTIPATH_VALID_PATHS, 0);
    multipathHealthHandler.handleMultipathHealthReport(vds, struct);
    verify(auditLogDirector, times(1)).log(any(), logTypeCaptor.capture());
    assertTrue(logTypeCaptor.getAllValues().contains(AuditLogType.MULTIPATH_DEVICES_WITHOUT_VALID_PATHS_ON_HOST));
}
#end_block

#method_before
@Test
public void testMultipathMixedReport() {
    VDS vds = new VDS();
    Map<String, Object> struct = new HashMap();
    Map<String, Object> report = new HashMap();
    struct.put(VdsProperties.MULTIPATH_HEALTH, report);
    Map<String, Object> guid1Report = new HashMap();
    report.put("guid-1", guid1Report);
    guid1Report.put(VdsProperties.MULTIPATH_VALID_PATHS, 0);
    Map<String, Object> guid2Report = new HashMap();
    report.put("guid-2", guid2Report);
    guid2Report.put(VdsProperties.MULTIPATH_VALID_PATHS, 2);
    multipathHealthHandler.handleMultipathHealthReport(vds, struct);
    verify(auditLogDirector, times(2)).log(any(), logTypeCaptor.capture());
    assertTrue(logTypeCaptor.getAllValues().contains(AuditLogType.MULTIPATH_DEVICES_WITHOUT_VALID_PATHS_ON_HOST));
    assertTrue(logTypeCaptor.getAllValues().contains(AuditLogType.FAULTY_MULTIPATHS_ON_HOST));
}
#method_after
@Test
public void testMultipathMixedReport() {
    VDS vds = new VDS();
    Map<String, Object> struct = new HashMap<>();
    Map<String, Object> report = new HashMap<>();
    struct.put(VdsProperties.MULTIPATH_HEALTH, report);
    Map<String, Object> guid1Report = new HashMap<>();
    report.put("guid-1", guid1Report);
    guid1Report.put(VdsProperties.MULTIPATH_VALID_PATHS, 0);
    Map<String, Object> guid2Report = new HashMap<>();
    report.put("guid-2", guid2Report);
    guid2Report.put(VdsProperties.MULTIPATH_VALID_PATHS, 2);
    multipathHealthHandler.handleMultipathHealthReport(vds, struct);
    verify(auditLogDirector, times(2)).log(any(), logTypeCaptor.capture());
    assertTrue(logTypeCaptor.getAllValues().contains(AuditLogType.MULTIPATH_DEVICES_WITHOUT_VALID_PATHS_ON_HOST));
    assertTrue(logTypeCaptor.getAllValues().contains(AuditLogType.FAULTY_MULTIPATHS_ON_HOST));
}
#end_block

#method_before
private void init() {
    // $NON-NLS-1$
    leftBound.setEntity(macRange.getMacFrom() == null ? "" : macRange.getMacFrom());
    // $NON-NLS-1$
    rightBound.setEntity(macRange.getMacTo() == null ? "" : macRange.getMacTo());
    recalculateMacsCount();
    leftBound.getEntityChangedEvent().addListener((ev, sender, args) -> recalculateMacsCount());
    rightBound.getEntityChangedEvent().addListener((ev, sender, args) -> recalculateMacsCount());
}
#method_after
private void init() {
    // $NON-NLS-1$
    leftBound.setEntity(macRange.getMacFrom() == null ? "" : macRange.getMacFrom());
    // $NON-NLS-1$
    rightBound.setEntity(macRange.getMacTo() == null ? "" : macRange.getMacTo());
    recalculateMacsCount();
}
#end_block

#method_before
@Override
public void edit(final MacRangeModel model) {
    driver.edit(model);
}
#method_after
@Override
public void edit(final MacRangeModel model) {
    driver.edit(model);
    IEventListener<EventArgs> textChangedListener = (ev, sender, args) -> {
        ValueChangeEvent.fire(MacRangeEditor.this, model);
        model.recalculateMacsCount();
    };
    model.getLeftBound().getEntityChangedEvent().addListener(textChangedListener);
    model.getRightBound().getEntityChangedEvent().addListener(textChangedListener);
}
#end_block

#method_before
@Override
public Response register(Action action) {
    validateParameters(action, "cluster.id|name");
    BackendVnicProfileHelper.validateVnicMappings(action, this);
    ImportVmTemplateFromConfParameters params = new ImportVmTemplateFromConfParameters();
    ExternalRegistrationConfigurationMapper.mapFromModel(action.getRegistrationConfiguration(), params);
    params.setContainerId(guid);
    params.setStorageDomainId(parent.getStorageDomainId());
    params.setClusterId(getClusterId(action));
    params.setImagesExistOnTargetStorageDomain(true);
    params.setExternalVnicProfileMappings(ExternalVnicProfileMappingMapper.mapFromModel(action.getVnicProfileMappings()));
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getTemplate().isSetName()) {
            params.getVmTemplate().setName(action.getTemplate().getName());
        }
    }
    if (action.isSetAllowPartialImport()) {
        params.setAllowPartialImport(action.isAllowPartialImport());
    }
    return doAction(ActionType.ImportVmTemplateFromConfiguration, params, action);
}
#method_after
@Override
public Response register(Action action) {
    BackendVnicProfileHelper.validateVnicMappings(this, action);
    ImportVmTemplateFromConfParameters params = new ImportVmTemplateFromConfParameters();
    ExternalRegistrationConfigurationMapper.mapFromModel(action.getRegistrationConfiguration(), params);
    params.setContainerId(guid);
    params.setStorageDomainId(parent.getStorageDomainId());
    if (action.isSetCluster()) {
        params.setClusterId(getClusterId(action));
    }
    params.setImagesExistOnTargetStorageDomain(true);
    params.setExternalVnicProfileMappings(ExternalVnicProfileMappingMapper.mapFromModel(action.getVnicProfileMappings()));
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getTemplate().isSetName()) {
            params.getVmTemplate().setName(action.getTemplate().getName());
        }
    }
    if (action.isSetAllowPartialImport()) {
        params.setAllowPartialImport(action.isAllowPartialImport());
    }
    return doAction(ActionType.ImportVmTemplateFromConfiguration, params, action);
}
#end_block

#method_before
@Override
public Response doImport(Action action) {
    validateParameters(action, "cluster.id|name", "storageDomain.id|name");
    Guid destStorageDomainId = getDestStorageDomainId(action);
    ImportVmTemplateParameters params = new ImportVmTemplateParameters(parent.getDataCenterId(destStorageDomainId), parent.getStorageDomainId(), destStorageDomainId, getClusterId(action), getEntity());
    params.setImageToDestinationDomainMap(getDiskToDestinationMap(action));
    params.setForceOverride(action.isSetExclusive() ? action.isExclusive() : false);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetTemplate() && action.getTemplate().isSetName()) {
            params.getVmTemplate().setName(action.getTemplate().getName());
        }
    }
    return doAction(ActionType.ImportVmTemplate, params, action);
}
#method_after
@Override
public Response doImport(Action action) {
    validateParameters(action, "storageDomain.id|name");
    Guid destStorageDomainId = getDestStorageDomainId(action);
    Guid clusterId = null;
    if (action.isSetCluster()) {
        clusterId = getClusterId(action);
    }
    ImportVmTemplateParameters params = new ImportVmTemplateParameters(parent.getDataCenterId(destStorageDomainId), parent.getStorageDomainId(), destStorageDomainId, clusterId, getEntity());
    params.setImageToDestinationDomainMap(getDiskToDestinationMap(action));
    params.setForceOverride(action.isSetExclusive() ? action.isExclusive() : false);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetTemplate() && action.getTemplate().isSetName()) {
            params.getVmTemplate().setName(action.getTemplate().getName());
        }
    }
    return doAction(ActionType.ImportVmTemplate, params, action);
}
#end_block

#method_before
@Override
public Response register(Action action) {
    validateParameters(action, "cluster.id|name");
    BackendVnicProfileHelper.validateVnicMappings(action, this);
    if (action.isSetRegistrationConfiguration()) {
        validateClusterMappings(action);
        validateRoleMappings(action);
        validateDomainMappings(action);
        validateAffinityGroupMappings(action);
        validateAffinityLabelMappings(action);
        validateLunMappings(action);
    }
    ImportVmFromConfParameters params = new ImportVmFromConfParameters(getVnicProfileMappings(action), getReassignBadMacs(action));
    ExternalRegistrationConfigurationMapper.mapFromModel(action.getRegistrationConfiguration(), params);
    params.setContainerId(guid);
    params.setStorageDomainId(parent.getStorageDomainId());
    params.setClusterId(getClusterId(action));
    params.setImagesExistOnTargetStorageDomain(true);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getVm().isSetName()) {
            params.getVm().setName(action.getVm().getName());
        }
    }
    if (action.isSetAllowPartialImport()) {
        params.setAllowPartialImport(action.isAllowPartialImport());
    }
    return doAction(ActionType.ImportVmFromConfiguration, params, action);
}
#method_after
@Override
public Response register(Action action) {
    BackendVnicProfileHelper.validateVnicMappings(this, action);
    if (action.isSetRegistrationConfiguration()) {
        validateClusterMappings(action);
        validateRoleMappings(action);
        validateDomainMappings(action);
        validateAffinityGroupMappings(action);
        validateAffinityLabelMappings(action);
        validateLunMappings(action);
    }
    ImportVmFromConfParameters params = new ImportVmFromConfParameters(getVnicProfileMappings(action), getReassignBadMacs(action));
    ExternalRegistrationConfigurationMapper.mapFromModel(action.getRegistrationConfiguration(), params);
    params.setContainerId(guid);
    params.setStorageDomainId(parent.getStorageDomainId());
    if (action.isSetCluster()) {
        params.setClusterId(getClusterId(action));
    }
    params.setImagesExistOnTargetStorageDomain(true);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getVm().isSetName()) {
            params.getVm().setName(action.getVm().getName());
        }
    }
    if (action.isSetAllowPartialImport()) {
        params.setAllowPartialImport(action.isAllowPartialImport());
    }
    return doAction(ActionType.ImportVmFromConfiguration, params, action);
}
#end_block

#method_before
@Override
public Response doImport(Action action) {
    validateParameters(action, "cluster.id|name", "storageDomain.id|name");
    Guid destStorageDomainId = getDestStorageDomainId(action);
    ImportVmParameters params = new ImportVmParameters(getEntity(), parent.getStorageDomainId(), destStorageDomainId, parent.getDataCenterId(destStorageDomainId), getClusterId(action));
    params.setImageToDestinationDomainMap(getDiskToDestinationMap(action));
    params.setForceOverride(action.isSetExclusive() ? action.isExclusive() : false);
    boolean collapseSnapshots = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, COLLAPSE_SNAPSHOTS, true, false);
    if (collapseSnapshots) {
        params.setCopyCollapse(collapseSnapshots);
    }
    setVolumesTypeFormat(action);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getVm().isSetName()) {
            params.getVm().setName(action.getVm().getName());
        }
    }
    return doAction(ActionType.ImportVm, params, action);
}
#method_after
@Override
public Response doImport(Action action) {
    validateParameters(action, "storageDomain.id|name");
    Guid destStorageDomainId = getDestStorageDomainId(action);
    Guid clusterId = null;
    if (action.isSetCluster()) {
        clusterId = getClusterId(action);
    }
    ImportVmParameters params = new ImportVmParameters(getEntity(), parent.getStorageDomainId(), destStorageDomainId, parent.getDataCenterId(destStorageDomainId), clusterId);
    params.setImageToDestinationDomainMap(getDiskToDestinationMap(action));
    params.setForceOverride(action.isSetExclusive() ? action.isExclusive() : false);
    boolean collapseSnapshots = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, COLLAPSE_SNAPSHOTS, true, false);
    if (collapseSnapshots) {
        params.setCopyCollapse(collapseSnapshots);
    }
    setVolumesTypeFormat(action);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getVm().isSetName()) {
            params.getVm().setName(action.getVm().getName());
        }
    }
    return doAction(ActionType.ImportVm, params, action);
}
#end_block

#method_before
public static void validateVnicMappings(Action action, BackendResource bs) {
    if (action.isSetVnicProfileMappings()) {
        bs.validateParameters(action.getVnicProfileMappings(), "vnicProfileMappings");
        for (VnicProfileMapping mapping : action.getVnicProfileMappings().getVnicProfileMappings()) {
            bs.validateParameters(mapping, "sourceNetworkName");
            bs.validateParameters(mapping, "sourceNetworkProfileName");
            bs.validateParameters(mapping, "targetVnicProfile");
            bs.validateParameters(mapping, "targetVnicProfile.id");
            bs.asGuid(mapping.getTargetVnicProfile().getId());
        }
    }
}
#method_after
public static void validateVnicMappings(BackendResource bs, Action action) {
    if (action.isSetVnicProfileMappings()) {
        bs.validateParameters(action.getVnicProfileMappings(), "vnicProfileMappings");
        for (VnicProfileMapping mapping : action.getVnicProfileMappings().getVnicProfileMappings()) {
            bs.validateParameters(mapping, "sourceNetworkName");
            bs.validateParameters(mapping, "sourceNetworkProfileName");
            bs.validateParameters(mapping, "targetVnicProfile");
            bs.validateParameters(mapping, "targetVnicProfile.id");
            bs.asGuid(mapping.getTargetVnicProfile().getId());
        }
    }
}
#end_block

#method_before
private void createVnicProfileMappingsModel() {
    updateExternalVnicProfilesPerTargetCluster();
    vnicProfileMappingModel = new VnicProfileMappingModel(RegisterTemplateModel.this, externalVnicProfilesPerTargetCluster);
    vnicProfileMappingModel.initialize();
}
#method_after
private void createVnicProfileMappingsModel() {
    updateExternalVnicProfilesPerTargetCluster();
    vnicProfileMappingModel = new VnicProfileMappingModel(this, externalVnicProfilesPerTargetCluster);
    vnicProfileMappingModel.initialize();
}
#end_block

#method_before
protected void onSave() {
    ArrayList<ActionParametersBase> parameters = new ArrayList<>();
    for (ImportTemplateData entityData : getEntities().getItems()) {
        VmTemplate vmTemplate = entityData.getEntity();
        Cluster cluster = entityData.getCluster().getSelectedItem();
        ImportVmTemplateFromConfParameters params = new ImportVmTemplateFromConfParameters();
        params.setContainerId(vmTemplate.getId());
        params.setStorageDomainId(getStorageDomainId());
        params.setImagesExistOnTargetStorageDomain(true);
        params.setClusterId(cluster != null ? cluster.getId() : null);
        params.setExternalVnicProfileMappings(getExternalVnicProfileMappings(cluster));
        if (isQuotaEnabled()) {
            Quota quota = entityData.getClusterQuota().getSelectedItem();
            params.setQuotaId(quota != null ? quota.getId() : null);
            params.setDiskTemplateMap(vmTemplate.getDiskTemplateMap());
            updateDiskQuotas(new ArrayList<Disk>(params.getDiskTemplateMap().values()));
        }
        parameters.add(params);
    }
    startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.ImportVmTemplateFromConfiguration, parameters, result -> {
        stopProgress();
        cancel();
    }, this);
}
#method_after
protected void onSave() {
    ArrayList<ActionParametersBase> parameters = new ArrayList<>();
    for (ImportTemplateData entityData : getEntities().getItems()) {
        VmTemplate vmTemplate = entityData.getEntity();
        Cluster cluster = entityData.getCluster().getSelectedItem();
        ImportVmTemplateFromConfParameters params = new ImportVmTemplateFromConfParameters();
        params.setExternalVnicProfileMappings(getExternalVnicProfileMappings(cluster));
        params.setContainerId(vmTemplate.getId());
        params.setStorageDomainId(getStorageDomainId());
        params.setImagesExistOnTargetStorageDomain(true);
        params.setClusterId(cluster != null ? cluster.getId() : null);
        if (isQuotaEnabled()) {
            Quota quota = entityData.getClusterQuota().getSelectedItem();
            params.setQuotaId(quota != null ? quota.getId() : null);
            params.setDiskTemplateMap(vmTemplate.getDiskTemplateMap());
            updateDiskQuotas(new ArrayList<Disk>(params.getDiskTemplateMap().values()));
        }
        parameters.add(params);
    }
    startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.ImportVmTemplateFromConfiguration, parameters, result -> {
        stopProgress();
        cancel();
    }, this);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getParameters().getExternalVnicProfileMappings() != null && !validateExternalVnicProfileMapping()) {
        return false;
    }
    initVmTemplate();
    ArrayList<DiskImage> disks = new ArrayList(getVmTemplate().getDiskTemplateMap().values());
    setImagesWithStoragePoolId(getStorageDomain().getStoragePoolId(), disks);
    getVmTemplate().setImages(disks);
    if (getParameters().isImagesExistOnTargetStorageDomain() && !validateUnregisteredEntity(vmTemplateFromConfiguration, ovfEntityData)) {
        return false;
    }
    return super.validate();
}
#method_after
@Override
protected boolean validate() {
    if (!validateExternalVnicProfileMapping()) {
        return false;
    }
    initVmTemplate();
    ArrayList<DiskImage> disks = new ArrayList(getVmTemplate().getDiskTemplateMap().values());
    setImagesWithStoragePoolId(getStorageDomain().getStoragePoolId(), disks);
    getVmTemplate().setImages(disks);
    if (getParameters().isImagesExistOnTargetStorageDomain() && !validateUnregisteredEntity(vmTemplateFromConfiguration, ovfEntityData)) {
        return false;
    }
    return super.validate();
}
#end_block

#method_before
private boolean validateUnregisteredEntity(VmTemplate entityFromConfiguration, OvfEntityData ovfEntityData) {
    if (ovfEntityData == null && !getParameters().isImportAsNewEntity()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
    }
    if (entityFromConfiguration == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
    }
    for (DiskImage image : new ArrayList<>(getImages())) {
        DiskImage fromIrs = null;
        Guid storageDomainId = image.getStorageIds().get(0);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        try {
            fromIrs = (DiskImage) runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(getStoragePool().getId(), storageDomainId, imageGroupId, image.getImageId())).getReturnValue();
        } catch (Exception e) {
            log.debug("Unable to get image info from storage", e);
        }
        if (fromIrs == null) {
            if (!getParameters().isAllowPartialImport()) {
                return failValidation(EngineMessage.TEMPLATE_IMAGE_NOT_EXIST);
            }
            log.warn("Disk image '{}/{}' doesn't exist on storage domain '{}'. Ignoring since force flag in on", imageGroupId, image.getImageId(), storageDomainId);
            getImages().remove(image);
            failedDisksToImportForAuditLog.putIfAbsent(image.getId(), image.getDiskAlias());
        }
    }
    for (DiskImage image : getImages()) {
        StorageDomain sd = storageDomainDao.getForStoragePool(image.getStorageIds().get(0), getStoragePool().getId());
        if (!validate(new StorageDomainValidator(sd).isDomainExistAndActive())) {
            return false;
        }
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED, String.format("$domainId %1$s", getParameters().getStorageDomainId()), String.format("$domainType %1$s", getStorageDomain().getStorageDomainType()));
    }
    return true;
}
#method_after
private boolean validateUnregisteredEntity(VmTemplate entityFromConfiguration, OvfEntityData ovfEntityData) {
    if (ovfEntityData == null && !getParameters().isImportAsNewEntity()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
    }
    if (entityFromConfiguration == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
    }
    ImportValidator importValidator = new ImportValidator(getParameters());
    // Avoid from sending imageToDestinationDomainMap because it isn't initialized at this point
    if (!validate(importValidator.validateDiskNotAlreadyExistOnDB(getImages(), getParameters().isAllowPartialImport(), null, failedDisksToImportForAuditLog))) {
        return false;
    }
    for (DiskImage image : new ArrayList<>(getImages())) {
        DiskImage fromIrs = null;
        Guid storageDomainId = image.getStorageIds().get(0);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        try {
            fromIrs = (DiskImage) runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(getStoragePool().getId(), storageDomainId, imageGroupId, image.getImageId())).getReturnValue();
        } catch (Exception e) {
            log.debug("Unable to get image info from storage", e);
        }
        if (fromIrs == null) {
            if (!getParameters().isAllowPartialImport()) {
                return failValidation(EngineMessage.TEMPLATE_IMAGE_NOT_EXIST);
            }
            log.warn("Disk image '{}/{}' doesn't exist on storage domain '{}'. Ignoring since force flag in on", imageGroupId, image.getImageId(), storageDomainId);
            getImages().remove(image);
            failedDisksToImportForAuditLog.putIfAbsent(image.getId(), image.getDiskAlias());
        }
    }
    for (DiskImage image : getImages()) {
        StorageDomain sd = storageDomainDao.getForStoragePool(image.getStorageIds().get(0), getStoragePool().getId());
        if (!validate(new StorageDomainValidator(sd).isDomainExistAndActive())) {
            return false;
        }
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED, String.format("$domainId %1$s", getParameters().getStorageDomainId()), String.format("$domainType %1$s", getStorageDomain().getStorageDomainType()));
    }
    return true;
}
#end_block

#method_before
private void initVmTemplate() {
    List<OvfEntityData> ovfEntityList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmTemplateFromOvf(ovfEntityData.getOvfData());
            mapCluster(fullEntityOvfData);
            vmTemplateFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmTemplateFromConfiguration.getInterfaces());
            setVmTemplate(vmTemplateFromConfiguration);
            setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getVmTemplate(), this::getCluster));
            vmHandler.updateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion());
            getParameters().setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskTemplateMap() != null) {
                ArrayList imageList = new ArrayList<>(getParameters().getDiskTemplateMap().values());
                vmTemplateFromConfiguration.setDiskList(imageList);
                ensureDomainMap(imageList, getParameters().getDestDomainId());
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
    setClusterId(getParameters().getClusterId());
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
}
#method_after
private void initVmTemplate() {
    List<OvfEntityData> ovfEntityList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmTemplateFromOvf(ovfEntityData.getOvfData());
            vmTemplateFromConfiguration = fullEntityOvfData.getVmTemplate();
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                mapCluster(fullEntityOvfData);
            }
            vmTemplateFromConfiguration.setClusterId(getParameters().getClusterId());
            drMappingHelper.mapVnicProfiles(vmTemplateFromConfiguration.getInterfaces(), getParameters().getExternalVnicProfileMappings());
            setVmTemplate(vmTemplateFromConfiguration);
            setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getVmTemplate(), this::getCluster));
            vmHandler.updateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion());
            getParameters().setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskTemplateMap() != null) {
                ArrayList imageList = new ArrayList<>(getParameters().getDiskTemplateMap().values());
                vmTemplateFromConfiguration.setDiskList(imageList);
                ensureDomainMap(imageList, getParameters().getDestDomainId());
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
    setClusterId(getParameters().getClusterId());
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
}
#end_block

#method_before
private void mapCluster(FullEntityOvfData fullEntityOvfData) {
    vmTemplateFromConfiguration = fullEntityOvfData.getVmTemplate();
    Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmTemplateFromConfiguration.getId(), getParameters().getClusterMap());
    if (cluster != null) {
        getParameters().setClusterId(cluster.getId());
    }
}
#method_after
private void mapCluster(FullEntityOvfData fullEntityOvfData) {
    Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmTemplateFromConfiguration.getId(), getParameters().getClusterMap());
    if (cluster != null) {
        getParameters().setClusterId(cluster.getId());
    }
}
#end_block

#method_before
@Override
public void executeCommand() {
    addAuditLogForPartialVMs();
    super.executeCommand();
    if (getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!getImages().isEmpty()) {
            findAndSaveDiskCopies();
            getImages().stream().forEach(diskImage -> {
                initQcowVersionForDisks(diskImage.getId());
            });
        }
        unregisteredOVFDataDao.removeEntity(ovfEntityData.getEntityId(), null);
        unregisteredDisksDao.removeUnregisteredDiskRelatedToVM(ovfEntityData.getEntityId(), null);
    }
    setActionReturnValue(getVmTemplate().getId());
    setSucceeded(true);
}
#method_after
@Override
public void executeCommand() {
    addAuditLogForPartialVMs();
    filterInvalidDisksForImport();
    super.executeCommand();
    if (getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!getImages().isEmpty()) {
            findAndSaveDiskCopies();
            getImages().stream().forEach(diskImage -> {
                initQcowVersionForDisks(diskImage.getId());
            });
        }
        unregisteredOVFDataDao.removeEntity(ovfEntityData.getEntityId(), null);
        unregisteredDisksDao.removeUnregisteredDiskRelatedToVM(ovfEntityData.getEntityId(), null);
    }
    setActionReturnValue(getVmTemplate().getId());
    setSucceeded(true);
}
#end_block

#method_before
public ValidationResult validateDiskNotAlreadyExistOnDB(List<DiskImage> images, boolean allowPartial, Map<Guid, Guid> imageToDestinationDomainMap, Map<Guid, String> failedDisksToImport) {
    for (DiskImage image : new ArrayList<>(images)) {
        DiskImage diskImage = getDiskImageDao().get(image.getImageId());
        if (diskImage != null) {
            log.info("Disk '{}' with id '{}', already exist on storage domain '{}'", diskImage.getDiskAlias(), diskImage.getImageId(), diskImage.getStoragesNames().get(0));
            if (!allowPartial) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST, String.format("$diskAlias %s", diskImage.getDiskAlias()));
            }
            failedDisksToImport.putIfAbsent(image.getId(), image.getDiskAlias());
            imageToDestinationDomainMap.remove(image.getId());
            images.remove(image);
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateDiskNotAlreadyExistOnDB(List<DiskImage> images, boolean allowPartial, Map<Guid, Guid> imageToDestinationDomainMap, Map<Guid, String> failedDisksToImport) {
    // Creating new ArrayList in order to manipulate the original List and remove the existing disks
    for (DiskImage image : new ArrayList<>(images)) {
        DiskImage diskImage = getDiskImageDao().get(image.getImageId());
        if (diskImage != null) {
            log.info("Disk '{}' with id '{}', already exist on storage domain '{}'", diskImage.getDiskAlias(), diskImage.getImageId(), diskImage.getStoragesNames().get(0));
            if (!allowPartial) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST, String.format("$diskAliases %s", diskImage.getDiskAlias()));
            }
            failedDisksToImport.putIfAbsent(image.getId(), image.getDiskAlias());
            imageToDestinationDomainMap.remove(image.getId());
            images.remove(image);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected void init() {
    VM vmFromConfiguration = getParameters().getVm();
    if (vmFromConfiguration != null) {
        vmFromConfiguration.getStaticData().setClusterId(getParameters().getClusterId());
        if (!isImagesAlreadyOnTarget()) {
            setDisksToBeAttached(vmFromConfiguration);
        }
        getParameters().setContainerId(vmFromConfiguration.getId());
    } else {
        initUnregisteredVM();
    }
    if (Guid.Empty.equals(getParameters().getVmId()) && getParameters().getVm() != null) {
        getParameters().setVmId(getParameters().getVm().getId());
    }
    setClusterId(getParameters().getClusterId());
    getParameters().setStoragePoolId(getCluster().getStoragePoolId());
    super.init();
}
#method_after
@Override
protected void init() {
    VM vmFromConfiguration = getParameters().getVm();
    if (vmFromConfiguration != null) {
        vmFromConfiguration.getStaticData().setClusterId(getParameters().getClusterId());
        if (!isImagesAlreadyOnTarget()) {
            setDisksToBeAttached(vmFromConfiguration);
        }
        getParameters().setContainerId(vmFromConfiguration.getId());
    } else {
        initUnregisteredVM();
    }
    if (Guid.Empty.equals(getParameters().getVmId()) && getParameters().getVm() != null) {
        getParameters().setVmId(getParameters().getVm().getId());
    }
    setClusterId(getParameters().getClusterId());
    if (getCluster() != null) {
        getParameters().setStoragePoolId(getCluster().getStoragePoolId());
    }
    super.init();
}
#end_block

#method_before
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            mapCluster(fullEntityOvfData.getClusterName());
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setAffinityGroups(fullEntityOvfData.getAffinityGroups());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
            mapExternalLunDisks(DisksFilter.filterLunDisks(vmFromConfiguration.getDiskMap().values()));
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#method_after
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmFromConfiguration.getId(), getParameters().getClusterMap());
                if (cluster != null) {
                    getParameters().setClusterId(cluster.getId());
                }
            }
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setAffinityGroups(fullEntityOvfData.getAffinityGroups());
            getParameters().setAffinityLabels(fullEntityOvfData.getAffinityLabels());
            getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
            // Note: The VM's OVF does not preserve the username and password for the LUN's connection.
            // Therefore to achieve a simple VM registration the iSCSI storage server should not use
            // credentials, although if the user will use the mapping attribute, one can set the credentials through
            // there.
            drMappingHelper.mapExternalLunDisks(DisksFilter.filterLunDisks(vmFromConfiguration.getDiskMap().values()), getParameters().getExternalLunMap());
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
@Override
public void addVmToAffinityGroups() {
    mapAffinityGroups().forEach(affinityGroup -> {
        affinityGroup.setClusterId(getParameters().getClusterId());
        Set<Guid> vmIds = new HashSet<>(affinityGroup.getVmIds());
        vmIds.add(getParameters().getVm().getId());
        affinityGroup.setVmIds(new ArrayList<>(vmIds));
        affinityGroupDao.update(affinityGroup);
    });
}
#method_after
@Override
public void addVmToAffinityGroups() {
    drMappingHelper.addVmToAffinityGroups(getParameters().getClusterId(), getParameters().getVmId(), getParameters().getAffinityGroupMap(), getParameters().getAffinityGroups());
}
#end_block

#method_before
private boolean validateUnregisteredEntity(VmTemplate entityFromConfiguration, OvfEntityData ovfEntityData) {
    if (ovfEntityData == null && !getParameters().isImportAsNewEntity()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
    }
    if (entityFromConfiguration == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
    }
    if (!validate(new ImportValidator(getParameters()).validateDiskNotAlreadyExistOnDB(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
        return false;
    }
    for (DiskImage image : new ArrayList<>(getImages())) {
        DiskImage fromIrs = null;
        Guid storageDomainId = image.getStorageIds().get(0);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        try {
            fromIrs = (DiskImage) runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(getStoragePool().getId(), storageDomainId, imageGroupId, image.getImageId())).getReturnValue();
        } catch (Exception e) {
            log.debug("Unable to get image info from storage", e);
        }
        if (fromIrs == null) {
            if (!getParameters().isAllowPartialImport()) {
                return failValidation(EngineMessage.TEMPLATE_IMAGE_NOT_EXIST);
            }
            log.warn("Disk image '{}/{}' doesn't exist on storage domain '{}'. Ignoring since force flag in on", imageGroupId, image.getImageId(), storageDomainId);
            getImages().remove(image);
            failedDisksToImportForAuditLog.putIfAbsent(image.getId(), image.getDiskAlias());
        }
    }
    for (DiskImage image : getImages()) {
        StorageDomain sd = storageDomainDao.getForStoragePool(image.getStorageIds().get(0), getStoragePool().getId());
        if (!validate(new StorageDomainValidator(sd).isDomainExistAndActive())) {
            return false;
        }
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED, String.format("$domainId %1$s", getParameters().getStorageDomainId()), String.format("$domainType %1$s", getStorageDomain().getStorageDomainType()));
    }
    return true;
}
#method_after
private boolean validateUnregisteredEntity(VmTemplate entityFromConfiguration, OvfEntityData ovfEntityData) {
    if (ovfEntityData == null && !getParameters().isImportAsNewEntity()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
    }
    if (entityFromConfiguration == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
    }
    ImportValidator importValidator = new ImportValidator(getParameters());
    // Avoid from sending imageToDestinationDomainMap because it isn't initialized at this point
    if (!validate(importValidator.validateDiskNotAlreadyExistOnDB(getImages(), getParameters().isAllowPartialImport(), null, failedDisksToImportForAuditLog))) {
        return false;
    }
    for (DiskImage image : new ArrayList<>(getImages())) {
        DiskImage fromIrs = null;
        Guid storageDomainId = image.getStorageIds().get(0);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        try {
            fromIrs = (DiskImage) runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(getStoragePool().getId(), storageDomainId, imageGroupId, image.getImageId())).getReturnValue();
        } catch (Exception e) {
            log.debug("Unable to get image info from storage", e);
        }
        if (fromIrs == null) {
            if (!getParameters().isAllowPartialImport()) {
                return failValidation(EngineMessage.TEMPLATE_IMAGE_NOT_EXIST);
            }
            log.warn("Disk image '{}/{}' doesn't exist on storage domain '{}'. Ignoring since force flag in on", imageGroupId, image.getImageId(), storageDomainId);
            getImages().remove(image);
            failedDisksToImportForAuditLog.putIfAbsent(image.getId(), image.getDiskAlias());
        }
    }
    for (DiskImage image : getImages()) {
        StorageDomain sd = storageDomainDao.getForStoragePool(image.getStorageIds().get(0), getStoragePool().getId());
        if (!validate(new StorageDomainValidator(sd).isDomainExistAndActive())) {
            return false;
        }
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED, String.format("$domainId %1$s", getParameters().getStorageDomainId()), String.format("$domainType %1$s", getStorageDomain().getStorageDomainType()));
    }
    return true;
}
#end_block

#method_before
private void initVmTemplate() {
    List<OvfEntityData> ovfEntityList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmTemplateFromOvf(ovfEntityData.getOvfData());
            mapCluster(fullEntityOvfData);
            vmTemplateFromConfiguration.setClusterId(getParameters().getClusterId());
            setVmTemplate(vmTemplateFromConfiguration);
            setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getVmTemplate(), this::getCluster));
            vmHandler.updateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion());
            getParameters().setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskTemplateMap() != null) {
                ArrayList imageList = new ArrayList<>(getParameters().getDiskTemplateMap().values());
                vmTemplateFromConfiguration.setDiskList(imageList);
                ensureDomainMap(imageList, getParameters().getDestDomainId());
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
    setClusterId(getParameters().getClusterId());
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
}
#method_after
private void initVmTemplate() {
    List<OvfEntityData> ovfEntityList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmTemplateFromOvf(ovfEntityData.getOvfData());
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                mapCluster(fullEntityOvfData);
            }
            vmTemplateFromConfiguration.setClusterId(getParameters().getClusterId());
            setVmTemplate(vmTemplateFromConfiguration);
            setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getVmTemplate(), this::getCluster));
            vmHandler.updateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion());
            getParameters().setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskTemplateMap() != null) {
                ArrayList imageList = new ArrayList<>(getParameters().getDiskTemplateMap().values());
                vmTemplateFromConfiguration.setDiskList(imageList);
                ensureDomainMap(imageList, getParameters().getDestDomainId());
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
    setClusterId(getParameters().getClusterId());
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
}
#end_block

#method_before
@Override
public void executeCommand() {
    addAuditLogForPartialVMs();
    filterFailedToImportDisks();
    super.executeCommand();
    if (getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!getImages().isEmpty()) {
            findAndSaveDiskCopies();
            getImages().stream().forEach(diskImage -> {
                initQcowVersionForDisks(diskImage.getId());
            });
        }
        unregisteredOVFDataDao.removeEntity(ovfEntityData.getEntityId(), null);
        unregisteredDisksDao.removeUnregisteredDiskRelatedToVM(ovfEntityData.getEntityId(), null);
    }
    setActionReturnValue(getVmTemplate().getId());
    setSucceeded(true);
}
#method_after
@Override
public void executeCommand() {
    addAuditLogForPartialVMs();
    filterInvalidDisksForImport();
    super.executeCommand();
    if (getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!getImages().isEmpty()) {
            findAndSaveDiskCopies();
            getImages().stream().forEach(diskImage -> {
                initQcowVersionForDisks(diskImage.getId());
            });
        }
        unregisteredOVFDataDao.removeEntity(ovfEntityData.getEntityId(), null);
        unregisteredDisksDao.removeUnregisteredDiskRelatedToVM(ovfEntityData.getEntityId(), null);
    }
    setActionReturnValue(getVmTemplate().getId());
    setSucceeded(true);
}
#end_block

#method_before
public ValidationResult validateDiskNotAlreadyExistOnDB(List<DiskImage> images, boolean allowPartial, Map<Guid, Guid> imageToDestinationDomainMap, Map<Guid, String> failedDisksToImport) {
    for (DiskImage image : new ArrayList<>(images)) {
        DiskImage diskImage = getDiskImageDao().get(image.getImageId());
        if (diskImage != null) {
            log.info("Disk '{}' with id '{}', already exist on storage domain '{}'", diskImage.getDiskAlias(), diskImage.getImageId(), diskImage.getStoragesNames().get(0));
            if (!allowPartial) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST, String.format("$diskAliases %s", diskImage.getDiskAlias()));
            }
            failedDisksToImport.putIfAbsent(image.getId(), image.getDiskAlias());
            if (imageToDestinationDomainMap != null) {
                imageToDestinationDomainMap.remove(image.getId());
            }
            images.remove(image);
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateDiskNotAlreadyExistOnDB(List<DiskImage> images, boolean allowPartial, Map<Guid, Guid> imageToDestinationDomainMap, Map<Guid, String> failedDisksToImport) {
    // Creating new ArrayList in order to manipulate the original List and remove the existing disks
    for (DiskImage image : new ArrayList<>(images)) {
        DiskImage diskImage = getDiskImageDao().get(image.getImageId());
        if (diskImage != null) {
            log.info("Disk '{}' with id '{}', already exist on storage domain '{}'", diskImage.getDiskAlias(), diskImage.getImageId(), diskImage.getStoragesNames().get(0));
            if (!allowPartial) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST, String.format("$diskAliases %s", diskImage.getDiskAlias()));
            }
            failedDisksToImport.putIfAbsent(image.getId(), image.getDiskAlias());
            if (imageToDestinationDomainMap != null) {
                imageToDestinationDomainMap.remove(image.getId());
            }
            images.remove(image);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public void onInstall() {
    final VDS host = getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    if (!model.validate(host.isOvirtVintageNode())) {
        model.setValidationFailed(new EntityModel<>(true));
        return;
    }
    final UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setReinstallOrUpgrade(true);
    param.setInstallHost(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    // Explicitly set null, to be clear we don't want to update fence agents.
    param.setFenceAgents(null);
    param.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getSelectedItem()));
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(returnValue -> Frontend.getInstance().runAction(ActionType.InstallVds, param, result -> {
        ActionReturnValue returnValue1 = result.getReturnValue();
        if (returnValue1 != null && returnValue1.getSucceeded()) {
            cancel();
        }
    })), host.getClusterId());
}
#method_after
public void onInstall() {
    final VDS host = getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    if (!model.validate(host.isOvirtVintageNode())) {
        model.setValidationFailed(new EntityModel<>(true));
        return;
    }
    final UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword(model.getUserPassword().getEntity());
    param.setReinstallOrUpgrade(true);
    param.setInstallHost(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall(model.getOverrideIpTables().getEntity());
    param.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    // Explicitly set null, to be clear we don't want to update fence agents.
    param.setFenceAgents(null);
    param.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getSelectedItem()));
    Provider<?> networkProvider = (Provider<?>) model.getNetworkProviders().getSelectedItem();
    if (networkProvider == null) {
        param.getVdsStaticData().setOpenstackNetworkProviderId(null);
    } else {
        param.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(returnValue -> Frontend.getInstance().runAction(ActionType.InstallVds, param, result -> {
        ActionReturnValue returnValue1 = result.getReturnValue();
        if (returnValue1 != null && returnValue1.getSucceeded()) {
            cancel();
        }
    })), host.getClusterId());
}
#end_block

#method_before
private void updateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallRequiredAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    setHasGlusterDisconnectedAlert(false);
    setHasDefaultRouteAlert(false);
    // Check the network alert presense.
    setHasNICsAlert(getEntity().getNetConfigDirty() == null ? false : getEntity().getNetConfigDirty());
    boolean hasDefaultRoute = getEntity().getInterfaces().stream().anyMatch(VdsNetworkInterface::isIpv4DefaultRoute);
    setHasDefaultRouteAlert(!hasDefaultRoute);
    // Check manual fence alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive && !getEntity().isPmEnabled() && ((getEntity().getVmActive() == null ? 0 : getEntity().getVmActive()) > 0 || getEntity().getSpmStatus() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().isPmEnabled()) {
        setHasNoPowerManagementAlert(true);
    }
    if (getEntity().getStaticData().isReinstallRequired()) {
        setHasReinstallRequiredAlert(true);
    }
    // Check the reinstall alert presence.
    if (getEntity().getStatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getStatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getStatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    }
    if (getEntity().getClusterSupportsGlusterService() && !(getEntity().getStatus() == VDSStatus.Installing || getEntity().getStatus() == VDSStatus.Initializing) && getEntity().getGlusterPeerStatus() != PeerStatus.CONNECTED) {
        setHasGlusterDisconnectedAlert(true);
    }
    setNonOperationalReasonEntity(getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : getEntity().getNonOperationalReason());
    updateActionAvailability();
    setHasUpgradeAlert(getEntity().isUpdateAvailable() && getEntity().getStatus() != VDSStatus.Installing);
    setHasAnyAlert();
}
#method_after
private void updateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallRequiredAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    setHasGlusterDisconnectedAlert(false);
    setHasDefaultRouteAlert(false);
    // Check the network alert presense.
    setHasNICsAlert(getEntity().getNetConfigDirty() == null ? false : getEntity().getNetConfigDirty());
    setHasDefaultRouteAlert(!NetworkCommonUtils.hasDefaultRoute(getEntity().getInterfaces()));
    // Check manual fence alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive && !getEntity().isPmEnabled() && ((getEntity().getVmActive() == null ? 0 : getEntity().getVmActive()) > 0 || getEntity().getSpmStatus() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().isPmEnabled()) {
        setHasNoPowerManagementAlert(true);
    }
    if (getEntity().getStaticData().isReinstallRequired()) {
        setHasReinstallRequiredAlert(true);
    }
    // Check the reinstall alert presence.
    if (getEntity().getStatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getStatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getStatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    }
    if (getEntity().getClusterSupportsGlusterService() && !(getEntity().getStatus() == VDSStatus.Installing || getEntity().getStatus() == VDSStatus.Initializing) && getEntity().getGlusterPeerStatus() != PeerStatus.CONNECTED) {
        setHasGlusterDisconnectedAlert(true);
    }
    setNonOperationalReasonEntity(getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : getEntity().getNonOperationalReason());
    updateActionAvailability();
    setHasUpgradeAlert(getEntity().isUpdateAvailable() && getEntity().getStatus() != VDSStatus.Installing);
    setHasAnyAlert();
}
#end_block

#method_before
@Override
public void render(Context context, VDS vds, SafeHtmlBuilder sb, String id) {
    // Nothing to render if no host is provided:
    if (vds == null) {
        return;
    }
    // Find the image corresponding to the status of the host:
    VDSStatus status = vds.getStatus();
    ImageResource statusImage = null;
    switch(status) {
        case Unassigned:
        case NonResponsive:
        case InstallFailed:
        case Connecting:
        case Down:
            statusImage = resources.downImage();
            break;
        case PreparingForMaintenance:
            statusImage = resources.prepareImage();
            break;
        case Maintenance:
            statusImage = resources.maintenanceImage();
            break;
        case Up:
            statusImage = resources.upImage();
            break;
        case Error:
            statusImage = resources.errorImage();
            break;
        case Installing:
            statusImage = resources.hostInstallingImage();
            break;
        case Reboot:
            statusImage = resources.waitImage();
            break;
        case NonOperational:
            statusImage = resources.nonOperationalImage();
            break;
        case PendingApproval:
        case InstallingOS:
            statusImage = resources.unconfiguredImage();
            break;
        case Initializing:
            statusImage = resources.waitImage();
            break;
        case Kdumping:
            statusImage = resources.waitImage();
            break;
        default:
            statusImage = resources.downImage();
    }
    // Find the image corresponding to the alert:
    ImageResource alertImage = resources.alertImage();
    // Generate the HTML for the images:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    SafeHtml alertImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(alertImage).getHTML());
    // Generate the HTML for the cell including the exclamation mark only if
    // power management is not enabled or there are network configuration
    // changes that haven't been saved yet:
    // $NON-NLS-1$ //$NON-NLS-2$
    sb.appendHtmlConstant("<div id=\"" + id + "\" style=\"text-align: center;\">");
    sb.append(statusImageHtml);
    boolean getnet_config_dirty = vds.getNetConfigDirty() == null ? false : vds.getNetConfigDirty().booleanValue();
    boolean showPMAlert = vds.getClusterSupportsVirtService() && !vds.isPmEnabled() && vds.isFencingEnabled();
    boolean hasDefaultRoute = vds.getInterfaces().stream().anyMatch(VdsNetworkInterface::isIpv4DefaultRoute);
    boolean showGlusterAlert = vds.getClusterSupportsGlusterService() && vds.getGlusterPeerStatus() != PeerStatus.CONNECTED;
    if (showPMAlert || getnet_config_dirty || showGlusterAlert || vds.getStaticData().isReinstallRequired() || !hasDefaultRoute) {
        sb.append(alertImageHtml);
    }
    // $NON-NLS-1$
    sb.appendHtmlConstant("</div>");
}
#method_after
@Override
public void render(Context context, VDS vds, SafeHtmlBuilder sb, String id) {
    // Nothing to render if no host is provided:
    if (vds == null) {
        return;
    }
    // Find the image corresponding to the status of the host:
    VDSStatus status = vds.getStatus();
    ImageResource statusImage = null;
    switch(status) {
        case Unassigned:
            statusImage = resources.hostActivating();
            break;
        case NonResponsive:
        case InstallFailed:
        case Connecting:
        case Down:
            statusImage = resources.downImage();
            break;
        case PreparingForMaintenance:
            statusImage = resources.prepareForMaintenance();
            break;
        case Maintenance:
            statusImage = resources.maintenanceImage();
            break;
        case Up:
            statusImage = resources.upImage();
            break;
        case Error:
            statusImage = resources.errorImage();
            break;
        case Installing:
            statusImage = resources.hostInstallingImage();
            break;
        case Reboot:
            statusImage = resources.waitImage();
            break;
        case NonOperational:
            statusImage = resources.nonOperationalImage();
            break;
        case PendingApproval:
        case InstallingOS:
            statusImage = resources.unconfiguredImage();
            break;
        case Initializing:
            statusImage = resources.waitImage();
            break;
        case Kdumping:
            statusImage = resources.waitImage();
            break;
        default:
            statusImage = resources.downImage();
    }
    // Find the image corresponding to the alert:
    ImageResource alertImage = resources.alertImage();
    // Generate the HTML for the images:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    SafeHtml alertImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(alertImage).getHTML());
    // Generate the HTML for the cell including the exclamation mark only if
    // power management is not enabled or there are network configuration
    // changes that haven't been saved yet:
    // $NON-NLS-1$ //$NON-NLS-2$
    sb.appendHtmlConstant("<div id=\"" + id + "\" style=\"text-align: center;\">");
    sb.append(statusImageHtml);
    boolean getnet_config_dirty = vds.getNetConfigDirty() == null ? false : vds.getNetConfigDirty().booleanValue();
    boolean showPMAlert = vds.getClusterSupportsVirtService() && !vds.isPmEnabled() && vds.isFencingEnabled();
    boolean hasDefaultRoute = NetworkCommonUtils.hasDefaultRoute(vds.getInterfaces());
    boolean showGlusterAlert = vds.getClusterSupportsGlusterService() && vds.getGlusterPeerStatus() != PeerStatus.CONNECTED;
    if (showPMAlert || getnet_config_dirty || showGlusterAlert || vds.getStaticData().isReinstallRequired() || !hasDefaultRoute) {
        sb.append(alertImageHtml);
    }
    // $NON-NLS-1$
    sb.appendHtmlConstant("</div>");
}
#end_block

#method_before
@Test
public void testHotsetUpdateableWhenHotsetRequested() {
    ObjectIdentityChecker oic = new ObjectIdentityChecker(Jedi.class);
    oic.addHotsetFields("name");
    assertTrue("hot set requested for hot set fields should be true in state Up", oic.isFieldUpdatable(VMStatus.Up, "name", null, true));
}
#method_after
@Test
public void testHotsetUpdateableWhenHotsetRequested() {
    ObjectIdentityChecker oic = new ObjectIdentityChecker(Jedi.class);
    oic.addHotsetField("name", EnumSet.of(VMStatus.Up));
    assertTrue("hot set requested for hot set fields should be true in state Up", oic.isFieldUpdatable(VMStatus.Up, "name", null, true));
}
#end_block

#method_before
@Test
public void testHotsetNotUpdateableWhenHotsetNotRequested() {
    ObjectIdentityChecker oic = new ObjectIdentityChecker(Jedi.class);
    assertFalse("Should be false by default", oic.isFieldUpdatable("name"));
    oic.addHotsetFields("name");
    assertFalse("hot set not requested should return false even if field is hot set", oic.isFieldUpdatable(null, "name", null, false));
}
#method_after
@Test
public void testHotsetNotUpdateableWhenHotsetNotRequested() {
    ObjectIdentityChecker oic = new ObjectIdentityChecker(Jedi.class);
    assertFalse("Should be false by default", oic.isFieldUpdatable("name"));
    oic.addHotsetField("name", EnumSet.of(VMStatus.Up));
    assertFalse("hot set not requested should return false even if field is hot set", oic.isFieldUpdatable(null, "name", null, false));
}
#end_block

#method_before
@Test
public void testHotsetUpdateableWhenHotsetRequestedWithStatus() {
    ObjectIdentityChecker oic = new ObjectIdentityChecker(Jedi.class);
    oic.addField(VMStatus.Down, "name");
    oic.addHotsetFields("name");
    assertTrue("hot set requested for hot set fields should be true", oic.isFieldUpdatable(VMStatus.Down, "name", null, true));
}
#method_after
@Test
public void testHotsetUpdateableWhenHotsetRequestedWithStatus() {
    ObjectIdentityChecker oic = new ObjectIdentityChecker(Jedi.class);
    oic.addField(VMStatus.Down, "name");
    oic.addHotsetField("name", EnumSet.of(VMStatus.Up));
    assertTrue("hot set requested for hot set fields should be true", oic.isFieldUpdatable(VMStatus.Down, "name", null, true));
}
#end_block

#method_before
@Test
public void testHotsetUpdateableWhenHotsetNotRequestedWithStatus() {
    ObjectIdentityChecker oic = new ObjectIdentityChecker(Jedi.class);
    oic.addField(VMStatus.Down, "name");
    oic.addHotsetFields("name");
    assertTrue("hot set not requested field should be updateable according to status", oic.isFieldUpdatable(VMStatus.Down, "name", null, false));
}
#method_after
@Test
public void testHotsetUpdateableWhenHotsetNotRequestedWithStatus() {
    ObjectIdentityChecker oic = new ObjectIdentityChecker(Jedi.class);
    oic.addField(VMStatus.Down, "name");
    oic.addHotsetField("name", EnumSet.of(VMStatus.Up));
    assertTrue("hot set not requested field should be updateable according to status", oic.isFieldUpdatable(VMStatus.Down, "name", null, false));
}
#end_block

#method_before
public boolean isFieldUpdatable(Enum<?> status, String name, Object fieldContainer, boolean hotsetEnabled) {
    boolean returnValue = true;
    if (!isFieldUpdatable(name)) {
        if (fieldContainer != null && container != null && !container.canUpdateField(fieldContainer, name, status)) {
            returnValue = false;
        } else {
            Set<String> values = dictionary.get(status);
            returnValue = values != null ? values.contains(name) : false;
            // if field is not updateable in this status, check if hotset request and its an hotset allowed field
            if (!returnValue && hotsetEnabled && status == VMStatus.Up) {
                returnValue = isHotSetField(name);
            }
        }
        if (!returnValue) {
            log.warn("Field '{}' can not be updated when status is '{}'", name, status);
        }
    }
    return returnValue;
}
#method_after
public boolean isFieldUpdatable(Enum<?> status, String name, Object fieldContainer, boolean hotsetEnabled) {
    boolean returnValue = true;
    if (!isFieldUpdatable(name)) {
        if (fieldContainer != null && container != null && !container.canUpdateField(fieldContainer, name, status)) {
            returnValue = false;
        } else {
            Set<String> values = dictionary.get(status);
            returnValue = values != null ? values.contains(name) : false;
            // if field is not updatable in this status, check if it's hotset request and an hotset allowed field
            if (!returnValue) {
                returnValue = status instanceof VMStatus && isFieldHotSettableInStatus(name, (VMStatus) status);
            }
        }
        if (!returnValue) {
            log.warn("Field '{}' can not be updated when status is '{}'", name, status);
        }
    }
    return returnValue;
}
#end_block

#method_before
public boolean copyNonEditableFieldsToDestination(Object source, Object destination, boolean hotSetEnabled) {
    Class<?> cls = source.getClass();
    while (!cls.equals(Object.class)) {
        for (Field srcFld : cls.getDeclaredFields()) {
            try {
                // copy fields that are non final, and not-editable and not a hotset field or it is but this is not hotset case
                if (!Modifier.isFinal(srcFld.getModifiers()) && !isFieldUpdatable(srcFld.getName()) && (!isHotSetField(srcFld.getName()) || !hotSetEnabled)) {
                    srcFld.setAccessible(true);
                    Field dstFld = cls.getDeclaredField(srcFld.getName());
                    dstFld.setAccessible(true);
                    dstFld.set(destination, srcFld.get(source));
                }
            } catch (Exception exp) {
                log.error("Failed to copy non editable field '{}', error: {}", srcFld.getName(), exp.getMessage());
                log.debug("Exception", exp);
                return false;
            }
        }
        cls = cls.getSuperclass();
    }
    return true;
}
#method_after
public boolean copyNonEditableFieldsToDestination(Object source, Object destination, boolean hotSetEnabled, VMStatus vmStatus) {
    Class<?> cls = source.getClass();
    while (!cls.equals(Object.class)) {
        for (Field srcFld : cls.getDeclaredFields()) {
            try {
                // copy fields that are non final, and not-editable and not a hotset field or it is but this is not hotset case
                if (!Modifier.isFinal(srcFld.getModifiers()) && !isFieldUpdatable(srcFld.getName()) && (!isFieldHotSettableInStatus(srcFld.getName(), vmStatus) || !hotSetEnabled)) {
                    srcFld.setAccessible(true);
                    Field dstFld = cls.getDeclaredField(srcFld.getName());
                    dstFld.setAccessible(true);
                    dstFld.set(destination, srcFld.get(source));
                }
            } catch (Exception exp) {
                log.error("Failed to copy non editable field '{}', error: {}", srcFld.getName(), exp.getMessage());
                log.debug("Exception", exp);
                return false;
            }
        }
        cls = cls.getSuperclass();
    }
    return true;
}
#end_block

#method_before
private void writeInterfaces(List<VmDevice> devices) {
    Map<VmDeviceId, VmNetworkInterface> devIdToNic = vm.getInterfaces().stream().collect(Collectors.toMap(nic -> new VmDeviceId(nic.getId(), nic.getVmId()), nic -> nic));
    devices.forEach(dev -> writeInterface(dev, devIdToNic.get(dev.getId())));
}
#method_after
private void writeInterfaces(List<VmDevice> devices) {
    Map<VmDeviceId, VmNetworkInterface> devIdToNic = vm.getInterfaces().stream().collect(Collectors.toMap(nic -> new VmDeviceId(nic.getId(), nic.getVmId()), nic -> nic));
    devices.stream().sorted(Comparator.comparing(dev -> devIdToNic.get(dev.getId()).getMacAddress())).forEach(dev -> writeInterface(dev, devIdToNic.get(dev.getId())));
}
#end_block

#method_before
private void writeDiskDriver(VmDevice device, Disk disk, DiskVmElement dve) {
    writer.writeStartElement("driver");
    writer.writeAttributeString("name", "qemu");
    if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion()) && dve.isPassDiscard()) {
        writer.writeAttributeString("discard", "unmap");
    }
    if (device.getSpecParams().containsKey("pinToIoThread")) {
        writer.writeAttributeString("iothread", device.getSpecParams().get("pinToIoThread").toString());
    }
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            writer.writeAttributeString("io", "file".equals(diskType) ? "native" : "threads");
            writer.writeAttributeString("type", diskImage.getVolumeFormat() == VolumeFormat.COW ? "qcow2" : "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case LUN:
            writer.writeAttributeString("io", "native");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case CINDER:
            // case RBD
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", "stop");
            writer.writeAttributeString("io", "threads");
            break;
    }
    if (device.getSnapshotId() != null) {
        // transient disk
        /**
         *            Force the cache to be writethrough, which is qemu's default.
         *            This is done to ensure that we don't ever use cache=none for
         *            transient disks, since we create them in /var/run/vdsm which
         *            may end up on tmpfs and don't support O_DIRECT, and qemu uses
         *            O_DIRECT when cache=none and hence hotplug might fail with
         *            error that one can take eternity to debug the reason behind it!
         */
        writer.writeAttributeString("cache", "writethrough");
    } else {
        switch(dve.getDiskInterface()) {
            case VirtIO:
            // TODO: if custom property is set...
            default:
                writer.writeAttributeString("cache", "none");
        }
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskDriver(VmDevice device, Disk disk, DiskVmElement dve) {
    writer.writeStartElement("driver");
    writer.writeAttributeString("name", "qemu");
    if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion()) && dve.isPassDiscard()) {
        writer.writeAttributeString("discard", "unmap");
    }
    if (device.getSpecParams().containsKey("pinToIoThread")) {
        writer.writeAttributeString("iothread", device.getSpecParams().get("pinToIoThread").toString());
    }
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            writer.writeAttributeString("io", "file".equals(diskType) ? "threads" : "native");
            writer.writeAttributeString("type", diskImage.getVolumeFormat() == VolumeFormat.COW ? "qcow2" : "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case LUN:
            writer.writeAttributeString("io", "native");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case CINDER:
            // case RBD
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", "stop");
            writer.writeAttributeString("io", "threads");
            break;
    }
    if (device.getSnapshotId() != null) {
        // transient disk
        /**
         *            Force the cache to be writethrough, which is qemu's default.
         *            This is done to ensure that we don't ever use cache=none for
         *            transient disks, since we create them in /var/run/vdsm which
         *            may end up on tmpfs and don't support O_DIRECT, and qemu uses
         *            O_DIRECT when cache=none and hence hotplug might fail with
         *            error that one can take eternity to debug the reason behind it!
         */
        writer.writeAttributeString("cache", "writethrough");
    } else {
        switch(dve.getDiskInterface()) {
            case VirtIO:
            // TODO: if custom property is set...
            default:
                writer.writeAttributeString("cache", "none");
        }
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDiskSource(Disk disk, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", String.format("/rhev/data-center/mnt/blockSD/%s/images/%s/%s", diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                    break;
                case "file":
                    writer.writeAttributeString("file", String.format("/rhev/data-center/%s/%s/images/%s/%s", diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                    break;
                case "network":
                    writer.writeAttributeString("protocol", "gluster");
                    StorageDomainStatic dom = this.storageDomainStaticDao.get(((DiskImage) disk).getStorageIds().get(0));
                    StorageServerConnections con = this.storageServerConnectionDao.getAllForDomain(dom.getId()).get(0);
                    GlusterVolumeEntity vol = glusterVolumeDao.getById(con.getGlusterVolumeId());
                    writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", vol.getName(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                    vol.getBricks().stream().filter(b -> b.getStatus().equals(GlusterStatus.UP)).limit(// Due to BZ#1465810 we have to limit hosts. Remove it when libvirt will be fixed.
                    1).forEach((brick) -> {
                        writer.writeStartElement("host");
                        writer.writeAttributeString("name", brick.getServerName());
                        writer.writeAttributeString("port", "0");
                        writer.writeEndElement();
                    });
                    break;
            }
            Map<String, Object> diskUuids = new HashMap<>();
            diskUuids.put("poolID", diskImage.getStoragePoolId());
            diskUuids.put("domainID", diskImage.getStorageIds().get(0));
            diskUuids.put("imageID", diskImage.getId());
            diskUuids.put("volumeID", diskImage.getImageId());
            diskMetadata.put(dev, diskUuids);
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskSource(Disk disk, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", String.format("/rhev/data-center/mnt/blockSD/%s/images/%s/%s", diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                    break;
                case "file":
                    writer.writeAttributeString("file", String.format("/rhev/data-center/%s/%s/images/%s/%s", diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                    break;
                case "network":
                    writer.writeAttributeString("protocol", "gluster");
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                    writer.writeStartElement("host");
                    writer.writeAttributeString("name", volInfo[0]);
                    writer.writeAttributeString("port", "0");
                    writer.writeEndElement();
                    break;
            }
            Map<String, Object> diskUuids = new HashMap<>();
            diskUuids.put("poolID", diskImage.getStoragePoolId());
            diskUuids.put("domainID", diskImage.getStorageIds().get(0));
            diskUuids.put("imageID", diskImage.getId());
            diskUuids.put("volumeID", diskImage.getImageId());
            diskMetadata.put(dev, diskUuids);
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#end_block

#method_before
@Override
public Response add(Network network) {
    validateParameters(network, getRequiredAddFields());
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    AddNetworkStoragePoolParameters params = getAddParameters(network, entity);
    return performCreate(network.isSetExternalProvider() ? addOnProviderAction : addAction, params, new DataCenterNetworkIdResolver(network.getName(), params.getStoragePoolId().toString()));
}
#method_after
@Override
public Response add(Network network) {
    validateParameters(network, getRequiredAddFields());
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    AddNetworkStoragePoolParameters params = getAddParameters(network, entity);
    return performCreate(network.isSetExternalProvider() ? ActionType.AddNetworkOnProvider : addAction, params, new DataCenterNetworkIdResolver(network.getName(), params.getStoragePoolId().toString()));
}
#end_block

#method_before
public boolean canSyncNics(List<? extends NetworkInterface> currentDbNics, List<? extends NetworkInterface> snapshotedNics) {
    CountMacUsageDifference macUsageDifference = new CountMacUsageDifference(vmNicsToMacAddresses(currentDbNics), vmNicsToMacAddresses(snapshotedNics), macsInSnapshotAreExpectedToBeAlreadyAllocated);
    // release extra macs.
    macPool.freeMacs(macUsageDifference.getExtraMacs());
    List<String> macs = macUsageDifference.getMissingMacs();
    if (macs.isEmpty()) {
        return true;
    }
    boolean canReallocateMacs = true;
    List<String> macsCopy = new ArrayList<>(macs);
    for (NetworkInterface vmInterface : snapshotedNics) {
        String originalMacAddress = vmInterface.getMacAddress();
        if (macsCopy.contains(originalMacAddress)) {
            canReallocateMacs &= macPool.canAllocateNewMac();
        }
    }
    return canReallocateMacs;
}
#method_after
public boolean canSyncNics(List<? extends NetworkInterface> currentDbNics, List<? extends NetworkInterface> snapshotedNics) {
    CountMacUsageDifference macUsageDifference = new CountMacUsageDifference(vmNicsToMacAddresses(currentDbNics), vmNicsToMacAddresses(snapshotedNics), macsInSnapshotAreExpectedToBeAlreadyAllocated);
    List<String> macsToBeAdded = macUsageDifference.getMissingMacs();
    if (macsToBeAdded.isEmpty()) {
        return true;
    }
    List<String> macsToBeRemoved = macUsageDifference.getExtraMacs();
    int numOfMacsToAdd = macsToBeAdded.size() - macsToBeRemoved.size();
    return numOfMacsToAdd > 0 ? macPool.canAllocateMacAddresses(numOfMacsToAdd) : true;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START : AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT;
        default:
            return AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getSucceeded()) {
                if (getParameters().getSnapshotAction() == SnapshotActionEnum.UNDO) {
                    return AuditLogType.USER_UNDO_RESTORE_FROM_SNAPSHOT_START;
                }
                return AuditLogType.USER_COMMIT_RESTORE_FROM_SNAPSHOT_START;
            }
            if (getParameters().getSnapshotAction() == SnapshotActionEnum.UNDO) {
                return AuditLogType.USER_UNDO_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE;
            }
            return AuditLogType.USER_COMMIT_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE;
        default:
            if (getParameters().getSnapshotAction() == SnapshotActionEnum.UNDO) {
                return AuditLogType.USER_UNDO_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS;
            }
            return AuditLogType.USER_COMMIT_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS;
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(snapshotsValidator.snapshotExists(getSnapshot())) || !validate(snapshotsValidator.snapshotExists(getVmId(), getSnapshot().getId())) || !validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (Guid.Empty.equals(getSnapshot().getId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    VmValidator vmValidator = createVmValidator(getVm());
    MultipleStorageDomainsValidator storageValidator = createStorageDomainValidator();
    if (!validate(storageValidator.allDomainsExistAndActive()) || !performImagesChecks() || !validate(vmValidator.vmDown()) || // if the user choose to commit a snapshot the vm can't have disk snapshots attached to other vms.
    getSnapshot().getType() == SnapshotType.REGULAR && !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    if (getSnapshot().getType() == SnapshotType.REGULAR && getSnapshot().getStatus() != SnapshotStatus.IN_PREVIEW) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_NOT_IN_PREVIEW);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(snapshotsValidator.snapshotExists(getSnapshot())) || !validate(snapshotsValidator.snapshotExists(getVmId(), getSnapshot().getId())) || !validate(new StoragePoolValidator(getStoragePool()).existsAndUp())) {
        return false;
    }
    if (Guid.Empty.equals(getSnapshot().getId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    VmValidator vmValidator = createVmValidator(getVm());
    MultipleStorageDomainsValidator storageValidator = createStorageDomainValidator();
    if (!validate(storageValidator.allDomainsExistAndActive()) || !performImagesChecks() || !validate(vmValidator.vmDown()) || // if the user choose to commit a snapshot the vm can't have disk snapshots attached to other vms.
    getSnapshot().getType() == SnapshotType.REGULAR && !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    if (getSnapshot().getType() == SnapshotType.REGULAR && getSnapshot().getStatus() != SnapshotStatus.IN_PREVIEW) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_NOT_IN_PREVIEW);
    }
    if (!canRestoreVmConfigFromSnapshot()) {
        return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = isRestoreMemory();
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        snapshotDao.remove(previousActiveSnapshotId);
        getSnapshotsManager().addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
        getSnapshotsManager().addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, snapshotToBePreviewed.getCreationDate(), images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    if (!filteredImages.isEmpty()) {
        vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    ActionReturnValue actionReturnValue = runInternalActionWithTasksContext(ActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (actionReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
                    } else if (actionReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(actionReturnValue.getFault().getError(), actionReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(ActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    } else {
        // if there are no disks to restore, no compensation context is saved and the VM Configuration
        // (including clusterCompatibilityVersionOrigin) is already restored at this point. Otherwise,
        // if disks are being restored, the VM Configuration is restored later in endSuccessfully()
        updateClusterCompatibilityVersionToOldCluster(true);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = isRestoreMemory();
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    if (log.isInfoEnabled()) {
        log.info("Previewing snapshot {} with the disks:\n{}", getSnapshotName(), filteredImages.stream().map(disk -> String.format("%s (%s) to imageId %s", disk.getName(), disk.getId().toString(), disk.getImageId().toString())).collect(Collectors.joining("\n")));
    }
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        snapshotDao.remove(previousActiveSnapshotId);
        getSnapshotsManager().addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
        getSnapshotsManager().addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, snapshotToBePreviewed.getCreationDate(), images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    if (!filteredImages.isEmpty()) {
        vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    ActionReturnValue actionReturnValue = runInternalActionWithTasksContext(ActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (actionReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
                    } else if (actionReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(actionReturnValue.getFault().getError(), actionReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(ActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    } else {
        // if there are no disks to restore, no compensation context is saved and the VM Configuration
        // (including clusterCompatibilityVersionOrigin) is already restored at this point. Otherwise,
        // if disks are being restored, the VM Configuration is restored later in endSuccessfully()
        updateClusterCompatibilityVersionToOldCluster(true);
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (Guid.Empty.equals(getParameters().getDstSnapshotId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    VmValidator vmValidator = new VmValidator(getVm());
    if (!validate(vmValidator.isVmExists()) || !validate(vmValidator.vmDown()) || !validate(snapshotsValidator.snapshotExists(getVmId(), getParameters().getDstSnapshotId())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) || !validate(snapshotsValidator.vmNotInPreview(getVmId())) || !validate(snapshotsValidator.snapshotVmConfigurationBroken(getDstSnapshot(), getVmName()))) {
        return false;
    }
    updateVmDisksFromDb();
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE);
    diskImages.addAll(DisksFilter.filterCinderDisks(getVm().getDiskMap().values(), ONLY_PLUGGED));
    if (!diskImages.isEmpty()) {
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImages);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        DiskImagesValidator diskImagesToPreviewValidator = new DiskImagesValidator(getImagesToPreview());
        if (!validate(diskImagesToPreviewValidator.diskImagesNotIllegal()) || !validate(diskImagesToPreviewValidator.diskImagesNotLocked())) {
            return false;
        }
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(diskImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !validateCinder()) {
            return false;
        }
    }
    DiskSnapshotsValidator diskSnapshotsValidator = new DiskSnapshotsValidator(getParameters().getDisks());
    if (!validate(diskSnapshotsValidator.canDiskSnapshotsBePreviewed(getParameters().getDstSnapshotId()))) {
        return false;
    }
    if (isRestoreMemory() && !validateMemoryTakenInSupportedVersion()) {
        return false;
    }
    if (!canRestoreVmConfigFromSnapshot()) {
        return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (Guid.Empty.equals(getParameters().getDstSnapshotId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    VmValidator vmValidator = new VmValidator(getVm());
    if (!validate(vmValidator.isVmExists()) || !validate(vmValidator.vmDown()) || !validate(snapshotsValidator.snapshotExists(getVmId(), getParameters().getDstSnapshotId())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) || !validate(snapshotsValidator.vmNotInPreview(getVmId())) || !validate(snapshotsValidator.snapshotVmConfigurationBroken(getDstSnapshot(), getVmName()))) {
        return false;
    }
    updateVmDisksFromDb();
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE);
    diskImages.addAll(DisksFilter.filterCinderDisks(getVm().getDiskMap().values(), ONLY_PLUGGED));
    if (!diskImages.isEmpty()) {
        if (!validate(new StoragePoolValidator(getStoragePool()).existsAndUp())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImages);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        DiskImagesValidator diskImagesToPreviewValidator = new DiskImagesValidator(getImagesToPreview());
        if (!validate(diskImagesToPreviewValidator.diskImagesNotIllegal()) || !validate(diskImagesToPreviewValidator.diskImagesNotLocked())) {
            return false;
        }
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(diskImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !validateCinder()) {
            return false;
        }
    }
    DiskSnapshotsValidator diskSnapshotsValidator = new DiskSnapshotsValidator(getParameters().getDisks());
    if (!validate(diskSnapshotsValidator.canDiskSnapshotsBePreviewed(getParameters().getDstSnapshotId()))) {
        return false;
    }
    if (isRestoreMemory() && !validateMemoryTakenInSupportedVersion()) {
        return false;
    }
    if (!canRestoreVmConfigFromSnapshot()) {
        return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
    }
    return true;
}
#end_block

#method_before
private boolean validateMemoryTakenInSupportedVersion() {
    VM vmFromSnapshot = null;
    try {
        vmFromSnapshot = ovfHelper.readVmFromOvf(getDstSnapshot().getVmConfiguration());
    } catch (OvfReaderException e) {
        // should never happen since the OVF was created by us
        log.error("Failed to parse a given ovf configuration: {}", e.getMessage());
        return false;
    }
    Version originalClusterVersion = vmFromSnapshot.getClusterCompatibilityVersionOrigin();
    if (Version.getLowest().greater(originalClusterVersion)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_TOO_OLD, String.format("$Cv %s", originalClusterVersion != null ? originalClusterVersion : "N/A"));
    }
    return true;
}
#method_after
private boolean validateMemoryTakenInSupportedVersion() {
    VM vmFromSnapshot = null;
    try {
        vmFromSnapshot = ovfHelper.readVmFromOvf(getDstSnapshot().getVmConfiguration()).getVm();
    } catch (OvfReaderException e) {
        // should never happen since the OVF was created by us
        log.error("Failed to parse a given ovf configuration: {}", e.getMessage());
        return false;
    }
    Version originalClusterVersion = vmFromSnapshot.getClusterCompatibilityVersionOrigin();
    if (Version.getLowest().greater(originalClusterVersion)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_TOO_OLD, String.format("$Cv %s", originalClusterVersion != null ? originalClusterVersion : "N/A"));
    }
    return true;
}
#end_block

#method_before
protected String generateVmConfiguration(VM vm, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices) {
    if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(vmNetworkInterfaceDao.getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = vmTemplateDao.get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    if (vmDevices == null) {
        vmDeviceUtils.setVmDevices(vm.getStaticData());
    } else {
        vm.getStaticData().setManagedDeviceMap(vmDevices);
    }
    if (disks == null) {
        disks = DisksFilter.filterImageDisks(diskDao.getAllForVm(vm.getId()), ONLY_SNAPABLE, ONLY_ACTIVE);
        disks.addAll(imagesHandler.getCinderLeafImages(diskDao.getAllForVm(vm.getId())));
    }
    populateDisksWithVmData(disks, vm.getId());
    disks.forEach(image -> image.setStorageIds(null));
    return ovfManager.exportVm(vm, new ArrayList<>(disks), Collections.EMPTY_LIST, clusterUtils.getCompatibilityVersion(vm));
}
#method_after
protected String generateVmConfiguration(VM vm, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices) {
    if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(vmNetworkInterfaceDao.getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = vmTemplateDao.get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    if (vmDevices == null) {
        vmDeviceUtils.setVmDevices(vm.getStaticData());
    } else {
        vm.getStaticData().setManagedDeviceMap(vmDevices);
    }
    if (disks == null) {
        disks = DisksFilter.filterImageDisks(diskDao.getAllForVm(vm.getId()), ONLY_SNAPABLE, ONLY_ACTIVE);
        disks.addAll(imagesHandler.getCinderLeafImages(diskDao.getAllForVm(vm.getId())));
    }
    populateDisksWithVmData(disks, vm.getId());
    disks.forEach(image -> image.setStorageIds(null));
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(vm);
    fullEntityOvfData.setDiskImages(disks);
    return ovfManager.exportVm(vm, fullEntityOvfData, clusterUtils.getCompatibilityVersion(vm));
}
#end_block

#method_before
public boolean canRestoreVmConfigurationFromSnapshot(VM vm, Snapshot snapshot, VmInterfaceManager vmInterfaceManager) {
    boolean canReallocateMacs = false;
    if (snapshot.getVmConfiguration() != null) {
        VM tempVM = new VM();
        if (vm.getDynamicData() != null) {
            tempVM.setDynamicData(vm.getDynamicData());
        }
        ArrayList<VmNetworkInterface> interfaces = new ArrayList<>();
        try {
            ovfManager.importVm(snapshot.getVmConfiguration(), tempVM, new ArrayList<>(), interfaces);
        } catch (OvfReaderException e) {
            log.error("Failed to import VM from the configuration '{}': {}", snapshot.getVmConfiguration(), e.getMessage());
            log.debug("Exception", e);
            return false;
        }
        boolean macsInSnapshotAreExpectedToBeAlreadyAllocated = SnapshotType.STATELESS.equals(snapshot.getType());
        canReallocateMacs = canSynchronizeNics(vm, vmInterfaceManager, interfaces, macsInSnapshotAreExpectedToBeAlreadyAllocated);
    }
    return canReallocateMacs;
}
#method_after
public boolean canRestoreVmConfigurationFromSnapshot(VM vm, Snapshot snapshot, VmInterfaceManager vmInterfaceManager) {
    if (snapshot.getVmConfiguration() == null) {
        return false;
    }
    VM tempVM = new VM();
    if (vm.getDynamicData() != null) {
        tempVM.setDynamicData(vm.getDynamicData());
    }
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(tempVM);
    try {
        ovfManager.importVm(snapshot.getVmConfiguration(), tempVM, fullEntityOvfData);
    } catch (OvfReaderException e) {
        log.error("Failed to import VM from the configuration '{}': {}", snapshot.getVmConfiguration(), e.getMessage());
        log.debug("Exception", e);
        return false;
    }
    boolean macsInSnapshotAreExpectedToBeAlreadyAllocated = SnapshotType.STATELESS.equals(snapshot.getType());
    return canSynchronizeNics(vm, vmInterfaceManager, fullEntityOvfData.getInterfaces(), macsInSnapshotAreExpectedToBeAlreadyAllocated);
}
#end_block

#method_before
public boolean updateVmFromConfiguration(VM vm, String configuration) {
    try {
        VmStatic oldVmStatic = vm.getStaticData();
        VM tempVM = new VM();
        if (vm.getDynamicData() != null) {
            tempVM.setDynamicData(vm.getDynamicData());
        }
        ArrayList<DiskImage> images = new ArrayList<>();
        ArrayList<VmNetworkInterface> interfaces = new ArrayList<>();
        ovfManager.importVm(configuration, tempVM, images, Collections.EMPTY_LIST, interfaces);
        for (DiskImage diskImage : images) {
            DiskImage dbImage = diskImageDao.getSnapshotById(diskImage.getImageId());
            if (dbImage != null) {
                diskImage.setStorageIds(dbImage.getStorageIds());
            }
        }
        new VMStaticOvfLogHandler(tempVM.getStaticData()).resetDefaults(oldVmStatic);
        vm.setStaticData(tempVM.getStaticData());
        IconUtils.preserveIcons(vm.getStaticData(), oldVmStatic);
        vm.setImages(images);
        vm.setInterfaces(interfaces);
        // These fields are not saved in the OVF, so get them from the current VM.
        vm.setIsoPath(oldVmStatic.getIsoPath());
        vm.setCpuProfileId(oldVmStatic.getCpuProfileId());
        vm.setClusterId(oldVmStatic.getClusterId());
        // The VM configuration does not hold the vds group Id.
        // It is necessary to fetch the vm static from the Db, in order to get this information
        VmStatic vmStaticFromDb = vmStaticDao.get(vm.getId());
        if (vmStaticFromDb != null) {
            Cluster cluster = clusterDao.get(vmStaticFromDb.getClusterId());
            if (cluster != null) {
                vm.setStoragePoolId(cluster.getStoragePoolId());
                vm.setClusterCompatibilityVersion(cluster.getCompatibilityVersion());
                vm.setClusterName(cluster.getName());
                vm.setClusterCpuName(cluster.getCpuName());
            }
        }
        // if the required dedicated host is invalid -> use current VM dedicated host
        if (!vmHandler.validateDedicatedVdsExistOnSameCluster(vm.getStaticData()).isValid()) {
            vm.setDedicatedVmForVdsList(oldVmStatic.getDedicatedVmForVdsList());
        }
        vmHandler.updateMaxMemorySize(vm.getStaticData(), vm.getCompatibilityVersion());
        validateQuota(vm);
        return true;
    } catch (OvfReaderException e) {
        log.error("Failed to update VM from the configuration '{}': {}", configuration, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#method_after
public boolean updateVmFromConfiguration(VM vm, String configuration) {
    try {
        VmStatic oldVmStatic = vm.getStaticData();
        VM tempVM = new VM();
        if (vm.getDynamicData() != null) {
            tempVM.setDynamicData(vm.getDynamicData());
        }
        FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(tempVM);
        ovfManager.importVm(configuration, tempVM, fullEntityOvfData);
        for (DiskImage diskImage : fullEntityOvfData.getDiskImages()) {
            DiskImage dbImage = diskImageDao.getSnapshotById(diskImage.getImageId());
            if (dbImage != null) {
                diskImage.setStorageIds(dbImage.getStorageIds());
            }
        }
        new VMStaticOvfLogHandler(tempVM.getStaticData()).resetDefaults(oldVmStatic);
        vm.setStaticData(tempVM.getStaticData());
        IconUtils.preserveIcons(vm.getStaticData(), oldVmStatic);
        vm.setImages((ArrayList<DiskImage>) fullEntityOvfData.getDiskImages());
        vm.setInterfaces(fullEntityOvfData.getInterfaces());
        // These fields are not saved in the OVF, so get them from the current VM.
        vm.setIsoPath(oldVmStatic.getIsoPath());
        vm.setCpuProfileId(oldVmStatic.getCpuProfileId());
        vm.setClusterId(oldVmStatic.getClusterId());
        // The VM configuration does not hold the vds group Id.
        // It is necessary to fetch the vm static from the Db, in order to get this information
        VmStatic vmStaticFromDb = vmStaticDao.get(vm.getId());
        if (vmStaticFromDb != null) {
            Cluster cluster = clusterDao.get(vmStaticFromDb.getClusterId());
            if (cluster != null) {
                vm.setStoragePoolId(cluster.getStoragePoolId());
                vm.setClusterCompatibilityVersion(cluster.getCompatibilityVersion());
                vm.setClusterName(cluster.getName());
                vm.setClusterCpuName(cluster.getCpuName());
            }
        }
        // if the required dedicated host is invalid -> use current VM dedicated host
        if (!vmHandler.validateDedicatedVdsExistOnSameCluster(vm.getStaticData()).isValid()) {
            vm.setDedicatedVmForVdsList(oldVmStatic.getDedicatedVmForVdsList());
        }
        vmHandler.updateMaxMemorySize(vm.getStaticData(), vm.getCompatibilityVersion());
        vmHandler.autoSelectResumeBehavior(vm.getStaticData(), vm.getCompatibilityVersion());
        validateQuota(vm);
        return true;
    } catch (OvfReaderException e) {
        log.error("Failed to update VM from the configuration '{}': {}", configuration, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#end_block

#method_before
public Optional<VM> getVmConfigurationInStatelessSnapshotOfVm(Guid vmId) {
    Snapshot snapshot = snapshotDao.get(vmId, SnapshotType.STATELESS);
    if (snapshot == null) {
        return Optional.empty();
    }
    try {
        return Optional.of(ovfHelper.readVmFromOvf(snapshot.getVmConfiguration()));
    } catch (OvfReaderException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public Optional<VM> getVmConfigurationInStatelessSnapshotOfVm(Guid vmId) {
    Snapshot snapshot = snapshotDao.get(vmId, SnapshotType.STATELESS);
    if (snapshot == null) {
        return Optional.empty();
    }
    try {
        return Optional.of(ovfHelper.readVmFromOvf(snapshot.getVmConfiguration()).getVm());
    } catch (OvfReaderException e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public boolean canSynchronizeNics(VM snapshotedVm, VmInterfaceManager vmInterfaceManager, ArrayList<VmNetworkInterface> interfaces, boolean macsInSnapshotAreExpectedToBeAlreadyAllocated) {
    MacPool macPool = vmInterfaceManager.getMacPool();
    List<VmNic> dbNics = vmNicDao.getAllForVm(snapshotedVm.getId());
    return new SyncMacsOfDbNicsWithSnapshot(macPool, auditLogDirector, macsInSnapshotAreExpectedToBeAlreadyAllocated).canSyncNics(dbNics, interfaces);
}
#method_after
public boolean canSynchronizeNics(VM snapshotedVm, VmInterfaceManager vmInterfaceManager, List<VmNetworkInterface> interfaces, boolean macsInSnapshotAreExpectedToBeAlreadyAllocated) {
    MacPool macPool = vmInterfaceManager.getMacPool();
    List<VmNic> dbNics = vmNicDao.getAllForVm(snapshotedVm.getId());
    return new SyncMacsOfDbNicsWithSnapshot(macPool, auditLogDirector, macsInSnapshotAreExpectedToBeAlreadyAllocated).canSyncNics(dbNics, interfaces);
}
#end_block

#method_before
@Mapping(from = Network.class, to = org.ovirt.engine.core.common.businessentities.network.Network.class)
public static org.ovirt.engine.core.common.businessentities.network.Network map(Network model, org.ovirt.engine.core.common.businessentities.network.Network template) {
    org.ovirt.engine.core.common.businessentities.network.Network entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.network.Network();
    entity.setCluster(template != null && template.getCluster() != null ? template.getCluster() : new NetworkCluster());
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setDataCenterId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setAddr(model.getIp().getAddress());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setSubnet(model.getIp().getNetmask());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
    }
    if (model.isSetVlan()) {
        entity.setVlanId(model.getVlan().getId());
    }
    if (model.isSetStp()) {
        entity.setStp(model.isStp());
    }
    if (model.isSetDisplay()) {
        // for backward compatibility use display tag or usage tag
        entity.getCluster().setDisplay(model.isDisplay());
    }
    if (model.isSetUsages()) {
        List<NetworkUsage> networkUsages = new ArrayList<>();
        for (NetworkUsage usage : model.getUsages().getUsages()) {
            networkUsages.add(usage);
        }
        entity.getCluster().setDisplay(networkUsages.contains(NetworkUsage.DISPLAY));
        entity.getCluster().setMigration(networkUsages.contains(NetworkUsage.MIGRATION));
        entity.getCluster().setManagement(networkUsages.contains(NetworkUsage.MANAGEMENT));
        entity.getCluster().setGluster(networkUsages.contains(NetworkUsage.GLUSTER));
        entity.getCluster().setDefaultRoute(networkUsages.contains(NetworkUsage.DEFAULT_ROUTE));
        entity.setVmNetwork(networkUsages.contains(NetworkUsage.VM));
    }
    if (model.isSetMtu()) {
        entity.setMtu(model.getMtu());
    }
    if (model.isSetRequired()) {
        entity.getCluster().setRequired(model.isRequired());
    }
    if (model.isSetQos()) {
        entity.setQosId(Guid.createGuidFromString(model.getQos().getId()));
    }
    if (model.isSetDnsResolverConfiguration()) {
        entity.setDnsResolverConfiguration(DnsResolverConfigurationMapper.map(entity.getDnsResolverConfiguration(), model.getDnsResolverConfiguration()));
    }
    if (model.isSetExternalProvider()) {
        ProviderNetwork providerNetwork = new ProviderNetwork();
        providerNetwork.setProviderId(GuidUtils.asGuid(model.getExternalProvider().getId()));
        entity.setProvidedBy(providerNetwork);
    }
    return entity;
}
#method_after
@Mapping(from = Network.class, to = org.ovirt.engine.core.common.businessentities.network.Network.class)
public static org.ovirt.engine.core.common.businessentities.network.Network map(Network model, org.ovirt.engine.core.common.businessentities.network.Network template) {
    org.ovirt.engine.core.common.businessentities.network.Network entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.network.Network();
    entity.setCluster(template != null && template.getCluster() != null ? template.getCluster() : new NetworkCluster());
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setDataCenterId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setAddr(model.getIp().getAddress());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setSubnet(model.getIp().getNetmask());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
    }
    if (model.isSetVlan()) {
        entity.setVlanId(model.getVlan().getId());
    }
    if (model.isSetStp()) {
        entity.setStp(model.isStp());
    }
    if (model.isSetDisplay()) {
        // for backward compatibility use display tag or usage tag
        entity.getCluster().setDisplay(model.isDisplay());
    }
    if (model.isSetUsages()) {
        List<NetworkUsage> networkUsages = new ArrayList<>();
        for (NetworkUsage usage : model.getUsages().getUsages()) {
            networkUsages.add(usage);
        }
        entity.getCluster().setDisplay(networkUsages.contains(NetworkUsage.DISPLAY));
        entity.getCluster().setMigration(networkUsages.contains(NetworkUsage.MIGRATION));
        entity.getCluster().setManagement(networkUsages.contains(NetworkUsage.MANAGEMENT));
        entity.getCluster().setGluster(networkUsages.contains(NetworkUsage.GLUSTER));
        entity.getCluster().setDefaultRoute(networkUsages.contains(NetworkUsage.DEFAULT_ROUTE));
        entity.setVmNetwork(networkUsages.contains(NetworkUsage.VM));
    }
    if (model.isSetMtu()) {
        entity.setMtu(model.getMtu());
    }
    if (model.isSetRequired()) {
        entity.getCluster().setRequired(model.isRequired());
    }
    if (model.isSetQos()) {
        entity.setQosId(Guid.createGuidFromString(model.getQos().getId()));
    }
    if (model.isSetDnsResolverConfiguration()) {
        entity.setDnsResolverConfiguration(DnsResolverConfigurationMapper.map(entity.getDnsResolverConfiguration(), model.getDnsResolverConfiguration()));
    }
    if (model.isSetExternalProvider() && model.getExternalProvider().isSetId()) {
        ProviderNetwork providerNetwork = new ProviderNetwork();
        providerNetwork.setProviderId(GuidUtils.asGuid(model.getExternalProvider().getId()));
        entity.setProvidedBy(providerNetwork);
    }
    return entity;
}
#end_block

#method_before
protected void setQcowCompatByQemuImageInfo(Guid storagePoolId, Guid newImageGroupId, Guid newImageId, Guid newStorageDomainID, DiskImage diskImage) {
    // If the VM is running then the volume is already prepared in the guest's host so there
    // is no need for prepare and teardown.
    Guid hostIdToExecuteQemuImageInfo = vmDao.getVmsWithPlugInfo(diskImage.getId()).stream().map(p -> p.getFirst().getRunOnVds()).findFirst().orElse(null);
    setQcowCompat(diskImage.getImage(), storagePoolId, newImageGroupId, newImageId, newStorageDomainID, hostIdToExecuteQemuImageInfo);
}
#method_after
protected void setQcowCompatByQemuImageInfo(Guid storagePoolId, Guid newImageGroupId, Guid newImageId, Guid newStorageDomainID, DiskImage diskImage) {
    // If the VM is running then the volume is already prepared in the guest's host so there
    // is no need for prepare and teardown.
    Guid hostIdToExecuteQemuImageInfo = vmDao.getVmsWithPlugInfo(diskImage.getId()).stream().filter(p -> p.getSecond().isPlugged()).map(p -> p.getFirst().getRunOnVds()).filter(// filter out null Vds, happens when VM isn't running
    Objects::nonNull).findFirst().orElse(null);
    setQcowCompat(diskImage.getImage(), storagePoolId, newImageGroupId, newImageId, newStorageDomainID, hostIdToExecuteQemuImageInfo);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<DiskVmElement> diskVmElements = diskVmElementDao.getAllDiskVmElementsByDiskId(getParameters().getImageGroupID());
    ActionType actionType = getMoveActionType(diskVmElements);
    if (actionType == ActionType.MoveOrCopyDisk) {
        MoveDiskParameters moveDiskParameters = getParameters();
        // This is required to make MoveDiskCommand and MoveOrCopyDiskCommand have
        // different a commandId. Having the same commandId will make CommandsCache
        // return the wrong command and lead to unexpected results
        moveDiskParameters.setCommandId(null);
        actionReturnValue = runInternalAction(actionType, moveDiskParameters, ExecutionHandler.createInternalJobContext(getContext(), getLock()));
    } else {
        Guid vmId = diskVmElements.get(0).getVmId();
        engineLock = lockVmWithWait(vmId);
        actionReturnValue = runInternalAction(actionType, createLiveMigrateDiskParameters(getParameters(), vmId), ExecutionHandler.createInternalJobContext(getContext(), engineLock));
    }
    handleChildReturnValue();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    List<DiskVmElement> diskVmElements = diskVmElementDao.getAllDiskVmElementsByDiskId(getParameters().getImageGroupID());
    ActionType actionType = getMoveActionType(diskVmElements);
    if (actionType == ActionType.MoveOrCopyDisk) {
        MoveDiskParameters moveDiskParameters = getParameters();
        // This is required to make MoveDiskCommand and MoveOrCopyDiskCommand have
        // different a commandId. Having the same commandId will make CommandsCache
        // return the wrong command and lead to unexpected results
        moveDiskParameters.setCommandId(null);
        setReturnValue(runInternalAction(actionType, moveDiskParameters, ExecutionHandler.createInternalJobContext(getContext(), getLock())));
    } else {
        Guid vmId = diskVmElements.get(0).getVmId();
        engineLock = lockVmWithWait(vmId);
        setReturnValue(runInternalAction(actionType, createLiveMigrateDiskParameters(getParameters(), vmId), ExecutionHandler.createInternalJobContext(getContext(), engineLock)));
    }
    setSucceeded(true);
}
#end_block

#method_before
private LiveMigrateDiskParameters createLiveMigrateDiskParameters(MoveDiskParameters moveDiskParameters, Guid vmId) {
    return new LiveMigrateDiskParameters(moveDiskParameters.getImageId(), moveDiskParameters.getSourceDomainId(), moveDiskParameters.getStorageDomainId(), vmId, moveDiskParameters.getQuotaId(), moveDiskParameters.getDiskProfileId(), getParameters().getImageGroupID());
}
#method_after
private LiveMigrateDiskParameters createLiveMigrateDiskParameters(MoveDiskParameters moveDiskParameters, Guid vmId) {
    LiveMigrateDiskParameters params = new LiveMigrateDiskParameters(moveDiskParameters.getImageId(), moveDiskParameters.getSourceDomainId(), moveDiskParameters.getStorageDomainId(), vmId, moveDiskParameters.getQuotaId(), moveDiskParameters.getDiskProfileId(), getParameters().getImageGroupID());
    // Pass down correlation ID, useful when it's set externally (e.g. via the API)
    params.setCorrelationId(getCorrelationId());
    return params;
}
#end_block

#method_before
private ArrayList<LunModel> getLuns(boolean selectedLuns, boolean includedLuns) {
    ArrayList<LunModel> luns = new ArrayList<>();
    if (getItems() != null) {
        if (getIsGrouppedByTarget()) {
            List<SanTargetModel> items = (List<SanTargetModel>) getItems();
            for (SanTargetModel item : items) {
                luns.addAll(getAddedLuns(item.getLuns(), selectedLuns, includedLuns));
            }
        } else {
            List<LunModel> items = (List<LunModel>) getItems();
            luns.addAll(getAddedLuns(items, selectedLuns, includedLuns));
        }
    }
    return luns;
}
#method_after
private ArrayList<LunModel> getLuns(boolean selectedLuns, boolean includedLuns) {
    ArrayList<LunModel> luns = new ArrayList<>();
    if (getItems() != null) {
        if (getIsGrouppedByTarget()) {
            List<SanTargetModel> items = (List<SanTargetModel>) getItems();
            for (SanTargetModel item : items) {
                aggregateAddedLuns(item.getLuns(), selectedLuns, includedLuns, luns);
            }
        } else {
            List<LunModel> items = (List<LunModel>) getItems();
            aggregateAddedLuns(items, selectedLuns, includedLuns, luns);
        }
    }
    return luns;
}
#end_block

#method_before
public ArrayList<LunModel> getLunsToRefresh() {
    ArrayList<LunModel> luns = new ArrayList<>();
    if (!getIsGrouppedByTarget()) {
        List<LunModel> items = (List<LunModel>) getItems();
        luns.addAll(items.stream().filter(LunModel::getIsIncluded).filter(LunModel::isAdditionalAvailableSizeSelected).distinct().collect(Collectors.toList()));
    } else {
        List<SanTargetModel> sanTargetModels = (List<SanTargetModel>) getItems();
        for (SanTargetModel sanTargetModel : sanTargetModels) {
            luns.addAll(sanTargetModel.getLuns().stream().filter(LunModel::getIsIncluded).filter(LunModel::isAdditionalAvailableSizeSelected).distinct().collect(Collectors.toList()));
        }
    }
    return luns;
}
#method_after
public Set<String> getLunsToRefresh() {
    if (!getIsGrouppedByTarget()) {
        return filterLunsToRefresh(((List<LunModel>) getItems()).stream());
    }
    return filterLunsToRefresh(((List<SanTargetModel>) getItems()).stream().map(SanTargetModel::getLuns).flatMap(List::stream));
}
#end_block

#method_before
public List<LunModel> getLunsToRemove() {
    if (getIsGrouppedByTarget()) {
        List<LunModel> luns = new ArrayList<>();
        List<SanTargetModel> sanTargetModels = (List<SanTargetModel>) getItems();
        for (SanTargetModel sanTargetModel : sanTargetModels) {
            luns.addAll(sanTargetModel.getLuns().stream().filter(LunModel::getIsIncluded).filter(LunModel::isRemoveLunSelected).distinct().collect(Collectors.toList()));
        }
        return luns;
    }
    return ((List<LunModel>) getItems()).stream().filter(LunModel::getIsIncluded).filter(LunModel::isRemoveLunSelected).distinct().collect(Collectors.toList());
}
#method_after
public Set<String> getLunsToRemove() {
    if (getIsGrouppedByTarget()) {
        return filterLunsToRemove(((List<SanTargetModel>) getItems()).stream().map(SanTargetModel::getLuns).flatMap(List::stream));
    }
    return filterLunsToRemove(((List<LunModel>) getItems()).stream());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected TreeItem createLeafNode(ListModel leafModel) {
    final TreeItem item = new TreeItem();
    List<LunModel> items = (List<LunModel>) leafModel.getItems();
    if (hideLeaf || items.isEmpty()) {
        item.setUserObject(Boolean.TRUE);
        return item;
    }
    final SortedListModel sortedLeafModel = new SortedListModel();
    sortedLeafModel.setItems(items);
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunTableResources.class));
    table.initModelSortHandler(sortedLeafModel);
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn() {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "20px");
    AbstractLunTextColumn lunIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    };
    lunIdColumn.makeSortable();
    table.addColumn(lunIdColumn, constants.lunIdSanStorage());
    AbstractLunTextColumn devSizeColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return messages.gigabytes(String.valueOf(model.getSize()));
        }
    };
    devSizeColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(devSizeColumn, constants.devSizeSanStorage(), "70px");
    AbstractLunTextColumn path = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    };
    path.makeSortable();
    // $NON-NLS-1$
    table.addColumn(path, constants.pathSanStorage(), "55px");
    AbstractLunTextColumn vendorIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    };
    vendorIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "100px");
    AbstractLunTextColumn productIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    };
    productIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(productIdColumn, constants.productIdSanStorage(), "100px");
    AbstractLunTextColumn serialNumColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    };
    serialNumColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(serialNumColumn, constants.serialSanStorage(), "350px");
    if (!model.getContainer().isNewStorage()) {
        StorageDomainStatus status = model.getContainer().getStorage().getStatus();
        if (status == StorageDomainStatus.Maintenance) {
            boolean reduceDeviceFromStorageDomainSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.ReduceDeviceFromStorageDomain, model.getContainer().getDataCenter().getSelectedItem().getCompatibilityVersion().toString());
            if (reduceDeviceFromStorageDomainSupported) {
                AbstractLunRemoveColumn removeColumn = new AbstractLunRemoveColumn(model) {

                    @Override
                    public LunModel getValue(LunModel object) {
                        return object;
                    }
                };
                // $NON-NLS-1$
                table.addColumn(removeColumn, constants.removeSanStorage(), "87px");
                model.getRequireTableRefresh().getEntityChangedEvent().addListener((ev, sender, args) -> {
                    table.redraw();
                });
            }
        } else if (status == StorageDomainStatus.Active) {
            AbstractLunAddOrExtendColumn addOrExtendColumn = new AbstractLunAddOrExtendColumn() {

                @Override
                public LunModel getValue(LunModel object) {
                    return object;
                }
            };
            addOrExtendColumn.makeSortable();
            // $NON-NLS-1$
            table.addColumn(addOrExtendColumn, constants.addOrExtendSanStorage(), "87px");
        }
    } else {
        AbstractLunAddOrExtendColumn addOrExtendColumn = new AbstractLunAddOrExtendColumn() {

            @Override
            public LunModel getValue(LunModel object) {
                return object;
            }
        };
        addOrExtendColumn.makeSortable();
        // $NON-NLS-1$
        table.addColumn(addOrExtendColumn, constants.addOrExtendSanStorage(), "87px");
    }
    table.setRowData(items);
    final Object selectedItem = sortedLeafModel.getSelectedItem();
    sortedLeafModel.setSelectedItem(null);
    table.asEditor().edit(sortedLeafModel);
    sortedLeafModel.setSelectedItem(selectedItem);
    // $NON-NLS-1$
    table.setWidth("100%");
    if (!multiSelection) {
        for (LunModel lunModel : items) {
            if (lunModel.getIsSelected()) {
                table.getSelectionModel().setSelected(lunModel, true);
            }
        }
        table.getSelectionModel().addSelectionChangeHandler(event -> {
            SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
            selectedLunModel = SingleSelectionModel.getSelectedObject() == null ? selectedLunModel : (LunModel) SingleSelectionModel.getSelectedObject();
            if (selectedLunModel != null) {
                updateSelectedLunWarning(selectedLunModel);
                sortedLeafModel.setSelectedItem(selectedLunModel);
            }
        });
    } else {
        for (LunModel lunModel : items) {
            table.getSelectionModel().setSelected(lunModel, lunModel.getIsSelected());
        }
        table.getSelectionModel().addSelectionChangeHandler(event -> model.updateLunWarningForDiscardAfterDelete());
    }
    item.setWidget(table);
    // Display LUNs as grayed-out if needed
    for (LunModel lunModel : items) {
        if (lunModel.getIsGrayedOut()) {
            grayOutItem(lunModel.getGrayedOutReasons(), lunModel, table);
        }
    }
    addOpenHandlerToTree(tree, item, table);
    return item;
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected TreeItem createLeafNode(ListModel leafModel) {
    final TreeItem item = new TreeItem();
    List<LunModel> items = (List<LunModel>) leafModel.getItems();
    if (hideLeaf || items.isEmpty()) {
        item.setUserObject(Boolean.TRUE);
        return item;
    }
    final SortedListModel sortedLeafModel = new SortedListModel();
    sortedLeafModel.setItems(items);
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunTableResources.class));
    table.initModelSortHandler(sortedLeafModel);
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn() {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "20px");
    AbstractLunTextColumn lunIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    };
    lunIdColumn.makeSortable();
    table.addColumn(lunIdColumn, constants.lunIdSanStorage());
    AbstractLunTextColumn devSizeColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return messages.gigabytes(String.valueOf(model.getSize()));
        }
    };
    devSizeColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(devSizeColumn, constants.devSizeSanStorage(), "70px");
    AbstractLunTextColumn path = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    };
    path.makeSortable();
    // $NON-NLS-1$
    table.addColumn(path, constants.pathSanStorage(), "55px");
    AbstractLunTextColumn vendorIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    };
    vendorIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "100px");
    AbstractLunTextColumn productIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    };
    productIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(productIdColumn, constants.productIdSanStorage(), "100px");
    AbstractLunTextColumn serialNumColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    };
    serialNumColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(serialNumColumn, constants.serialSanStorage(), "370px");
    if (model.getContainer().isNewStorage() || model.getContainer().getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        addAbstractLunAddOrExtendColumn(table, model.getContainer().isNewStorage() ? constants.addSanStorage() : constants.actionsSanStorage());
    } else {
        boolean reduceDeviceFromStorageDomainSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.ReduceDeviceFromStorageDomain, model.getContainer().getDataCenter().getSelectedItem().getCompatibilityVersion().toString());
        if (reduceDeviceFromStorageDomainSupported) {
            AbstractLunRemoveColumn removeColumn = new AbstractLunRemoveColumn(model) {

                @Override
                public LunModel getValue(LunModel object) {
                    return object;
                }
            };
            // $NON-NLS-1$
            table.addColumn(removeColumn, constants.removeSanStorage(), "95px");
            model.getRequireTableRefresh().getEntityChangedEvent().addListener((ev, sender, args) -> {
                table.redraw();
            });
        }
    }
    table.setRowData(items);
    final Object selectedItem = sortedLeafModel.getSelectedItem();
    sortedLeafModel.setSelectedItem(null);
    table.asEditor().edit(sortedLeafModel);
    sortedLeafModel.setSelectedItem(selectedItem);
    // $NON-NLS-1$
    table.setWidth("100%");
    if (!multiSelection) {
        for (LunModel lunModel : items) {
            if (lunModel.getIsSelected()) {
                table.getSelectionModel().setSelected(lunModel, true);
            }
        }
        table.getSelectionModel().addSelectionChangeHandler(event -> {
            SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
            selectedLunModel = SingleSelectionModel.getSelectedObject() == null ? selectedLunModel : (LunModel) SingleSelectionModel.getSelectedObject();
            if (selectedLunModel != null) {
                updateSelectedLunWarning(selectedLunModel);
                sortedLeafModel.setSelectedItem(selectedLunModel);
            }
        });
    } else {
        for (LunModel lunModel : items) {
            table.getSelectionModel().setSelected(lunModel, lunModel.getIsSelected());
        }
        table.getSelectionModel().addSelectionChangeHandler(event -> model.updateLunWarningForDiscardAfterDelete());
    }
    item.setWidget(table);
    // Display LUNs as grayed-out if needed
    for (LunModel lunModel : items) {
        if (lunModel.getIsGrayedOut()) {
            grayOutItem(lunModel.getGrayedOutReasons(), lunModel, table);
        }
    }
    addOpenHandlerToTree(tree, item, table);
    return item;
}
#end_block

#method_before
private ArrayList<LunModel> getLuns(boolean selectedLuns, boolean includedLuns) {
    ArrayList<LunModel> luns = new ArrayList<>();
    if (getItems() != null) {
        if (getIsGrouppedByTarget()) {
            List<SanTargetModel> items = (List<SanTargetModel>) getItems();
            for (SanTargetModel item : items) {
                luns.addAll(getAddedLuns(item.getLuns(), selectedLuns, includedLuns));
            }
        } else {
            List<LunModel> items = (List<LunModel>) getItems();
            luns.addAll(getAddedLuns(items, selectedLuns, includedLuns));
        }
    }
    return luns;
}
#method_after
private ArrayList<LunModel> getLuns(boolean selectedLuns, boolean includedLuns) {
    ArrayList<LunModel> luns = new ArrayList<>();
    if (getItems() != null) {
        if (getIsGrouppedByTarget()) {
            List<SanTargetModel> items = (List<SanTargetModel>) getItems();
            for (SanTargetModel item : items) {
                aggregateAddedLuns(item.getLuns(), selectedLuns, includedLuns, luns);
            }
        } else {
            List<LunModel> items = (List<LunModel>) getItems();
            aggregateAddedLuns(items, selectedLuns, includedLuns, luns);
        }
    }
    return luns;
}
#end_block

#method_before
public List<LunModel> getLunsToRemove() {
    if (getIsGrouppedByTarget()) {
        List<LunModel> luns = new ArrayList<>();
        List<SanTargetModel> sanTargetModels = (List<SanTargetModel>) getItems();
        for (SanTargetModel sanTargetModel : sanTargetModels) {
            luns.addAll(sanTargetModel.getLuns().stream().filter(LunModel::getIsIncluded).filter(LunModel::isRemoveLunSelected).distinct().collect(Collectors.toList()));
        }
        return luns;
    }
    return ((List<LunModel>) getItems()).stream().filter(LunModel::getIsIncluded).filter(LunModel::isRemoveLunSelected).distinct().collect(Collectors.toList());
}
#method_after
public List<LunModel> getLunsToRemove() {
    if (getIsGrouppedByTarget()) {
        return ((List<SanTargetModel>) getItems()).stream().map(SanTargetModel::getLuns).flatMap(List::stream).filter(LunModel::isRemoveLunSelected).distinct().collect(Collectors.toList());
    }
    return ((List<LunModel>) getItems()).stream().filter(LunModel::isRemoveLunSelected).distinct().collect(Collectors.toList());
}
#end_block

#method_before
@Override
protected void createHeaderWidget() {
    EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(false, (Resources) GWT.create(SanStorageListTargetTableResources.class), true);
    table.addColumn(new TextColumn<LunModel>() {

        @Override
        public String getValue(LunModel model) {
            // $NON-NLS-1$
            return "";
        }
    }, "", // $NON-NLS-1$
    "20px");
    // Create header table
    initRootNodeTable(table);
    // Add first blank column
    table.insertColumn(0, new TextColumn<LunModel>() {

        @Override
        public String getValue(LunModel model) {
            // $NON-NLS-1$
            return "";
        }
    }, "", // $NON-NLS-1$ //$NON-NLS-2$
    "15px");
    // Add last blank column
    table.addColumn(new TextColumn<LunModel>() {

        @Override
        public String getValue(LunModel model) {
            // $NON-NLS-1$
            return "";
        }
    }, "", // $NON-NLS-1$ //$NON-NLS-2$
    "22px");
    // Add blank item list
    table.setRowData(new ArrayList<EntityModel>());
    // Style table
    // $NON-NLS-1$
    table.setWidth("100%");
    // This was the height of the header
    // $NON-NLS-1$
    table.setHeight("23px");
    // Add table as header widget
    treeHeader.add(table);
}
#method_after
@Override
protected void createHeaderWidget() {
    EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(false, (Resources) GWT.create(SanStorageListTargetTableResources.class), true);
    // Add first blank header
    table.addColumn(new TextColumn<LunModel>() {

        @Override
        public String getValue(LunModel model) {
            // $NON-NLS-1$
            return "";
        }
    }, "", // $NON-NLS-1$
    "20px");
    // Create header table
    initRootNodeTable(table);
    // Add first blank column
    table.insertColumn(0, new TextColumn<LunModel>() {

        @Override
        public String getValue(LunModel model) {
            // $NON-NLS-1$
            return "";
        }
    }, "", // $NON-NLS-1$ //$NON-NLS-2$
    "15px");
    // Add last blank column
    table.addColumn(new TextColumn<LunModel>() {

        @Override
        public String getValue(LunModel model) {
            // $NON-NLS-1$
            return "";
        }
    }, "", // $NON-NLS-1$ //$NON-NLS-2$
    "22px");
    // Add blank item list
    table.setRowData(new ArrayList<EntityModel>());
    // Style table
    // $NON-NLS-1$
    table.setWidth("100%");
    // This was the height of the header
    // $NON-NLS-1$
    table.setHeight("23px");
    // Add table as header widget
    treeHeader.add(table);
}
#end_block

#method_before
@Override
protected TreeItem createRootNode(LunModel rootModel) {
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunRootResources.class));
    // Create table
    initRootNodeTable(table);
    // Set custom selection column
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn(multiSelection) {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "20px");
    // Add items
    List<LunModel> items = new ArrayList<>();
    items.add(rootModel);
    ListModel<LunModel> listModel = new ListModel<>();
    listModel.setItems(items);
    // Update table
    table.setRowData(items);
    table.asEditor().edit(listModel);
    // $NON-NLS-1$
    table.setWidth("100%");
    // This was the height of the header
    // $NON-NLS-1$
    table.setHeight("46px");
    rootModel.getPropertyChangedEvent().removeListener(lunModelSelectedItemListener);
    rootModel.getPropertyChangedEvent().addListener(lunModelSelectedItemListener, table);
    if (!multiSelection) {
        table.getSelectionModel().addSelectionChangeHandler(event -> {
            SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
            LunModel selectedLunModel = (LunModel) SingleSelectionModel.getSelectedObject();
            if (selectedLunModel != null) {
                updateSelectedLunWarning(selectedLunModel);
            }
        });
    } else {
        table.getSelectionModel().setSelected(rootModel, rootModel.getIsSelected());
        table.getSelectionModel().addSelectionChangeHandler(event -> model.updateLunWarningForDiscardAfterDelete());
    }
    // Create tree item
    HorizontalPanel panel = new HorizontalPanel();
    panel.add(table);
    // $NON-NLS-1$
    panel.setWidth("100%");
    panel.getElement().getStyle().setTableLayout(TableLayout.FIXED);
    TreeItem item = new TreeItem(table);
    // Display LUNs as grayed-out if needed
    if (rootModel.getIsGrayedOut()) {
        grayOutItem(rootModel.getGrayedOutReasons(), rootModel, table);
    }
    return item;
}
#method_after
@Override
protected TreeItem createRootNode(LunModel rootModel) {
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunRootResources.class));
    // Create table
    initRootNodeTable(table);
    // Set custom selection column
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn() {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "20px");
    // Add items
    List<LunModel> items = new ArrayList<>();
    items.add(rootModel);
    ListModel<LunModel> listModel = new ListModel<>();
    listModel.setItems(items);
    // Update table
    table.setRowData(items);
    table.asEditor().edit(listModel);
    // $NON-NLS-1$
    table.setWidth("100%");
    // This was the height of the header
    // $NON-NLS-1$
    table.setHeight("46px");
    rootModel.getPropertyChangedEvent().removeListener(lunModelSelectedItemListener);
    rootModel.getPropertyChangedEvent().addListener(lunModelSelectedItemListener, table);
    if (!multiSelection) {
        table.getSelectionModel().addSelectionChangeHandler(event -> {
            SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
            LunModel selectedLunModel = (LunModel) SingleSelectionModel.getSelectedObject();
            if (selectedLunModel != null) {
                updateSelectedLunWarning(selectedLunModel);
            }
        });
    } else {
        table.getSelectionModel().setSelected(rootModel, rootModel.getIsSelected());
        table.getSelectionModel().addSelectionChangeHandler(event -> model.updateLunWarningForDiscardAfterDelete());
    }
    // Create tree item
    HorizontalPanel panel = new HorizontalPanel();
    panel.add(table);
    // $NON-NLS-1$
    panel.setWidth("100%");
    panel.getElement().getStyle().setTableLayout(TableLayout.FIXED);
    TreeItem item = new TreeItem(table);
    // Display LUNs as grayed-out if needed
    if (rootModel.getIsGrayedOut()) {
        grayOutItem(rootModel.getGrayedOutReasons(), rootModel, table);
    }
    return item;
}
#end_block

#method_before
private void initRootNodeTable(EntityModelCellTable<ListModel<LunModel>> table) {
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    }, constants.lunIdSanStorage());
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return messages.gigabytes(String.valueOf(model.getSize()));
        }
    }, constants.devSizeSanStorage(), // $NON-NLS-1$
    "70px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    }, constants.pathSanStorage(), // $NON-NLS-1$
    "55px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    }, constants.vendorIdSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    }, constants.productIdSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    }, constants.serialSanStorage(), // $NON-NLS-1$
    "350px");
    if (!model.getContainer().isNewStorage()) {
        StorageDomainStatus status = model.getContainer().getStorage().getStatus();
        if (status == StorageDomainStatus.Maintenance) {
            boolean reduceDeviceFromStorageDomainSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.ReduceDeviceFromStorageDomain, model.getContainer().getDataCenter().getSelectedItem().getCompatibilityVersion().toString());
            if (reduceDeviceFromStorageDomainSupported) {
                table.addColumn(new AbstractLunRemoveColumn(model) {

                    @Override
                    public LunModel getValue(LunModel object) {
                        return object;
                    }
                }, constants.removeSanStorage(), // $NON-NLS-1$
                "85px");
                model.getRequireTableRefresh().getEntityChangedEvent().addListener((ev, sender, args) -> {
                    table.redraw();
                });
            }
        } else {
            table.addColumn(new AbstractLunAddOrExtendColumn() {

                @Override
                public LunModel getValue(LunModel object) {
                    return object;
                }
            }, constants.addOrExtendSanStorage(), // $NON-NLS-1$
            "85px");
        }
    } else {
        table.addColumn(new AbstractLunAddOrExtendColumn() {

            @Override
            public LunModel getValue(LunModel object) {
                return object;
            }
        }, constants.addSanStorage(), // $NON-NLS-1$
        "85px");
    }
}
#method_after
private void initRootNodeTable(EntityModelCellTable<ListModel<LunModel>> table) {
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    }, constants.lunIdSanStorage());
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return messages.gigabytes(String.valueOf(model.getSize()));
        }
    }, constants.devSizeSanStorage(), // $NON-NLS-1$
    "70px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    }, constants.pathSanStorage(), // $NON-NLS-1$
    "55px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    }, constants.vendorIdSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    }, constants.productIdSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    }, constants.serialSanStorage(), // $NON-NLS-1$
    "350px");
    if (!model.getContainer().isNewStorage()) {
        StorageDomainStatus status = model.getContainer().getStorage().getStatus();
        if (status == StorageDomainStatus.Maintenance) {
            boolean reduceDeviceFromStorageDomainSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.ReduceDeviceFromStorageDomain, model.getContainer().getDataCenter().getSelectedItem().getCompatibilityVersion().toString());
            if (reduceDeviceFromStorageDomainSupported) {
                table.addColumn(new AbstractLunRemoveColumn(model) {

                    @Override
                    public LunModel getValue(LunModel object) {
                        return object;
                    }
                }, constants.removeSanStorage(), // $NON-NLS-1$
                "85px");
                model.getRequireTableRefresh().getEntityChangedEvent().addListener((ev, sender, args) -> {
                    table.redraw();
                });
            }
        } else {
            addAbstractLunAddOrExtendColumn(table, constants.actionsSanStorage());
        }
    } else {
        addAbstractLunAddOrExtendColumn(table, constants.addSanStorage());
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected TreeItem createLeafNode(ListModel leafModel) {
    final TreeItem item = new TreeItem();
    List<LunModel> items = (List<LunModel>) leafModel.getItems();
    if (hideLeaf || items.isEmpty()) {
        item.setUserObject(Boolean.TRUE);
        return item;
    }
    final SortedListModel sortedLeafModel = new SortedListModel();
    sortedLeafModel.setItems(items);
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunTableResources.class));
    table.initModelSortHandler(sortedLeafModel);
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn(multiSelection) {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "30px");
    AbstractLunTextColumn lunIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    };
    lunIdColumn.makeSortable();
    table.addColumn(lunIdColumn, constants.lunIdSanStorage());
    AbstractLunTextColumn devSizeColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return messages.gigabytes(String.valueOf(model.getSize()));
        }
    };
    devSizeColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(devSizeColumn, constants.devSizeSanStorage(), "70px");
    AbstractLunTextColumn path = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    };
    path.makeSortable();
    // $NON-NLS-1$
    table.addColumn(path, constants.pathSanStorage(), "55px");
    AbstractLunTextColumn vendorIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    };
    vendorIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "100px");
    AbstractLunTextColumn productIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    };
    productIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(productIdColumn, constants.productIdSanStorage(), "100px");
    AbstractLunTextColumn serialNumColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    };
    serialNumColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(serialNumColumn, constants.serialSanStorage(), "350px");
    table.setRowData(items);
    final Object selectedItem = sortedLeafModel.getSelectedItem();
    sortedLeafModel.setSelectedItem(null);
    table.asEditor().edit(sortedLeafModel);
    sortedLeafModel.setSelectedItem(selectedItem);
    // $NON-NLS-1$
    table.setWidth("100%");
    if (!multiSelection) {
        for (LunModel lunModel : items) {
            if (lunModel.getIsSelected()) {
                table.getSelectionModel().setSelected(lunModel, true);
            }
        }
        table.getSelectionModel().addSelectionChangeHandler(event -> {
            SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
            selectedLunModel = SingleSelectionModel.getSelectedObject() == null ? selectedLunModel : (LunModel) SingleSelectionModel.getSelectedObject();
            if (selectedLunModel != null) {
                updateSelectedLunWarning(selectedLunModel);
                sortedLeafModel.setSelectedItem(selectedLunModel);
            }
        });
    } else {
        for (LunModel lunModel : items) {
            table.getSelectionModel().setSelected(lunModel, lunModel.getIsSelected());
        }
        table.getSelectionModel().addSelectionChangeHandler(event -> model.updateLunWarningForDiscardAfterDelete());
    }
    item.setWidget(table);
    // Display LUNs as grayed-out if needed
    for (LunModel lunModel : items) {
        if (lunModel.getIsGrayedOut()) {
            grayOutItem(lunModel.getGrayedOutReasons(), lunModel, table);
        }
    }
    addOpenHandlerToTree(tree, item, table);
    return item;
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected TreeItem createLeafNode(ListModel leafModel) {
    final TreeItem item = new TreeItem();
    List<LunModel> items = (List<LunModel>) leafModel.getItems();
    if (hideLeaf || items.isEmpty()) {
        item.setUserObject(Boolean.TRUE);
        return item;
    }
    final SortedListModel sortedLeafModel = new SortedListModel();
    sortedLeafModel.setItems(items);
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunTableResources.class));
    table.initModelSortHandler(sortedLeafModel);
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn() {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "30px");
    AbstractLunTextColumn lunIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    };
    lunIdColumn.makeSortable();
    table.addColumn(lunIdColumn, constants.lunIdSanStorage());
    AbstractLunTextColumn devSizeColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return messages.gigabytes(String.valueOf(model.getSize()));
        }
    };
    devSizeColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(devSizeColumn, constants.devSizeSanStorage(), "70px");
    AbstractLunTextColumn path = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    };
    path.makeSortable();
    // $NON-NLS-1$
    table.addColumn(path, constants.pathSanStorage(), "55px");
    AbstractLunTextColumn vendorIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    };
    vendorIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "100px");
    AbstractLunTextColumn productIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    };
    productIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(productIdColumn, constants.productIdSanStorage(), "100px");
    AbstractLunTextColumn serialNumColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    };
    serialNumColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(serialNumColumn, constants.serialSanStorage(), "350px");
    table.setRowData(items);
    final Object selectedItem = sortedLeafModel.getSelectedItem();
    sortedLeafModel.setSelectedItem(null);
    table.asEditor().edit(sortedLeafModel);
    sortedLeafModel.setSelectedItem(selectedItem);
    // $NON-NLS-1$
    table.setWidth("100%");
    if (!multiSelection) {
        for (LunModel lunModel : items) {
            if (lunModel.getIsSelected()) {
                table.getSelectionModel().setSelected(lunModel, true);
            }
        }
        table.getSelectionModel().addSelectionChangeHandler(event -> {
            SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
            selectedLunModel = SingleSelectionModel.getSelectedObject() == null ? selectedLunModel : (LunModel) SingleSelectionModel.getSelectedObject();
            if (selectedLunModel != null) {
                updateSelectedLunWarning(selectedLunModel);
                sortedLeafModel.setSelectedItem(selectedLunModel);
            }
        });
    } else {
        for (LunModel lunModel : items) {
            table.getSelectionModel().setSelected(lunModel, lunModel.getIsSelected());
        }
        table.getSelectionModel().addSelectionChangeHandler(event -> model.updateLunWarningForDiscardAfterDelete());
    }
    item.setWidget(table);
    // Display LUNs as grayed-out if needed
    for (LunModel lunModel : items) {
        if (lunModel.getIsGrayedOut()) {
            grayOutItem(lunModel.getGrayedOutReasons(), lunModel, table);
        }
    }
    addOpenHandlerToTree(tree, item, table);
    return item;
}
#end_block

#method_before
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForDisk(DiskImage source, DiskImage destination) {
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(getParameters().getEntityId(), source.getId(), source.getImageId(), destination.getId(), destination.getImageId(), // TODO: change
    source.getStorageIds().get(0), ImageOperation.Copy);
    params.setParentCommand(getActionType());
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(true);
    params.setSourceDomainId(source.getStorageIds().get(0));
    params.setStoragePoolId(source.getStoragePoolId());
    params.setImportEntity(true);
    // params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    params.setParentParameters(getParameters());
    params.setUseCopyCollapse(true);
    params.setVolumeType(VolumeType.Sparse);
    params.setVolumeFormat(VolumeFormat.COW);
    // params.setLeaveLocked(true);
    return params;
}
#method_after
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForDisk(DiskImage source, DiskImage destination) {
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(getParameters().getEntityId(), source.getId(), source.getImageId(), destination.getId(), destination.getImageId(), // TODO: change
    source.getStorageIds().get(0), ImageOperation.Copy);
    params.setParentCommand(getActionType());
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(true);
    params.setSourceDomainId(source.getStorageIds().get(0));
    params.setStoragePoolId(source.getStoragePoolId());
    params.setImportEntity(true);
    params.setParentParameters(getParameters());
    params.setUseCopyCollapse(true);
    params.setVolumeType(VolumeType.Sparse);
    params.setVolumeFormat(VolumeFormat.COW);
    return params;
}
#end_block

#method_before
private Map<DiskImage, DiskImage> createTemporaryDisks() {
    ActionReturnValue returnValue = runInternalAction(ActionType.CreateAllOvaDisks, buildCreateAllOvaDisksParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
    return returnValue.getActionReturnValue();
}
#method_after
private Map<DiskImage, DiskImage> createTemporaryDisks() {
    ActionReturnValue returnValue = runInternalAction(ActionType.CreateAllOvaDisks, buildCreateAllOvaDisksParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        log.error("Failed to create OVA disks");
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
    return returnValue.getActionReturnValue();
}
#end_block

#method_before
private void createOva() {
    ActionReturnValue returnValue = runInternalAction(ActionType.CreateOva, buildCreateOvaParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#method_after
private void createOva() {
    ActionReturnValue returnValue = runInternalAction(ActionType.CreateOva, buildCreateOvaParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        log.error("Failed to create OVA file");
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#end_block

#method_before
protected java.util.Map<String, org.ovirt.engine.core.common.utils.Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getParameters().getEntityId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
}
#method_after
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getParameters().getEntityId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
}
#end_block

#method_before
private Map<Guid, String> prepareImages(Collection<DiskImage> disks) {
    Map<Guid, String> diskIdToPath = new HashMap<>();
    for (DiskImage disk : disks) {
        VDSReturnValue vdsRetVal = runVdsCommand(VDSCommandType.PrepareImage, buildPrepareParameters(disk));
        String path = ((PrepareImageReturn) vdsRetVal.getReturnValue()).getImagePath();
        diskIdToPath.put(disk.getId(), path);
    }
    return diskIdToPath;
}
#method_after
private Map<Guid, String> prepareImages(Collection<DiskImage> disks) {
    Map<Guid, String> diskIdToPath = new HashMap<>();
    for (DiskImage disk : disks) {
        VDSReturnValue vdsRetVal = imagesHandler.prepareImage(disk.getStoragePoolId(), disk.getStorageIds().get(0), disk.getId(), disk.getImageId(), getParameters().getProxyHostId());
        String path = ((PrepareImageReturn) vdsRetVal.getReturnValue()).getImagePath();
        diskIdToPath.put(disk.getId(), path);
    }
    return diskIdToPath;
}
#end_block

#method_before
private Response performCreate(ImageTransfer imageTransfer, TransferDiskImageParameters params) {
    updateTransferType(imageTransfer, params);
    if (imageTransfer.isSetHost()) {
        params.setVdsId(Guid.createGuidFromString(imageTransfer.getHost().getId()));
    }
    return performCreate(ActionType.TransferDiskImage, params, new QueryIdResolver<Guid>(QueryType.GetImageTransferById, IdQueryParameters.class));
}
#method_after
private Response performCreate(ImageTransfer imageTransfer, TransferDiskImageParameters params) {
    updateTransferType(imageTransfer, params);
    if (imageTransfer.isSetHost() && imageTransfer.getHost().isSetId()) {
        params.setVdsId(Guid.createGuidFromString(imageTransfer.getHost().getId()));
    }
    return performCreate(ActionType.TransferDiskImage, params, new QueryIdResolver<Guid>(QueryType.GetImageTransferById, IdQueryParameters.class));
}
#end_block

#method_before
private Action mapTargets(Action action, List<StorageServerConnections> targets) {
    if (targets != null) {
        Action.IscsiTargetsList iscsiTargets = new Action.IscsiTargetsList();
        IscsiDetailss iscsiDetailss = new IscsiDetailss();
        for (StorageServerConnections cnx : targets) {
            LogicalUnit logicalUnit = map(cnx);
            iscsiTargets.getIscsiTargets().add(logicalUnit.getTarget());
            iscsiDetailss.getIscsiDetailss().add(mapLogicalUnitToIscsiDetails(logicalUnit));
        }
        action.setIscsiTargets(iscsiTargets);
        action.setDiscoveredTargets(iscsiDetailss);
    }
    return action;
}
#method_after
private Action mapTargets(Action action, List<StorageServerConnections> targets) {
    if (targets != null) {
        Action.IscsiTargetsList iscsiTargets = new Action.IscsiTargetsList();
        IscsiDetailss iscsiDetailss = new IscsiDetailss();
        for (StorageServerConnections cnx : targets) {
            LogicalUnit logicalUnit = map(cnx);
            // The iscsiTargets property is replaced by discoveredTargets. The property is preserved
            // for backward compatibility, and should be removed in version 5 of the API.
            iscsiTargets.getIscsiTargets().add(logicalUnit.getTarget());
            iscsiDetailss.getIscsiDetailss().add(mapLogicalUnitToIscsiDetails(logicalUnit));
        }
        action.setIscsiTargets(iscsiTargets);
        action.setDiscoveredTargets(iscsiDetailss);
    }
    return action;
}
#end_block

#method_before
private IscsiDetails mapLogicalUnitToIscsiDetails(LogicalUnit logicalUnit) {
    IscsiDetails iscsiDetails = new IscsiDetails();
    iscsiDetails.setAddress(logicalUnit.getAddress());
    iscsiDetails.setPort(logicalUnit.getPort());
    iscsiDetails.setTarget(logicalUnit.getTarget());
    return iscsiDetails;
}
#method_after
private IscsiDetails mapLogicalUnitToIscsiDetails(LogicalUnit logicalUnit) {
    IscsiDetails iscsiDetails = new IscsiDetails();
    iscsiDetails.setAddress(logicalUnit.getAddress());
    iscsiDetails.setPort(logicalUnit.getPort());
    iscsiDetails.setTarget(logicalUnit.getTarget());
    iscsiDetails.setPortal(logicalUnit.getPortal());
    iscsiDetails.setPaths(logicalUnit.getPaths());
    iscsiDetails.setVendorId(logicalUnit.getVendorId());
    iscsiDetails.setProductId(logicalUnit.getProductId());
    iscsiDetails.setSerial(logicalUnit.getSerial());
    return iscsiDetails;
}
#end_block

#method_before
public ValidationResult providerIsNoDefaultProvider() {
    List<Cluster> clusters = clusterDao.getAllClustersByDefaultNetworkProviderId(provider.getId());
    return clusters.isEmpty() ? ValidationResult.VALID : new ValidationResult(getProviderUsedInClusterValidationMessage(clusters.size()), ReplacementUtils.replaceWithNameable("CLUSTER_NAMES", clusters));
}
#method_after
public ValidationResult providerIsNoDefaultProvider() {
    List<Cluster> clusters = clusterDao.getAllClustersByDefaultNetworkProviderId(provider.getId());
    return clusters.isEmpty() ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_USED_IN_CLUSTER, ReplacementUtils.replaceWithNameable("CLUSTER_NAMES", clusters));
}
#end_block

#method_before
protected void setQcowCompatByQemuImageInfo(Guid storagePoolId, Guid newImageGroupId, Guid newImageId, Guid newStorageDomainID, DiskImage diskImage) {
    // If the VM is running then the volume is already prepared in the guest's host so there
    // is no need for prepare and teardown.
    VM vm = vmDao.getVmsWithPlugInfo(diskImage.getId()).stream().map(pair -> pair.getFirst()).findFirst().get();
    setQcowCompat(diskImage.getImage(), storagePoolId, newImageGroupId, newImageId, newStorageDomainID, vm.getRunOnVds());
}
#method_after
protected void setQcowCompatByQemuImageInfo(Guid storagePoolId, Guid newImageGroupId, Guid newImageId, Guid newStorageDomainID, DiskImage diskImage) {
    // If the VM is running then the volume is already prepared in the guest's host so there
    // is no need for prepare and teardown.
    Guid hostIdToExecuteQemuImageInfo = vmDao.getVmsWithPlugInfo(diskImage.getId()).stream().filter(p -> !p.getFirst().isDown()).filter(p -> p.getSecond().isPlugged()).map(p -> p.getFirst().getRunOnVds()).findFirst().orElse(null);
    setQcowCompat(diskImage.getImage(), storagePoolId, newImageGroupId, newImageId, newStorageDomainID, hostIdToExecuteQemuImageInfo);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    StoragePoolIsoMap map = loadStoragePoolIsoMap();
    changeDomainStatusWithCompensation(map, StorageDomainStatus.Unknown, StorageDomainStatus.Locked, getCompensationContext());
    if (shouldPerformOvfUpdate()) {
        runInternalAction(ActionType.UpdateOvfStoreForStorageDomain, createUpdateOvfStoreParams(), getContext());
    }
    if (noAsyncOperations()) {
        executeDeactivateCommand();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    StoragePoolIsoMap map = loadStoragePoolIsoMap();
    changeDomainStatusWithCompensation(map, StorageDomainStatus.Unknown, StorageDomainStatus.Locked, getCompensationContext());
    if (shouldPerformOvfUpdate()) {
        ActionReturnValue returnValue = runInternalAction(ActionType.UpdateOvfStoreForStorageDomain, createUpdateOvfStoreParams(), cloneContext().withoutCompensationContext());
        if (!returnValue.getSucceeded()) {
            propagateFailure(returnValue);
            return;
        }
    }
    if (noAsyncOperations()) {
        executeDeactivateCommand();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case END_FAILURE:
            return AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED;
        default:
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return getActionState() == CommandActionState.END_FAILURE ? AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED : AuditLogType.UNASSIGNED;
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    if (commandCoordinatorUtil.getCommandExecutionStatus(getCommandId()) != CommandExecutionStatus.EXECUTED) {
        changeStorageDomainStatusInTransaction(loadStoragePoolIsoMap(), StorageDomainStatus.Unknown);
        auditLogDirector.log(this, AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_OVF_UPDATE_INCOMPLETE);
    } else {
        StoragePoolIsoMap map = loadStoragePoolIsoMap();
        changeDomainStatusWithCompensation(map, StorageDomainStatus.Unknown, StorageDomainStatus.Active, getCompensationContext());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    if (commandCoordinatorUtil.getCommandExecutionStatus(getCommandId()) != CommandExecutionStatus.EXECUTED) {
        changeStorageDomainStatusInTransaction(loadStoragePoolIsoMap(), StorageDomainStatus.Unknown);
        auditLogDirector.log(this, AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_OVF_UPDATE_INCOMPLETE);
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    StoragePoolIsoMap map = loadStoragePoolIsoMap();
    changeDomainStatusWithCompensation(map, StorageDomainStatus.Unknown, StorageDomainStatus.Locked, getCompensationContext());
    if (shouldPerformOvfUpdate()) {
        runInternalAction(ActionType.UpdateOvfStoreForStorageDomain, createUpdateOvfStoreParams(), getContext());
    }
    if (noAsyncOperations()) {
        executeDeactivateCommand();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    StoragePoolIsoMap map = loadStoragePoolIsoMap();
    changeDomainStatusWithCompensation(map, StorageDomainStatus.Unknown, StorageDomainStatus.Locked, getCompensationContext());
    if (shouldPerformOvfUpdate()) {
        ActionReturnValue returnValue = runInternalAction(ActionType.UpdateOvfStoreForStorageDomain, createUpdateOvfStoreParams(), cloneContext().withoutCompensationContext());
        if (!returnValue.getSucceeded()) {
            propagateFailure(returnValue);
            return;
        }
    }
    if (noAsyncOperations()) {
        executeDeactivateCommand();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case END_FAILURE:
            return getSucceeded() ? AuditLogType.UNASSIGNED : AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED;
        default:
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return AuditLogType.UNASSIGNED;
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    if (commandCoordinatorUtil.getCommandExecutionStatus(getCommandId()) != CommandExecutionStatus.EXECUTED) {
        changeStorageDomainStatusInTransaction(loadStoragePoolIsoMap(), StorageDomainStatus.Unknown);
        auditLogDirector.log(this, AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_OVF_UPDATE_INCOMPLETE);
        getReturnValue().setEndActionTryAgain(false);
        setSucceeded(false);
    } else if (getParameters().isForceMaintenance()) {
        executeDeactivateCommand();
        setSucceeded(true);
    } else {
        StoragePoolIsoMap map = loadStoragePoolIsoMap();
        changeDomainStatusWithCompensation(map, StorageDomainStatus.Unknown, StorageDomainStatus.Active, getCompensationContext());
        getReturnValue().setEndActionTryAgain(false);
        setSucceeded(false);
    }
}
#method_after
@Override
protected void endWithFailure() {
    if (commandCoordinatorUtil.getCommandExecutionStatus(getCommandId()) != CommandExecutionStatus.EXECUTED) {
        changeStorageDomainStatusInTransaction(loadStoragePoolIsoMap(), StorageDomainStatus.Unknown);
        auditLogDirector.log(this, AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_OVF_UPDATE_INCOMPLETE);
    } else if (getParameters().isForceMaintenance()) {
        executeDeactivateCommand();
    } else {
        auditLogDirector.log(this, AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED);
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public Response deactivate(Action action) {
    boolean forceMaintenance = action.isForce() == null ? false : action.isForce();
    return doAction(ActionType.DeactivateStorageDomainWithOvfUpdate, new DeactivateStorageDomainWithOvfUpdateParameters(guid, dataCenterId, forceMaintenance), action);
}
#method_after
@Override
public Response deactivate(Action action) {
    boolean forceMaintenance = action.isSetForce() ? action.isForce() : false;
    return doAction(ActionType.DeactivateStorageDomainWithOvfUpdate, new DeactivateStorageDomainWithOvfUpdateParameters(guid, dataCenterId, forceMaintenance), action);
}
#end_block

#method_before
private void onMaintenance() {
    ArrayList<ActionParametersBase> list = new ArrayList<>();
    for (StorageDomain item : getSelectedItems()) {
        DeactivateStorageDomainWithOvfUpdateParameters parameters = new DeactivateStorageDomainWithOvfUpdateParameters();
        parameters.setStorageDomainId(getEntity().getId());
        parameters.setForceMaintenance(false);
        if (item.getStoragePoolId() != null) {
            parameters.setStoragePoolId(item.getStoragePoolId());
        }
        list.add(parameters);
    }
    final ConfirmationModel confirmationModel = (ConfirmationModel) getWindow();
    confirmationModel.startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.DeactivateStorageDomainWithOvfUpdate, list, result -> {
        confirmationModel.stopProgress();
        setWindow(null);
    }, null);
}
#method_after
private void onMaintenance() {
    ArrayList<ActionParametersBase> list = new ArrayList<>();
    for (StorageDomain item : getSelectedItems()) {
        DeactivateStorageDomainWithOvfUpdateParameters parameters = new DeactivateStorageDomainWithOvfUpdateParameters();
        parameters.setStorageDomainId(getEntity().getId());
        if (item.getStoragePoolId() != null) {
            parameters.setStoragePoolId(item.getStoragePoolId());
        }
        list.add(parameters);
    }
    final ConfirmationModel confirmationModel = (ConfirmationModel) getWindow();
    confirmationModel.startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.DeactivateStorageDomainWithOvfUpdate, list, result -> {
        confirmationModel.stopProgress();
        setWindow(null);
    }, null);
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    // DEPRECATED
    mandatory(host().rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(host().ssh().authenticationMethod());
    mandatory(host().ssh().user().password());
    mandatory(host().ssh().user().userName());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(ssh().authenticationMethod());
    optional(ssh().fingerprint());
    optional(ssh().port());
    optional(ssh().user().password());
    optional(ssh().user().userName());
}
#end_block

#method_before
private void aggregateAddedLuns(List<LunModel> lunModels, boolean selectedLuns, boolean includedLuns, ArrayList<LunModel> aggregatedLuns) {
    for (LunModel lun : lunModels) {
        if (((selectedLuns && lun.getIsSelected() && !lun.getIsIncluded()) || (includedLuns && lun.getIsIncluded() && !lun.getIsSelected())) && Linq.firstOrNull(aggregatedLuns, new Linq.LunPredicate(lun)) == null) {
            aggregatedLuns.add(lun);
        }
    }
}
#method_after
private void aggregateAddedLuns(List<LunModel> lunModels, boolean selectedLuns, boolean includedLuns, List<LunModel> aggregatedLuns) {
    for (LunModel lun : lunModels) {
        if (((selectedLuns && lun.getIsSelected() && !lun.getIsIncluded()) || (includedLuns && lun.getIsIncluded() && !lun.getIsSelected())) && Linq.firstOrNull(aggregatedLuns, new Linq.LunPredicate(lun)) == null) {
            aggregatedLuns.add(lun);
        }
    }
}
#end_block

#method_before
private void initNetworkProvidersList() {
    startProgress();
    AsyncDataProvider.getInstance().getAllProvidersByType(new AsyncQuery<>(result -> {
        stopProgress();
        List<Provider<OpenstackNetworkProviderProperties>> providers = (List) result;
        providers.add(0, null);
        getNetworkProviders().setItems(providers);
        getNetworkProviders().setSelectedItem(null);
    }), ProviderType.OPENSTACK_NETWORK, ProviderType.EXTERNAL_NETWORK);
}
#method_after
private void initNetworkProvidersList() {
    startProgress();
    AsyncDataProvider.getInstance().getAllProvidersByType(new AsyncQuery<>(result -> {
        stopProgress();
        List<Provider<OpenstackNetworkProviderProperties>> providers = (List) result;
        providers.add(0, null);
        getNetworkProviders().setItems(providers);
        selectDefaultProvider();
    }), ProviderType.OPENSTACK_NETWORK, ProviderType.EXTERNAL_NETWORK);
}
#end_block

#method_before
void initEntityModelCellTable() {
    AbstractCheckboxHeader assignAllHeader = new AbstractCheckboxHeader() {

        @Override
        protected void selectionChanged(Boolean value) {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (networkClusterModel.getIsChangable()) {
                    networkClusterModel.setAttached(value);
                    networkClusterModel.setRequired(networkClusterModel.isRequired() && value);
                }
            }
            refreshClustersTable();
        }

        @Override
        public Boolean getValue() {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (networkClusterModel.getIsChangable() && !networkClusterModel.isAttached()) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (networkClusterModel.getIsChangable()) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public String getLabel() {
            return constants.attachAll();
        }
    };
    AbstractCheckboxHeader requiredAllHeader = new AbstractCheckboxHeader() {

        @Override
        protected void selectionChanged(Boolean value) {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                networkClusterModel.setRequired(value && networkClusterModel.isAttached());
            }
            refreshClustersTable();
        }

        @Override
        public Boolean getValue() {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (!networkClusterModel.isRequired()) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            return isRequiredChangeable();
        }

        @Override
        public String getLabel() {
            return constants.requiredAll();
        }
    };
    clustersTable.addColumn(new AbstractTextColumn<NetworkClusterModel>() {

        @Override
        public String getValue(NetworkClusterModel model) {
            return model.getName();
        }
    }, constants.nameClusterHeader());
    clustersTable.addColumn(new AbstractCheckboxColumn<NetworkClusterModel>((index, model, value) -> {
        model.setAttached(value);
        model.setRequired(model.isRequired() && value);
        refreshClustersTable();
    }) {

        @Override
        public Boolean getValue(NetworkClusterModel model) {
            return model.isAttached();
        }

        @Override
        protected boolean canEdit(NetworkClusterModel model) {
            return model.getIsChangable();
        }

        @Override
        public void render(Context context, NetworkClusterModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.attach()));
        }
    }, assignAllHeader, // $NON-NLS-1$
    "110px");
    clustersTable.addColumn(new AbstractCheckboxColumn<NetworkClusterModel>((index, model, value) -> {
        model.setRequired(value && model.isAttached());
        refreshClustersTable();
    }) {

        @Override
        public Boolean getValue(NetworkClusterModel model) {
            return model.isRequired();
        }

        @Override
        protected boolean canEdit(NetworkClusterModel model) {
            return isRequiredChangeable() && model.isAttached();
        }

        @Override
        public void render(Context context, NetworkClusterModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.required()));
        }
    }, requiredAllHeader, // $NON-NLS-1$
    "110px");
}
#method_after
void initEntityModelCellTable() {
    AbstractCheckboxHeader assignAllHeader = new AbstractCheckboxHeader() {

        @Override
        protected void selectionChanged(Boolean value) {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (networkClusterModel.getIsChangable()) {
                    networkClusterModel.setAttached(value);
                    networkClusterModel.setRequired(value && networkClusterModel.isRequired());
                }
            }
            refreshClustersTable();
        }

        @Override
        public Boolean getValue() {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (networkClusterModel.getIsChangable() && !networkClusterModel.isAttached()) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (networkClusterModel.getIsChangable()) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public String getLabel() {
            return constants.attachAll();
        }
    };
    AbstractCheckboxHeader requiredAllHeader = new AbstractCheckboxHeader() {

        @Override
        protected void selectionChanged(Boolean value) {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                networkClusterModel.setRequired(value && networkClusterModel.isAttached());
            }
            refreshClustersTable();
        }

        @Override
        public Boolean getValue() {
            for (NetworkClusterModel networkClusterModel : getClustersTableItems()) {
                if (!networkClusterModel.isRequired()) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            return isRequiredChangeable();
        }

        @Override
        public String getLabel() {
            return constants.requiredAll();
        }
    };
    clustersTable.addColumn(new AbstractTextColumn<NetworkClusterModel>() {

        @Override
        public String getValue(NetworkClusterModel model) {
            return model.getName();
        }
    }, constants.nameClusterHeader());
    clustersTable.addColumn(new AbstractCheckboxColumn<NetworkClusterModel>((index, model, value) -> {
        model.setAttached(value);
        model.setRequired(value && model.isRequired());
        refreshClustersTable();
    }) {

        @Override
        public Boolean getValue(NetworkClusterModel model) {
            return model.isAttached();
        }

        @Override
        protected boolean canEdit(NetworkClusterModel model) {
            return model.getIsChangable();
        }

        @Override
        public void render(Context context, NetworkClusterModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.attach()));
        }
    }, assignAllHeader, // $NON-NLS-1$
    "110px");
    clustersTable.addColumn(new AbstractCheckboxColumn<NetworkClusterModel>((index, model, value) -> {
        model.setRequired(value && model.isAttached());
        refreshClustersTable();
    }) {

        @Override
        public Boolean getValue(NetworkClusterModel model) {
            return model.isRequired();
        }

        @Override
        protected boolean canEdit(NetworkClusterModel model) {
            return isRequiredChangeable() && model.isAttached();
        }

        @Override
        public void render(Context context, NetworkClusterModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.required()));
        }
    }, requiredAllHeader, // $NON-NLS-1$
    "110px");
}
#end_block

#method_before
@Mapping(from = NicConfiguration.class, to = VmInitNetwork.class)
public static VmInitNetwork map(NicConfiguration model, VmInitNetwork template) {
    VmInitNetwork entity = template != null ? template : new VmInitNetwork();
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isOnBoot()) {
        entity.setStartOnBoot(model.isOnBoot());
    }
    if (model.isSetBootProtocol()) {
        entity.setBootProtocol(Ipv4BootProtocolMapper.map(model.getBootProtocol()));
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setIp(model.getIp().getAddress());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setNetmask(model.getIp().getNetmask());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
    }
    if (model.isSetIpv6BootProtocol()) {
        entity.setIpv6BootProtocol(Ipv6BootProtocolMapper.map(model.getIpv6BootProtocol()));
    }
    if (model.isSetIpv6()) {
        if (model.getIpv6().isSetAddress()) {
            entity.setIpv6Address(model.getIpv6().getAddress());
        }
        if (model.getIpv6().isSetNetmask()) {
            entity.setIpv6Prefix((int) IntegerParser.parseUnsignedInt(model.getIpv6().getNetmask()));
        }
        if (model.getIpv6().isSetGateway()) {
            entity.setIpv6Gateway(model.getIpv6().getGateway());
        }
    }
    return entity;
}
#method_after
@Mapping(from = NicConfiguration.class, to = VmInitNetwork.class)
public static VmInitNetwork map(NicConfiguration model, VmInitNetwork template) {
    VmInitNetwork entity = template != null ? template : new VmInitNetwork();
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetOnBoot()) {
        entity.setStartOnBoot(model.isOnBoot());
    }
    if (model.isSetBootProtocol()) {
        entity.setBootProtocol(Ipv4BootProtocolMapper.map(model.getBootProtocol()));
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setIp(model.getIp().getAddress());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setNetmask(model.getIp().getNetmask());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
    }
    if (model.isSetIpv6BootProtocol()) {
        entity.setIpv6BootProtocol(Ipv6BootProtocolMapper.map(model.getIpv6BootProtocol()));
    }
    if (model.isSetIpv6()) {
        if (model.getIpv6().isSetAddress()) {
            entity.setIpv6Address(model.getIpv6().getAddress());
        }
        if (model.getIpv6().isSetNetmask()) {
            entity.setIpv6Prefix((int) IntegerParser.parseUnsignedInt(model.getIpv6().getNetmask()));
        }
        if (model.getIpv6().isSetGateway()) {
            entity.setIpv6Gateway(model.getIpv6().getGateway());
        }
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = Initialization.class, to = VmInit.class)
public static VmInit map(Initialization model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    boolean someSubTagSet = false;
    if (model.isSetHostName()) {
        someSubTagSet = true;
        entity.setHostname(model.getHostName());
    }
    if (model.isSetDomain()) {
        someSubTagSet = true;
        entity.setDomain(model.getDomain());
    }
    if (model.isSetTimezone()) {
        someSubTagSet = true;
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetAuthorizedSshKeys()) {
        someSubTagSet = true;
        entity.setAuthorizedKeys(model.getAuthorizedSshKeys());
    }
    if (model.isSetRegenerateSshKeys()) {
        someSubTagSet = true;
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetDnsServers()) {
        someSubTagSet = true;
        entity.setDnsServers(model.getDnsServers());
    }
    if (model.isSetDnsSearch()) {
        someSubTagSet = true;
        entity.setDnsSearch(model.getDnsSearch());
    }
    if (model.isSetWindowsLicenseKey()) {
        someSubTagSet = true;
        entity.setWinKey(model.getWindowsLicenseKey());
    }
    if (model.isSetRootPassword()) {
        someSubTagSet = true;
        entity.setRootPassword(model.getRootPassword());
    }
    if (model.isSetCustomScript()) {
        someSubTagSet = true;
        entity.setCustomScript(model.getCustomScript());
    }
    if (model.isSetNicConfigurations()) {
        someSubTagSet = true;
        List<VmInitNetwork> networks = new ArrayList<>();
        for (NicConfiguration nic : model.getNicConfigurations().getNicConfigurations()) {
            networks.add(map(nic, null));
        }
        entity.setNetworks(networks);
    }
    if (model.isSetInputLocale()) {
        someSubTagSet = true;
        entity.setInputLocale(model.getInputLocale());
    }
    if (model.isSetUiLanguage()) {
        someSubTagSet = true;
        entity.setUiLanguage(model.getUiLanguage());
    }
    if (model.isSetSystemLocale()) {
        someSubTagSet = true;
        entity.setSystemLocale(model.getSystemLocale());
    }
    if (model.isSetUserLocale()) {
        someSubTagSet = true;
        entity.setUserLocale(model.getUserLocale());
    }
    if (model.isSetUserName()) {
        someSubTagSet = true;
        entity.setUserName(model.getUserName());
    }
    if (model.isSetActiveDirectoryOu()) {
        entity.setActiveDirectoryOU(model.getActiveDirectoryOu());
    }
    if (model.isSetOrgName()) {
        someSubTagSet = true;
        entity.setOrgName(model.getOrgName());
    }
    if (model.isSetCloudInit()) {
        someSubTagSet = true;
        VmMapper.map(model.getCloudInit(), entity);
    }
    if (!someSubTagSet) {
        return null;
    }
    return entity;
}
#method_after
@Mapping(from = Initialization.class, to = VmInit.class)
public static VmInit map(Initialization model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    boolean someSubTagSet = false;
    if (model.isSetHostName()) {
        someSubTagSet = true;
        entity.setHostname(model.getHostName());
    }
    if (model.isSetDomain()) {
        someSubTagSet = true;
        entity.setDomain(model.getDomain());
    }
    if (model.isSetTimezone()) {
        someSubTagSet = true;
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetAuthorizedSshKeys()) {
        someSubTagSet = true;
        entity.setAuthorizedKeys(model.getAuthorizedSshKeys());
    }
    if (model.isSetRegenerateSshKeys()) {
        someSubTagSet = true;
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetDnsServers()) {
        someSubTagSet = true;
        entity.setDnsServers(model.getDnsServers());
    }
    if (model.isSetDnsSearch()) {
        someSubTagSet = true;
        entity.setDnsSearch(model.getDnsSearch());
    }
    if (model.isSetWindowsLicenseKey()) {
        someSubTagSet = true;
        entity.setWinKey(model.getWindowsLicenseKey());
    }
    if (model.isSetRootPassword()) {
        someSubTagSet = true;
        entity.setRootPassword(model.getRootPassword());
    }
    if (model.isSetCustomScript()) {
        someSubTagSet = true;
        entity.setCustomScript(model.getCustomScript());
    }
    if (model.isSetNicConfigurations()) {
        someSubTagSet = true;
        List<VmInitNetwork> networks = new ArrayList<>();
        for (NicConfiguration nic : model.getNicConfigurations().getNicConfigurations()) {
            networks.add(map(nic, null));
        }
        entity.setNetworks(networks);
    }
    if (model.isSetInputLocale()) {
        someSubTagSet = true;
        entity.setInputLocale(model.getInputLocale());
    }
    if (model.isSetUiLanguage()) {
        someSubTagSet = true;
        entity.setUiLanguage(model.getUiLanguage());
    }
    if (model.isSetSystemLocale()) {
        someSubTagSet = true;
        entity.setSystemLocale(model.getSystemLocale());
    }
    if (model.isSetUserLocale()) {
        someSubTagSet = true;
        entity.setUserLocale(model.getUserLocale());
    }
    if (model.isSetUserName()) {
        someSubTagSet = true;
        entity.setUserName(model.getUserName());
    }
    if (model.isSetActiveDirectoryOu()) {
        someSubTagSet = true;
        entity.setActiveDirectoryOU(model.getActiveDirectoryOu());
    }
    if (model.isSetOrgName()) {
        someSubTagSet = true;
        entity.setOrgName(model.getOrgName());
    }
    if (model.isSetCloudInit()) {
        someSubTagSet = true;
        VmMapper.map(model.getCloudInit(), entity);
    }
    if (!someSubTagSet) {
        return null;
    }
    return entity;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void runAnsibleRemovePlaybook() {
    AuditLogable logable = new AuditLogableImpl();
    logable.setVdsName(getVds().getName());
    logable.setVdsId(getVds().getId());
    logable.addCustomValue("Playbook", AnsibleConstants.HOST_REMOVE_PLAYBOOK);
    try {
        AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(getVds().getHostName()).variables(new Pair<>("host_remove_is_hosted_engine", getVds().isHostedEngineHost())).playbook(AnsibleConstants.HOST_REMOVE_PLAYBOOK);
        auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_HOST_REMOVE_STARTED);
        AnsibleReturnValue ansibleReturnValue = ansibleExecutor.runCommand(command);
        logable.addCustomValue("LogFile", command.logFile().getAbsolutePath());
        if (ansibleReturnValue.getAnsibleReturnCode() != AnsibleReturnCode.OK) {
            auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_HOST_REMOVE_FAILED);
        } else {
            auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_HOST_REMOVE_FINISHED);
        }
    } catch (Exception e) {
        auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_HOST_REMOVE_FAILED);
    }
}
#method_after
@SuppressWarnings("unchecked")
private void runAnsibleRemovePlaybook() {
    AuditLogable logable = new AuditLogableImpl();
    logable.setVdsName(getVds().getName());
    logable.setVdsId(getVds().getId());
    logable.setCorrelationId(getCorrelationId());
    try {
        AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(getVds().getHostName()).playbook(AnsibleConstants.HOST_REMOVE_PLAYBOOK);
        auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_HOST_REMOVE_STARTED);
        AnsibleReturnValue ansibleReturnValue = ansibleExecutor.runCommand(command);
        logable.addCustomValue("LogFile", command.logFile().getAbsolutePath());
        if (ansibleReturnValue.getAnsibleReturnCode() != AnsibleReturnCode.OK) {
            auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_HOST_REMOVE_FAILED);
        } else {
            auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_HOST_REMOVE_FINISHED);
        }
    } catch (Exception e) {
        logable.addCustomValue("Message", e.getMessage());
        auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_HOST_REMOVE_EXECUTION_FAILED);
    }
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(cluster());
    optional(clone());
    optional(exclusive());
    optional(vm().name());
    or(optional(storageDomain().id()), optional(storageDomain().name()));
    optional(vm().diskAttachments()[COLLECTION].disk().format());
    optional(vm().diskAttachments()[COLLECTION].id());
    optional(vm().diskAttachments()[COLLECTION].disk().sparse());
}
#method_after
@InputDetail
default void inputDetail() {
    or(optional(cluster().id()), optional(cluster().name()));
    optional(clone());
    optional(exclusive());
    optional(vm().name());
    or(optional(storageDomain().id()), optional(storageDomain().name()));
    optional(vm().diskAttachments()[COLLECTION].disk().format());
    optional(vm().diskAttachments()[COLLECTION].id());
    optional(vm().diskAttachments()[COLLECTION].disk().sparse());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(cluster());
    optional(registrationConfiguration());
}
#method_after
@InputDetail
default void inputDetail() {
    or(optional(cluster().id()), optional(cluster().name()));
    optional(registrationConfiguration());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(cluster());
    optional(clone());
    optional(exclusive());
    optional(template().name());
    or(optional(storageDomain().id()), optional(storageDomain().name()));
    optional(vm().diskAttachments()[COLLECTION].id());
}
#method_after
@InputDetail
default void inputDetail() {
    or(optional(cluster().id()), optional(cluster().name()));
    optional(clone());
    optional(exclusive());
    optional(template().name());
    or(optional(storageDomain().id()), optional(storageDomain().name()));
    optional(vm().diskAttachments()[COLLECTION].id());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(cluster());
    optional(clone());
    optional(exclusive());
    optional(template().name());
    optional(registrationConfiguration());
}
#method_after
@InputDetail
default void inputDetail() {
    or(optional(cluster().id()), optional(cluster().name()));
    optional(clone());
    optional(exclusive());
    optional(template().name());
    optional(registrationConfiguration());
}
#end_block

#method_before
@Override
public void edit(HostNetworkProviderModel model) {
    driver.edit(model);
    final NeutronAgentModel neutronAgentModel = model.getNeutronAgentModel();
    neutronAgentWidget.edit(neutronAgentModel);
    neutronAgentPanel.setVisible(neutronAgentModel.isPluginConfigurationAvailable().getEntity());
    neutronAgentModel.isPluginConfigurationAvailable().getEntityChangedEvent().addListener((ev, sender, args) -> neutronAgentPanel.setVisible(neutronAgentModel.isPluginConfigurationAvailable().getEntity()));
    model.getNetworkProviders().setIsChangeable(!model.getUseClusterDefaultNetworkProvider().getEntity());
    model.getUseClusterDefaultNetworkProvider().getEntityChangedEvent().addListener((ev, sender, args) -> model.getNetworkProviders().setIsChangeable(!model.getUseClusterDefaultNetworkProvider().getEntity()));
}
#method_after
@Override
public void edit(HostNetworkProviderModel model) {
    driver.edit(model);
    final NeutronAgentModel neutronAgentModel = model.getNeutronAgentModel();
    neutronAgentWidget.edit(neutronAgentModel);
    neutronAgentPanel.setVisible(neutronAgentModel.isPluginConfigurationAvailable().getEntity());
    neutronAgentModel.isPluginConfigurationAvailable().getEntityChangedEvent().addListener((ev, sender, args) -> neutronAgentPanel.setVisible(neutronAgentModel.isPluginConfigurationAvailable().getEntity()));
}
#end_block

#method_before
protected void cluster_SelectedItemChanged() {
    Cluster cluster = getCluster().getSelectedItem();
    if (cluster == null) {
        return;
    }
    getFencingEnabled().setEntity(cluster.getFencingPolicy().isFencingEnabled());
    AsyncDataProvider.getInstance().getPmTypeList(new AsyncQuery<>(pmTypes -> updatePmTypeList(pmTypes)), cluster.getCompatibilityVersion());
    // Match the appropriate selected data center to the selected cluster, don't fire update events.
    if (getDataCenter() != null && getDataCenter().getItems() != null) {
        for (StoragePool datacenter : getDataCenter().getItems()) {
            if (datacenter.getId().equals(cluster.getStoragePoolId())) {
                getDataCenter().setSelectedItem(datacenter, false);
                break;
            }
        }
    }
    final CpuVendor newCpuVendor = getCurrentCpuVendor();
    if (newCpuVendor != null && !newCpuVendor.equals(lastNonNullCpuVendor)) {
        lastNonNullCpuVendor = newCpuVendor;
        cpuVendorChanged();
    }
    getHostedEngineWarning().setIsAvailable(cluster.getCompatibilityVersion().less(Version.v4_0));
    getNetworkProviderModel().setDefaultProviderById(cluster.getDefaultNetworkProviderId());
}
#method_after
protected void cluster_SelectedItemChanged() {
    Cluster cluster = getCluster().getSelectedItem();
    if (cluster == null) {
        return;
    }
    getFencingEnabled().setEntity(cluster.getFencingPolicy().isFencingEnabled());
    AsyncDataProvider.getInstance().getPmTypeList(new AsyncQuery<>(pmTypes -> updatePmTypeList(pmTypes)), cluster.getCompatibilityVersion());
    // Match the appropriate selected data center to the selected cluster, don't fire update events.
    if (getDataCenter() != null && getDataCenter().getItems() != null) {
        for (StoragePool datacenter : getDataCenter().getItems()) {
            if (datacenter.getId().equals(cluster.getStoragePoolId())) {
                getDataCenter().setSelectedItem(datacenter, false);
                break;
            }
        }
    }
    final CpuVendor newCpuVendor = getCurrentCpuVendor();
    if (newCpuVendor != null && !newCpuVendor.equals(lastNonNullCpuVendor)) {
        lastNonNullCpuVendor = newCpuVendor;
        cpuVendorChanged();
    }
    getHostedEngineWarning().setIsAvailable(cluster.getCompatibilityVersion().less(Version.v4_0));
    getNetworkProviderModel().setDefaultProviderId(cluster.getDefaultNetworkProviderId());
}
#end_block

#method_before
public void onDataInitialized() {
    addKernelCmdlineCheckboxesListeners();
    addKernelCmdlineListener();
    updateKernelCmdlineCheckboxesChangeability();
}
#method_after
public void onDataInitialized() {
    addKernelCmdlineCheckboxesListeners();
    addKernelCmdlineListener();
    updateKernelCmdlineCheckboxesChangeability();
    updateLabelList();
}
#end_block

#method_before
public void resetKernelCmdlineCheckboxes() {
    final CpuVendor cpuVendor = getCurrentCpuVendor();
    if (cpuVendor == null) {
        return;
    }
    switch(cpuVendor) {
        case INTEL:
        case AMD:
            setKernelCmdlineCheckboxesValue(false);
            break;
        case IBM:
            setKernelCmdlineCheckboxesValue(true);
            break;
        default:
            // $NON-NLS-1$
            throw new RuntimeException("Unknown CpuVendor type: " + cpuVendor);
    }
    updateKernelCmdlineCheckboxesChangeability();
}
#method_after
public void resetKernelCmdlineCheckboxes() {
    final CpuVendor cpuVendor = getCurrentCpuVendor();
    if (cpuVendor == null) {
        return;
    }
    switch(cpuVendor) {
        case INTEL:
        case AMD:
        case IBMS390:
            setKernelCmdlineCheckboxesValue(false);
            break;
        case IBM:
            setKernelCmdlineCheckboxesValue(true);
            break;
        default:
            // $NON-NLS-1$
            throw new RuntimeException("Unknown CpuVendor type: " + cpuVendor);
    }
    updateKernelCmdlineCheckboxesChangeability();
}
#end_block

#method_before
protected void updateKernelCmdlineCheckboxesChangeability() {
    final CpuVendor cpuVendor = getCurrentCpuVendor();
    if (cpuVendor == null) {
        return;
    }
    switch(cpuVendor) {
        case INTEL:
        case AMD:
            setKernelCmdlineCheckboxesChangeability(isKernelCmdlineParsable(), constants.kernelCmdlineCheckboxesAndDirectCustomizationNotAllowed());
            break;
        case IBM:
            setKernelCmdlineCheckboxesChangeability(false, constants.kernelCmdlineNotAvailableInClusterWithIbmCpu());
            break;
        default:
            // $NON-NLS-1$
            throw new RuntimeException("Unknown CpuVendor type: " + cpuVendor);
    }
}
#method_after
protected void updateKernelCmdlineCheckboxesChangeability() {
    final CpuVendor cpuVendor = getCurrentCpuVendor();
    if (cpuVendor == null) {
        return;
    }
    switch(cpuVendor) {
        case INTEL:
        case AMD:
        case IBMS390:
            setKernelCmdlineCheckboxesChangeability(isKernelCmdlineParsable(), constants.kernelCmdlineCheckboxesAndDirectCustomizationNotAllowed());
            break;
        case IBM:
            setKernelCmdlineCheckboxesChangeability(false, constants.kernelCmdlineNotAvailableInClusterWithIbmCpu());
            break;
        default:
            // $NON-NLS-1$
            throw new RuntimeException("Unknown CpuVendor type: " + cpuVendor);
    }
}
#end_block

#method_before
private void initNetworkProvidersList() {
    startProgress();
    AsyncDataProvider.getInstance().getAllProvidersByType(new AsyncQuery<>(result -> {
        stopProgress();
        List<Provider<OpenstackNetworkProviderProperties>> providers = (List) result;
        providers.add(0, null);
        getNetworkProviders().setItems(providers);
        getNetworkProviders().setSelectedItem(null);
    }), ProviderType.OPENSTACK_NETWORK, ProviderType.EXTERNAL_NETWORK);
}
#method_after
private void initNetworkProvidersList() {
    startProgress();
    AsyncDataProvider.getInstance().getAllProvidersByType(new AsyncQuery<>(result -> {
        stopProgress();
        List<Provider<OpenstackNetworkProviderProperties>> providers = (List) result;
        providers.add(0, null);
        getNetworkProviders().setItems(providers);
        selectDefaultProvider();
    }), ProviderType.OPENSTACK_NETWORK, ProviderType.EXTERNAL_NETWORK);
}
#end_block

#method_before
private void selectDefaultProvider() {
    if (getUseClusterDefaultNetworkProvider().getEntity()) {
        getNetworkProviders().setSelectedItem(getDefaultProvider());
    }
}
#method_after
private void selectDefaultProvider() {
    if (getNetworkProviders().getItems() != null && getUseClusterDefaultNetworkProvider().getEntity()) {
        Provider defaultProvider = getNetworkProviders().getItems().stream().filter(provider -> provider != null).filter(provider -> provider.getId().equals(defaultProviderId)).findFirst().orElse(null);
        getNetworkProviders().setSelectedItem(defaultProvider);
    }
}
#end_block

#method_before
public void attemptResolution() {
    Set<Guid> images;
    if (vmDao.get(getParameters().getVmId()).isDown()) {
        StoragePool pool = storagePoolDao.get(getParameters().getStoragePoolId());
        if (pool.getSpmVdsId() == null || pool.getStatus() != StoragePoolStatus.Up) {
            log.info("VM down, waiting on SPM election to resolve Live Merge");
            setSucceeded(true);
            return;
        } else {
            log.error("VM is not running, proceeding with Live Merge recovery");
            images = getVolumeChainFromRecovery();
        }
    } else {
        images = getVolumeChain();
    }
    if (images == null || images.isEmpty()) {
        log.error("Failed to retrieve images list of VM {}. Retrying ...", getParameters().getVmId());
        setCommandStatus(CommandStatus.SUCCEEDED);
        setSucceeded(true);
        // As this command is executed only during live merge flow, the following casting is safe.
        ((RemoveSnapshotSingleDiskParameters) getParameters().getParentParameters()).setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
        return;
    }
    Set<Guid> imagesToRemove = getImagesToRemove();
    images.retainAll(imagesToRemove);
    if (images.size() != 1) {
        log.error("Failed to live merge, still in volume chain: {}", images);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (!images.contains(getParameters().getBaseImage().getImageId())) {
        // If the base image isn't found in qemu chain, it means that the image was already deleted.
        // In this case, we will not allow PULL merge but rather ask the user to check if the parent
        // snapshot contains illegal volume(s). If so, that snapshot must be deleted before deleting
        // other snapshots
        addCustomValue("SnapshotName", snapshotDao.get(getParameters().getBaseImage().getSnapshotId()).getDescription());
        addCustomValue("BaseVolumeId", getParameters().getBaseImage().getImageId().toString());
        auditLog(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_BASE_IMAGE_NOT_FOUND);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    imagesToRemove.removeAll(images);
    log.info("Successfully removed volume(s): {}", imagesToRemove);
    // For now, only COMMIT type is supported
    log.info("Volume merge type '{}'", VmBlockJobType.COMMIT.name());
    MergeStatusReturnValue returnValue = new MergeStatusReturnValue(VmBlockJobType.COMMIT, imagesToRemove);
    getReturnValue().setActionReturnValue(returnValue);
    setSucceeded(true);
    persistCommand(getParameters().getParentCommand(), true);
    setCommandStatus(CommandStatus.SUCCEEDED);
}
#method_after
public void attemptResolution() {
    Set<Guid> images;
    if (vmDynamicDao.get(getParameters().getVmId()).getStatus().isNotRunning()) {
        StoragePool pool = storagePoolDao.get(getParameters().getStoragePoolId());
        if (pool.getSpmVdsId() == null || pool.getStatus() != StoragePoolStatus.Up) {
            log.info("VM down, waiting on SPM election to resolve Live Merge");
            setSucceeded(true);
            return;
        } else {
            log.error("VM is not running, proceeding with Live Merge recovery");
            images = getVolumeChainFromRecovery();
        }
    } else {
        images = getVolumeChain();
    }
    if (images == null || images.isEmpty()) {
        log.error("Failed to retrieve images list of VM {}. Retrying ...", getParameters().getVmId());
        setCommandStatus(CommandStatus.SUCCEEDED);
        setSucceeded(true);
        // As this command is executed only during live merge flow, the following casting is safe.
        ((RemoveSnapshotSingleDiskParameters) getParameters().getParentParameters()).setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
        return;
    }
    Set<Guid> imagesToRemove = getImagesToRemove();
    images.retainAll(imagesToRemove);
    if (images.size() != 1) {
        log.error("Failed to live merge, still in volume chain: {}", images);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (!images.contains(getParameters().getBaseImage().getImageId())) {
        // If the base image isn't found in qemu chain, it means that the image was already deleted.
        // In this case, we will not allow PULL merge but rather ask the user to check if the parent
        // snapshot contains illegal volume(s). If so, that snapshot must be deleted before deleting
        // other snapshots
        addCustomValue("SnapshotName", snapshotDao.get(getParameters().getBaseImage().getSnapshotId()).getDescription());
        addCustomValue("BaseVolumeId", getParameters().getBaseImage().getImageId().toString());
        auditLog(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_BASE_IMAGE_NOT_FOUND);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    imagesToRemove.removeAll(images);
    log.info("Successfully removed volume(s): {}", imagesToRemove);
    // For now, only COMMIT type is supported
    log.info("Volume merge type '{}'", VmBlockJobType.COMMIT.name());
    MergeStatusReturnValue returnValue = new MergeStatusReturnValue(VmBlockJobType.COMMIT, imagesToRemove);
    getReturnValue().setActionReturnValue(returnValue);
    setSucceeded(true);
    persistCommand(getParameters().getParentCommand(), true);
    setCommandStatus(CommandStatus.SUCCEEDED);
}
#end_block

#method_before
private boolean isDomainXmlEnabledForVds() {
    return (boolean) Config.getValue(ConfigValues.DomainXML, vmDao.get(getParameters().getVmId()).getCompatibilityVersion().toString());
}
#method_after
private boolean isDomainXmlEnabledForVds() {
    return FeatureSupported.isDomainXMLSupported(resourceManager.getVdsManager(getParameters().getVdsId()).getCompatibilityVersion());
}
#end_block

#method_before
@Override
public void setElementId(String elementId) {
    this.elementId = elementId;
    popuplateSwappedList();
}
#method_after
@Override
public void setElementId(String elementId) {
    this.elementId = elementId;
    // We can only populate the swapped list after the id is set since we use the id to generate the key
    // to look up the swapped list. If the elementId is not set, then the map will remain empty and the
    // order cannot be overriden.
    popuplateSwappedList();
}
#end_block

#method_before
private void showNetwork(LogicalNetworkModel networkModel) {
    boolean descriptionSectionHasValues = false;
    contents.removeAllRows();
    Network entity = networkModel.getNetwork();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName(), BACKGROUND_COLOR));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageWithText(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
        descriptionSectionHasValues = true;
    } else {
        if (networkModel.getErrorMessage() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, templates.maxWidthNteworkItemPopup(networkModel.getErrorMessage())));
            descriptionSectionHasValues = true;
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
            descriptionSectionHasValues = true;
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addSyncDiff(networkModel);
            descriptionSectionHasValues = true;
        }
    }
    if (descriptionSectionHasValues) {
        insertHorizontalLine();
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    boolean isGluster = false;
    boolean isDefaultRoute = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
        isGluster = entity.getCluster().isGluster();
        isDefaultRoute = entity.getCluster().isDefaultRoute();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration || isGluster || isDefaultRoute) {
        // $NON-NLS-1$
        addRow(templates.strongTextWithColor(constants.usageItemInfo() + ":", WHITE_TEXT_COLOR));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo(), TEXT_COLOR));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo(), TEXT_COLOR));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo(), TEXT_COLOR));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo(), TEXT_COLOR));
        }
        if (isGluster) {
            addRow(templates.imageTextSetupNetworkUsage(glusterNwImage, constants.glusterNwItemInfo(), TEXT_COLOR));
        }
        if (isDefaultRoute) {
            addRow(templates.imageTextSetupNetworkUsage(defaultRouteImage, constants.defaultRouteItemInfo(), TEXT_COLOR));
        }
        insertHorizontalLine();
    }
    // Mtu
    if (!entity.isExternal()) {
        final String mtuValue = entity.getMtu() == 0 ? messages.defaultMtu(defaultMtu) : String.valueOf(entity.getMtu());
        // $NON-NLS-1$
        final String mtu = templates.strongTextWithColor(constants.mtuItemInfo(), WHITE_TEXT_COLOR).asString() + ": " + templates.coloredText(mtuValue, TEXT_COLOR).asString();
        addRow(SafeHtmlUtils.fromTrustedString(mtu));
    }
    // Boot protocol and IP info
    if (networkModel.isAttached()) {
        addBootProtoAndIpInfo(new InterfacePropertiesAccessor.FromNetworkAttachmentForModel(networkModel.getNetworkAttachment(), null, networkModel.getAttachedToNic().getOriginalIface()));
    }
}
#method_after
private void showNetwork(LogicalNetworkModel networkModel) {
    boolean descriptionSectionHasValues = false;
    contents.removeAllRows();
    Network entity = networkModel.getNetwork();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName(), BACKGROUND_COLOR));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageWithText(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
        descriptionSectionHasValues = true;
    } else {
        if (networkModel.getErrorMessage() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, templates.maxWidthNteworkItemPopup(networkModel.getErrorMessage())));
            descriptionSectionHasValues = true;
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
            descriptionSectionHasValues = true;
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addSyncDiff(networkModel);
            descriptionSectionHasValues = true;
        }
    }
    if (descriptionSectionHasValues) {
        insertHorizontalLine();
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    boolean isGluster = false;
    boolean isDefaultRoute = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
        isGluster = entity.getCluster().isGluster();
        isDefaultRoute = entity.getCluster().isDefaultRoute();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration || isGluster || isDefaultRoute) {
        // $NON-NLS-1$
        addRow(templates.strongTextWithColor(constants.usageItemInfo() + ":", WHITE_TEXT_COLOR));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo(), TEXT_COLOR));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo(), TEXT_COLOR));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo(), TEXT_COLOR));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo(), TEXT_COLOR));
        }
        if (isGluster) {
            addRow(templates.imageTextSetupNetworkUsage(glusterNwImage, constants.glusterNwItemInfo(), TEXT_COLOR));
        }
        if (isDefaultRoute) {
            addRow(templates.imageTextSetupNetworkUsage(defaultRouteImage, constants.defaultRouteItemInfo(), TEXT_COLOR));
        }
        insertHorizontalLine();
    }
    // Mtu
    if (!entity.isExternal()) {
        final String mtuValue = entity.getMtu() == 0 ? messages.defaultMtu(defaultMtu) : String.valueOf(entity.getMtu());
        // $NON-NLS-1$
        final String mtu = templates.strongTextWithColor(constants.mtuItemInfo(), WHITE_TEXT_COLOR).asString() + ": " + templates.coloredText(mtuValue, TEXT_COLOR).asString();
        addRow(SafeHtmlUtils.fromTrustedString(mtu));
    }
    // Boot protocol and IP info
    if (networkModel.isAttached() && networkModel.isManaged()) {
        addBootProtoAndIpInfo(new InterfacePropertiesAccessor.FromNetworkAttachmentForModel(networkModel.getNetworkAttachment(), null, networkModel.getVlanDevice() != null ? networkModel.getVlanDevice() : networkModel.getAttachedToNic().getOriginalIface()));
    }
}
#end_block

#method_before
private void flush() {
    provider.setName(name.getEntity());
    provider.setType(type.getSelectedItem());
    provider.setDescription(description.getEntity());
    provider.setUrl(url.getEntity());
    if (isTypeOpenStackNetwork() || isExternalNetwork()) {
        getNeutronAgentModel().flush(provider);
        OpenstackNetworkProviderProperties properties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
        properties.setReadOnly(readOnly.getEntity());
    } else if (isTypeOpenStackImage()) {
        provider.setAdditionalProperties(new OpenStackImageProviderProperties());
    } else if (isTypeOpenStackVolume()) {
        provider.setAdditionalProperties(new OpenStackVolumeProviderProperties(getDataCenter().getSelectedItem().getId()));
    } else if (isTypeVmware()) {
        provider.setAdditionalProperties(getVmwarePropertiesModel().getVmwareVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
        provider.setUrl(getVmwarePropertiesModel().getUrl());
    } else if (isTypeKVM()) {
        provider.setUrl(getKvmPropertiesModel().getUrl().getEntity());
        provider.setAdditionalProperties(getKvmPropertiesModel().getKVMVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
    } else if (isTypeXEN()) {
        provider.setUrl(getXenPropertiesModel().getUrl().getEntity());
        provider.setAdditionalProperties(getXenPropertiesModel().getXENVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
    }
    boolean authenticationRequired = requiresAuthentication.getEntity();
    provider.setRequiringAuthentication(authenticationRequired);
    if (authenticationRequired) {
        provider.setUsername(getUsername().getEntity());
        provider.setPassword(getPassword().getEntity());
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties == null) {
                properties = new TenantProviderProperties();
                provider.setAdditionalProperties(properties);
            }
            properties.setTenantName(getTenantName().getEntity());
        }
        provider.setAuthUrl(getAuthUrl().getEntity());
    } else {
        provider.setUsername(null);
        provider.setPassword(null);
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties != null) {
                properties.setTenantName(null);
            }
        }
        provider.setAuthUrl(null);
    }
}
#method_after
private void flush() {
    provider.setName(name.getEntity());
    provider.setType(type.getSelectedItem());
    provider.setDescription(description.getEntity());
    provider.setUrl(url.getEntity());
    if (isTypeNetwork()) {
        getNeutronAgentModel().flush(provider);
        OpenstackNetworkProviderProperties properties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
        properties.setReadOnly(readOnly.getEntity());
    } else if (isTypeOpenStackImage()) {
        provider.setAdditionalProperties(new OpenStackImageProviderProperties());
    } else if (isTypeOpenStackVolume()) {
        provider.setAdditionalProperties(new OpenStackVolumeProviderProperties(getDataCenter().getSelectedItem().getId()));
    } else if (isTypeVmware()) {
        provider.setAdditionalProperties(getVmwarePropertiesModel().getVmwareVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
        provider.setUrl(getVmwarePropertiesModel().getUrl());
    } else if (isTypeKVM()) {
        provider.setUrl(getKvmPropertiesModel().getUrl().getEntity());
        provider.setAdditionalProperties(getKvmPropertiesModel().getKVMVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
    } else if (isTypeXEN()) {
        provider.setUrl(getXenPropertiesModel().getUrl().getEntity());
        provider.setAdditionalProperties(getXenPropertiesModel().getXENVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
    }
    boolean authenticationRequired = requiresAuthentication.getEntity();
    provider.setRequiringAuthentication(authenticationRequired);
    if (authenticationRequired) {
        provider.setUsername(getUsername().getEntity());
        provider.setPassword(getPassword().getEntity());
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties == null) {
                properties = new TenantProviderProperties();
                provider.setAdditionalProperties(properties);
            }
            properties.setTenantName(getTenantName().getEntity());
        }
        provider.setAuthUrl(getAuthUrl().getEntity());
    } else {
        provider.setUsername(null);
        provider.setPassword(null);
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties != null) {
                properties.setTenantName(null);
            }
        }
        provider.setAuthUrl(null);
    }
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    registerHandler(getTable().getSelectionModel().addSelectionChangeHandler(event -> {
        // Update main model selection
        modelProvider.setSelectedItems(getSelectedItems());
        // Let others know that the table selection has changed
        fireTableSelectionChangeEvent();
        // quick switch search is run.
        if (isVisible()) {
            handlePlaceTransition(false);
        }
    }));
    registerHandler(getEventBus().addHandler(ApplySearchStringEvent.getType(), event -> {
        applySearchString(event.getSearchString());
    }));
    getView().setDetailPlaceTransitionHandler(this);
    registerHandler(getView().addWindowResizeHandler(e -> {
        Scheduler.get().scheduleDeferred(() -> getView().resizeToFullHeight());
    }));
    String searchString = searchStringCollector.getSearchStringPrefix(modelProvider.getModel().getSearchString());
    if (searchString != null) {
        // Someone set search string before we were instantiated, update the search string.
        applySearchString(searchString);
    }
    if (hasSearchPanelPresenterWidget()) {
        setInSlot(TYPE_SetSearchPanel, searchPanelPresenterWidget);
    }
    if (hasActionPanelPresenterWidget()) {
        setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
    }
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    registerHandler(getTable().getSelectionModel().addSelectionChangeHandler(event -> {
        // Update main model selection
        modelProvider.setSelectedItems(getSelectedItems());
        // Let others know that the table selection has changed
        fireTableSelectionChangeEvent();
        // quick switch search is run.
        if (isVisible()) {
            handlePlaceTransition(false);
        }
    }));
    registerHandler(getEventBus().addHandler(ApplySearchStringEvent.getType(), event -> {
        applySearchString(event.getSearchString());
    }));
    getView().setDetailPlaceTransitionHandler(this);
    registerHandler(getView().addWindowResizeHandler(e -> {
        if (!resizing) {
            Scheduler.get().scheduleDeferred(() -> {
                getView().resizeToFullHeight();
                resizing = false;
            });
            resizing = true;
        }
    }));
    String searchString = searchStringCollector.getSearchStringPrefix(modelProvider.getModel().getSearchString());
    if (searchString != null) {
        // Someone set search string before we were instantiated, update the search string.
        applySearchString(searchString);
    }
    if (hasSearchPanelPresenterWidget()) {
        setInSlot(TYPE_SetSearchPanel, searchPanelPresenterWidget);
    }
    if (hasActionPanelPresenterWidget()) {
        setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
    }
}
#end_block

#method_before
@Override
protected void onHide() {
    getTable().hideContextMenu();
    breadCrumbsPresenterWidget.rebuildBreadCrumbs();
}
#method_after
@Override
protected void onHide() {
    getTable().hideContextMenu();
    getView().resizeToFullHeight();
    breadCrumbsPresenterWidget.rebuildBreadCrumbs();
}
#end_block

#method_before
private void onImport() {
    StorageModel model = (StorageModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.startProgress(ConstantsManager.getInstance().getConstants().importingStorageDomainProgress());
    VDS host = model.getHost().getSelectedItem();
    // Save changes.
    if (model.getCurrentStorageItem() instanceof NfsStorageModel) {
        NfsStorageModel nfsModel = (NfsStorageModel) model.getCurrentStorageItem();
        nfsModel.setMessage(null);
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), nfsModel.getPath().getEntity(), nfsModel.getRole(), StorageType.NFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getCurrentStorageItem() instanceof LocalStorageModel) {
        LocalStorageModel localModel = (LocalStorageModel) model.getCurrentStorageItem();
        localModel.setMessage(null);
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), localModel.getPath().getEntity(), localModel.getRole(), StorageType.LOCALFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getCurrentStorageItem() instanceof PosixStorageModel) {
        PosixStorageModel posixModel = (PosixStorageModel) model.getCurrentStorageItem();
        posixModel.setMessage(null);
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), posixModel.getPath().getEntity(), posixModel.getRole(), posixModel.getType(), model.getActivateDomain().getEntity() }))).run();
    } else if (model.getCurrentStorageItem() instanceof ImportSanStorageModel) {
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportSan", host.getId(), model.getActivateDomain().getEntity() }))).run();
    }
}
#method_after
private void onImport() {
    StorageModel model = (StorageModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.startProgress(ConstantsManager.getInstance().getConstants().importingStorageDomainProgress());
    VDS host = model.getHost().getSelectedItem();
    // Save changes.
    if (model.getCurrentStorageItem() instanceof NfsStorageModel) {
        NfsStorageModel nfsModel = (NfsStorageModel) model.getCurrentStorageItem();
        nfsModel.setMessage(null);
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), nfsModel.getPath().getEntity(), nfsModel.getRole(), StorageType.NFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getCurrentStorageItem() instanceof LocalStorageModel) {
        LocalStorageModel localModel = (LocalStorageModel) model.getCurrentStorageItem();
        localModel.setMessage(null);
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), localModel.getPath().getEntity(), localModel.getRole(), StorageType.LOCALFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getCurrentStorageItem() instanceof GlusterStorageModel) {
        GlusterStorageModel glusterModel = (GlusterStorageModel) model.getCurrentStorageItem();
        glusterModel.setMessage(null);
        // Check checkbox is selected or not
        if (glusterModel.getLinkGlusterVolume().getEntity() && glusterModel.getGlusterVolumes().getSelectedItem() != null) {
            GlusterBrickEntity brick = glusterModel.getGlusterVolumes().getSelectedItem().getBricks().get(0);
            if (brick != null) {
                String server = brick.getNetworkId() != null && StringHelper.isNotNullOrEmpty(brick.getNetworkAddress()) ? brick.getNetworkAddress() : brick.getServerName();
                path = // $NON-NLS-1$
                server + ":/" + glusterModel.getGlusterVolumes().getSelectedItem().getName();
            }
        } else if (!glusterModel.getLinkGlusterVolume().getEntity()) {
            path = glusterModel.getPath().getEntity();
        }
        if (StringHelper.isNotNullOrEmpty(path)) {
            Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
            "ImportFile", host.getId(), path, glusterModel.getRole(), glusterModel.getType(), model.getActivateDomain().getEntity() }))).run();
        } else {
            return;
        }
    } else if (model.getCurrentStorageItem() instanceof PosixStorageModel) {
        PosixStorageModel posixModel = (PosixStorageModel) model.getCurrentStorageItem();
        posixModel.setMessage(null);
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), posixModel.getPath().getEntity(), posixModel.getRole(), posixModel.getType(), model.getActivateDomain().getEntity() }))).run();
    } else if (model.getCurrentStorageItem() instanceof ImportSanStorageModel) {
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportSan", host.getId(), model.getActivateDomain().getEntity() }))).run();
    }
}
#end_block

#method_before
private void saveSanStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    SanStorageModelBase sanModel = (SanStorageModelBase) model.getCurrentStorageItem();
    StorageDomain storage = getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(storage.getStorageStaticData());
    storageDomain.setStorageType(isNew ? sanModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? sanModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageFormat(isNew ? sanModel.getContainer().getFormat().getSelectedItem() : storageDomain.getStorageFormat());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    saveCommonStorageProperties(model);
    if (isNew) {
        saveNewSanStorage();
    } else {
        Frontend.getInstance().runAction(ActionType.UpdateStorageDomain, new StorageDomainManagementParameter(storageDomain), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                StorageListModel storageListModel = (StorageListModel) result.getState();
                StorageModel storageModel = (StorageModel) getWindow();
                SanStorageModelBase sanStorageModelBase = (SanStorageModelBase) storageModel.getCurrentStorageItem();
                boolean force = sanStorageModelBase.isForce();
                StorageDomain storageDomain1 = storageListModel.getSelectedItem();
                HashSet<String> lunIds = new HashSet<>();
                for (LunModel lun : sanStorageModelBase.getAddedLuns()) {
                    lunIds.add(lun.getLunId());
                }
                if (lunIds.size() > 0) {
                    Frontend.getInstance().runAction(ActionType.ExtendSANStorageDomain, new ExtendSANStorageDomainParameters(storageDomain1.getId(), new HashSet<>(lunIds), force), null, this);
                }
                Set<String> lunToRefreshIds = new HashSet<>();
                for (LunModel lun : sanStorageModelBase.getLunsToRefresh()) {
                    lunToRefreshIds.add(lun.getLunId());
                }
                if (lunToRefreshIds.size() > 0) {
                    Frontend.getInstance().runAction(ActionType.RefreshLunsSize, new ExtendSANStorageDomainParameters(storageDomain1.getId(), lunToRefreshIds, false), null, this);
                }
                if (storageDomain1.getStatus() == StorageDomainStatus.Maintenance) {
                    List<String> lunToRemoveIds = new ArrayList<>();
                    for (LunModel lun : sanStorageModelBase.getLunsToRemove()) {
                        lunToRemoveIds.add(lun.getLunId());
                    }
                    if (lunToRemoveIds.size() > 0) {
                        Frontend.getInstance().runAction(ActionType.ReduceSANStorageDomainDevices, new ReduceSANStorageDomainDevicesCommandParameters(storageDomain1.getId(), lunToRemoveIds), null, this);
                    }
                }
                storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
            }
        }, this);
    }
}
#method_after
private void saveSanStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    SanStorageModelBase sanModel = (SanStorageModelBase) model.getCurrentStorageItem();
    StorageDomain storage = getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(storage.getStorageStaticData());
    storageDomain.setStorageType(isNew ? sanModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? sanModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageFormat(isNew ? sanModel.getContainer().getFormat().getSelectedItem() : storageDomain.getStorageFormat());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    saveCommonStorageProperties(model);
    if (isNew) {
        saveNewSanStorage();
    } else {
        Frontend.getInstance().runAction(ActionType.UpdateStorageDomain, new StorageDomainManagementParameter(storageDomain), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                StorageListModel storageListModel = (StorageListModel) result.getState();
                StorageModel storageModel = (StorageModel) getWindow();
                SanStorageModelBase sanStorageModelBase = (SanStorageModelBase) storageModel.getCurrentStorageItem();
                boolean force = sanStorageModelBase.isForce();
                StorageDomain storageDomain1 = storageListModel.getSelectedItem();
                HashSet<String> lunIds = new HashSet<>();
                for (LunModel lun : sanStorageModelBase.getAddedLuns()) {
                    lunIds.add(lun.getLunId());
                }
                if (lunIds.size() > 0) {
                    Frontend.getInstance().runAction(ActionType.ExtendSANStorageDomain, new ExtendSANStorageDomainParameters(storageDomain1.getId(), new HashSet<>(lunIds), force), null, this);
                }
                Set<String> lunToRefreshIds = new HashSet<>();
                for (LunModel lun : sanStorageModelBase.getLunsToRefresh()) {
                    lunToRefreshIds.add(lun.getLunId());
                }
                if (lunToRefreshIds.size() > 0) {
                    Frontend.getInstance().runAction(ActionType.RefreshLunsSize, new ExtendSANStorageDomainParameters(storageDomain1.getId(), lunToRefreshIds, false), null, this);
                }
                if (storageDomain1.getStatus() == StorageDomainStatus.Maintenance) {
                    List<String> lunsToRemoveIds = new ArrayList<>();
                    for (LunModel lun : sanStorageModelBase.getLunsToRemove()) {
                        lunsToRemoveIds.add(lun.getLunId());
                    }
                    if (lunsToRemoveIds.size() > 0) {
                        Frontend.getInstance().runAction(ActionType.ReduceSANStorageDomainDevices, new ReduceSANStorageDomainDevicesCommandParameters(storageDomain1.getId(), lunsToRemoveIds), null, this);
                    }
                }
                storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
            }
        }, this);
    }
}
#end_block

#method_before
public List<LunModel> getLunsToRemove() {
    ArrayList<LunModel> luns = new ArrayList<>();
    if (!getIsGrouppedByTarget()) {
        List<LunModel> items = (List<LunModel>) getItems();
        for (LunModel lun : items) {
            if (lun.getIsIncluded() && lun.isRemoveLunSelected() && Linq.firstOrNull(luns, new Linq.LunPredicate(lun)) == null) {
                luns.add(lun);
            }
        }
    }
    return luns;
}
#method_after
public List<LunModel> getLunsToRemove() {
    if (getIsGrouppedByTarget()) {
        return Collections.emptyList();
    }
    return ((List<LunModel>) getItems()).stream().filter(LunModel::getIsIncluded).filter(LunModel::isRemoveLunSelected).distinct().collect(Collectors.toList());
}
#end_block

#method_before
public void attemptResolution() {
    Set<Guid> images;
    if (vmDynamicDao.get(getParameters().getVmId()).getStatus().isNotRunning()) {
        StoragePool pool = storagePoolDao.get(getParameters().getStoragePoolId());
        if (pool.getSpmVdsId() == null || pool.getStatus() != StoragePoolStatus.Up) {
            log.info("VM down, waiting on SPM election to resolve Live Merge");
            setSucceeded(true);
            return;
        } else {
            log.error("VM is not running, proceeding with Live Merge recovery");
            images = getVolumeChainFromRecovery();
        }
    } else {
        images = getVolumeChain();
    }
    if (images == null || images.isEmpty()) {
        log.error("Failed to retrieve images list of VM {}. Retrying ...", getParameters().getVmId());
        setCommandStatus(CommandStatus.SUCCEEDED);
        setSucceeded(true);
        // As this command is executed only during live merge flow, the following casting is safe.
        ((RemoveSnapshotSingleDiskParameters) getParameters().getParentParameters()).setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
        return;
    }
    Set<Guid> imagesToRemove = getImagesToRemove();
    images.retainAll(imagesToRemove);
    if (images.size() != 1) {
        log.error("Failed to live merge, still in volume chain: {}", images);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (!images.contains(getParameters().getBaseImage().getImageId())) {
        // If the base image isn't found in qemu chain, it means that the image was already deleted.
        // In this case, we will not allow PULL merge but rather ask the user to check if the parent
        // snapshot contains illegal volume(s). If so, that snapshot must be deleted before deleting
        // other snapshots
        addCustomValue("SnapshotName", snapshotDao.get(getParameters().getBaseImage().getSnapshotId()).getDescription());
        addCustomValue("BaseVolumeId", getParameters().getBaseImage().getImageId().toString());
        auditLog(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_BASE_IMAGE_NOT_FOUND);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    imagesToRemove.removeAll(images);
    log.info("Successfully removed volume(s): {}", imagesToRemove);
    // For now, only COMMIT type is supported
    log.info("Volume merge type '{}'", VmBlockJobType.COMMIT.name());
    MergeStatusReturnValue returnValue = new MergeStatusReturnValue(VmBlockJobType.COMMIT, imagesToRemove);
    getReturnValue().setActionReturnValue(returnValue);
    setSucceeded(true);
    persistCommand(getParameters().getParentCommand(), true);
    setCommandStatus(CommandStatus.SUCCEEDED);
}
#method_after
public void attemptResolution() {
    Set<Guid> images;
    if (vmDynamicDao.get(getParameters().getVmId()).getStatus() == VMStatus.Down) {
        StoragePool pool = storagePoolDao.get(getParameters().getStoragePoolId());
        if (pool.getSpmVdsId() == null || pool.getStatus() != StoragePoolStatus.Up) {
            log.info("VM down, waiting on SPM election to resolve Live Merge");
            setSucceeded(true);
            return;
        } else {
            log.error("VM is not running, proceeding with Live Merge recovery");
            images = getVolumeChainFromRecovery();
        }
    } else {
        images = getVolumeChain();
    }
    if (images == null || images.isEmpty()) {
        log.error("Failed to retrieve images list of VM {}. Retrying ...", getParameters().getVmId());
        setCommandStatus(CommandStatus.SUCCEEDED);
        setSucceeded(true);
        // As this command is executed only during live merge flow, the following casting is safe.
        ((RemoveSnapshotSingleDiskParameters) getParameters().getParentParameters()).setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
        return;
    }
    Set<Guid> imagesToRemove = getImagesToRemove();
    images.retainAll(imagesToRemove);
    if (images.size() != 1) {
        log.error("Failed to live merge, still in volume chain: {}", images);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (!images.contains(getParameters().getBaseImage().getImageId())) {
        // If the base image isn't found in qemu chain, it means that the image was already deleted.
        // In this case, we will not allow PULL merge but rather ask the user to check if the parent
        // snapshot contains illegal volume(s). If so, that snapshot must be deleted before deleting
        // other snapshots
        addCustomValue("SnapshotName", snapshotDao.get(getParameters().getBaseImage().getSnapshotId()).getDescription());
        addCustomValue("BaseVolumeId", getParameters().getBaseImage().getImageId().toString());
        auditLog(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_BASE_IMAGE_NOT_FOUND);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    imagesToRemove.removeAll(images);
    log.info("Successfully removed volume(s): {}", imagesToRemove);
    // For now, only COMMIT type is supported
    log.info("Volume merge type '{}'", VmBlockJobType.COMMIT.name());
    MergeStatusReturnValue returnValue = new MergeStatusReturnValue(VmBlockJobType.COMMIT, imagesToRemove);
    getReturnValue().setActionReturnValue(returnValue);
    setSucceeded(true);
    persistCommand(getParameters().getParentCommand(), true);
    setCommandStatus(CommandStatus.SUCCEEDED);
}
#end_block

#method_before
@Mapping(from = OpenStackNetworkProvider.class, to = Provider.class)
public static Provider<OpenstackNetworkProviderProperties> map(OpenStackNetworkProvider model, Provider<OpenstackNetworkProviderProperties> template) {
    Provider<OpenstackNetworkProviderProperties> entity = template != null ? template : new Provider<>();
    if (model.isSetType()) {
        entity.setType(mapProviderType(model.getType()));
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetUrl()) {
        entity.setUrl(model.getUrl());
    }
    if (model.isSetRequiresAuthentication()) {
        entity.setRequiringAuthentication(model.isRequiresAuthentication());
    }
    if (model.isSetUsername()) {
        entity.setUsername(model.getUsername());
    }
    if (model.isSetPassword()) {
        entity.setPassword(model.getPassword());
    }
    if (model.isSetAuthenticationUrl()) {
        entity.setAuthUrl(model.getAuthenticationUrl());
    }
    if (model.isSetProperties()) {
        Map<String, String> map = new HashMap<>();
        for (Property property : model.getProperties().getProperties()) {
            map.put(property.getName(), property.getValue());
        }
        entity.setCustomProperties(map);
    }
    OpenstackNetworkProviderProperties additionalProperties = new OpenstackNetworkProviderProperties();
    if (model.isSetTenantName()) {
        additionalProperties.setTenantName(model.getTenantName());
    }
    if (model.isSetExternalPluginType()) {
        additionalProperties.setPluginType(model.getExternalPluginType());
    } else if (model.isSetPluginType() && model.getType().value().equalsIgnoreCase(OpenStackNetworkProviderType.NEUTRON.value())) {
        additionalProperties.setPluginType(mapPluginType(model.getPluginType()));
    }
    if (model.isSetAgentConfiguration()) {
        additionalProperties.setAgentConfiguration(map(model.getAgentConfiguration(), null));
    }
    if (model.isSetReadOnly()) {
        additionalProperties.setReadOnly(model.isReadOnly());
    }
    entity.setAdditionalProperties(additionalProperties);
    return entity;
}
#method_after
@Mapping(from = OpenStackNetworkProvider.class, to = Provider.class)
public static Provider<OpenstackNetworkProviderProperties> map(OpenStackNetworkProvider model, Provider<OpenstackNetworkProviderProperties> template) {
    Provider<OpenstackNetworkProviderProperties> entity = template != null ? template : new Provider<>();
    if (model.isSetType()) {
        entity.setType(mapProviderType(model.getType()));
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetUrl()) {
        entity.setUrl(model.getUrl());
    }
    if (model.isSetRequiresAuthentication()) {
        entity.setRequiringAuthentication(model.isRequiresAuthentication());
    }
    if (model.isSetUsername()) {
        entity.setUsername(model.getUsername());
    }
    if (model.isSetPassword()) {
        entity.setPassword(model.getPassword());
    }
    if (model.isSetAuthenticationUrl()) {
        entity.setAuthUrl(model.getAuthenticationUrl());
    }
    if (model.isSetProperties()) {
        Map<String, String> map = new HashMap<>();
        for (Property property : model.getProperties().getProperties()) {
            map.put(property.getName(), property.getValue());
        }
        entity.setCustomProperties(map);
    }
    OpenstackNetworkProviderProperties additionalProperties = new OpenstackNetworkProviderProperties();
    if (model.isSetTenantName()) {
        additionalProperties.setTenantName(model.getTenantName());
    }
    // for backwards compatibility, and should be removed in version 5 of the API.
    if (model.isSetPluginType() && model.getType() == OpenStackNetworkProviderType.NEUTRON) {
        additionalProperties.setPluginType(mapPluginType(model.getPluginType()));
    }
    if (model.isSetExternalPluginType()) {
        additionalProperties.setPluginType(model.getExternalPluginType());
    }
    if (model.isSetAgentConfiguration()) {
        additionalProperties.setAgentConfiguration(map(model.getAgentConfiguration(), null));
    }
    if (model.isSetReadOnly()) {
        additionalProperties.setReadOnly(model.isReadOnly());
    }
    entity.setAdditionalProperties(additionalProperties);
    return entity;
}
#end_block

#method_before
@Mapping(from = Provider.class, to = OpenStackNetworkProvider.class)
public static OpenStackNetworkProvider map(Provider<OpenstackNetworkProviderProperties> entity, OpenStackNetworkProvider template) {
    OpenStackNetworkProvider model = template != null ? template : new OpenStackNetworkProvider();
    model.setType(mapProviderType(entity.getType()));
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getName() != null) {
        model.setName(entity.getName());
    }
    if (entity.getDescription() != null) {
        model.setDescription(entity.getDescription());
    }
    if (entity.getUrl() != null) {
        model.setUrl(entity.getUrl());
    }
    if (entity.getAuthUrl() != null) {
        model.setAuthenticationUrl(entity.getAuthUrl());
    }
    model.setRequiresAuthentication(entity.isRequiringAuthentication());
    if (entity.getUsername() != null) {
        model.setUsername(entity.getUsername());
    }
    // The password isn't mapped for security reasons.
    // if (entity.getPassword() != null) {
    // model.setPassword(entity.getPassword());
    // }
    Map<String, String> customProperties = entity.getCustomProperties();
    if (customProperties != null) {
        Properties properties = new Properties();
        for (Map.Entry<String, String> entry : customProperties.entrySet()) {
            Property property = new Property();
            property.setName(entry.getKey());
            property.setValue(entry.getValue());
            properties.getProperties().add(property);
        }
        model.setProperties(properties);
    }
    OpenstackNetworkProviderProperties additionalProperties = entity.getAdditionalProperties();
    if (additionalProperties != null) {
        if (additionalProperties.getTenantName() != null) {
            model.setTenantName(additionalProperties.getTenantName());
        }
        String pluginType = additionalProperties.getPluginType();
        if (pluginType != null) {
            if (entity.getType() == ProviderType.OPENSTACK_NETWORK && OpenstackNetworkPluginType.OPEN_VSWITCH.name().equalsIgnoreCase(pluginType)) {
                model.setPluginType(NetworkPluginType.OPEN_VSWITCH);
            }
            model.setExternalPluginType(additionalProperties.getPluginType());
        }
        if (additionalProperties.getAgentConfiguration() != null) {
            model.setAgentConfiguration(map(additionalProperties.getAgentConfiguration(), null));
        }
    }
    return model;
}
#method_after
@Mapping(from = Provider.class, to = OpenStackNetworkProvider.class)
public static OpenStackNetworkProvider map(Provider<OpenstackNetworkProviderProperties> entity, OpenStackNetworkProvider template) {
    OpenStackNetworkProvider model = template != null ? template : new OpenStackNetworkProvider();
    model.setType(mapProviderType(entity.getType()));
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getName() != null) {
        model.setName(entity.getName());
    }
    if (entity.getDescription() != null) {
        model.setDescription(entity.getDescription());
    }
    if (entity.getUrl() != null) {
        model.setUrl(entity.getUrl());
    }
    if (entity.getAuthUrl() != null) {
        model.setAuthenticationUrl(entity.getAuthUrl());
    }
    model.setRequiresAuthentication(entity.isRequiringAuthentication());
    if (entity.getUsername() != null) {
        model.setUsername(entity.getUsername());
    }
    // The password isn't mapped for security reasons.
    // if (entity.getPassword() != null) {
    // model.setPassword(entity.getPassword());
    // }
    Map<String, String> customProperties = entity.getCustomProperties();
    if (customProperties != null) {
        Properties properties = new Properties();
        for (Map.Entry<String, String> entry : customProperties.entrySet()) {
            Property property = new Property();
            property.setName(entry.getKey());
            property.setValue(entry.getValue());
            properties.getProperties().add(property);
        }
        model.setProperties(properties);
    }
    OpenstackNetworkProviderProperties additionalProperties = entity.getAdditionalProperties();
    if (additionalProperties != null) {
        if (additionalProperties.getTenantName() != null) {
            model.setTenantName(additionalProperties.getTenantName());
        }
        String pluginType = additionalProperties.getPluginType();
        if (pluginType != null) {
            // for backwards compatibility, and should be removed in version 5 of the API.
            if (entity.getType() == ProviderType.OPENSTACK_NETWORK && OpenstackNetworkPluginType.OPEN_VSWITCH.name().equalsIgnoreCase(pluginType)) {
                model.setPluginType(NetworkPluginType.OPEN_VSWITCH);
            }
            model.setExternalPluginType(additionalProperties.getPluginType());
        }
        if (additionalProperties.getAgentConfiguration() != null) {
            model.setAgentConfiguration(map(additionalProperties.getAgentConfiguration(), null));
        }
    }
    return model;
}
#end_block

#method_before
private static String mapPluginType(NetworkPluginType pluginType) {
    if (pluginType == NetworkPluginType.OPEN_VSWITCH) {
        return OpenstackNetworkPluginType.OPEN_VSWITCH.name();
    }
    throw new IllegalArgumentException("Unknown neutron network plugin type \"" + pluginType + "\"");
}
#method_after
private static String mapPluginType(NetworkPluginType pluginType) {
    if (pluginType == NetworkPluginType.OPEN_VSWITCH) {
        return OpenstackNetworkPluginType.OPEN_VSWITCH.name();
    }
    throw new IllegalArgumentException("Unknown Neutron network plugin type \"" + pluginType + "\"");
}
#end_block

#method_before
protected SsoSession buildSsoSession(HttpServletRequest request) throws Exception {
    String clientId = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_CLIENT_ID);
    String scope = SsoUtils.getScopeRequestParameter(request, "");
    String state = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_STATE, "");
    String appUrl = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_APP_URL, "");
    String engineUrl = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_ENGINE_URL, "");
    String redirectUri = request.getParameter(SsoConstants.HTTP_PARAM_REDIRECT_URI);
    String clientIp = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_CLIENT_IP, "UNKNOWN");
    validateClientRequest(request, clientId, scope, redirectUri);
    // Create the session
    request.getSession(true);
    SsoSession ssoSession = SsoUtils.getSsoSession(request);
    ssoSession.setAppUrl(appUrl);
    ssoSession.setClientId(clientId);
    ssoSession.setClientIp(clientIp);
    ssoSession.setRedirectUri(redirectUri);
    ssoSession.setScope(scope);
    ssoSession.setState(state);
    ssoSession.getHttpSession().setMaxInactiveInterval(-1);
    if (StringUtils.isNotEmpty(engineUrl)) {
        ssoSession.setEngineUrl(engineUrl);
    } else {
        ssoSession.setEngineUrl(SsoUtils.getSsoContext(request).getEngineUrl());
    }
    return ssoSession;
}
#method_after
protected SsoSession buildSsoSession(HttpServletRequest request) throws Exception {
    String clientId = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_CLIENT_ID);
    String scope = SsoUtils.getScopeRequestParameter(request, "");
    String state = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_STATE, "");
    String appUrl = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_APP_URL, "");
    String engineUrl = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_ENGINE_URL, "");
    String redirectUri = request.getParameter(SsoConstants.HTTP_PARAM_REDIRECT_URI);
    String sourceAddr = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_SOURCE_ADDR, "UNKNOWN");
    validateClientRequest(request, clientId, scope, redirectUri);
    // Create the session
    request.getSession(true);
    SsoSession ssoSession = SsoUtils.getSsoSession(request);
    ssoSession.setAppUrl(appUrl);
    ssoSession.setClientId(clientId);
    ssoSession.setSourceAddr(sourceAddr);
    ssoSession.setRedirectUri(redirectUri);
    ssoSession.setScope(scope);
    ssoSession.setState(state);
    ssoSession.getHttpSession().setMaxInactiveInterval(-1);
    if (StringUtils.isNotEmpty(engineUrl)) {
        ssoSession.setEngineUrl(engineUrl);
    } else {
        ssoSession.setEngineUrl(SsoUtils.getSsoContext(request).getEngineUrl());
    }
    return ssoSession;
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered InteractiveAuthServlet");
    try {
        String redirectUrl;
        SsoSession ssoSession = SsoUtils.getSsoSession(request);
        // clean up the sso session id token
        ssoContext.removeSsoSessionById(ssoSession);
        if (StringUtils.isEmpty(ssoSession.getClientId())) {
            redirectUrl = ssoContext.getEngineUrl();
        } else {
            Credentials userCredentials = getUserCredentials(request);
            try {
                if (SsoUtils.isUserAuthenticated(request)) {
                    log.debug("User is authenticated redirecting to {}", SsoConstants.INTERACTIVE_REDIRECT_TO_MODULE_URI);
                    redirectUrl = request.getContextPath() + SsoConstants.INTERACTIVE_REDIRECT_TO_MODULE_URI;
                } else {
                    redirectUrl = authenticateUser(request, response, userCredentials);
                }
            } catch (AuthenticationException ex) {
                if (userCredentials != null) {
                    String profile = userCredentials.getProfile() == null ? "N/A" : userCredentials.getProfile();
                    log.error("Cannot authenticate user '{}@{}' connecting from '{}': {}", userCredentials.getUsername(), profile, ssoSession.getClientIp(), ex.getMessage());
                    log.debug("Exception", ex);
                    SsoUtils.getSsoSession(request).setLoginMessage(ex.getMessage());
                }
                log.debug("Redirecting to LoginPage");
                ssoSession.setReauthenticate(false);
                ssoContext.registerSsoSessionById(SsoUtils.generateIdToken(), ssoSession);
                if (StringUtils.isNotEmpty(ssoContext.getSsoDefaultProfile()) && Arrays.stream(request.getCookies()).noneMatch(c -> c.getName().equals("profile"))) {
                    Cookie cookie = new Cookie("profile", ssoContext.getSsoDefaultProfile());
                    cookie.setSecure(true);
                    response.addCookie(cookie);
                }
                redirectUrl = request.getContextPath() + SsoConstants.INTERACTIVE_LOGIN_FORM_URI;
            }
        }
        if (redirectUrl != null) {
            response.sendRedirect(redirectUrl);
        }
    } catch (Exception ex) {
        SsoUtils.redirectToErrorPage(request, response, ex);
    }
}
#method_after
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered InteractiveAuthServlet");
    try {
        String redirectUrl;
        SsoSession ssoSession = SsoUtils.getSsoSession(request);
        // clean up the sso session id token
        ssoContext.removeSsoSessionById(ssoSession);
        if (StringUtils.isEmpty(ssoSession.getClientId())) {
            redirectUrl = ssoContext.getEngineUrl();
        } else {
            Credentials userCredentials = getUserCredentials(request);
            try {
                if (SsoUtils.isUserAuthenticated(request)) {
                    log.debug("User is authenticated redirecting to {}", SsoConstants.INTERACTIVE_REDIRECT_TO_MODULE_URI);
                    redirectUrl = request.getContextPath() + SsoConstants.INTERACTIVE_REDIRECT_TO_MODULE_URI;
                } else {
                    redirectUrl = authenticateUser(request, response, userCredentials);
                }
            } catch (AuthenticationException ex) {
                if (userCredentials != null) {
                    String profile = userCredentials.getProfile() == null ? "N/A" : userCredentials.getProfile();
                    log.error("Cannot authenticate user '{}@{}' connecting from '{}': {}", userCredentials.getUsername(), profile, ssoSession.getSourceAddr(), ex.getMessage());
                    log.debug("Exception", ex);
                    SsoUtils.getSsoSession(request).setLoginMessage(ex.getMessage());
                }
                log.debug("Redirecting to LoginPage");
                ssoSession.setReauthenticate(false);
                ssoContext.registerSsoSessionById(SsoUtils.generateIdToken(), ssoSession);
                if (StringUtils.isNotEmpty(ssoContext.getSsoDefaultProfile()) && Arrays.stream(request.getCookies()).noneMatch(c -> c.getName().equals("profile"))) {
                    Cookie cookie = new Cookie("profile", ssoContext.getSsoDefaultProfile());
                    cookie.setSecure(true);
                    response.addCookie(cookie);
                }
                redirectUrl = request.getContextPath() + SsoConstants.INTERACTIVE_LOGIN_FORM_URI;
            }
        }
        if (redirectUrl != null) {
            response.sendRedirect(redirectUrl);
        }
    } catch (Exception ex) {
        SsoUtils.redirectToErrorPage(request, response, ex);
    }
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered SsoLoginServlet");
    String scope = String.format("ovirt-app-admin ovirt-app-portal ovirt-ext=auth:sequence-priority=%s", EngineLocalConfig.getInstance().getProperty(authSequencePriorityPropertyName));
    String redirectUri = String.format("%s://%s:%s%s", request.getScheme(), FiltersHelper.getRedirectUriServerName(request.getServerName()), request.getServerPort(), postActionUrl);
    URLBuilder urlBuilder = new URLBuilder(FiltersHelper.getEngineSsoUrl(request), "/oauth/authorize").addParameter("client_id", EngineLocalConfig.getInstance().getProperty("ENGINE_SSO_CLIENT_ID")).addParameter("response_type", "code").addParameter("app_url", request.getParameter("app_url")).addParameter("engine_url", FiltersHelper.getEngineUrl(request)).addParameter("redirect_uri", redirectUri).addParameter("scope", scope).addParameter("client_ip", request.getRemoteAddr());
    if (StringUtils.isNotEmpty(request.getParameter("sso_token"))) {
        urlBuilder.addParameter("sso_token", request.getParameter("sso_token"));
    }
    String url = urlBuilder.build();
    log.debug("Redirecting to '{}'", url);
    response.sendRedirect(url);
}
#method_after
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered SsoLoginServlet");
    String scope = String.format("ovirt-app-admin ovirt-app-portal ovirt-ext=auth:sequence-priority=%s", EngineLocalConfig.getInstance().getProperty(authSequencePriorityPropertyName));
    String redirectUri = String.format("%s://%s:%s%s", request.getScheme(), FiltersHelper.getRedirectUriServerName(request.getServerName()), request.getServerPort(), postActionUrl);
    URLBuilder urlBuilder = new URLBuilder(FiltersHelper.getEngineSsoUrl(request), "/oauth/authorize").addParameter("client_id", EngineLocalConfig.getInstance().getProperty("ENGINE_SSO_CLIENT_ID")).addParameter("response_type", "code").addParameter("app_url", request.getParameter("app_url")).addParameter("engine_url", FiltersHelper.getEngineUrl(request)).addParameter("redirect_uri", redirectUri).addParameter("scope", scope).addParameter("source_addr", request.getRemoteAddr());
    if (StringUtils.isNotEmpty(request.getParameter("sso_token"))) {
        urlBuilder.addParameter("sso_token", request.getParameter("sso_token"));
    }
    String url = urlBuilder.build();
    log.debug("Redirecting to '{}'", url);
    response.sendRedirect(url);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        vmHandler.setVmDestroyOnReboot(getVm());
    } else if (!updateVmLease()) {
        return;
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new TransactionCompletionListener() {

            @Override
            public void onSuccess() {
                ovfDataUpdater.triggerNow();
            }

            @Override
            public void onRollback() {
            // No notification is needed
            }
        });
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), getParameters().isHotUnplugMemory())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    iconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        vmHandler.setVmDestroyOnReboot(getVm());
    } else if (!updateVmLease()) {
        return;
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new TransactionCompletionListener() {

            @Override
            public void onSuccess() {
                ovfDataUpdater.triggerNow();
            }

            @Override
            public void onRollback() {
            // No notification is needed
            }
        });
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), getParameters().isMemoryHotUnplugEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    iconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#end_block

#method_before
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        ActionReturnValue setNumberOfCpusResult = runInternalAction(ActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        // into the OVF store and automatically used during the next HE VM start
        if (!getVm().isHostedEngine()) {
            newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        }
        logHotSetActionEvent(setNumberOfCpusResult, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#method_after
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotpluggedOrUnplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        ActionReturnValue setNumberOfCpusResult = runInternalAction(ActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        // into the OVF store and automatically used during the next HE VM start
        if (!getVm().isHostedEngine()) {
            newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        }
        logHotSetActionEvent(setNumberOfCpusResult, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#end_block

#method_before
private void hotUnplugMemory(VM newVm) {
    if (!getParameters().isHotUnplugMemory()) {
        return;
    }
    final List<VmDevice> vmMemoryDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(getVmId(), VmDeviceGeneralType.MEMORY, VmDeviceType.MEMORY);
    final int oldMemoryMb = oldVm.getMemSizeMb();
    final int oldMinMemoryMb = oldVm.getMinAllocatedMem();
    final List<VmDevice> memoryDevicesToUnplug = MemoryUtils.computeMemoryDevicesToHotUnplug(vmMemoryDevices, oldMemoryMb, getParameters().getVm().getMemSizeMb());
    if (memoryDevicesToUnplug.isEmpty()) {
        logNoDeviceToHotUnplug(vmMemoryDevices);
        // in vm_static table.
        if (!oldVm.isHostedEngine()) {
            newVmStatic.setMemSizeMb(oldMemoryMb);
            newVmStatic.setMinAllocatedMem(oldMinMemoryMb);
        }
        return;
    }
    final int totalHotUnpluggedMemoryMb = memoryDevicesToUnplug.stream().mapToInt(deviceToHotUnplug -> {
        final ActionReturnValue hotUnplugReturnValue = runInternalAction(ActionType.HotUnplugMemoryWithoutVmUpdate, new HotUnplugMemoryWithoutVmUpdateParameters(deviceToHotUnplug.getId(), newVm.getMinAllocatedMem()), cloneContextAndDetachFromParent());
        return hotUnplugReturnValue.getSucceeded() ? VmDeviceCommonUtils.getSizeOfMemoryDeviceMb(deviceToHotUnplug).get() : 0;
    }).sum();
    // in vm_static table.
    if (!oldVm.isHostedEngine()) {
        newVmStatic.setMemSizeMb(oldMemoryMb - totalHotUnpluggedMemoryMb);
        newVmStatic.setMinAllocatedMem(// at least one hot unplug succeeded
        totalHotUnpluggedMemoryMb > 0 ? newVm.getMinAllocatedMem() : oldMinMemoryMb);
    }
}
#method_after
private void hotUnplugMemory(VM newVm) {
    if (!getParameters().isMemoryHotUnplugEnabled()) {
        return;
    }
    final List<VmDevice> vmMemoryDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(getVmId(), VmDeviceGeneralType.MEMORY, VmDeviceType.MEMORY);
    final int oldMemoryMb = oldVm.getMemSizeMb();
    final int oldMinMemoryMb = oldVm.getMinAllocatedMem();
    final List<VmDevice> memoryDevicesToUnplug = MemoryUtils.computeMemoryDevicesToHotUnplug(vmMemoryDevices, oldMemoryMb, getParameters().getVm().getMemSizeMb());
    if (memoryDevicesToUnplug.isEmpty()) {
        logNoDeviceToHotUnplug(vmMemoryDevices);
        // in vm_static table.
        if (!oldVm.isHostedEngine()) {
            newVmStatic.setMemSizeMb(oldMemoryMb);
            newVmStatic.setMinAllocatedMem(oldMinMemoryMb);
        }
        return;
    }
    final int totalHotUnpluggedMemoryMb = memoryDevicesToUnplug.stream().mapToInt(deviceToHotUnplug -> {
        final ActionReturnValue hotUnplugReturnValue = runInternalAction(ActionType.HotUnplugMemoryWithoutVmUpdate, new HotUnplugMemoryWithoutVmUpdateParameters(deviceToHotUnplug.getId(), newVm.getMinAllocatedMem()), cloneContextAndDetachFromParent());
        return hotUnplugReturnValue.getSucceeded() ? VmDeviceCommonUtils.getSizeOfMemoryDeviceMb(deviceToHotUnplug).get() : 0;
    }).sum();
    // in vm_static table.
    if (!oldVm.isHostedEngine()) {
        newVmStatic.setMemSizeMb(oldMemoryMb - totalHotUnpluggedMemoryMb);
        newVmStatic.setMinAllocatedMem(// at least one hot unplug succeeded
        totalHotUnpluggedMemoryMb > 0 ? newVm.getMinAllocatedMem() : oldMinMemoryMb);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isHotUnplugMemory();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isMemoryHotUnplugEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    return true;
}
#end_block

#method_before
private boolean memoryNextRunSnapshotRequired() {
    final VM vmFromDb = getVm();
    final VM vmFromParams = getParameters().getVm();
    return VMStatus.Down != getVm().getStatus() && vmFromDb.getMemSizeMb() != vmFromParams.getMemSizeMb();
}
#method_after
private boolean memoryNextRunSnapshotRequired() {
    final VM oldVm = getVm();
    return VMStatus.Down != getVm().getStatus() && oldVm.getMemSizeMb() != getParameters().getVm().getMemSizeMb();
}
#end_block

#method_before
@Override
public ActionParametersBase getParameters(Vm incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy()));
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    params.setApplyChangesLater(isNextRunRequested());
    params.setHotUnplugMemory(!isNextRunRequested());
    if (incoming.isSetPayloads()) {
        if (incoming.isSetPayloads() && incoming.getPayloads().isSetPayloads()) {
            params.setVmPayload(parent.getPayload(incoming));
        } else {
            params.setClearPayload(true);
        }
    }
    if (incoming.isSetMemoryPolicy() && incoming.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(incoming.getMemoryPolicy().isBallooning());
    }
    if (incoming.isSetConsole() && incoming.getConsole().isSetEnabled()) {
        params.setConsoleEnabled(incoming.getConsole().isEnabled());
    }
    if (incoming.isSetVirtioScsi()) {
        if (incoming.getVirtioScsi().isSetEnabled()) {
            params.setVirtioScsiEnabled(incoming.getVirtioScsi().isEnabled());
        }
    }
    if (incoming.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(incoming.isSoundcardEnabled());
    }
    if (incoming.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    DisplayHelper.setGraphicsToParams(incoming.getDisplay(), params);
    if (incoming.isSetInstanceType() && (incoming.getInstanceType().isSetId() || incoming.getInstanceType().isSetName())) {
        updated.setInstanceTypeId(lookupInstanceTypeId(incoming.getInstanceType()));
    } else if (incoming.isSetInstanceType()) {
        // this means that the instance type should be unset
        updated.setInstanceTypeId(null);
    }
    IconHelper.setIconToParams(incoming, params);
    return params;
}
#method_after
@Override
public ActionParametersBase getParameters(Vm incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy()));
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    params.setApplyChangesLater(isNextRunRequested());
    params.setMemoryHotUnplugEnabled(true);
    if (incoming.isSetPayloads()) {
        if (incoming.isSetPayloads() && incoming.getPayloads().isSetPayloads()) {
            params.setVmPayload(parent.getPayload(incoming));
        } else {
            params.setClearPayload(true);
        }
    }
    if (incoming.isSetMemoryPolicy() && incoming.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(incoming.getMemoryPolicy().isBallooning());
    }
    if (incoming.isSetConsole() && incoming.getConsole().isSetEnabled()) {
        params.setConsoleEnabled(incoming.getConsole().isEnabled());
    }
    if (incoming.isSetVirtioScsi()) {
        if (incoming.getVirtioScsi().isSetEnabled()) {
            params.setVirtioScsiEnabled(incoming.getVirtioScsi().isEnabled());
        }
    }
    if (incoming.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(incoming.isSoundcardEnabled());
    }
    if (incoming.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(incoming.getRngDevice(), null));
    }
    DisplayHelper.setGraphicsToParams(incoming.getDisplay(), params);
    if (incoming.isSetInstanceType() && (incoming.getInstanceType().isSetId() || incoming.getInstanceType().isSetName())) {
        updated.setInstanceTypeId(lookupInstanceTypeId(incoming.getInstanceType()));
    } else if (incoming.isSetInstanceType()) {
        // this means that the instance type should be unset
        updated.setInstanceTypeId(null);
    }
    IconHelper.setIconToParams(incoming, params);
    return params;
}
#end_block

#method_before
void localize() {
    applicationTitle.setText(dynamicMessages.applicationTitle());
    copyrightNotice.setText(dynamicMessages.copyRightNotice());
    versionLabel.setText(constants.versionAboutLabel());
    userNameLabel.setText(constants.userNameAboutLabel());
}
#method_after
void localize() {
    applicationTitle.setText(dynamicMessages.applicationTitle());
    copyrightNotice.setText(dynamicMessages.copyRightNotice());
}
#end_block

#method_before
public String getIoThreadsAndEmulatorPinningCpus(VM vm, Map<String, Object> cpuPinning, MemoizingSupplier<List<VdsNumaNode>> hostNumaNodesSupplier, int vdsCpuThreads) {
    if (vm.getVmType() != VmType.HighPerformance) {
        return null;
    }
    List<VmNumaNode> vmNumaNodes = vmNumaNodeDao.getAllVmNumaNodeByVmId(vm.getId());
    Optional<VmNumaNode> pinnedVmNumaNode = vmNumaNodes.stream().filter(d -> !d.getVdsNumaNodeList().isEmpty()).findAny();
    if (MapUtils.isEmpty(cpuPinning) || !pinnedVmNumaNode.isPresent() || vm.getNumOfIoThreads() == 0) {
        String msgReason1 = MapUtils.isEmpty(cpuPinning) ? "CPU Pinning topology is not set" : "";
        String msgReason2 = vm.getNumOfIoThreads() == 0 ? "IO Threads is not enabled" : "";
        String msgReason3 = !pinnedVmNumaNode.isPresent() ? "vm's virtual NUMA nodes are not pinned to host's NUMA nodes" : "";
        String finalMsgReason = Arrays.asList(msgReason1, msgReason2, msgReason3).stream().filter(r -> !r.isEmpty()).collect(Collectors.joining(", ")) + ".";
        log.warn("No IO thread(s) pinning and Emulator thread(s) pinning for High Performance VM {} {} due to wrong configuration: {}", vm.getName(), vm.getId(), finalMsgReason);
        return null;
    }
    return findCpusToPinIoAndEmulator(vm, cpuPinning, hostNumaNodesSupplier, vdsCpuThreads);
}
#method_after
public String getIoThreadsAndEmulatorPinningCpus(VM vm, Map<String, Object> cpuPinning, MemoizingSupplier<List<VdsNumaNode>> hostNumaNodesSupplier, int vdsCpuThreads) {
    if (vm.getVmType() != VmType.HighPerformance) {
        return null;
    }
    List<VmNumaNode> vmNumaNodes = vmNumaNodeDao.getAllVmNumaNodeByVmId(vm.getId());
    Optional<VmNumaNode> pinnedVmNumaNode = vmNumaNodes.stream().filter(d -> !d.getVdsNumaNodeList().isEmpty()).findAny();
    if (MapUtils.isEmpty(cpuPinning) || !pinnedVmNumaNode.isPresent() || vm.getNumOfIoThreads() == 0) {
        String msgReason1 = MapUtils.isEmpty(cpuPinning) ? "CPU Pinning topology is not set" : null;
        String msgReason2 = vm.getNumOfIoThreads() == 0 ? "IO Threads is not enabled" : null;
        String msgReason3 = !pinnedVmNumaNode.isPresent() ? "vm's virtual NUMA nodes are not pinned to host's NUMA nodes" : null;
        String finalMsgReason = Arrays.asList(msgReason1, msgReason2, msgReason3).stream().filter(Objects::nonNull).collect(Collectors.joining(", ")) + ".";
        log.warn("No IO thread(s) pinning and Emulator thread(s) pinning for High Performance VM {} {} due to wrong configuration: {}", vm.getName(), vm.getId(), finalMsgReason);
        return null;
    }
    return findCpusToPinIoAndEmulator(vm, cpuPinning, hostNumaNodesSupplier, vdsCpuThreads);
}
#end_block

#method_before
private String findCpusToPinIoAndEmulator(VM vm, Map<String, Object> cpuPinning, MemoizingSupplier<List<VdsNumaNode>> hostNumaNodesSupplier, int vdsCpuThreads) {
    List<VdsNumaNode> vdsNumaNodes = hostNumaNodesSupplier.get();
    Set<Integer> vdsPinnedCpus = getAllPinnedPCpus(cpuPinning);
    VdsNumaNode mostPinnedPnumaNode = vdsNumaNodes.isEmpty() ? null : vdsNumaNodes.get(0);
    int maxNumOfPinnedCpusForNode = 0;
    // Go over all Host's NUMA nodes and find the node with most pinned CPU's in order to pin the
    // IO threads and emulator threads to
    Collections.reverse(vdsNumaNodes);
    for (VdsNumaNode pNode : vdsNumaNodes) {
        if (pNode.getCpuIds().isEmpty()) {
            continue;
        }
        int numOfPinnedCpus = CollectionUtils.intersection(pNode.getCpuIds(), vdsPinnedCpus).size();
        if (maxNumOfPinnedCpusForNode < numOfPinnedCpus) {
            maxNumOfPinnedCpusForNode = numOfPinnedCpus;
            mostPinnedPnumaNode = pNode;
        }
    }
    // Prepare the list of one or two CPUs to pin Io and emulator threads to
    List<Integer> retCpusList = new LinkedList<>();
    if (mostPinnedPnumaNode == null || mostPinnedPnumaNode.getCpuIds().isEmpty()) {
        // in case no NUMA node found or no CPU's for the NUMA node,
        // set pinned CPU's to be {0,1} or just {0) (depends on the number of CPUs in host)
        retCpusList.add(0);
        if (vdsCpuThreads > 1) {
            retCpusList.add(1);
        }
    } else {
        retCpusList.add(mostPinnedPnumaNode.getCpuIds().get(0));
        if (mostPinnedPnumaNode.getCpuIds().size() > 1) {
            retCpusList.add(mostPinnedPnumaNode.getCpuIds().get(1));
        }
    }
    String overridenPinCpus = getOverriddenPinnedCpusList(vdsPinnedCpus, retCpusList);
    if (!overridenPinCpus.isEmpty()) {
        log.warn("IO thread(s), Emulator thread(s) and few CPU thread(s) are pinned to the same physical CPU(s): [{}], for High Performance " + "VM {} {}. Please consider changing the CPU pinning topology to avoid that overlapping.", overridenPinCpus, vm.getName(), vm.getId());
    }
    return retCpusList.size() == 2 ? retCpusList.get(0) + "," + retCpusList.get(1) : retCpusList.get(0).toString();
}
#method_after
private String findCpusToPinIoAndEmulator(VM vm, Map<String, Object> cpuPinning, MemoizingSupplier<List<VdsNumaNode>> hostNumaNodesSupplier, int vdsCpuThreads) {
    List<VdsNumaNode> vdsNumaNodes = hostNumaNodesSupplier.get();
    Set<Integer> vdsPinnedCpus = getAllPinnedPCpus(cpuPinning);
    VdsNumaNode mostPinnedPnumaNode = vdsNumaNodes.isEmpty() ? null : vdsNumaNodes.get(0);
    int maxNumOfPinnedCpusForNode = 0;
    // IO threads and emulator threads to
    for (VdsNumaNode pNode : vdsNumaNodes) {
        if (pNode.getCpuIds().isEmpty()) {
            continue;
        }
        int numOfPinnedCpus = CollectionUtils.intersection(pNode.getCpuIds(), vdsPinnedCpus).size();
        if (maxNumOfPinnedCpusForNode < numOfPinnedCpus) {
            maxNumOfPinnedCpusForNode = numOfPinnedCpus;
            mostPinnedPnumaNode = pNode;
        } else if (maxNumOfPinnedCpusForNode == numOfPinnedCpus && !mostPinnedPnumaNode.getCpuIds().isEmpty()) {
            // choose the NUMA node with lower CPU ids
            mostPinnedPnumaNode = getNumaNodeWithLowerCpuIds(mostPinnedPnumaNode, pNode);
        }
    }
    // Prepare the list of one or two CPUs to pin Io and emulator threads to
    List<Integer> retCpusList = new LinkedList<>();
    if (mostPinnedPnumaNode == null || mostPinnedPnumaNode.getCpuIds().isEmpty()) {
        // in case no NUMA node found or no CPU's for the NUMA node,
        // set pinned CPU's to be {0,1} or just {0) (depends on the number of CPUs in host)
        retCpusList.add(0);
        if (vdsCpuThreads > 1) {
            retCpusList.add(1);
        }
    } else {
        retCpusList.add(mostPinnedPnumaNode.getCpuIds().get(0));
        if (mostPinnedPnumaNode.getCpuIds().size() > 1) {
            retCpusList.add(mostPinnedPnumaNode.getCpuIds().get(1));
        }
    }
    String overridenPinCpus = getOverriddenPinnedCpusList(vdsPinnedCpus, retCpusList);
    if (!overridenPinCpus.isEmpty()) {
        log.warn("IO thread(s), Emulator thread(s) and few CPU thread(s) are pinned to the same physical CPU(s): [{}], for High Performance " + "VM {} {}. Please consider changing the CPU pinning topology to avoid that overlapping.", overridenPinCpus, vm.getName(), vm.getId());
    }
    return retCpusList.size() == 2 ? retCpusList.get(0) + "," + retCpusList.get(1) : retCpusList.get(0).toString();
}
#end_block

#method_before
@SuppressWarnings("incomplete-switch")
private void writeCpu() {
    writer.writeStartElement("cpu");
    String cpuType = createInfo.get(VdsProperties.cpuType).toString();
    switch(vm.getClusterArch().getFamily()) {
        case x86:
            writer.writeAttributeString("match", "exact");
            // is this a list of strings??..
            switch(cpuType) {
                case "hostPassthrough":
                    writer.writeAttributeString("mode", "host-passthrough");
                    break;
                case "hostModel":
                    writer.writeAttributeString("mode", "host-model");
                    break;
                default:
                    writer.writeStartElement("model");
                    writer.writeRaw(cpuType);
                    // TODO: features
                    writer.writeEndElement();
                    break;
            }
            break;
        case ppc:
            writer.writeStartElement("model");
            writer.writeRaw(cpuType);
            writer.writeEndElement();
    }
    if ((boolean) Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        writer.writeStartElement("topology");
        writer.writeAttributeString("cores", Integer.toString(vm.getCpuPerSocket()));
        writer.writeAttributeString("threads", Integer.toString(vm.getThreadsPerCpu()));
        int vcpus = FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch()) ? VmCpuCountHelper.calcMaxVCpu(vm, vm.getClusterCompatibilityVersion()) : vm.getNumOfCpus();
        writer.writeAttributeString("sockets", String.valueOf(vcpus / vm.getCpuPerSocket() / vm.getThreadsPerCpu()));
        writer.writeEndElement();
    }
    if (createInfo.containsKey(VdsProperties.VM_NUMA_NODES)) {
        writer.writeStartElement("numa");
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> createVmNumaNodes = (List<Map<String, Object>>) createInfo.get(VdsProperties.VM_NUMA_NODES);
        for (Map<String, Object> vmNumaNode : createVmNumaNodes) {
            writer.writeStartElement("cell");
            writer.writeAttributeString("cpus", vmNumaNode.get(VdsProperties.NUMA_NODE_CPU_LIST).toString());
            writer.writeAttributeString("memory", String.valueOf(Integer.parseInt((String) vmNumaNode.get(VdsProperties.VM_NUMA_NODE_MEM)) * 1024));
            writer.writeEndElement();
        }
        writer.writeEndElement();
    }
    if (vm.getVmType() == VmType.HighPerformance) {
        writer.writeStartElement("cache");
        writer.writeAttributeString("level", "3");
        writer.writeAttributeString("mode", "emulate");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
@SuppressWarnings("incomplete-switch")
private void writeCpu() {
    writer.writeStartElement("cpu");
    String cpuType = createInfo.get(VdsProperties.cpuType).toString();
    switch(vm.getClusterArch().getFamily()) {
        case x86:
            writer.writeAttributeString("match", "exact");
            // is this a list of strings??..
            switch(cpuType) {
                case "hostPassthrough":
                    writer.writeAttributeString("mode", "host-passthrough");
                    break;
                case "hostModel":
                    writer.writeAttributeString("mode", "host-model");
                    break;
                default:
                    writer.writeStartElement("model");
                    writer.writeRaw(cpuType);
                    // TODO: features
                    writer.writeEndElement();
                    break;
            }
            break;
        case ppc:
            writer.writeStartElement("model");
            writer.writeRaw(cpuType);
            writer.writeEndElement();
    }
    if ((boolean) Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        writer.writeStartElement("topology");
        writer.writeAttributeString("cores", Integer.toString(vm.getCpuPerSocket()));
        writer.writeAttributeString("threads", Integer.toString(vm.getThreadsPerCpu()));
        int vcpus = FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch()) ? VmCpuCountHelper.calcMaxVCpu(vm, vm.getClusterCompatibilityVersion()) : vm.getNumOfCpus();
        writer.writeAttributeString("sockets", String.valueOf(vcpus / vm.getCpuPerSocket() / vm.getThreadsPerCpu()));
        writer.writeEndElement();
    }
    if (createInfo.containsKey(VdsProperties.VM_NUMA_NODES)) {
        writer.writeStartElement("numa");
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> createVmNumaNodes = (List<Map<String, Object>>) createInfo.get(VdsProperties.VM_NUMA_NODES);
        for (Map<String, Object> vmNumaNode : createVmNumaNodes) {
            writer.writeStartElement("cell");
            writer.writeAttributeString("cpus", vmNumaNode.get(VdsProperties.NUMA_NODE_CPU_LIST).toString());
            writer.writeAttributeString("memory", String.valueOf(Integer.parseInt((String) vmNumaNode.get(VdsProperties.VM_NUMA_NODE_MEM)) * 1024));
            boolean hugepagesShared = HugePageUtils.getHugepagesShared(vm.getStaticData());
            if (hugepagesShared) {
                writer.writeAttributeString("memAccess", "shared");
            }
            writer.writeEndElement();
        }
        writer.writeEndElement();
    }
    if (vm.getVmType() == VmType.HighPerformance) {
        writer.writeStartElement("cache");
        writer.writeAttributeString("level", "3");
        writer.writeAttributeString("mode", "emulate");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x) {
        // no mouse or tablet for s390x
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if (device.getSpecParams() != null && "serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmDevicesMonitoring.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.forEach(this::replaceNullSpecParams);
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x) {
        // no mouse or tablet for s390x
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if (device.getSpecParams() != null && "serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmDevicesMonitoring.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#end_block

#method_before
void localize() {
    applicationTitle.setText(dynamicMessages.applicationTitle());
    copyrightNotice.setText(dynamicMessages.copyRightNotice());
    versionLabel.setText(dynamicMessages.ovirtVersionAbout());
    userNameLabel.setText(constants.userNameAboutLabel());
}
#method_after
void localize() {
    applicationTitle.setText(dynamicMessages.applicationTitle());
    copyrightNotice.setText(dynamicMessages.copyRightNotice());
    versionLabel.setText(dynamicMessages.ovirtVersionAbout());
}
#end_block

#method_before
private void onImport() {
    StorageModel model = (StorageModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.startProgress(ConstantsManager.getInstance().getConstants().importingStorageDomainProgress());
    VDS host = model.getHost().getSelectedItem();
    // Save changes.
    if (model.getCurrentStorageItem() instanceof NfsStorageModel) {
        NfsStorageModel nfsModel = (NfsStorageModel) model.getCurrentStorageItem();
        nfsModel.setMessage(null);
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), nfsModel.getPath().getEntity(), nfsModel.getRole(), StorageType.NFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getCurrentStorageItem() instanceof LocalStorageModel) {
        LocalStorageModel localModel = (LocalStorageModel) model.getCurrentStorageItem();
        localModel.setMessage(null);
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), localModel.getPath().getEntity(), localModel.getRole(), StorageType.LOCALFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getCurrentStorageItem() instanceof GlusterStorageModel) {
        GlusterStorageModel glusterModel = (GlusterStorageModel) model.getCurrentStorageItem();
        glusterModel.setMessage(null);
        // Check checkbox is selected or not
        if (glusterModel.getLinkGlusterVolume().getEntity()) {
            GlusterBrickEntity brick = glusterModel.getGlusterVolumes().getSelectedItem().getBricks().get(0);
            if (brick != null) {
                String server = brick.getNetworkId() != null && StringHelper.isNotNullOrEmpty(brick.getNetworkAddress()) ? brick.getNetworkAddress() : brick.getServerName();
                path = // $NON-NLS-1$
                server + ":/" + glusterModel.getGlusterVolumes().getSelectedItem().getName();
            } else {
                path = glusterModel.getGlusterVolumes().getSelectedItem().getName();
            }
        } else {
            path = glusterModel.getPath().getEntity();
        }
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), path, glusterModel.getRole(), glusterModel.getType(), model.getActivateDomain().getEntity() }))).run();
    } else if (model.getCurrentStorageItem() instanceof PosixStorageModel) {
        PosixStorageModel posixModel = (PosixStorageModel) model.getCurrentStorageItem();
        posixModel.setMessage(null);
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), posixModel.getPath().getEntity(), posixModel.getRole(), posixModel.getType(), model.getActivateDomain().getEntity() }))).run();
    } else if (model.getCurrentStorageItem() instanceof ImportSanStorageModel) {
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportSan", host.getId(), model.getActivateDomain().getEntity() }))).run();
    }
}
#method_after
private void onImport() {
    StorageModel model = (StorageModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.startProgress(ConstantsManager.getInstance().getConstants().importingStorageDomainProgress());
    VDS host = model.getHost().getSelectedItem();
    // Save changes.
    if (model.getCurrentStorageItem() instanceof NfsStorageModel) {
        NfsStorageModel nfsModel = (NfsStorageModel) model.getCurrentStorageItem();
        nfsModel.setMessage(null);
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), nfsModel.getPath().getEntity(), nfsModel.getRole(), StorageType.NFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getCurrentStorageItem() instanceof LocalStorageModel) {
        LocalStorageModel localModel = (LocalStorageModel) model.getCurrentStorageItem();
        localModel.setMessage(null);
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), localModel.getPath().getEntity(), localModel.getRole(), StorageType.LOCALFS, model.getActivateDomain().getEntity() }))).run();
    } else if (model.getCurrentStorageItem() instanceof GlusterStorageModel) {
        GlusterStorageModel glusterModel = (GlusterStorageModel) model.getCurrentStorageItem();
        glusterModel.setMessage(null);
        // Check checkbox is selected or not
        if (glusterModel.getLinkGlusterVolume().getEntity() && glusterModel.getGlusterVolumes().getSelectedItem() != null) {
            GlusterBrickEntity brick = glusterModel.getGlusterVolumes().getSelectedItem().getBricks().get(0);
            if (brick != null) {
                String server = brick.getNetworkId() != null && StringHelper.isNotNullOrEmpty(brick.getNetworkAddress()) ? brick.getNetworkAddress() : brick.getServerName();
                path = // $NON-NLS-1$
                server + ":/" + glusterModel.getGlusterVolumes().getSelectedItem().getName();
            }
        } else if (!glusterModel.getLinkGlusterVolume().getEntity()) {
            path = glusterModel.getPath().getEntity();
        }
        if (StringHelper.isNotNullOrEmpty(path)) {
            Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
            "ImportFile", host.getId(), path, glusterModel.getRole(), glusterModel.getType(), model.getActivateDomain().getEntity() }))).run();
        } else {
            return;
        }
    } else if (model.getCurrentStorageItem() instanceof PosixStorageModel) {
        PosixStorageModel posixModel = (PosixStorageModel) model.getCurrentStorageItem();
        posixModel.setMessage(null);
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportFile", host.getId(), posixModel.getPath().getEntity(), posixModel.getRole(), posixModel.getType(), model.getActivateDomain().getEntity() }))).run();
    } else if (model.getCurrentStorageItem() instanceof ImportSanStorageModel) {
        Task.create(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
        "ImportSan", host.getId(), model.getActivateDomain().getEntity() }))).run();
    }
}
#end_block

#method_before
private void saveDefaultedStorageProperties(StorageModel model, StorageDomainStatic storageDomainStatic) {
    storageDomainStatic.setWipeAfterDelete(model.getWipeAfterDelete().getEntity());
    storageDomainStatic.setDiscardAfterDelete(model.getDiscardAfterDelete().getEntity());
    storageDomainStatic.setWarningLowSpaceIndicator(model.getWarningLowSpaceIndicator().getEntity());
    storageDomainStatic.setCriticalSpaceActionBlocker(model.getCriticalSpaceActionBlocker().getEntity());
}
#method_after
private void saveDefaultedStorageProperties(StorageModel model, StorageDomainStatic storageDomainStatic) {
    storageDomainStatic.setWipeAfterDelete(model.getWipeAfterDelete().getEntity());
    storageDomainStatic.setDiscardAfterDelete(model.getDiscardAfterDelete().getEntity());
    storageDomainStatic.setWarningLowSpaceIndicator(model.getWarningLowSpaceIndicator().getEntity());
    storageDomainStatic.setCriticalSpaceActionBlocker(model.getCriticalSpaceActionBlocker().getEntity());
    storageDomainStatic.setBackup(model.getBackup().getEntity());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getParameters() == null || getParameters().getAgent() == null || getParameters().getAgent().getId() == null) {
        return failValidation(EngineMessage.VDS_REMOVE_FENCE_AGENT_ID_REQUIRED);
    }
    // check for removal of last fence agent while PM is enabled in the host
    VDS host = getVds();
    if (host == null) {
        return failValidation(EngineMessage.VDS_INVALID_SERVER_ID);
    }
    if (host.isPmEnabled()) {
        List<FenceAgent> fenceAgents = fenceAgentDao.getFenceAgentsForHost(getVdsId());
        if (fenceAgents.size() == 1) {
            return failValidation(EngineMessage.VDS_REMOVE_LAST_FENCE_AGENT_PM_ENABLED);
        }
    }
    return super.validate();
}
#method_after
@Override
protected boolean validate() {
    if (getParameters() == null || getParameters().getAgent() == null || getParameters().getAgent().getId() == null) {
        return failValidation(EngineMessage.VDS_REMOVE_FENCE_AGENT_ID_REQUIRED);
    }
    // check for removal of last fence agent while PM is enabled in the host
    Guid vdsId = getParameters().getAgent().getHostId();
    VDS host = vdsDao.get(vdsId);
    if (host == null) {
        return failValidation(EngineMessage.VDS_INVALID_SERVER_ID);
    }
    if (host.isPmEnabled()) {
        List<FenceAgent> fenceAgents = fenceAgentDao.getFenceAgentsForHost(getVdsId());
        if (fenceAgents.size() == 1) {
            return failValidation(EngineMessage.VDS_REMOVE_LAST_FENCE_AGENT_PM_ENABLED);
        }
    }
    return super.validate();
}
#end_block

#method_before
private void setAuthenticatedUser(Api api) {
    QueryReturnValue returnValue = runQuery(QueryType.GetUserBySessionId, new QueryParametersBase());
    DbUser authenticatedUser = (DbUser) returnValue.getReturnValue();
    User user = new User();
    user.setId(authenticatedUser.getId().toString());
    LinkHelper.addLinks(user);
    api.setAuthenticatedUser(user);
}
#method_after
private void setAuthenticatedUser(Api api) {
    QueryReturnValue returnValue = runQuery(QueryType.GetUserBySessionId, new QueryParametersBase());
    DbUser authenticatedUser = (DbUser) returnValue.getReturnValue();
    User user = new User();
    user.setId(authenticatedUser.getId().toString());
    LinkHelper.addLinks(user);
    api.setAuthenticatedUser(user);
    api.setEffectiveUser(user);
// currently the authenticated and effective users are the same one,
// but if and when impersonation is introduced, they may be different.
}
#end_block

#method_before
@Override
protected void updateVM(final UnitVmModel model) {
    final VM selectedItem = getSelectedItem();
    // explicitly pass non-editable field from the original VM
    getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
    getcurrentVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    if (selectedItem.isRunningOrPaused() && !selectedItem.isHostedEngine()) {
        AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery<>(new AsyncCallback<QueryReturnValue>() {

            @Override
            public void onSuccess(QueryReturnValue returnValue) {
                List<String> changedFields = returnValue.getReturnValue();
                final boolean cpuHotPluggable = VmCommonUtils.isCpusToBeHotplugged(selectedItem, getcurrentVm());
                final boolean isHeadlessModeChanged = isHeadlessModeChanged(editedVm, getUpdateVmParameters(false));
                final boolean memoryHotPluggable = VmCommonUtils.isMemoryToBeHotplugged(selectedItem, getcurrentVm());
                final boolean minAllocatedMemoryChanged = selectedItem.getMinAllocatedMem() != getcurrentVm().getMinAllocatedMem();
                final boolean vmLeaseUpdated = VmCommonUtils.isVmLeaseBeHotplugged(selectedItem, getcurrentVm());
                if (isHeadlessModeChanged) {
                    changedFields.add(constants.headlessMode());
                }
                // provide warnings if isVmUnpinned()
                if (!changedFields.isEmpty() || isVmUnpinned() || memoryHotPluggable || cpuHotPluggable || vmLeaseUpdated) {
                    VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                    if (isVmUnpinned()) {
                        confirmModel.setVmUnpinned();
                    }
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                    confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_next_run_configuration");
                    confirmModel.setChangedFields(changedFields);
                    confirmModel.setCpuPluggable(cpuHotPluggable);
                    confirmModel.setMemoryPluggable(memoryHotPluggable);
                    // it can be plugged only together with the memory, never alone
                    confirmModel.setMinAllocatedMemoryPluggable(memoryHotPluggable && minAllocatedMemoryChanged);
                    confirmModel.setVmLeaseUpdated(vmLeaseUpdated);
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", VmListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    updateExistingVm(false);
                }
            }

            private boolean isVmUnpinned() {
                if (selectedItem.isRunning()) {
                    if (selectedItem.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && getcurrentVm().getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
                        return true;
                    }
                }
                return false;
            }
        }));
    } else {
        updateExistingVm(false);
    }
}
#method_after
@Override
protected void updateVM(final UnitVmModel model) {
    final VM selectedItem = getSelectedItem();
    // explicitly pass non-editable field from the original VM
    getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
    getcurrentVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    if (selectedItem.isRunningOrPaused() && !selectedItem.isHostedEngine()) {
        AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery<>(new AsyncCallback<QueryReturnValue>() {

            @Override
            public void onSuccess(QueryReturnValue returnValue) {
                List<String> changedFields = returnValue.getReturnValue();
                final boolean cpuHotPluggable = VmCommonUtils.isCpusToBeHotpluggedOrUnplugged(selectedItem, getcurrentVm());
                final boolean isHeadlessModeChanged = isHeadlessModeChanged(editedVm, getUpdateVmParameters(false));
                final boolean memoryHotPluggable = VmCommonUtils.isMemoryToBeHotplugged(selectedItem, getcurrentVm());
                final boolean minAllocatedMemoryChanged = selectedItem.getMinAllocatedMem() != getcurrentVm().getMinAllocatedMem();
                final boolean vmLeaseUpdated = VmCommonUtils.isVmLeaseToBeHotPluggedOrUnplugged(selectedItem, getcurrentVm());
                if (isHeadlessModeChanged) {
                    changedFields.add(constants.headlessMode());
                }
                // provide warnings if isVmUnpinned()
                if (!changedFields.isEmpty() || isVmUnpinned() || memoryHotPluggable || cpuHotPluggable || vmLeaseUpdated) {
                    VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                    if (isVmUnpinned()) {
                        confirmModel.setVmUnpinned();
                    }
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                    confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_next_run_configuration");
                    confirmModel.setChangedFields(changedFields);
                    confirmModel.setCpuPluggable(cpuHotPluggable);
                    confirmModel.setMemoryPluggable(memoryHotPluggable);
                    // it can be plugged only together with the memory, never alone
                    confirmModel.setMinAllocatedMemoryPluggable(memoryHotPluggable && minAllocatedMemoryChanged);
                    confirmModel.setVmLeaseUpdated(vmLeaseUpdated);
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", VmListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    updateExistingVm(false);
                }
            }

            private boolean isVmUnpinned() {
                if (selectedItem.isRunning()) {
                    if (selectedItem.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && getcurrentVm().getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
                        return true;
                    }
                }
                return false;
            }
        }));
    } else {
        updateExistingVm(false);
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VM srcVm = getParameters().getOriginal();
    VM dstVm = getParameters().getUpdated();
    VmStatic srcStatic = srcVm.getStaticData();
    VmStatic dstStatic = dstVm.getStaticData();
    // copy fields which are not saved as part of the OVF
    dstStatic.setExportDate(srcStatic.getExportDate());
    dstStatic.setManagedDeviceMap(srcStatic.getManagedDeviceMap());
    dstStatic.setUnmanagedDeviceList(srcStatic.getUnmanagedDeviceList());
    dstStatic.setOvfVersion(srcStatic.getOvfVersion());
    // Copy creationDate to ignore it, because it is never changed by user.
    // Without this creationDate will always show change in milliseconds,
    // because creationDate is saved without milliseconds in OVF, but
    // with milliseconds in the DB.
    dstStatic.setCreationDate(srcStatic.getCreationDate());
    // so it is not needed to include them into changed fields list.
    if (VmCommonUtils.isCpusToBeHotplugged(srcVm, dstVm)) {
        dstStatic.setNumOfSockets(srcStatic.getNumOfSockets());
    }
    if (VmCommonUtils.isMemoryToBeHotplugged(srcVm, dstVm)) {
        dstStatic.setMemSizeMb(srcStatic.getMemSizeMb());
        dstStatic.setMinAllocatedMem(srcStatic.getMinAllocatedMem());
    }
    if (VmCommonUtils.isVmLeaseBeHotplugged(srcVm, dstVm)) {
        dstStatic.setLeaseStorageDomainId(srcStatic.getLeaseStorageDomainId());
    }
    VmPropertiesUtils vmPropertiesUtils = SimpleDependencyInjector.getInstance().get(VmPropertiesUtils.class);
    vmPropertiesUtils.separateCustomPropertiesToUserAndPredefined(srcVm.getCompatibilityVersion(), srcStatic);
    vmPropertiesUtils.separateCustomPropertiesToUserAndPredefined(dstVm.getCompatibilityVersion(), dstStatic);
    Set<String> result = new HashSet<>(vmHandler.getChangedFieldsForStatus(srcStatic, dstStatic, VMStatus.Up));
    for (VmDeviceUpdate device : vmHandler.getVmDevicesFieldsToUpdateOnNextRun(srcVm.getId(), VMStatus.Up, getParameters().getUpdateVmParameters())) {
        if (!device.getName().isEmpty()) {
            result.add(device.getName());
        } else {
            switch(device.getType()) {
                case UNKNOWN:
                case VIRTIO:
                    result.add(device.getGeneralType().name());
                    break;
                default:
                    result.add(device.getType().getName());
                    break;
            }
        }
    }
    setReturnValue(new ArrayList<>(result));
}
#method_after
@Override
protected void executeQueryCommand() {
    VM srcVm = getParameters().getOriginal();
    VM dstVm = getParameters().getUpdated();
    VmStatic srcStatic = srcVm.getStaticData();
    VmStatic dstStatic = dstVm.getStaticData();
    // Copy creationDate to ignore it, because it is never changed by user.
    // Without this creationDate will always show change in milliseconds,
    // because creationDate is saved without milliseconds in OVF, but
    // with milliseconds in the DB.
    dstStatic.setCreationDate(srcStatic.getCreationDate());
    // so it is not needed to include them into changed fields list.
    if (VmCommonUtils.isCpusToBeHotpluggedOrUnplugged(srcVm, dstVm)) {
        dstStatic.setNumOfSockets(srcStatic.getNumOfSockets());
    }
    if (VmCommonUtils.isMemoryToBeHotplugged(srcVm, dstVm)) {
        dstStatic.setMemSizeMb(srcStatic.getMemSizeMb());
        dstStatic.setMinAllocatedMem(srcStatic.getMinAllocatedMem());
    }
    if (VmCommonUtils.isVmLeaseToBeHotPluggedOrUnplugged(srcVm, dstVm)) {
        dstStatic.setLeaseStorageDomainId(srcStatic.getLeaseStorageDomainId());
    }
    VmPropertiesUtils vmPropertiesUtils = SimpleDependencyInjector.getInstance().get(VmPropertiesUtils.class);
    vmPropertiesUtils.separateCustomPropertiesToUserAndPredefined(srcVm.getCompatibilityVersion(), srcStatic);
    vmPropertiesUtils.separateCustomPropertiesToUserAndPredefined(dstVm.getCompatibilityVersion(), dstStatic);
    Set<String> result = new HashSet<>(vmHandler.getChangedFieldsForStatus(srcStatic, dstStatic, VMStatus.Up));
    for (VmDeviceUpdate device : vmHandler.getVmDevicesFieldsToUpdateOnNextRun(srcVm.getId(), VMStatus.Up, getParameters().getUpdateVmParameters())) {
        if (!device.getName().isEmpty()) {
            result.add(device.getName());
        } else {
            switch(device.getType()) {
                case UNKNOWN:
                case VIRTIO:
                    result.add(device.getGeneralType().name());
                    break;
                default:
                    result.add(device.getType().getName());
                    break;
            }
        }
    }
    setReturnValue(new ArrayList<>(result));
}
#end_block

#method_before
private void writePowerManagement() {
    writer.writeStartElement("pm");
    writer.writeStartElement("suspend-to-disk");
    writer.writeAttributeString("enabled", "no");
    writer.writeEndElement();
    writer.writeStartElement("suspend-to-mem");
    writer.writeAttributeString("enabled", "no");
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writePowerManagement() {
    if (vm.getClusterArch() == ArchitectureType.s390x) {
        // s390x doesn't like the pm elements
        return;
    }
    writer.writeStartElement("pm");
    writer.writeStartElement("suspend-to-disk");
    writer.writeAttributeString("enabled", "no");
    writer.writeEndElement();
    writer.writeStartElement("suspend-to-mem");
    writer.writeAttributeString("enabled", "no");
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    writer.writeStartElement("devices");
    writeInput();
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if (device.getSpecParams() != null && "serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmDevicesMonitoring.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.forEach(this::replaceNullSpecParams);
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x) {
        // no mouse or tablet for s390x
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if (device.getSpecParams() != null && "serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmDevicesMonitoring.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeVideo(VmDevice device) {
    writer.writeStartElement("video");
    writer.writeStartElement("model");
    writer.writeAttributeString("type", device.getDevice());
    if (device.getSpecParams() != null) {
        Object vram = device.getSpecParams().get(VdsProperties.VIDEO_VRAM);
        writer.writeAttributeString("vram", vram != null ? vram.toString() : "32768");
        Object heads = device.getSpecParams().get(VdsProperties.VIDEO_HEADS);
        writer.writeAttributeString("heads", heads != null ? heads.toString() : "1");
        if (device.getSpecParams().containsKey(VdsProperties.VIDEO_RAM)) {
            writer.writeAttributeString("ram", device.getSpecParams().get(VdsProperties.VIDEO_RAM).toString());
        }
        if (device.getSpecParams().containsKey(VdsProperties.VIDEO_VGAMEM)) {
            writer.writeAttributeString("vgamem", device.getSpecParams().get(VdsProperties.VIDEO_VGAMEM).toString());
        }
    }
    writer.writeEndElement();
    writeAddress(device);
    writer.writeEndElement();
}
#method_after
private void writeVideo(VmDevice device) {
    writer.writeStartElement("video");
    writer.writeStartElement("model");
    writer.writeAttributeString("type", device.getDevice());
    Object vram = device.getSpecParams().get(VdsProperties.VIDEO_VRAM);
    writer.writeAttributeString("vram", vram != null ? vram.toString() : "32768");
    Object heads = device.getSpecParams().get(VdsProperties.VIDEO_HEADS);
    writer.writeAttributeString("heads", heads != null ? heads.toString() : "1");
    if (device.getSpecParams().containsKey(VdsProperties.VIDEO_RAM)) {
        writer.writeAttributeString("ram", device.getSpecParams().get(VdsProperties.VIDEO_RAM).toString());
    }
    if (device.getSpecParams().containsKey(VdsProperties.VIDEO_VGAMEM)) {
        writer.writeAttributeString("vgamem", device.getSpecParams().get(VdsProperties.VIDEO_VGAMEM).toString());
    }
    writer.writeEndElement();
    writeAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeAddress(VmDevice device) {
    if (!device.getAddress().isEmpty()) {
        writeAddress(StringMapUtils.string2Map(device.getAddress()));
    }
}
#method_after
private void writeAddress(VmDevice device) {
    writeAddress(StringMapUtils.string2Map(device.getAddress()));
}
#end_block

#method_before
private void writeInput() {
    writer.writeStartElement("input");
    boolean tabletEnable = vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC);
    if (tabletEnable) {
        writer.writeAttributeString("type", "tablet");
        writer.writeAttributeString("bus", "usb");
    } else if (vm.getClusterArch().getFamily() == ArchitectureType.x86) {
        writer.writeAttributeString("type", "mouse");
        writer.writeAttributeString("bus", "ps2");
    } else {
        writer.writeAttributeString("type", "mouse");
        writer.writeAttributeString("bus", "usb");
    }
    writer.writeEndElement();
}
#method_after
private void writeInput() {
    writer.writeStartElement("input");
    // Avoid adding Tablet device for High Performance VMs since no USB devices are set
    boolean tabletEnable = vm.getVmType() != VmType.HighPerformance && vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC);
    if (tabletEnable) {
        writer.writeAttributeString("type", "tablet");
        writer.writeAttributeString("bus", "usb");
    } else if (vm.getClusterArch().getFamily() == ArchitectureType.x86) {
        writer.writeAttributeString("type", "mouse");
        writer.writeAttributeString("bus", "ps2");
    } else {
        writer.writeAttributeString("type", "mouse");
        writer.writeAttributeString("bus", "usb");
    }
    writer.writeEndElement();
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVmTemplate() == null) {
        return false;
    }
    setDescription(getVmTemplateName());
    // check that the storage pool is valid
    if (!checkStoragePool() || !validateTemplateArchitecture() || !isClusterCompatible()) {
        return false;
    }
    // set the source domain and check that it is ImportExport type and active
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
    if (!validate(sourceDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    if ((getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !getParameters().isImagesExistOnTargetStorageDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!getParameters().isImagesExistOnTargetStorageDomain()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        QueryReturnValue qretVal = runInternalQuery(QueryType.GetTemplatesFromExportDomain, tempVar);
        if (!qretVal.getSucceeded()) {
            return false;
        }
        Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
        ArrayList<DiskImage> images = new ArrayList<>();
        for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
            if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                images = new ArrayList<>(entry.getValue());
                getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                break;
            }
        }
        getParameters().setImages(images);
        getVmTemplate().setImages(images);
        ensureDomainMap(getImages(), getParameters().getDestDomainId());
        HashMap<Guid, DiskImage> imageMap = new HashMap<>();
        for (DiskImage image : images) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
            changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
            if (!ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getValidationMessages())) {
                return false;
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            image.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
            imageMap.put(image.getImageId(), image);
        }
        getVmTemplate().setDiskImageMap(imageMap);
    }
    sourceTemplateId = getVmTemplateId();
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    VmTemplate duplicateTemplate = vmTemplateDao.get(getParameters().getVmTemplate().getId());
    // check that the template does not exists in the target domain
    if (duplicateTemplate != null) {
        return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS, String.format("$TemplateName %1$s", duplicateTemplate.getName()));
    }
    if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
        return failValidation(EngineMessage.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
    }
    if (!validateNoDuplicateDiskImages(getImages())) {
        return false;
    }
    if (getImages() != null && !getImages().isEmpty() && !getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!validateSpaceRequirements(getImages())) {
            return false;
        }
    }
    List<VmNetworkInterface> vmNetworkInterfaces = getVmTemplate().getInterfaces();
    vmNicMacsUtils.replaceInvalidEmptyStringMacAddressesWithNull(vmNetworkInterfaces);
    if (!validate(vmNicMacsUtils.validateMacAddress(vmNetworkInterfaces))) {
        return false;
    }
    // if this is a template version, check base template exist
    if (!getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = vmTemplateDao.get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVmTemplate() == null) {
        return false;
    }
    setDescription(getVmTemplateName());
    // check that the storage pool is valid
    if (!checkStoragePool() || !validateTemplateArchitecture() || !isClusterCompatible()) {
        return false;
    }
    // set the source domain and check that it is ImportExport type and active
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
    if (!validate(sourceDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    if ((getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !getParameters().isImagesExistOnTargetStorageDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!getParameters().isImagesExistOnTargetStorageDomain()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        QueryReturnValue qretVal = runInternalQuery(QueryType.GetTemplatesFromExportDomain, tempVar);
        if (!qretVal.getSucceeded()) {
            return false;
        }
        Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
        ArrayList<DiskImage> images = new ArrayList<>();
        for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
            if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                images = new ArrayList<>(entry.getValue());
                getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                break;
            }
        }
        getParameters().setImages(images);
        getVmTemplate().setImages(images);
        ensureDomainMap(getImages(), getParameters().getDestDomainId());
        HashMap<Guid, DiskImage> imageMap = new HashMap<>();
        for (DiskImage image : images) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
            changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
            if (!ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getValidationMessages())) {
                return false;
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            image.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
            imageMap.put(image.getImageId(), image);
        }
        getVmTemplate().setDiskImageMap(imageMap);
    }
    sourceTemplateId = getVmTemplateId();
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    VmTemplate duplicateTemplate = vmTemplateDao.get(getParameters().getVmTemplate().getId());
    // check that the template does not exists in the target domain
    if (duplicateTemplate != null) {
        return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS, String.format("$TemplateName %1$s", duplicateTemplate.getName()));
    }
    if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
        return failValidation(EngineMessage.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
    }
    if (!validateNoDuplicateDiskImages(getImages())) {
        return false;
    }
    if (getImages() != null && !getImages().isEmpty() && !getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!validateSpaceRequirements(getImages())) {
            return false;
        }
    }
    List<VmNetworkInterface> vmNetworkInterfaces = getVmTemplate().getInterfaces();
    vmNicMacsUtils.replaceInvalidEmptyStringMacAddressesWithNull(vmNetworkInterfaces);
    if (!validate(vmNicMacsUtils.validateMacAddress(vmNetworkInterfaces))) {
        return false;
    }
    // if this is a template version, check base template exist
    if (!getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = vmTemplateDao.get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getVmTemplate().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    return true;
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    getVmTemplate().setClusterId(getParameters().getClusterId());
    // if "run on host" field points to a non existent vds (in the current cluster) -> remove field and continue
    if (!vmHandler.validateDedicatedVdsExistOnSameCluster(getVmTemplate()).isValid()) {
        getVmTemplate().setDedicatedVmForVdsList(Collections.emptyList());
    }
    getVmTemplate().setStatus(VmTemplateStatus.Locked);
    getVmTemplate().setQuotaId(getParameters().getQuotaId());
    vmTemplateDao.save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    int count = 1;
    for (DiskImage image : getImages()) {
        image.setActive(true);
        ImageStorageDomainMap map = imagesHandler.saveImage(image);
        getCompensationContext().snapshotNewEntity(image.getImage());
        getCompensationContext().snapshotNewEntity(map);
        if (!baseDiskDao.exists(image.getId())) {
            image.setDiskAlias(ImagesHandler.getSuggestedDiskAlias(image, getVmTemplateName(), count));
            count++;
            baseDiskDao.save(image);
            getCompensationContext().snapshotNewEntity(image);
        }
        DiskImageDynamic diskDynamic = new DiskImageDynamic();
        diskDynamic.setId(image.getImageId());
        diskDynamic.setActualSize(image.getActualSizeInBytes());
        diskImageDynamicDao.save(diskDynamic);
        DiskVmElement dve = DiskVmElement.copyOf(image.getDiskVmElementForVm(sourceTemplateId), image.getId(), getVmTemplateId());
        diskVmElementDao.save(dve);
        getCompensationContext().snapshotNewEntity(diskDynamic);
    }
}
#method_after
protected void addVmTemplateToDb() {
    getVmTemplate().setClusterId(getParameters().getClusterId());
    // if "run on host" field points to a non existent vds (in the current cluster) -> remove field and continue
    if (!vmHandler.validateDedicatedVdsExistOnSameCluster(getVmTemplate()).isValid()) {
        getVmTemplate().setDedicatedVmForVdsList(Collections.emptyList());
    }
    getVmTemplate().setStatus(VmTemplateStatus.Locked);
    getVmTemplate().setQuotaId(getParameters().getQuotaId());
    vmHandler.autoSelectResumeBehavior(getVmTemplate(), getCluster());
    vmTemplateDao.save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    int count = 1;
    for (DiskImage image : getImages()) {
        image.setActive(true);
        ImageStorageDomainMap map = imagesHandler.saveImage(image);
        getCompensationContext().snapshotNewEntity(image.getImage());
        getCompensationContext().snapshotNewEntity(map);
        if (!baseDiskDao.exists(image.getId())) {
            image.setDiskAlias(ImagesHandler.getSuggestedDiskAlias(image, getVmTemplateName(), count));
            count++;
            baseDiskDao.save(image);
            getCompensationContext().snapshotNewEntity(image);
        }
        DiskImageDynamic diskDynamic = new DiskImageDynamic();
        diskDynamic.setId(image.getImageId());
        diskDynamic.setActualSize(image.getActualSizeInBytes());
        diskImageDynamicDao.save(diskDynamic);
        DiskVmElement dve = DiskVmElement.copyOf(image.getDiskVmElementForVm(sourceTemplateId), image.getId(), getVmTemplateId());
        diskVmElementDao.save(dve);
        getCompensationContext().snapshotNewEntity(diskDynamic);
    }
}
#end_block

#method_before
private void initVmTemplate() {
    List<OvfEntityData> ovfEntityList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmTemplateFromOvf(ovfEntityData.getOvfData());
            mapCluster(fullEntityOvfData);
            vmTemplateFromConfiguration.setClusterId(getParameters().getClusterId());
            setVmTemplate(vmTemplateFromConfiguration);
            setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getVmTemplate(), this::getCluster));
            vmHandler.updateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion());
            getParameters().setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskTemplateMap() != null) {
                ArrayList imageList = new ArrayList<>(getParameters().getDiskTemplateMap().values());
                vmTemplateFromConfiguration.setDiskList(imageList);
                ensureDomainMap(imageList, getParameters().getDestDomainId());
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
    setClusterId(getParameters().getClusterId());
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
}
#method_after
private void initVmTemplate() {
    List<OvfEntityData> ovfEntityList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmTemplateFromOvf(ovfEntityData.getOvfData());
            vmTemplateFromConfiguration = fullEntityOvfData.getVmTemplate();
            mapCluster(fullEntityOvfData.getClusterName());
            vmTemplateFromConfiguration.setClusterId(getParameters().getClusterId());
            setVmTemplate(vmTemplateFromConfiguration);
            setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getVmTemplate(), this::getCluster));
            vmHandler.updateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion());
            getParameters().setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskTemplateMap() != null) {
                ArrayList imageList = new ArrayList<>(getParameters().getDiskTemplateMap().values());
                vmTemplateFromConfiguration.setDiskList(imageList);
                ensureDomainMap(imageList, getParameters().getDestDomainId());
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
    setClusterId(getParameters().getClusterId());
    setStoragePoolId(getCluster().getStoragePoolId());
}
#end_block

#method_before
private void mapCluster(FullEntityOvfData fullEntityOvfData) {
    vmTemplateFromConfiguration = fullEntityOvfData.getVmTemplate();
    Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmTemplateFromConfiguration.getId(), getParameters().getClusterMap());
    if (cluster != null) {
        getParameters().setClusterId(cluster.getId());
    }
}
#method_after
private void mapCluster(String clusterName) {
    if (getParameters().getClusterMap() != null) {
        String clusterDest = getParameters().getClusterMap().get(clusterName);
        Cluster cluster = clusterDao.getByName(clusterDest);
        if (cluster == null) {
            cluster = clusterDao.getByName(clusterName);
        }
        if (cluster != null) {
            getParameters().setClusterId(cluster.getId());
        }
    }
}
#end_block

#method_before
@Override
protected void mapDbUsers() {
    Map<String, String> userDomainsMap = getParameters().getDomainMap();
    getParameters().getDbUsers().forEach(dbUser -> {
        DbUser originalDbUser = dbUserDao.getByUsernameAndDomain(dbUser.getLoginName(), dbUser.getDomain());
        if (userDomainsMap != null) {
            String destDomain = userDomainsMap.get(dbUser.getDomain());
            if (destDomain != null) {
                DbUser destDbUser = dbUserDao.getByUsernameAndDomain(dbUser.getLoginName(), destDomain);
                if (destDbUser != null) {
                    addPermissionsForUser(destDbUser, getParameters().getUserToRoles());
                }
            } else if (originalDbUser != null) {
                addPermissionsForUser(originalDbUser, getParameters().getUserToRoles());
            }
        } else if (originalDbUser != null) {
            addPermissionsForUser(originalDbUser, getParameters().getUserToRoles());
        } else // The user does not exist at all, creating it
        {
            DbUser newDbUser = new DbUser();
            newDbUser.setLoginName(dbUser.getLoginName());
            newDbUser.setDomain(dbUser.getDomain());
            dbUserDao.save(newDbUser);
            log.debug("User {}@{} does not exist, creating it...", newDbUser.getLoginName(), newDbUser.getDomain());
        }
    });
}
#method_after
@Override
protected void mapDbUsers() {
    drMappingHelper.mapDbUsers(getParameters().getDomainMap(), getParameters().getDbUsers(), getParameters().getUserToRoles(), getVmTemplateId(), VdcObjectType.VmTemplate, getParameters().getRoleMap());
}
#end_block

#method_before
public String buildMetadataDictionaryForTemplate(VmTemplate template, Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary) {
    List<DiskImage> allTemplateImages = template.getDiskList();
    Set<DbUser> dbUsers = new HashSet<>(dbUserDao.getAllForTemplate(template.getId()));
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(template);
    fullEntityOvfData.setDbUsers(dbUsers);
    fullEntityOvfData.setDiskImages(allTemplateImages);
    populateUserToRoles(fullEntityOvfData, template.getId());
    String templateMeta = generateVmTemplateMetadata(fullEntityOvfData);
    metaDictionary.put(template.getId(), new KeyValuePairCompat<>(templateMeta, allTemplateImages.stream().map(BaseDisk::getId).collect(Collectors.toList())));
    return templateMeta;
}
#method_after
public String buildMetadataDictionaryForTemplate(VmTemplate template, Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary) {
    List<DiskImage> allTemplateImages = template.getDiskList();
    Set<DbUser> dbUsers = new HashSet<>(dbUserDao.getAllForTemplate(template.getId()));
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(template);
    fullEntityOvfData.setDbUsers(dbUsers);
    fullEntityOvfData.setDiskImages(allTemplateImages);
    ovfHelper.populateUserToRoles(fullEntityOvfData, template.getId());
    String templateMeta = generateVmTemplateMetadata(fullEntityOvfData);
    metaDictionary.put(template.getId(), new KeyValuePairCompat<>(templateMeta, allTemplateImages.stream().map(BaseDisk::getId).collect(Collectors.toList())));
    return templateMeta;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    setDescription(getVmName());
    setStoragePoolId(getVm().getStoragePoolId());
    // check that target domain exists
    StorageDomainValidator targetstorageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!validate(targetstorageDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    // load the disks of vm from database
    vmHandler.updateDisksFromDb(getVm());
    List<DiskImage> disksForExport = getDisksBasedOnImage();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(disksForExport);
    if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
        return false;
    }
    // update vm snapshots for storage free space check
    imagesHandler.fillImagesBySnapshots(getVm());
    // check that the target and source domain are in the same storage_pool
    if (storagePoolIsoMapDao.get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getStoragePoolId())) == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        return false;
    }
    // check if template exists only if asked for
    if (getParameters().getTemplateMustExists()) {
        if (!checkTemplateInStorageDomain(getVm().getStoragePoolId(), getParameters().getStorageDomainId(), getVm().getVmtGuid(), getContext().getEngineContext())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN, String.format("$TemplateName %1$s", getVm().getVmtName()));
        }
    }
    // check that the images requested format are valid (COW+Sparse)
    if (!imagesHandler.checkImagesConfiguration(getParameters().getStorageDomainId(), disksForExport, getReturnValue().getValidationMessages())) {
        return false;
    }
    Map<Guid, ? extends Disk> images = getVm().getDiskMap();
    if (getParameters().getCopyCollapse()) {
        for (DiskImage img : disksForExport) {
            if (images.containsKey(img.getId())) {
                // check that no RAW format exists (we are in collapse mode)
                if (((DiskImage) images.get(img.getId())).getVolumeFormat() == VolumeFormat.RAW && img.getVolumeFormat() != VolumeFormat.RAW) {
                    addValidationMessage(EngineMessage.VM_CANNOT_EXPORT_RAW_FORMAT);
                    return false;
                }
            }
        }
    }
    // check destination storage is Export domain
    if (getStorageDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN, String.format("$storageDomainName %1$s", getStorageDomainName()));
    }
    // get the snapshots that are going to be exported and have memory
    snapshotsWithMemory = getSnapshotsToBeExportedWithMemory();
    // check destination storage have free space
    if (!handleDestStorageDomain(disksForExport)) {
        return false;
    }
    if (!(checkVmInStorageDomain() && validate(new StoragePoolValidator(getStoragePool()).isUp()) && validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotsValidator.vmNotInPreview(getVmId())) && validate(new VmValidator(getVm()).vmDown()) && validate(new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), ImagesHandler.getAllStorageIdsForImageIds(disksForExport)).allDomainsExistAndActive()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    setDescription(getVmName());
    setStoragePoolId(getVm().getStoragePoolId());
    // check that target domain exists
    StorageDomainValidator targetstorageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!validate(targetstorageDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    // load the disks of vm from database
    vmHandler.updateDisksFromDb(getVm());
    List<DiskImage> disksForExport = getDisksBasedOnImage();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(disksForExport);
    if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
        return false;
    }
    // update vm snapshots for storage free space check
    imagesHandler.fillImagesBySnapshots(getVm());
    // check that the target and source domain are in the same storage_pool
    if (storagePoolIsoMapDao.get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getStoragePoolId())) == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    // check if template exists only if asked for
    if (getParameters().getTemplateMustExists()) {
        if (!checkTemplateInStorageDomain(getVm().getStoragePoolId(), getParameters().getStorageDomainId(), getVm().getVmtGuid(), getContext().getEngineContext())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN, String.format("$TemplateName %1$s", getVm().getVmtName()));
        }
    }
    Map<Guid, ? extends Disk> images = getVm().getDiskMap();
    if (getParameters().getCopyCollapse()) {
        for (DiskImage img : disksForExport) {
            if (images.containsKey(img.getId())) {
                // check that no RAW format exists (we are in collapse mode)
                if (((DiskImage) images.get(img.getId())).getVolumeFormat() == VolumeFormat.RAW && img.getVolumeFormat() != VolumeFormat.RAW) {
                    return failValidation(EngineMessage.VM_CANNOT_EXPORT_RAW_FORMAT);
                }
            }
        }
    }
    // check destination storage is Export domain
    if (getStorageDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN, String.format("$storageDomainName %1$s", getStorageDomainName()));
    }
    // get the snapshots that are going to be exported and have memory
    snapshotsWithMemory = getSnapshotsToBeExportedWithMemory();
    // check destination storage have free space
    if (!handleDestStorageDomain(disksForExport)) {
        return false;
    }
    if (!(checkVmInStorageDomain() && validate(new StoragePoolValidator(getStoragePool()).isUp()) && validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotsValidator.vmNotInPreview(getVmId())) && validate(new VmValidator(getVm()).vmDown()) && validate(new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), ImagesHandler.getAllStorageIdsForImageIds(disksForExport)).allDomainsExistAndActive()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<>();
    List<DiskImage> vmImages = new ArrayList<>();
    List<LunDisk> lunDisks = new ArrayList<>();
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    List<AffinityGroup> affinityGroups = affinityGroupDao.getAllAffinityGroupsByVmId(vm.getId());
    Set<DbUser> dbUsers = new HashSet<>(dbUserDao.getAllForVm(vm.getId()));
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(vmNetworkInterfaceDao.getAllForVm(vm.getId()));
    }
    List<Guid> imageGroupIds = new ArrayList<>();
    for (Disk disk : getDisksBasedOnImage()) {
        DiskImage diskImage = (DiskImage) disk;
        diskImage.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomainId)));
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
        diskImage.setVolumeFormat(diskForVolumeInfo.getVolumeFormat());
        diskImage.setVolumeType(diskForVolumeInfo.getVolumeType());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
            diskImage.setActualSizeInBytes(fromVdsm.getActualSizeInBytes());
        }
        vmImages.add(diskImage);
        imageGroupIds.add(disk.getId());
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = vmTemplateDao.get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    lunDisks.addAll(DisksFilter.filterLunDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE));
    lunDisks.forEach(lun -> lun.getLun().setLunConnections(new ArrayList<>(storageServerConnectionDao.getAllForLun(lun.getLun().getId()))));
    getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(vm);
    fullEntityOvfData.setClusterName(vm.getClusterName());
    fullEntityOvfData.setDiskImages(vmImages);
    fullEntityOvfData.setLunDisks(lunDisks);
    fullEntityOvfData.setAffinityGroups(affinityGroups);
    fullEntityOvfData.setDbUsers(dbUsers);
    populateUserToRoles(fullEntityOvfData);
    String vmMeta = ovfManager.exportVm(vm, fullEntityOvfData, clusterUtils.getCompatibilityVersion(vm));
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    runVdsCommand(VDSCommandType.UpdateVM, tempVar);
}
#method_after
private void updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<>();
    List<DiskImage> vmImages = new ArrayList<>();
    List<LunDisk> lunDisks = new ArrayList<>();
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    List<AffinityGroup> affinityGroups = affinityGroupDao.getAllAffinityGroupsByVmId(vm.getId());
    Set<DbUser> dbUsers = new HashSet<>(dbUserDao.getAllForVm(vm.getId()));
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(vmNetworkInterfaceDao.getAllForVm(vm.getId()));
    }
    List<Guid> imageGroupIds = new ArrayList<>();
    for (Disk disk : getDisksBasedOnImage()) {
        DiskImage diskImage = (DiskImage) disk;
        diskImage.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomainId)));
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
        diskImage.setVolumeFormat(diskForVolumeInfo.getVolumeFormat());
        diskImage.setVolumeType(diskForVolumeInfo.getVolumeType());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
            diskImage.setActualSizeInBytes(fromVdsm.getActualSizeInBytes());
        }
        vmImages.add(diskImage);
        imageGroupIds.add(disk.getId());
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = vmTemplateDao.get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    lunDisks.addAll(DisksFilter.filterLunDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE));
    lunDisks.forEach(lun -> lun.getLun().setLunConnections(new ArrayList<>(storageServerConnectionDao.getAllForLun(lun.getLun().getId()))));
    getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(vm);
    fullEntityOvfData.setClusterName(vm.getClusterName());
    fullEntityOvfData.setDiskImages(vmImages);
    fullEntityOvfData.setLunDisks(lunDisks);
    fullEntityOvfData.setAffinityGroups(affinityGroups);
    fullEntityOvfData.setDbUsers(dbUsers);
    ovfHelper.populateUserToRoles(fullEntityOvfData, vm.getId());
    String vmMeta = ovfManager.exportVm(vm, fullEntityOvfData, clusterUtils.getCompatibilityVersion(vm));
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    runVdsCommand(VDSCommandType.UpdateVM, tempVar);
}
#end_block

#method_before
protected boolean checkVmInStorageDomain() {
    boolean retVal = true;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getVm().getStoragePoolId(), getParameters().getStorageDomainId());
    QueryReturnValue qretVal = runInternalQuery(QueryType.GetVmsFromExportDomain, tempVar);
    if (qretVal.getSucceeded()) {
        ArrayList<VM> vms = qretVal.getReturnValue();
        for (VM vm : vms) {
            if (vm.getId().equals(getVm().getId())) {
                if (!getParameters().getForceOverride()) {
                    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_GUID_ALREADY_EXIST);
                    retVal = false;
                    break;
                }
            } else if (vm.getName().equals(getVm().getName())) {
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                retVal = false;
                break;
            }
        }
    }
    return retVal;
}
#method_after
protected boolean checkVmInStorageDomain() {
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getVm().getStoragePoolId(), getParameters().getStorageDomainId());
    QueryReturnValue qretVal = runInternalQuery(QueryType.GetVmsFromExportDomain, tempVar);
    if (qretVal.getSucceeded()) {
        List<VM> vms = qretVal.getReturnValue();
        for (VM vm : vms) {
            if (vm.getId().equals(getVm().getId())) {
                if (!getParameters().getForceOverride()) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_GUID_ALREADY_EXIST);
                }
            } else if (vm.getName().equals(getVm().getName())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        }
    }
    return true;
}
#end_block

#method_before
public static boolean checkTemplateInStorageDomain(Guid storagePoolId, Guid storageDomainId, final Guid tmplId, EngineContext engineContext) {
    boolean retVal = false;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    QueryReturnValue qretVal = Backend.getInstance().runInternalQuery(QueryType.GetTemplatesFromExportDomain, tempVar, engineContext);
    if (qretVal.getSucceeded()) {
        if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(tmplId)) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            retVal = templates.keySet().stream().anyMatch(vmTemplate -> vmTemplate.getId().equals(tmplId));
        } else {
            retVal = true;
        }
    }
    return retVal;
}
#method_after
public static boolean checkTemplateInStorageDomain(Guid storagePoolId, Guid storageDomainId, final Guid tmplId, EngineContext engineContext) {
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    QueryReturnValue qretVal = Backend.getInstance().runInternalQuery(QueryType.GetTemplatesFromExportDomain, tempVar, engineContext);
    if (qretVal.getSucceeded()) {
        if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(tmplId)) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            return templates.keySet().stream().anyMatch(vmTemplate -> vmTemplate.getId().equals(tmplId));
        } else {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
protected void updateVmInSpm() {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<>();
    ovfUpdateProcessHelper.loadVmData(getVm());
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(getVm());
    fullEntityOvfData.setClusterName(getVm().getClusterName());
    fullEntityOvfData.setDiskImages(ovfUpdateProcessHelper.getVmImagesFromDb(getVm()));
    fullEntityOvfData.setAffinityGroups(affinityGroupDao.getAllAffinityGroupsByVmId(getVmId()));
    fullEntityOvfData.setDbUsers(new HashSet<>(dbUserDao.getAllForVm(getVm().getId())));
    populateUserToRoles(fullEntityOvfData);
    ovfUpdateProcessHelper.buildMetadataDictionaryForVm(getVm(), metaDictionary, fullEntityOvfData);
    ovfUpdateProcessHelper.executeUpdateVmInSpmCommand(getVm().getStoragePoolId(), metaDictionary, getParameters().getStorageDomainId());
}
#method_after
protected void updateVmInSpm() {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<>();
    ovfUpdateProcessHelper.loadVmData(getVm());
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(getVm());
    fullEntityOvfData.setClusterName(getVm().getClusterName());
    fullEntityOvfData.setDiskImages(ovfUpdateProcessHelper.getVmImagesFromDb(getVm()));
    fullEntityOvfData.setAffinityGroups(affinityGroupDao.getAllAffinityGroupsByVmId(getVmId()));
    fullEntityOvfData.setDbUsers(new HashSet<>(dbUserDao.getAllForVm(getVmId())));
    ovfHelper.populateUserToRoles(fullEntityOvfData, getVmId());
    ovfUpdateProcessHelper.buildMetadataDictionaryForVm(getVm(), metaDictionary, fullEntityOvfData);
    ovfUpdateProcessHelper.executeUpdateVmInSpmCommand(getVm().getStoragePoolId(), metaDictionary, getParameters().getStorageDomainId());
}
#end_block

#method_before
private void initTestForPool(StoragePool pool, List<Guid> vmGuids, List<Guid> templatesGuids, List<Guid> removedGuids) {
    Guid poolId = pool.getId();
    doReturn(vmGuids).when(vmAndTemplatesGenerationsDao).getVmsIdsForOvfUpdate(poolId);
    doReturn(templatesGuids).when(vmAndTemplatesGenerationsDao).getVmTemplatesIdsForOvfUpdate(poolId);
    doReturn(removedGuids).when(vmAndTemplatesGenerationsDao).getIdsForOvfDeletion(poolId);
    doReturn(Collections.EMPTY_LIST).when(affinityGroupDao).getAllAffinityGroupsByVmId(any());
    doReturn(new DbUser()).when(dbUserDao).getByUsernameAndDomain(any(), any());
    doReturn(Collections.EMPTY_LIST).when(permissionDao).getAllDirectPermissionsForAdElement(any());
    pool.setStatus(StoragePoolStatus.Up);
}
#method_after
private void initTestForPool(StoragePool pool, List<Guid> vmGuids, List<Guid> templatesGuids, List<Guid> removedGuids) {
    Guid poolId = pool.getId();
    doReturn(vmGuids).when(vmAndTemplatesGenerationsDao).getVmsIdsForOvfUpdate(poolId);
    doReturn(templatesGuids).when(vmAndTemplatesGenerationsDao).getVmTemplatesIdsForOvfUpdate(poolId);
    doReturn(removedGuids).when(vmAndTemplatesGenerationsDao).getIdsForOvfDeletion(poolId);
    doReturn(Collections.EMPTY_LIST).when(affinityGroupDao).getAllAffinityGroupsByVmId(any());
    doReturn(new DbUser()).when(dbUserDao).getByUsernameAndDomain(any(), any());
    doReturn(Collections.EMPTY_LIST).when(permissionDao).getAllForAdElementAndObjectId(any(), any());
    pool.setStatus(StoragePoolStatus.Up);
}
#end_block

#method_before
@Override
protected void writeLunDisk(LunDisk lun) {
    // Lun disk does not have image id, therefor the id will be preserved with the disk ID as identifier.
    _writer.writeAttributeString(OVF_URI, "diskId", lun.getId().toString());
    DiskVmElement dve = lun.getDiskVmElementForVm(vmBase.getId());
    if (lun.getDiskAlias() != null) {
        _writer.writeAttributeString(OVF_URI, "disk-alias", lun.getDiskAlias().toString());
    }
    if (lun.getDiskDescription() != null) {
        _writer.writeAttributeString(OVF_URI, "disk-description", lun.getDiskDescription().toString());
    }
    if (FeatureSupported.passDiscardSupported(version)) {
        _writer.writeAttributeString(OVF_URI, "pass-discard", String.valueOf(dve.isPassDiscard()));
    }
    _writer.writeAttributeString(OVF_URI, "fileRef", OvfParser.createLunFile(lun));
    _writer.writeAttributeString(OVF_URI, "shareable", String.valueOf(lun.isShareable()));
    _writer.writeAttributeString(OVF_URI, "boot", String.valueOf(dve.isBoot()));
    _writer.writeAttributeString(OVF_URI, "disk-interface", dve.getDiskInterface().toString());
    _writer.writeAttributeString(OVF_URI, "read-only", String.valueOf(dve.isReadOnly()));
    _writer.writeAttributeString(OVF_URI, "scsi_reservation", String.valueOf(dve.isUsingScsiReservation()));
    _writer.writeAttributeString(OVF_URI, "plugged", String.valueOf(dve.isPlugged()));
    _writer.writeAttributeString(OVF_URI, LUN_DISCARD_ZEROES_DATA, String.valueOf(lun.getLun().getDiscardZeroesData()));
    _writer.writeAttributeString(OVF_URI, LUN_DISCARD_MAX_SIZE, String.valueOf(lun.getLun().getDiscardMaxSize()));
    _writer.writeAttributeString(OVF_URI, LUN_DEVICE_SIZE, String.valueOf(lun.getLun().getDeviceSize()));
    _writer.writeAttributeString(OVF_URI, LUN_PRODUCT_ID, String.valueOf(lun.getLun().getProductId()));
    _writer.writeAttributeString(OVF_URI, LUN_VENDOR_ID, String.valueOf(lun.getLun().getVendorId()));
    _writer.writeAttributeString(OVF_URI, LUN_MAPPING, String.valueOf(lun.getLun().getLunMapping()));
    _writer.writeAttributeString(OVF_URI, LUN_SERIAL, String.valueOf(lun.getLun().getSerial()));
    _writer.writeAttributeString(OVF_URI, LUN_VOLUME_GROUP_ID, String.valueOf(lun.getLun().getVolumeGroupId()));
    _writer.writeAttributeString(OVF_URI, LUN_ID, String.valueOf(lun.getLun().getLUNId()));
    _writer.writeAttributeString(OVF_URI, LUN_PHYSICAL_VOLUME_ID, String.valueOf(lun.getLun().getPhysicalVolumeId()));
    if (lun.getLun().getLunConnections() != null) {
        for (StorageServerConnections conn : lun.getLun().getLunConnections()) {
            _writer.writeStartElement(LUN_CONNECTION);
            _writer.writeAttributeString(OVF_URI, LUNS_CONNECTION, conn.getConnection());
            _writer.writeAttributeString(OVF_URI, LUNS_IQN, conn.getIqn());
            _writer.writeAttributeString(OVF_URI, LUNS_PORT, conn.getPort());
            _writer.writeAttributeString(XSI_URI, LUNS_STORAGE_TYPE, conn.getStorageType().name());
            _writer.writeAttributeString(XSI_URI, LUNS_PORTAL, conn.getPortal());
            // TODO: Username and password should be initilaized by the mapping file.
            // conn.getUserName()
            // conn.getPassword()
            _writer.writeEndElement();
        }
    }
}
#method_after
@Override
protected void writeLunDisk(LunDisk lun) {
    // Lun disk does not have image id, therefor the id will be preserved with the disk ID as identifier.
    _writer.writeAttributeString(OVF_URI, "diskId", lun.getId().toString());
    DiskVmElement dve = lun.getDiskVmElementForVm(vmBase.getId());
    if (lun.getDiskAlias() != null) {
        _writer.writeAttributeString(OVF_URI, "disk-alias", lun.getDiskAlias().toString());
    }
    if (lun.getDiskDescription() != null) {
        _writer.writeAttributeString(OVF_URI, "disk-description", lun.getDiskDescription().toString());
    }
    if (FeatureSupported.passDiscardSupported(version)) {
        _writer.writeAttributeString(OVF_URI, "pass-discard", String.valueOf(dve.isPassDiscard()));
    }
    _writer.writeAttributeString(OVF_URI, "fileRef", OvfParser.createLunFile(lun));
    _writer.writeAttributeString(OVF_URI, "shareable", String.valueOf(lun.isShareable()));
    _writer.writeAttributeString(OVF_URI, "boot", String.valueOf(dve.isBoot()));
    _writer.writeAttributeString(OVF_URI, "disk-interface", dve.getDiskInterface().toString());
    _writer.writeAttributeString(OVF_URI, "read-only", String.valueOf(dve.isReadOnly()));
    _writer.writeAttributeString(OVF_URI, "scsi_reservation", String.valueOf(dve.isUsingScsiReservation()));
    _writer.writeAttributeString(OVF_URI, "plugged", String.valueOf(dve.isPlugged()));
    _writer.writeAttributeString(OVF_URI, LUN_ID, String.valueOf(lun.getLun().getLUNId()));
    if (lun.getLun().getLunConnections() != null) {
        for (StorageServerConnections conn : lun.getLun().getLunConnections()) {
            _writer.writeStartElement(LUN_CONNECTION);
            _writer.writeAttributeString(OVF_URI, LUNS_CONNECTION, conn.getConnection());
            _writer.writeAttributeString(OVF_URI, LUNS_IQN, conn.getIqn());
            _writer.writeAttributeString(OVF_URI, LUNS_PORT, conn.getPort());
            _writer.writeAttributeString(XSI_URI, LUNS_STORAGE_TYPE, conn.getStorageType().name());
            _writer.writeAttributeString(XSI_URI, LUNS_PORTAL, conn.getPortal());
            _writer.writeEndElement();
        }
    }
}
#end_block

#method_before
private void writeUserData() {
    Set<DbUser> dbUsers = fullEntityOvfData.getDbUsers();
    if (dbUsers == null || dbUsers.isEmpty()) {
        return;
    }
    _writer.writeStartElement("Section");
    _writer.writeAttributeString(XSI_URI, "type", "ovf:UserDomainsSection_Type");
    dbUsers.forEach(dbUser -> {
        _writer.writeStartElement(OvfProperties.USER);
        _writer.writeElement(OvfProperties.USER_DOMAIN, String.format("%s@%s", dbUser.getName(), dbUser.getDomain()));
        _writer.writeStartElement(OvfProperties.USER_ROLES);
        Set<String> roles = fullEntityOvfData.getUserToRoles().getOrDefault(dbUser.getLoginName(), Collections.EMPTY_SET);
        roles.forEach(role -> _writer.writeElement(OvfProperties.ROLE_NAME, role));
        _writer.writeEndElement();
        _writer.writeEndElement();
    });
    _writer.writeEndElement();
}
#method_after
private void writeUserData() {
    Set<DbUser> dbUsers = fullEntityOvfData.getDbUsers();
    if (dbUsers.isEmpty()) {
        return;
    }
    _writer.writeStartElement("Section");
    _writer.writeAttributeString(XSI_URI, "type", "ovf:UserDomainsSection_Type");
    dbUsers.forEach(dbUser -> {
        _writer.writeStartElement(OvfProperties.USER);
        _writer.writeElement(OvfProperties.USER_DOMAIN, String.format("%s@%s", dbUser.getName(), dbUser.getDomain()));
        _writer.writeStartElement(OvfProperties.USER_ROLES);
        Set<String> roles = fullEntityOvfData.getUserToRoles().getOrDefault(dbUser.getLoginName(), Collections.emptySet());
        roles.forEach(role -> _writer.writeElement(OvfProperties.ROLE_NAME, role));
        // Close the <UserRoles> element
        _writer.writeEndElement();
        // Close the <User> element
        _writer.writeEndElement();
    });
    _writer.writeEndElement();
}
#end_block

#method_before
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    List<VmNetworkInterface> nicsUnableToBeImported = getVm().getInterfaces().stream().filter(this::ifaceMacCannotBeAddedToMacPool).collect(Collectors.toList());
    if (!nicsUnableToBeImported.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_ADD_IFACE_DUE_TO_MAC_DUPLICATES;
        Collection<String> replacements = ReplacementUtils.getListVariableAssignmentString(engineMessage, nicsUnableToBeImported);
        return validate(new ValidationResult(engineMessage, replacements));
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    List<VmNetworkInterface> nicsUnableToBeImported = getVm().getInterfaces().stream().filter(this::ifaceMacCannotBeAddedToMacPool).collect(Collectors.toList());
    if (!nicsUnableToBeImported.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_ADD_IFACE_DUE_TO_MAC_DUPLICATES;
        Collection<String> replacements = ReplacementUtils.getListVariableAssignmentString(engineMessage, nicsUnableToBeImported);
        return validate(new ValidationResult(engineMessage, replacements));
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getVm().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    return true;
}
#end_block

#method_before
private boolean ifaceMacCannotBeAddedToMacPool(VmNetworkInterface iface) {
    return iface.getMacAddress() != null && !macPool.isDuplicateMacAddressesAllowed() && !shouldReassignMac(iface) && macPool.isMacInUse(iface.getMacAddress());
}
#method_after
private boolean ifaceMacCannotBeAddedToMacPool(VmNetworkInterface iface) {
    return !macPool.isDuplicateMacAddressesAllowed() && !shouldReassignMac(iface) && macPool.isMacInUse(iface.getMacAddress());
}
#end_block

#method_before
protected void mapDbUsers() {
// Left empty to override in ImportVmFromConfiguration
}
#method_after
protected void mapDbUsers() {
// Left empty to be overridden by ImportVmFromConfiguration
}
#end_block

#method_before
protected void addVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setCreationDate(new Date());
    getVm().getStaticData().setClusterId(getParameters().getClusterId());
    getVm().getStaticData().setMinAllocatedMem(computeMinAllocatedMem());
    getVm().getStaticData().setQuotaId(getParameters().getQuotaId());
    // if "run on host" field points to a non existent vds (in the current cluster) -> remove field and continue
    if (!vmHandler.validateDedicatedVdsExistOnSameCluster(getVm().getStaticData()).isValid()) {
        getVm().setDedicatedVmForVdsList(Collections.emptyList());
    }
    if (getVm().getOriginalTemplateGuid() != null && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getOriginalTemplateGuid())) {
        // no need to check this for blank
        VmTemplate originalTemplate = vmTemplateDao.get(getVm().getOriginalTemplateGuid());
        if (originalTemplate != null) {
            // in case the original template name has been changed in the meantime
            getVm().getStaticData().setOriginalTemplateName(originalTemplate.getName());
        }
    }
    if (getParameters().getCopyCollapse()) {
        getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    }
    vmStaticDao.save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#method_after
protected void addVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setCreationDate(new Date());
    getVm().getStaticData().setClusterId(getParameters().getClusterId());
    getVm().getStaticData().setMinAllocatedMem(computeMinAllocatedMem());
    getVm().getStaticData().setQuotaId(getParameters().getQuotaId());
    // if "run on host" field points to a non existent vds (in the current cluster) -> remove field and continue
    if (!vmHandler.validateDedicatedVdsExistOnSameCluster(getVm().getStaticData()).isValid()) {
        getVm().setDedicatedVmForVdsList(Collections.emptyList());
    }
    if (getVm().getOriginalTemplateGuid() != null && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getOriginalTemplateGuid())) {
        // no need to check this for blank
        VmTemplate originalTemplate = vmTemplateDao.get(getVm().getOriginalTemplateGuid());
        if (originalTemplate != null) {
            // in case the original template name has been changed in the meantime
            getVm().getStaticData().setOriginalTemplateName(originalTemplate.getName());
        }
    }
    if (getParameters().getCopyCollapse()) {
        getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    }
    vmHandler.autoSelectResumeBehavior(getVm().getStaticData(), getCluster());
    vmStaticDao.save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#end_block

#method_before
private boolean shouldReassignMac(VmNetworkInterface iface) {
    return (getParameters().isReassignBadMacs() && vNicHasBadMac(iface)) || getParameters().isImportAsNewEntity();
}
#method_after
private boolean shouldReassignMac(VmNetworkInterface iface) {
    return StringUtils.isEmpty(iface.getMacAddress()) || (getParameters().isReassignBadMacs() && vNicHasBadMac(iface)) || getParameters().isImportAsNewEntity();
}
#end_block

#method_before
private void initInterface(VmNic iface) {
    if (iface.getId() == null) {
        iface.setId(Guid.newGuid());
    }
    fillMacAddressIfMissing(iface);
    iface.setVmTemplateId(null);
    iface.setVmId(getVmId());
}
#method_after
private void initInterface(VmNic iface) {
    if (iface.getId() == null) {
        iface.setId(Guid.newGuid());
    }
    iface.setVmTemplateId(null);
    iface.setVmId(getVmId());
}
#end_block

#method_before
@Override
protected void readLunDisk(XmlNode node, LunDisk lun) {
    lun.setDiskVmElements(Collections.singletonList(new DiskVmElement(lun.getId(), fullEntityOvfData.getVmBase().getId())));
    LUNs luns = new LUNs();
    consumeReadXmlAttribute(node, OVF_PREFIX + COLON + LUN_DISCARD_ZEROES_DATA, val -> luns.setDiscardZeroesData(Boolean.parseBoolean(val)));
    consumeReadXmlAttribute(node, OVF_PREFIX + COLON + LUN_DISCARD_MAX_SIZE, val -> luns.setDiscardMaxSize(Long.parseLong(val)));
    consumeReadXmlAttribute(node, OVF_PREFIX + COLON + LUN_DEVICE_SIZE, val -> luns.setDeviceSize(Integer.parseInt(val)));
    consumeReadXmlAttribute(node, OVF_PREFIX + COLON + LUN_PRODUCT_ID, val -> luns.setProductId(val));
    consumeReadXmlAttribute(node, OVF_PREFIX + COLON + LUN_VENDOR_ID, val -> luns.setVendorId(val));
    consumeReadXmlAttribute(node, OVF_PREFIX + COLON + LUN_MAPPING, val -> luns.setLunMapping(Integer.parseInt(val)));
    consumeReadXmlAttribute(node, OVF_PREFIX + COLON + LUN_SERIAL, val -> luns.setSerial(val));
    consumeReadXmlAttribute(node, OVF_PREFIX + COLON + LUN_VOLUME_GROUP_ID, val -> luns.setVolumeGroupId(val));
    consumeReadXmlAttribute(node, OVF_PREFIX + COLON + LUN_ID, val -> luns.setLUNId(val));
    consumeReadXmlAttribute(node, OVF_PREFIX + COLON + LUN_PHYSICAL_VOLUME_ID, val -> luns.setPhysicalVolumeId(val));
    ArrayList<StorageServerConnections> lunConnections = new ArrayList<>();
    for (XmlNode connNode : selectNodes(node, LUN_CONNECTION)) {
        StorageServerConnections conn = new StorageServerConnections();
        consumeReadXmlAttribute(connNode, OVF_PREFIX + COLON + LUNS_CONNECTION, val -> conn.setConnection(val));
        consumeReadXmlAttribute(connNode, OVF_PREFIX + COLON + LUNS_IQN, val -> conn.setIqn(val));
        consumeReadXmlAttribute(connNode, OVF_PREFIX + COLON + LUNS_PORT, val -> conn.setPort(val));
        consumeReadXmlAttribute(connNode, XSI_PREFIX + COLON + LUNS_STORAGE_TYPE, val -> conn.setStorageType(StorageType.valueOf(val)));
        consumeReadXmlAttribute(connNode, XSI_PREFIX + COLON + LUNS_PORTAL, val -> conn.setPortal(val));
        // TODO: Username and password should be initilaized by the mapping file.
        // conn.setUsername(FromMap);
        // conn.setPassword(FromMap);
        lunConnections.add(conn);
    }
    luns.setLunConnections(lunConnections);
    lun.setLun(luns);
    DiskVmElement dve = lun.getDiskVmElementForVm(fullEntityOvfData.getVmBase().getId());
    initGeneralDiskAttributes(node, lun, dve);
}
#method_after
@Override
protected void readLunDisk(XmlNode node, LunDisk lun) {
    lun.setDiskVmElements(Collections.singletonList(new DiskVmElement(lun.getId(), fullEntityOvfData.getVmBase().getId())));
    LUNs luns = new LUNs();
    consumeReadXmlAttribute(node, OVF_PREFIX + COLON + LUN_ID, val -> luns.setLUNId(val));
    ArrayList<StorageServerConnections> lunConnections = new ArrayList<>();
    for (XmlNode connNode : selectNodes(node, LUN_CONNECTION)) {
        StorageServerConnections conn = new StorageServerConnections();
        consumeReadXmlAttribute(connNode, OVF_PREFIX + COLON + LUNS_CONNECTION, val -> conn.setConnection(val));
        consumeReadXmlAttribute(connNode, OVF_PREFIX + COLON + LUNS_IQN, val -> conn.setIqn(val));
        consumeReadXmlAttribute(connNode, OVF_PREFIX + COLON + LUNS_PORT, val -> conn.setPort(val));
        consumeReadXmlAttribute(connNode, XSI_PREFIX + COLON + LUNS_STORAGE_TYPE, val -> conn.setStorageType(StorageType.valueOf(val)));
        consumeReadXmlAttribute(connNode, XSI_PREFIX + COLON + LUNS_PORTAL, val -> conn.setPortal(val));
        lunConnections.add(conn);
    }
    luns.setLunConnections(lunConnections);
    lun.setLun(luns);
    DiskVmElement dve = lun.getDiskVmElementForVm(fullEntityOvfData.getVmBase().getId());
    initGeneralDiskAttributes(node, lun, dve);
}
#end_block

#method_before
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            mapCluster(fullEntityOvfData.getClusterName());
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setAffinityGroups(fullEntityOvfData.getAffinityGroups());
            getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
            mapExternalLunDisks(DisksFilter.filterLunDisks(vmFromConfiguration.getDiskMap().values()));
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#method_after
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            mapCluster(fullEntityOvfData.getClusterName());
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setAffinityGroups(fullEntityOvfData.getAffinityGroups());
            getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
            // Note: The VM's OVF does not preserve the username and password for the LUN's connection.
            // Therefore to achieve a simple VM registration the iSCSI storage server should not use
            // credentials, although if the user will use the mapping attribute, one can set the credentials through
            // there.
            mapExternalLunDisks(DisksFilter.filterLunDisks(vmFromConfiguration.getDiskMap().values()));
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
@Override
public void addVmToAffinityGroups() {
    mapAffinityGroups().forEach(affinityGroup -> {
        affinityGroup.setClusterId(getParameters().getClusterId());
        Set<Guid> vmIds = new HashSet<>(affinityGroup.getVmIds());
        vmIds.add(getParameters().getVm().getId());
        affinityGroup.setVmIds(vmIds.stream().collect(Collectors.toList()));
        affinityGroupDao.update(affinityGroup);
    });
}
#method_after
@Override
public void addVmToAffinityGroups() {
    mapAffinityGroups().forEach(affinityGroup -> {
        affinityGroup.setClusterId(getParameters().getClusterId());
        Set<Guid> vmIds = new HashSet<>(affinityGroup.getVmIds());
        vmIds.add(getParameters().getVm().getId());
        affinityGroup.setVmIds(new ArrayList<>(vmIds));
        affinityGroupDao.update(affinityGroup);
    });
}
#end_block

#method_before
@Override
protected void mapDbUsers() {
    Map<String, String> userDomainsMap = getParameters().getDomainMap();
    getParameters().getDbUsers().forEach(dbUser -> {
        DbUser originalDbUser = dbUserDao.getByUsernameAndDomain(dbUser.getLoginName(), dbUser.getDomain());
        if (userDomainsMap != null) {
            String destDomain = userDomainsMap.get(dbUser.getDomain());
            if (destDomain != null) {
                DbUser destDbUser = dbUserDao.getByUsernameAndDomain(dbUser.getLoginName(), destDomain);
                if (destDbUser != null) {
                    addPermissions(destDbUser, getParameters().getUserToRoles().getOrDefault(destDbUser.getLoginName(), Collections.EMPTY_SET));
                }
            } else if (originalDbUser != null) {
                addPermissions(originalDbUser, getParameters().getUserToRoles().getOrDefault(originalDbUser.getLoginName(), Collections.EMPTY_SET));
            }
        } else {
            addPermissions(originalDbUser, getParameters().getUserToRoles().getOrDefault(originalDbUser.getLoginName(), Collections.EMPTY_SET));
        }
    });
}
#method_after
@Override
protected void mapDbUsers() {
    Map<String, String> userDomainsMap = getParameters().getDomainMap();
    getParameters().getDbUsers().forEach(dbUser -> {
        DbUser originalDbUser = dbUserDao.getByUsernameAndDomain(dbUser.getLoginName(), dbUser.getDomain());
        if (userDomainsMap != null) {
            String destDomain = userDomainsMap.get(dbUser.getDomain());
            if (destDomain != null) {
                DbUser destDbUser = dbUserDao.getByUsernameAndDomain(dbUser.getLoginName(), destDomain);
                if (destDbUser != null) {
                    addPermissionsForUser(destDbUser, getParameters().getUserToRoles());
                }
            } else if (originalDbUser != null) {
                addPermissionsForUser(originalDbUser, getParameters().getUserToRoles());
            }
        } else if (originalDbUser != null) {
            addPermissionsForUser(originalDbUser, getParameters().getUserToRoles());
        }
    });
}
#end_block

#method_before
private String buildMetadataDictionaryForVm(VM vm) {
    List<DiskImage> allVmImages = new ArrayList<>();
    List<DiskImage> filteredDisks = DisksFilter.filterImageDisks(vm.getDiskList(), ONLY_SNAPABLE, ONLY_ACTIVE);
    List<LunDisk> lunDisks = DisksFilter.filterLunDisks(vm.getDiskMap().values());
    List<AffinityGroup> affinityGroups = affinityGroupDao.getAllAffinityGroupsByVmId(vm.getId());
    Set<DbUser> dbUsers = new HashSet<>(dbUserDao.getAllForVm(vm.getId()));
    for (DiskImage diskImage : filteredDisks) {
        List<DiskImage> images = diskImageDao.getAllSnapshotsForLeaf(diskImage.getImageId());
        images.forEach(d -> d.setDiskVmElements(Collections.singletonList(diskImage.getDiskVmElementForVm(vm.getId()))));
        allVmImages.addAll(images);
    }
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(vm);
    fullEntityOvfData.setDiskImages(allVmImages);
    fullEntityOvfData.setLunDisks(lunDisks);
    fullEntityOvfData.setAffinityGroups(affinityGroups);
    fullEntityOvfData.setDbUsers(dbUsers);
    populateUserToRoles(fullEntityOvfData);
    return ovfManager.exportVm(vm, fullEntityOvfData, clusterUtils.getCompatibilityVersion(vm));
}
#method_after
private String buildMetadataDictionaryForVm(VM vm) {
    List<DiskImage> allVmImages = new ArrayList<>();
    List<DiskImage> filteredDisks = DisksFilter.filterImageDisks(vm.getDiskList(), ONLY_SNAPABLE, ONLY_ACTIVE);
    List<LunDisk> lunDisks = DisksFilter.filterLunDisks(vm.getDiskMap().values());
    List<AffinityGroup> affinityGroups = affinityGroupDao.getAllAffinityGroupsByVmId(vm.getId());
    Set<DbUser> dbUsers = new HashSet<>(dbUserDao.getAllForVm(vm.getId()));
    for (DiskImage diskImage : filteredDisks) {
        List<DiskImage> images = diskImageDao.getAllSnapshotsForLeaf(diskImage.getImageId());
        images.forEach(d -> d.setDiskVmElements(Collections.singletonList(diskImage.getDiskVmElementForVm(vm.getId()))));
        allVmImages.addAll(images);
    }
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(vm);
    fullEntityOvfData.setDiskImages(allVmImages);
    fullEntityOvfData.setLunDisks(lunDisks);
    fullEntityOvfData.setAffinityGroups(affinityGroups);
    fullEntityOvfData.setDbUsers(dbUsers);
    populateUserToRoles(fullEntityOvfData, vm.getId());
    return ovfManager.exportVm(vm, fullEntityOvfData, clusterUtils.getCompatibilityVersion(vm));
}
#end_block

#method_before
private void populateUserToRoles(FullEntityOvfData fullEntityOvfData) {
    Map<String, Set<String>> userToRoles = new HashMap<>();
    fullEntityOvfData.getDbUsers().forEach(dbUser -> {
        Set<String> roles = new HashSet<>();
        List<Permission> permissions = permissionDao.getAllDirectPermissionsForAdElement(dbUser.getId());
        permissions.forEach(permission -> roles.add(permission.getRoleName()));
        userToRoles.put(dbUser.getLoginName(), roles);
    });
    fullEntityOvfData.setUserToRoles(userToRoles);
}
#method_after
public void populateUserToRoles(FullEntityOvfData fullEntityOvfData, Guid entityId) {
    Map<String, Set<String>> userToRoles = new HashMap<>();
    fullEntityOvfData.getDbUsers().forEach(dbUser -> {
        Set<String> roles = new HashSet<>();
        List<Permission> permissions = permissionDao.getAllForAdElementAndObjectId(dbUser.getId(), entityId);
        permissions.forEach(permission -> roles.add(permission.getRoleName()));
        userToRoles.put(dbUser.getLoginName(), roles);
    });
    fullEntityOvfData.setUserToRoles(userToRoles);
}
#end_block

#method_before
protected void proccessDomainsForOvfUpdate(StoragePool pool) {
    List<StorageDomain> domainsInPool = storageDomainDao.getAllForStoragePool(pool.getId());
    for (StorageDomain domain : domainsInPool) {
        if (!domain.getStorageDomainType().isDataDomain() || domain.getStatus() != StorageDomainStatus.Active) {
            continue;
        }
        activeDataDomainsIds.add(domain.getId());
        Integer ovfStoresCountForDomain = Config.<Integer>getValue(ConfigValues.StorageDomainOvfStoreCount);
        List<StorageDomainOvfInfo> storageDomainOvfInfos = storageDomainOvfInfoDao.getAllForDomain(domain.getId());
        if (storageDomainOvfInfos.size() < ovfStoresCountForDomain) {
            proccessedDomains.add(domain.getId());
            continue;
        }
        for (StorageDomainOvfInfo storageDomainOvfInfo : storageDomainOvfInfos) {
            if (storageDomainOvfInfo.getStatus() == StorageDomainOvfInfoStatus.OUTDATED) {
                proccessedDomains.add(storageDomainOvfInfo.getStorageDomainId());
                break;
            }
        }
    }
}
#method_after
protected void proccessDomainsForOvfUpdate(StoragePool pool) {
    List<StorageDomain> domainsInPool = storageDomainDao.getAllForStoragePool(pool.getId());
    for (StorageDomain domain : domainsInPool) {
        if (!domain.getStorageDomainType().isDataDomain() || (domain.getStatus() != StorageDomainStatus.Active && getParameters().getStorageDomainId() != null && !domain.getId().equals(getParameters().getStorageDomainId()))) {
            continue;
        }
        activeDataDomainsIds.add(domain.getId());
        Integer ovfStoresCountForDomain = Config.<Integer>getValue(ConfigValues.StorageDomainOvfStoreCount);
        List<StorageDomainOvfInfo> storageDomainOvfInfos = storageDomainOvfInfoDao.getAllForDomain(domain.getId());
        if (storageDomainOvfInfos.size() < ovfStoresCountForDomain) {
            proccessedDomains.add(domain.getId());
            continue;
        }
        for (StorageDomainOvfInfo storageDomainOvfInfo : storageDomainOvfInfos) {
            if (storageDomainOvfInfo.getStatus() == StorageDomainOvfInfoStatus.OUTDATED) {
                proccessedDomains.add(storageDomainOvfInfo.getStorageDomainId());
                break;
            }
        }
    }
}
#end_block

#method_before
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateVmsMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<>();
    List<VM> vms = vmDao.getVmsByIds(idsToProcess);
    for (VM vm : vms) {
        if (VMStatus.ImageLocked != vm.getStatus()) {
            updateVmDisksFromDb(vm);
            if (!verifyImagesStatus(vm.getDiskList())) {
                continue;
            }
            ArrayList<DiskImage> vmImages = ovfUpdateProcessHelper.getVmImagesFromDb(vm);
            if (!verifyImagesStatus(vmImages)) {
                continue;
            }
            vm.setSnapshots(snapshotDao.getAllWithConfiguration(vm.getId()));
            if (!verifySnapshotsStatus(vm.getSnapshots())) {
                continue;
            }
            ovfUpdateProcessHelper.loadVmData(vm);
            Long currentDbGeneration = vmStaticDao.getDbGeneration(vm.getId());
            if (currentDbGeneration == null) {
                log.warn("currentDbGeneration of VM (name: '{}', id: '{}') is null, probably because the VM was deleted during the run of OvfDataUpdater.", vm.getName(), vm.getId());
                continue;
            }
            if (vm.getStaticData().getDbGeneration() == currentDbGeneration) {
                List<LunDisk> lunDisks = DisksFilter.filterLunDisks(vm.getDiskMap().values());
                for (LunDisk lun : lunDisks) {
                    lun.getLun().setLunConnections(new ArrayList<>(storageServerConnectionDao.getAllForLun(lun.getLun().getId())));
                }
                List<AffinityGroup> affinityGroups = affinityGroupDao.getAllAffinityGroupsByVmId(vm.getId());
                Set<DbUser> dbUsers = new HashSet<>(dbUserDao.getAllForVm(vm.getId()));
                FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(vm);
                fullEntityOvfData.setDiskImages(vmImages);
                fullEntityOvfData.setLunDisks(lunDisks);
                fullEntityOvfData.setAffinityGroups(affinityGroups);
                fullEntityOvfData.setDbUsers(dbUsers);
                populateUserToRoles(fullEntityOvfData);
                proccessedOvfConfigurationsInfo.add(ovfUpdateProcessHelper.buildMetadataDictionaryForVm(vm, vmsAndTemplateMetadata, fullEntityOvfData));
                proccessedIdsInfo.add(vm.getId());
                proccessedOvfGenerationsInfo.add(vm.getStaticData().getDbGeneration());
                proccessDisksDomains(vm.getDiskList());
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#method_after
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateVmsMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<>();
    List<VM> vms = vmDao.getVmsByIds(idsToProcess);
    for (VM vm : vms) {
        if (VMStatus.ImageLocked != vm.getStatus()) {
            updateVmDisksFromDb(vm);
            if (!verifyImagesStatus(vm.getDiskList())) {
                continue;
            }
            ArrayList<DiskImage> vmImages = ovfUpdateProcessHelper.getVmImagesFromDb(vm);
            if (!verifyImagesStatus(vmImages)) {
                continue;
            }
            vm.setSnapshots(snapshotDao.getAllWithConfiguration(vm.getId()));
            if (!verifySnapshotsStatus(vm.getSnapshots())) {
                continue;
            }
            ovfUpdateProcessHelper.loadVmData(vm);
            Long currentDbGeneration = vmStaticDao.getDbGeneration(vm.getId());
            if (currentDbGeneration == null) {
                log.warn("currentDbGeneration of VM (name: '{}', id: '{}') is null, probably because the VM was deleted during the run of OvfDataUpdater.", vm.getName(), vm.getId());
                continue;
            }
            if (vm.getStaticData().getDbGeneration() == currentDbGeneration) {
                List<LunDisk> lunDisks = DisksFilter.filterLunDisks(vm.getDiskMap().values());
                for (LunDisk lun : lunDisks) {
                    lun.getLun().setLunConnections(new ArrayList<>(storageServerConnectionDao.getAllForLun(lun.getLun().getId())));
                }
                List<AffinityGroup> affinityGroups = affinityGroupDao.getAllAffinityGroupsByVmId(vm.getId());
                Set<DbUser> dbUsers = new HashSet<>(dbUserDao.getAllForVm(vm.getId()));
                FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(vm);
                fullEntityOvfData.setDiskImages(vmImages);
                fullEntityOvfData.setLunDisks(lunDisks);
                fullEntityOvfData.setAffinityGroups(affinityGroups);
                fullEntityOvfData.setDbUsers(dbUsers);
                ovfHelper.populateUserToRoles(fullEntityOvfData, vm.getId());
                proccessedOvfConfigurationsInfo.add(ovfUpdateProcessHelper.buildMetadataDictionaryForVm(vm, vmsAndTemplateMetadata, fullEntityOvfData));
                proccessedIdsInfo.add(vm.getId());
                proccessedOvfGenerationsInfo.add(vm.getStaticData().getDbGeneration());
                proccessDisksDomains(vm.getDiskList());
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#end_block

#method_before
public Map<String, byte[]> getFileData() throws UnsupportedEncodingException, IOException, JsonGenerationException, JsonMappingException {
    if (vmInit != null) {
        try {
            storeHostname();
            storeAuthorizedKeys();
            storeRegenerateKeys();
            storeNetwork();
            storeTimeZone();
            storeRootPassword();
            storeUserName();
        } catch (IllegalArgumentException ex) {
            throw new IllegalArgumentException("Malformed input", ex);
        }
    }
    // Add other required/supplemental data
    storeExecutionParameters();
    String metaDataStr = mapToJson(metaData);
    String userDataStr = mapToYaml(userData);
    String networkDataStr = mapToJson(networkData);
    if (vmInit != null && vmInit.getCustomScript() != null) {
        userDataStr += vmInit.getCustomScript();
    }
    // add #cloud-config for user data file head
    if (StringUtils.isNotBlank(userDataStr)) {
        userDataStr = "#cloud-config\n" + userDataStr;
    }
    files.put("openstack/latest/meta_data.json", metaDataStr.getBytes("UTF-8"));
    files.put("openstack/latest/user_data", userDataStr.getBytes("UTF-8"));
    files.put("openstack/latest/network_data.json", networkDataStr.getBytes("UTF-8"));
    // mask password for log if exists
    if (metaDataStr.contains(passwordKey) && vmInit != null && vmInit.getRootPassword() != null) {
        String oldStr = String.format("\"%s\" : \"%s\"", passwordKey, vmInit.getRootPassword());
        String newStr = String.format("\"%s\" : ***", passwordKey);
        metaDataStr = metaDataStr.replace(oldStr, newStr);
    }
    log.debug("cloud-init meta-data:\n{}", metaDataStr);
    log.debug("cloud-init user-data:\n{}", userDataStr);
    log.debug("cloud-init network-data:\n{}", networkDataStr);
    return files;
}
#method_after
public Map<String, byte[]> getFileData() throws UnsupportedEncodingException, IOException, JsonGenerationException, JsonMappingException {
    if (vmInit != null) {
        try {
            storeHostname();
            storeAuthorizedKeys();
            storeRegenerateKeys();
            storeNetwork();
            storeTimeZone();
            storeRootPassword();
            storeUserName();
        } catch (IllegalArgumentException ex) {
            throw new IllegalArgumentException("Malformed input", ex);
        }
    }
    // Add other required/supplemental data
    storeExecutionParameters();
    String metaDataStr = mapToJson(metaData);
    String userDataStr = mapToYaml(userData);
    String networkDataStr = !MapUtils.isEmpty(networkData) ? mapToJson(networkData) : "";
    if (vmInit != null && vmInit.getCustomScript() != null) {
        userDataStr += vmInit.getCustomScript();
    }
    // add #cloud-config for user data file head
    if (StringUtils.isNotBlank(userDataStr)) {
        userDataStr = "#cloud-config\n" + userDataStr;
    }
    files.put("openstack/latest/meta_data.json", metaDataStr.getBytes("UTF-8"));
    files.put("openstack/latest/user_data", userDataStr.getBytes("UTF-8"));
    if (isOpenstackMetadataProtocol() && !StringUtils.isEmpty(networkDataStr)) {
        // must not pass an empty file or a file with an empty json to cloud-init-0.7.9-9 because the whole init flow fails
        files.put("openstack/latest/network_data.json", networkDataStr.getBytes("UTF-8"));
    }
    // mask password for log if exists
    if (metaDataStr.contains(passwordKey) && vmInit != null && vmInit.getRootPassword() != null) {
        String oldStr = String.format("\"%s\" : \"%s\"", passwordKey, vmInit.getRootPassword());
        String newStr = String.format("\"%s\" : ***", passwordKey);
        metaDataStr = metaDataStr.replace(oldStr, newStr);
    }
    log.debug("cloud-init meta-data:\n{}", metaDataStr);
    log.debug("cloud-init user-data:\n{}", userDataStr);
    if (isOpenstackMetadataProtocol()) {
        log.debug("cloud-init network-data:\n{}", networkDataStr);
    }
    return files;
}
#end_block

#method_before
private void storeNetwork() throws UnsupportedEncodingException {
    if (sourceProtocol.equals(NetConfigSourceProtocol.OPENSTACK_METADATA)) {
        networkData = new VmInitToOpenStackMetadata(vmInit).asMap();
    } else {
        storeNetworkAsEni();
    }
}
#method_after
private void storeNetwork() throws UnsupportedEncodingException {
    if (isOpenstackMetadataProtocol()) {
        networkData = new VmInitToOpenStackMetadataAdapter().asMap(vmInit);
    } else {
        storeNetworkAsEni();
    }
}
#end_block

#method_before
@Parameterized.Parameters(name = "{index}: {1}")
public static Collection<Object[]> params() {
    Pair noneAndNone = noneAndNone();
    Pair staticIPv4 = staticIPv4();
    Pair staticIPv6 = staticIPv6();
    Pair staticIPv6AddressOnly = staticIPv6AddressOnly();
    Pair staticIPv4AndIPv6 = staticIPv4AndIPv6();
    Pair dhcpIPv4 = dhcpIPv4();
    Pair dhcpIPv6 = dhcpIPv6();
    Pair dnsServersOnly = dnsServersOnly();
    return Arrays.asList(new Object[][] { { noneAndNone.getFirst(), noneAndNone.getSecond() }, { staticIPv4.getFirst(), staticIPv4.getSecond() }, { staticIPv6.getFirst(), staticIPv6.getSecond() }, { staticIPv6AddressOnly.getFirst(), staticIPv6AddressOnly.getSecond() }, { staticIPv4AndIPv6.getFirst(), staticIPv4AndIPv6.getSecond() }, { dhcpIPv4.getFirst(), dhcpIPv4.getSecond() }, { dhcpIPv6.getFirst(), dhcpIPv6.getSecond() }, { dnsServersOnly.getFirst(), dnsServersOnly.getSecond() } });
}
#method_after
@Parameterized.Parameters(name = "{index}: {1}")
public static Collection<Object[]> params() {
    Pair noneAndNone = noneAndNone();
    Pair staticIPv4 = staticIPv4();
    Pair staticIPv6 = staticIPv6();
    Pair staticIPv6AddressOnly = staticIPv6AddressOnly();
    Pair staticIPv4AndIPv6 = staticIPv4AndIPv6();
    Pair dhcpIPv4 = dhcpIPv4();
    Pair dhcpIPv6 = dhcpIPv6();
    Pair dnsServersOnly = dnsServersOnly();
    Pair startOnBootFalse = startOnBootFalse();
    return Arrays.asList(new Object[][] { { noneAndNone.getFirst(), noneAndNone.getSecond() }, { staticIPv4.getFirst(), staticIPv4.getSecond() }, { staticIPv6.getFirst(), staticIPv6.getSecond() }, { staticIPv6AddressOnly.getFirst(), staticIPv6AddressOnly.getSecond() }, { staticIPv4AndIPv6.getFirst(), staticIPv4AndIPv6.getSecond() }, { dhcpIPv4.getFirst(), dhcpIPv4.getSecond() }, { dhcpIPv6.getFirst(), dhcpIPv6.getSecond() }, { dnsServersOnly.getFirst(), dnsServersOnly.getSecond() }, { startOnBootFalse.getFirst(), startOnBootFalse.getSecond() } });
}
#end_block

#method_before
@Test
public void test() throws IOException {
    CloudInitHandler underTest = new CloudInitHandler(vmInit, NetConfigSourceProtocol.OPENSTACK_METADATA);
    final Map<String, byte[]> actual = underTest.getFileData();
    Map<String, Object> actualNetworkData = parseResult(actual);
    Map<String, Object> expectedNetworkData = JsonHelper.jsonToMap(expected);
    assertEquals(expectedNetworkData, actualNetworkData);
}
#method_after
@Test
public void test() throws IOException {
    CloudInitHandler underTest = new CloudInitHandler(vmInit, NetConfigSourceProtocol.OPENSTACK_METADATA);
    try {
        Map<String, byte[]> actual = underTest.getFileData();
        if (actual.get("openstack/latest/network_data.json") == null) {
            assertNull(expected);
        } else {
            Map<String, Object> actualNetworkData = parseResult(actual);
            Map<String, Object> expectedNetworkData = JsonHelper.jsonToMap((String) expected);
            assertEquals(expectedNetworkData, actualNetworkData);
            assertEquals(0, underTest.validate(vmInit).size());
        }
    } catch (Exception e) {
        assertEquals(((Exception) expected).getMessage(), e.getMessage());
        assertEquals(((Exception) expected).getCause().getMessage(), e.getCause().getMessage());
        assertNotEquals(0, underTest.validate(vmInit).size());
    }
}
#end_block

#method_before
private static Pair staticIPv4() {
    final VmInitNetwork underTest = new VmInitNetwork();
    underTest.setName(IFACE_NAME);
    underTest.setBootProtocol(Ipv4BootProtocol.STATIC_IP);
    underTest.setIp(IPV4_ADDRESS);
    underTest.setNetmask(IPV4_NETMASK);
    underTest.setGateway(IPV4_GATEWAY);
    VmInit vmInit = new VmInit();
    vmInit.setNetworks(Arrays.asList(underTest));
    String expectedOutput = "{\n" + "  \"links\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"vif\",\n" + "      \"name\": \"iface name\"\n" + "    }\n" + "  ],\n" + "  \"networks\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"ipv4\",\n" + "      \"link\": \"iface name\",\n" + "      \"ip_address\": \"ipv4 address\",\n" + "      \"netmask\": \"ipv4 netmask\",\n" + "      \"gateway\": \"ipv4 gateway\"\n" + "    }\n" + "  ]\n" + "}";
    return new Pair(vmInit, expectedOutput);
}
#method_after
private static Pair staticIPv4() {
    final VmInitNetwork underTest = new VmInitNetwork();
    underTest.setName(IFACE_NAME);
    underTest.setBootProtocol(Ipv4BootProtocol.STATIC_IP);
    underTest.setIp(IPV4_ADDRESS);
    underTest.setNetmask(IPV4_NETMASK);
    underTest.setGateway(IPV4_GATEWAY);
    underTest.setStartOnBoot(true);
    VmInit vmInit = new VmInit();
    vmInit.setNetworks(Arrays.asList(underTest));
    String expectedOutput = "{\n" + "  \"links\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"vif\",\n" + "      \"name\": \"iface name\"\n" + "    }\n" + "  ],\n" + "  \"networks\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"ipv4\",\n" + "      \"link\": \"iface name\",\n" + "      \"ip_address\": \"ipv4 address\",\n" + "      \"netmask\": \"ipv4 netmask\",\n" + "      \"gateway\": \"ipv4 gateway\"\n" + "    }\n" + "  ]\n" + "}";
    return new Pair(vmInit, expectedOutput);
}
#end_block

#method_before
private static Pair staticIPv6AddressOnly() {
    final VmInitNetwork underTest = new VmInitNetwork();
    underTest.setName(IFACE_NAME);
    underTest.setIpv6BootProtocol(Ipv6BootProtocol.STATIC_IP);
    underTest.setIpv6Address(IPV6_ADDRESS);
    VmInit vmInit = new VmInit();
    vmInit.setNetworks(Arrays.asList(underTest));
    String expectedOutput = "{\n" + "  \"links\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"vif\",\n" + "      \"name\": \"iface name\"\n" + "    }\n" + "  ],\n" + "  \"networks\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"ipv6\",\n" + "      \"link\": \"iface name\",\n" + "      \"ip_address\": \"ipv6 address\"\n" + "    }\n" + "  ]\n" + "}";
    return new Pair(vmInit, expectedOutput);
}
#method_after
private static Pair staticIPv6AddressOnly() {
    final VmInitNetwork underTest = new VmInitNetwork();
    underTest.setName(IFACE_NAME);
    underTest.setIpv6BootProtocol(Ipv6BootProtocol.STATIC_IP);
    underTest.setIpv6Address(IPV6_ADDRESS);
    underTest.setStartOnBoot(true);
    VmInit vmInit = new VmInit();
    vmInit.setNetworks(Arrays.asList(underTest));
    String expectedOutput = "{\n" + "  \"links\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"vif\",\n" + "      \"name\": \"iface name\"\n" + "    }\n" + "  ],\n" + "  \"networks\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"ipv6\",\n" + "      \"link\": \"iface name\",\n" + "      \"ip_address\": \"ipv6 address\"\n" + "    }\n" + "  ]\n" + "}";
    return new Pair(vmInit, expectedOutput);
}
#end_block

#method_before
private static Pair staticIPv6() {
    final VmInitNetwork underTest = new VmInitNetwork();
    underTest.setName(IFACE_NAME);
    underTest.setIpv6BootProtocol(Ipv6BootProtocol.STATIC_IP);
    underTest.setIpv6Address(IPV6_ADDRESS);
    underTest.setIpv6Prefix(IPV6_PREFIX);
    underTest.setIpv6Gateway(IPV6_GATEWAY);
    VmInit vmInit = new VmInit();
    vmInit.setNetworks(Arrays.asList(underTest));
    String expectedOutput = "{\n" + "  \"links\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"vif\",\n" + "      \"name\": \"iface name\"\n" + "    }\n" + "  ],\n" + "  \"networks\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"ipv6\",\n" + "      \"link\": \"iface name\",\n" + "      \"ip_address\": \"ipv6 address\",\n" + "      \"netmask\": 666,\n" + "      \"gateway\": \"ipv6 gateway\"\n" + "    }\n" + "  ]\n" + "}";
    return new Pair(vmInit, expectedOutput);
}
#method_after
private static Pair staticIPv6() {
    final VmInitNetwork underTest = new VmInitNetwork();
    underTest.setName(IFACE_NAME);
    underTest.setIpv6BootProtocol(Ipv6BootProtocol.STATIC_IP);
    underTest.setIpv6Address(IPV6_ADDRESS);
    underTest.setIpv6Prefix(IPV6_PREFIX);
    underTest.setIpv6Gateway(IPV6_GATEWAY);
    underTest.setStartOnBoot(true);
    VmInit vmInit = new VmInit();
    vmInit.setNetworks(Arrays.asList(underTest));
    String expectedOutput = "{\n" + "  \"links\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"vif\",\n" + "      \"name\": \"iface name\"\n" + "    }\n" + "  ],\n" + "  \"networks\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"ipv6\",\n" + "      \"link\": \"iface name\",\n" + "      \"ip_address\": \"ipv6 address\",\n" + "      \"netmask\": \"666\",\n" + "      \"gateway\": \"ipv6 gateway\"\n" + "    }\n" + "  ]\n" + "}";
    return new Pair(vmInit, expectedOutput);
}
#end_block

#method_before
private static Pair staticIPv4AndIPv6() {
    final VmInitNetwork underTest = new VmInitNetwork();
    underTest.setName(IFACE_NAME);
    underTest.setBootProtocol(Ipv4BootProtocol.STATIC_IP);
    underTest.setIp(IPV4_ADDRESS);
    underTest.setNetmask(IPV4_NETMASK);
    underTest.setGateway(IPV4_GATEWAY);
    underTest.setIpv6BootProtocol(Ipv6BootProtocol.STATIC_IP);
    underTest.setIpv6Address(IPV6_ADDRESS);
    underTest.setIpv6Prefix(IPV6_PREFIX);
    underTest.setIpv6Gateway(IPV6_GATEWAY);
    VmInit vmInit = new VmInit();
    vmInit.setNetworks(Arrays.asList(underTest));
    String expectedOutput = "{\n" + "  \"links\": [\n" + "    {\n" + "      \"name\": \"iface name\",\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"vif\"\n" + "    }\n" + "  ],\n" + "  \"networks\": [\n" + "    {\n" + "      \"netmask\": \"ipv4 netmask\",\n" + "      \"link\": \"iface name\",\n" + "      \"id\": \"iface name\",\n" + "      \"ip_address\": \"ipv4 address\",\n" + "      \"type\": \"ipv4\",\n" + "      \"gateway\": \"ipv4 gateway\"\n" + "    },\n" + "    {\n" + "      \"netmask\": 666,\n" + "      \"link\": \"iface name\",\n" + "      \"id\": \"iface name\",\n" + "      \"ip_address\": \"ipv6 address\",\n" + "      \"type\": \"ipv6\",\n" + "      \"gateway\": \"ipv6 gateway\"\n" + "    }\n" + "  ]\n" + "}";
    return new Pair(vmInit, expectedOutput);
}
#method_after
private static Pair staticIPv4AndIPv6() {
    final VmInitNetwork underTest = new VmInitNetwork();
    underTest.setName(IFACE_NAME);
    underTest.setBootProtocol(Ipv4BootProtocol.STATIC_IP);
    underTest.setIp(IPV4_ADDRESS);
    underTest.setNetmask(IPV4_NETMASK);
    underTest.setGateway(IPV4_GATEWAY);
    underTest.setIpv6BootProtocol(Ipv6BootProtocol.STATIC_IP);
    underTest.setIpv6Address(IPV6_ADDRESS);
    underTest.setIpv6Prefix(IPV6_PREFIX);
    underTest.setIpv6Gateway(IPV6_GATEWAY);
    underTest.setStartOnBoot(true);
    VmInit vmInit = new VmInit();
    vmInit.setNetworks(Arrays.asList(underTest));
    String expectedOutput = "{\n" + "  \"links\": [\n" + "    {\n" + "      \"name\": \"iface name\",\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"vif\"\n" + "    }\n" + "  ],\n" + "  \"networks\": [\n" + "    {\n" + "      \"netmask\": \"ipv4 netmask\",\n" + "      \"link\": \"iface name\",\n" + "      \"id\": \"iface name\",\n" + "      \"ip_address\": \"ipv4 address\",\n" + "      \"type\": \"ipv4\",\n" + "      \"gateway\": \"ipv4 gateway\"\n" + "    },\n" + "    {\n" + "      \"netmask\": \"666\",\n" + "      \"link\": \"iface name\",\n" + "      \"id\": \"iface name\",\n" + "      \"ip_address\": \"ipv6 address\",\n" + "      \"type\": \"ipv6\",\n" + "      \"gateway\": \"ipv6 gateway\"\n" + "    }\n" + "  ]\n" + "}";
    return new Pair(vmInit, expectedOutput);
}
#end_block

#method_before
private static Pair dnsServersOnly() {
    VmInit vmInit = new VmInit();
    vmInit.setDnsSearch("search1 search2");
    vmInit.setDnsServers("nameserver1 nameserver2 nameserver3");
    String expectedOutput = "{\n" + "  \"services\": [\n" + "    {\n" + "      \"address\": \"nameserver1\",\n" + "      \"type\": \"dns-nameserver\"\n" + "    },\n" + "    {\n" + "      \"address\": \"nameserver2\",\n" + "      \"type\": \"dns-nameserver\"\n" + "    },\n" + "    {\n" + "      \"address\": \"nameserver3\",\n" + "      \"type\": \"dns-nameserver\"\n" + "    },\n" + "    {\n" + "      \"address\": \"search1\",\n" + "      \"type\": \"dns-search\"\n" + "    },\n" + "    {\n" + "      \"address\": \"search2\",\n" + "      \"type\": \"dns-search\"\n" + "    }\n" + "  ]\n" + "}";
    return new Pair(vmInit, expectedOutput);
}
#method_after
private static Pair dnsServersOnly() {
    VmInit vmInit = new VmInit();
    VmInitNetwork underTest = new VmInitNetwork();
    underTest.setStartOnBoot(true);
    vmInit.setNetworks(Arrays.asList(underTest));
    vmInit.setDnsSearch("search1 search2");
    vmInit.setDnsServers("nameserver1 nameserver2 nameserver3");
    String expectedOutput = "{\n" + "  \"services\": [\n" + "    {\n" + "      \"address\": \"nameserver1\",\n" + "      \"type\": \"dns-nameserver\"\n" + "    },\n" + "    {\n" + "      \"address\": \"nameserver2\",\n" + "      \"type\": \"dns-nameserver\"\n" + "    },\n" + "    {\n" + "      \"address\": \"nameserver3\",\n" + "      \"type\": \"dns-nameserver\"\n" + "    },\n" + "    {\n" + "      \"address\": \"search1\",\n" + "      \"type\": \"dns-search\"\n" + "    },\n" + "    {\n" + "      \"address\": \"search2\",\n" + "      \"type\": \"dns-search\"\n" + "    }\n" + "  ]\n" + "}";
    return new Pair(vmInit, expectedOutput);
}
#end_block

#method_before
private static Pair dhcpIPv4() {
    final VmInitNetwork underTest = new VmInitNetwork();
    underTest.setName(IFACE_NAME);
    underTest.setBootProtocol(Ipv4BootProtocol.DHCP);
    VmInit vmInit = new VmInit();
    vmInit.setNetworks(Arrays.asList(underTest));
    String expectedOutput = "{\n" + "  \"links\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"vif\",\n" + "      \"name\": \"iface name\"\n" + "    }\n" + "  ],\n" + "  \"networks\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"dhcp4\",\n" + "      \"link\": \"iface name\"\n" + "    }\n" + "  ]\n" + "}";
    return new Pair(vmInit, expectedOutput);
}
#method_after
private static Pair dhcpIPv4() {
    final VmInitNetwork underTest = new VmInitNetwork();
    underTest.setName(IFACE_NAME);
    underTest.setBootProtocol(Ipv4BootProtocol.DHCP);
    underTest.setStartOnBoot(true);
    VmInit vmInit = new VmInit();
    vmInit.setNetworks(Arrays.asList(underTest));
    String expectedOutput = "{\n" + "  \"links\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"vif\",\n" + "      \"name\": \"iface name\"\n" + "    }\n" + "  ],\n" + "  \"networks\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"dhcp4\",\n" + "      \"link\": \"iface name\"\n" + "    }\n" + "  ]\n" + "}";
    return new Pair(vmInit, expectedOutput);
}
#end_block

#method_before
private static Pair dhcpIPv6() {
    final VmInitNetwork underTest = new VmInitNetwork();
    underTest.setName(IFACE_NAME);
    underTest.setIpv6BootProtocol(Ipv6BootProtocol.DHCP);
    VmInit vmInit = new VmInit();
    vmInit.setNetworks(Arrays.asList(underTest));
    String expectedOutput = "{\n" + "  \"links\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"vif\",\n" + "      \"name\": \"iface name\"\n" + "    }\n" + "  ],\n" + "  \"networks\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"dhcp6\",\n" + "      \"link\": \"iface name\"\n" + "    }\n" + "  ]\n" + "}";
    return new Pair(vmInit, expectedOutput);
}
#method_after
private static Pair dhcpIPv6() {
    final VmInitNetwork underTest = new VmInitNetwork();
    underTest.setName(IFACE_NAME);
    underTest.setIpv6BootProtocol(Ipv6BootProtocol.DHCP);
    underTest.setStartOnBoot(true);
    VmInit vmInit = new VmInit();
    vmInit.setNetworks(Arrays.asList(underTest));
    String expectedOutput = "{\n" + "  \"links\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"vif\",\n" + "      \"name\": \"iface name\"\n" + "    }\n" + "  ],\n" + "  \"networks\": [\n" + "    {\n" + "      \"id\": \"iface name\",\n" + "      \"type\": \"dhcp6\",\n" + "      \"link\": \"iface name\"\n" + "    }\n" + "  ]\n" + "}";
    return new Pair(vmInit, expectedOutput);
}
#end_block

#method_before
private static Pair noneAndNone() {
    VmInit vmInit = new VmInit();
    String expectedOutput = "{}";
    return new Pair(vmInit, expectedOutput);
}
#method_after
private static Pair noneAndNone() {
    VmInit vmInit = new VmInit();
    VmInitNetwork underTest = new VmInitNetwork();
    underTest.setStartOnBoot(true);
    vmInit.setNetworks(Arrays.asList(underTest));
    String expectedOutput = null;
    return new Pair(vmInit, expectedOutput);
}
#end_block

#method_before
@Test
public void testGetFileDataStoreNoNetwork() throws IOException {
    final Map<String, byte[]> actual = underTest.getFileData();
    final Map<String, Object> actualMetaData = parseResult(actual);
    assertThat(actualMetaData, not(hasKey("network_config")));
    assertThat(actualMetaData, not(hasKey("network-interfaces")));
}
#method_after
@Test
public void testGetFileDataStoreNoNetwork() throws IOException {
    final Map<String, byte[]> actual = underTest.getFileData();
    final Map<String, Object> actualMetaData = parseResult(actual);
    assertThat(actualMetaData, not(hasKey("network_config")));
    assertThat(actualMetaData, not(hasKey("network-interfaces")));
    assertOpenstackNetworkDataFileNotCreated(actual);
}
#end_block

#method_before
@Test
public void testGetFileDataStoreNetwork() throws IOException {
    vmInit.setNetworks(singletonList(createVmInitNetwork()));
    final Map<String, byte[]> actual = underTest.getFileData();
    final Map<String, Object> actualMetaData = parseResult(actual);
    assertNetworkConfig(actualMetaData);
    assertNetworkInterfaces(actualMetaData);
}
#method_after
@Test
public void testGetFileDataStoreNetwork() throws IOException {
    vmInit.setNetworks(singletonList(createVmInitNetwork()));
    final Map<String, byte[]> actual = underTest.getFileData();
    final Map<String, Object> actualMetaData = parseResult(actual);
    assertNetworkConfig(actualMetaData);
    assertNetworkInterfaces(actualMetaData);
    assertOpenstackNetworkDataFileNotCreated(actual);
}
#end_block

#method_before
@Test
public void testGetFileDataStoreDns() throws IOException {
    vmInit.setNetworks(singletonList(createVmInitNetwork()));
    vmInit.setDnsServers(DNS_SERVERS);
    vmInit.setDnsSearch(DNS_SEARCH);
    final Map<String, byte[]> actual = underTest.getFileData();
    final Map<String, Object> actualMetaData = parseResult(actual);
    assertDnsProperties(actualMetaData);
}
#method_after
@Test
public void testGetFileDataStoreDns() throws IOException {
    vmInit.setNetworks(singletonList(createVmInitNetwork()));
    vmInit.setDnsServers(DNS_SERVERS);
    vmInit.setDnsSearch(DNS_SEARCH);
    final Map<String, byte[]> actual = underTest.getFileData();
    final Map<String, Object> actualMetaData = parseResult(actual);
    assertDnsProperties(actualMetaData);
    assertOpenstackNetworkDataFileNotCreated(actual);
}
#end_block

#method_before
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    List<VmNetworkInterface> nicsUnableToBeImported = getVm().getInterfaces().stream().filter(this::ifaceMacCannotBeAddedToMacPool).collect(Collectors.toList());
    if (!nicsUnableToBeImported.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_ADD_IFACE_DUE_TO_MAC_DUPLICATES;
        Collection<String> replacements = ReplacementUtils.getListVariableAssignmentString(engineMessage, nicsUnableToBeImported);
        return validate(new ValidationResult(engineMessage, replacements));
    }
    List<EngineMessage> msgs = CloudInitHandler.validate(getVm().getVmInit());
    if (msgs != null && !msgs.isEmpty()) {
        return failValidation(msgs);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    List<VmNetworkInterface> nicsUnableToBeImported = getVm().getInterfaces().stream().filter(this::ifaceMacCannotBeAddedToMacPool).collect(Collectors.toList());
    if (!nicsUnableToBeImported.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_ADD_IFACE_DUE_TO_MAC_DUPLICATES;
        Collection<String> replacements = ReplacementUtils.getListVariableAssignmentString(engineMessage, nicsUnableToBeImported);
        return validate(new ValidationResult(engineMessage, replacements));
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getVm().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVmTemplate() == null) {
        return false;
    }
    setDescription(getVmTemplateName());
    // check that the storage pool is valid
    if (!checkStoragePool() || !validateTemplateArchitecture() || !isClusterCompatible()) {
        return false;
    }
    // set the source domain and check that it is ImportExport type and active
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
    if (!validate(sourceDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    if ((getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !getParameters().isImagesExistOnTargetStorageDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!getParameters().isImagesExistOnTargetStorageDomain()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        QueryReturnValue qretVal = runInternalQuery(QueryType.GetTemplatesFromExportDomain, tempVar);
        if (!qretVal.getSucceeded()) {
            return false;
        }
        Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
        ArrayList<DiskImage> images = new ArrayList<>();
        for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
            if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                images = new ArrayList<>(entry.getValue());
                getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                break;
            }
        }
        getParameters().setImages(images);
        getVmTemplate().setImages(images);
        ensureDomainMap(getImages(), getParameters().getDestDomainId());
        HashMap<Guid, DiskImage> imageMap = new HashMap<>();
        for (DiskImage image : images) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
            changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
            if (!ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getValidationMessages())) {
                return false;
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            image.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
            imageMap.put(image.getImageId(), image);
        }
        getVmTemplate().setDiskImageMap(imageMap);
    }
    sourceTemplateId = getVmTemplateId();
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    VmTemplate duplicateTemplate = vmTemplateDao.get(getParameters().getVmTemplate().getId());
    // check that the template does not exists in the target domain
    if (duplicateTemplate != null) {
        return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS, String.format("$TemplateName %1$s", duplicateTemplate.getName()));
    }
    if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
        return failValidation(EngineMessage.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
    }
    if (!validateNoDuplicateDiskImages(getImages())) {
        return false;
    }
    if (getImages() != null && !getImages().isEmpty() && !getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!validateSpaceRequirements(getImages())) {
            return false;
        }
    }
    List<VmNetworkInterface> vmNetworkInterfaces = getVmTemplate().getInterfaces();
    vmNicMacsUtils.replaceInvalidEmptyStringMacAddressesWithNull(vmNetworkInterfaces);
    if (!validate(vmNicMacsUtils.validateMacAddress(vmNetworkInterfaces))) {
        return false;
    }
    // if this is a template version, check base template exist
    if (!getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = vmTemplateDao.get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    List<EngineMessage> msgs = CloudInitHandler.validate(getVmTemplate().getVmInit());
    if (msgs != null && !msgs.isEmpty()) {
        return failValidation(msgs);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVmTemplate() == null) {
        return false;
    }
    setDescription(getVmTemplateName());
    // check that the storage pool is valid
    if (!checkStoragePool() || !validateTemplateArchitecture() || !isClusterCompatible()) {
        return false;
    }
    // set the source domain and check that it is ImportExport type and active
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
    if (!validate(sourceDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    if ((getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !getParameters().isImagesExistOnTargetStorageDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!getParameters().isImagesExistOnTargetStorageDomain()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        QueryReturnValue qretVal = runInternalQuery(QueryType.GetTemplatesFromExportDomain, tempVar);
        if (!qretVal.getSucceeded()) {
            return false;
        }
        Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
        ArrayList<DiskImage> images = new ArrayList<>();
        for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
            if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                images = new ArrayList<>(entry.getValue());
                getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                break;
            }
        }
        getParameters().setImages(images);
        getVmTemplate().setImages(images);
        ensureDomainMap(getImages(), getParameters().getDestDomainId());
        HashMap<Guid, DiskImage> imageMap = new HashMap<>();
        for (DiskImage image : images) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
            changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
            if (!ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getValidationMessages())) {
                return false;
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            image.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
            imageMap.put(image.getImageId(), image);
        }
        getVmTemplate().setDiskImageMap(imageMap);
    }
    sourceTemplateId = getVmTemplateId();
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    VmTemplate duplicateTemplate = vmTemplateDao.get(getParameters().getVmTemplate().getId());
    // check that the template does not exists in the target domain
    if (duplicateTemplate != null) {
        return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS, String.format("$TemplateName %1$s", duplicateTemplate.getName()));
    }
    if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
        return failValidation(EngineMessage.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
    }
    if (!validateNoDuplicateDiskImages(getImages())) {
        return false;
    }
    if (getImages() != null && !getImages().isEmpty() && !getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!validateSpaceRequirements(getImages())) {
            return false;
        }
    }
    List<VmNetworkInterface> vmNetworkInterfaces = getVmTemplate().getInterfaces();
    vmNicMacsUtils.replaceInvalidEmptyStringMacAddressesWithNull(vmNetworkInterfaces);
    if (!validate(vmNicMacsUtils.validateMacAddress(vmNetworkInterfaces))) {
        return false;
    }
    // if this is a template version, check base template exist
    if (!getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = vmTemplateDao.get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getVmTemplate().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    return true;
}
#end_block

#method_before
private void updateCurrentMemory(VM newVm) {
    int currentMemory = getVm().getMemSizeMb();
    int newAmountOfMemory = newVm.getMemSizeMb();
    if (getVm().getStatus().isNotRunning()) {
        newVmStatic.setMemSizeMb(newAmountOfMemory);
        return;
    }
    if (getVm().getStatus() != VMStatus.Up) {
        newVmStatic.setMemSizeMb(currentMemory);
        log.warn("Memory update {}MB -> {}MB of VM {} ({}) left out. Memory can't be updated in current VM state ({}).", currentMemory, newAmountOfMemory, getVm().getName(), getVm().getId(), getVm().getStatus());
        return;
    }
    if (!VmCommonUtils.isMemoryToBeHotplugged(getVm(), newVm)) {
        return;
    }
    final int memoryAddedMb = newAmountOfMemory - currentMemory;
    final int factor = Config.<Integer>getValue(ConfigValues.HotPlugMemoryBlockSizeMb);
    final boolean memoryDividable = memoryAddedMb % factor == 0;
    if (!memoryDividable) {
        addCustomValue("memoryAdded", String.valueOf(memoryAddedMb));
        addCustomValue("requiredFactor", String.valueOf(factor));
        auditLogDirector.log(this, AuditLogType.FAILED_HOT_SET_MEMORY_NOT_DIVIDABLE);
        newVmStatic.setMemSizeMb(currentMemory);
        return;
    }
    hotSetMemory(currentMemory, newAmountOfMemory);
}
#method_after
private void updateCurrentMemory(VM newVm) {
    int currentMemory = getVm().getMemSizeMb();
    int newAmountOfMemory = newVm.getMemSizeMb();
    if (getVm().getStatus().isNotRunning()) {
        newVmStatic.setMemSizeMb(newAmountOfMemory);
        return;
    }
    if (getVm().getStatus() != VMStatus.Up) {
        newVmStatic.setMemSizeMb(currentMemory);
        log.warn("Memory update {}MB -> {}MB of VM {} ({}) left out. Memory can't be updated in current VM state ({}).", currentMemory, newAmountOfMemory, getVm().getName(), getVm().getId(), getVm().getStatus());
        return;
    }
    if (VmCommonUtils.isMemoryToBeHotplugged(getVm(), newVm)) {
        final int memoryAddedMb = newAmountOfMemory - currentMemory;
        final int factor = Config.<Integer>getValue(ConfigValues.HotPlugMemoryBlockSizeMb);
        final boolean memoryDividable = memoryAddedMb % factor == 0;
        if (!memoryDividable) {
            addCustomValue("memoryAdded", String.valueOf(memoryAddedMb));
            addCustomValue("requiredFactor", String.valueOf(factor));
            auditLogDirector.log(this, AuditLogType.FAILED_HOT_SET_MEMORY_NOT_DIVIDABLE);
            newVmStatic.setMemSizeMb(currentMemory);
            return;
        }
        hotSetMemory(currentMemory, newAmountOfMemory);
        return;
    }
    if (currentMemory > newAmountOfMemory) {
        hotUnplugMemory(newVm);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = CloudInitHandler.validate(getParameters().getVmStaticData().getVmInit());
    if (msgs != null && !msgs.isEmpty()) {
        return failValidation(msgs);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (getParameters().getVmStaticData().getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData()) && !canAddLease()) {
        return false;
    }
    List<EngineMessage> msgs = CloudInitHandler.validate(getParameters().getVmStaticData().getVmInit());
    if (msgs != null && !msgs.isEmpty()) {
        return failValidation(msgs);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (getParameters().getVmStaticData().getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData()) && !canAddLease()) {
        return false;
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    return true;
}
#end_block

#method_before
@Override
protected void init() {
    if (getVm() == null) {
        return;
    }
    super.init();
    if (getParameters().getCustomCpuName() != null) {
        getVm().setCpuName(getParameters().getCustomCpuName());
    }
    if (getParameters().getCustomEmulatedMachine() != null) {
        getVm().setEmulatedMachine(getParameters().getCustomEmulatedMachine());
    }
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    if (getParameters().getBootSequence() != null) {
        getVm().setBootSequence(getParameters().getBootSequence());
    }
    getVm().setInitrdUrl(getParameters().getInitrdUrl());
    getVm().setKernelUrl(getParameters().getKernelUrl());
    getVm().setKernelParams(getParameters().getKernelParams());
    getVm().setCustomProperties(getParameters().getCustomProperties());
    getVm().setRunOnce(true);
}
#method_after
@Override
protected void init() {
    if (getVm() == null) {
        return;
    }
    super.init();
    if (getParameters().getCustomCpuName() != null) {
        getVm().setCpuName(getParameters().getCustomCpuName());
    }
    if (getParameters().getCustomEmulatedMachine() != null) {
        getVm().setEmulatedMachine(getParameters().getCustomEmulatedMachine());
    }
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    if (getParameters().getBootSequence() != null) {
        getVm().setBootSequence(getParameters().getBootSequence());
    }
    getVm().setVolatileRun(getParameters().isVolatileRun());
    getVm().setInitrdUrl(getParameters().getInitrdUrl());
    getVm().setKernelUrl(getParameters().getKernelUrl());
    getVm().setKernelParams(getParameters().getKernelParams());
    getVm().setCustomProperties(getParameters().getCustomProperties());
    getVm().setRunOnce(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    // set (null), the action will fail if only one of those parameters is null.
    if (getParameters().getSysPrepUserName() == null ^ getParameters().getSysPrepPassword() == null) {
        return failValidation(EngineMessage.VM_CANNOT_RUN_ONCE_WITH_ILLEGAL_SYSPREP_PARAM);
    }
    if (getParameters().getVmInit() != null && getParameters().getVmInit().isPasswordAlreadyStored()) {
        VmBase temp = new VmBase();
        temp.setId(getParameters().getVmId());
        vmHandler.updateVmInitFromDB(temp, false);
        getParameters().getVmInit().setRootPassword(temp.getVmInit().getRootPassword());
    }
    List<EngineMessage> msgs = CloudInitHandler.validate(getParameters().getVmInit());
    if (msgs != null && !msgs.isEmpty()) {
        return failValidation(msgs);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    // set (null), the action will fail if only one of those parameters is null.
    if (getParameters().getSysPrepUserName() == null ^ getParameters().getSysPrepPassword() == null) {
        return failValidation(EngineMessage.VM_CANNOT_RUN_ONCE_WITH_ILLEGAL_SYSPREP_PARAM);
    }
    if (getParameters().getVmInit() != null && getParameters().getVmInit().isPasswordAlreadyStored()) {
        VmBase temp = new VmBase();
        temp.setId(getParameters().getVmId());
        vmHandler.updateVmInitFromDB(temp, false);
        getParameters().getVmInit().setRootPassword(temp.getVmInit().getRootPassword());
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getCluster() == null && !(isInstanceType || isBlankTemplate)) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (oldTemplate == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!StringUtils.equals(oldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failValidation(EngineMessage.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else {
            // must be unique also across datacenters.
            if (isInstanceType) {
                if (isInstanceWithSameNameExists(getVmTemplateName())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            } else {
                if (isVmTemplateWithSameNameExist(getVmTemplateName(), isBlankTemplate ? null : getCluster().getStoragePoolId())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            }
        }
    }
    Version effectiveCompatibilityVersion = CompatibilityVersionUtils.getEffective(getParameters().getVmTemplateData(), this::getCluster);
    if (getParameters().getVmTemplateData().getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(effectiveCompatibilityVersion)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", effectiveCompatibilityVersion));
    }
    if (vmHandler.isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority()).isValid() && checkDomain()) {
        returnValue = vmTemplateHandler.isUpdateValid(oldTemplate, getVmTemplate());
        if (!returnValue) {
            addValidationMessage(EngineMessage.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmTemplateData()))) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate(new VmWatchdogValidator.VmWatchdogClusterIndependentValidator(getParameters().getWatchdog()).isValid());
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmTemplateData(), CompatibilityVersionUtils.getEffective(getParameters().getVmTemplateData(), this::getCluster)))) {
        return false;
    }
    List<EngineMessage> msgs = CloudInitHandler.validate(getParameters().getVmTemplateData().getVmInit());
    if (msgs != null && !msgs.isEmpty()) {
        return failValidation(msgs);
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#method_after
@Override
protected boolean validate() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getCluster() == null && !(isInstanceType || isBlankTemplate)) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (oldTemplate == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!StringUtils.equals(oldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failValidation(EngineMessage.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else {
            // must be unique also across datacenters.
            if (isInstanceType) {
                if (isInstanceWithSameNameExists(getVmTemplateName())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            } else {
                if (isVmTemplateWithSameNameExist(getVmTemplateName(), isBlankTemplate ? null : getCluster().getStoragePoolId())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            }
        }
    }
    Version effectiveCompatibilityVersion = CompatibilityVersionUtils.getEffective(getParameters().getVmTemplateData(), this::getCluster);
    if (getParameters().getVmTemplateData().getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(effectiveCompatibilityVersion)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", effectiveCompatibilityVersion));
    }
    if (vmHandler.isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority()).isValid() && checkDomain()) {
        returnValue = vmTemplateHandler.isUpdateValid(oldTemplate, getVmTemplate());
        if (!returnValue) {
            addValidationMessage(EngineMessage.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmTemplateData()))) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate(new VmWatchdogValidator.VmWatchdogClusterIndependentValidator(getParameters().getWatchdog()).isValid());
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmTemplateData(), CompatibilityVersionUtils.getEffective(getParameters().getVmTemplateData(), this::getCluster)))) {
        return false;
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmTemplateData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#end_block

#method_before
private void updateBackup() {
    if (getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport || getCurrentStorageItem() != null) {
        getBackup().setIsAvailable(false);
        getBackup().setEntity(false);
        return;
    }
    boolean backupSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.BackupSupported, getDataCenter().getSelectedItem().getCompatibilityVersion().toString());
    getBackup().setIsAvailable(backupSupported);
    getBackup().setEntity(isNewStorage() ? false : getStorage().isBackup());
}
#method_after
private void updateBackup() {
    if (getCurrentStorageItem() != null && getAvailableStorageTypeItems().getSelectedItem() != null) {
        boolean isStorageDomainUnattached = getDataCenter().getSelectedItem().getId().equals(UnassignedDataCenterId);
        if (isStorageDomainUnattached) {
            if (getCurrentStorageItem().getRole().isDataDomain()) {
                getBackup().setIsAvailable(true);
                getBackup().setEntity(isNewStorage() ? false : getStorage().isBackup());
            } else {
                getBackup().setIsAvailable(false);
                getBackup().setEntity(false);
            }
        } else if (getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport) {
            getBackup().setIsAvailable(false);
            getBackup().setEntity(false);
        } else {
            boolean backupSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.BackupSupported, getDataCenter().getSelectedItem().getCompatibilityVersion().toString());
            getBackup().setIsAvailable(backupSupported);
            getBackup().setEntity(isNewStorage() ? false : getStorage().isBackup());
        }
    } else {
        getBackup().setIsAvailable(false);
        getBackup().setEntity(false);
    }
}
#end_block

#method_before
DropDownMenu updateContextMenu(DropDownMenu menuBar, List<ActionButtonDefinition<T>> actions) {
    return updateContextMenu(menuBar, actions, true);
}
#method_after
private DropDownMenu updateContextMenu(DropDownMenu menuBar, List<ActionButtonDefinition<T>> actions) {
    return updateContextMenu(menuBar, actions, true);
}
#end_block

#method_before
DropDownMenu updateContextMenu(DropDownMenu dropDownMenu, List<ActionButtonDefinition<T>> actions, boolean removeOldItems) {
    if (removeOldItems) {
        ElementTooltipUtils.destroyMenuItemTooltips(dropDownMenu);
        dropDownMenu.clear();
        // Close any other open popups as well.
        closeOtherPopups();
    }
    for (final ActionButtonDefinition<T> buttonDef : actions) {
        if (buttonDef instanceof UiMenuBarButtonDefinition) {
            UiMenuBarButtonDefinition<T> menuBarDef = (UiMenuBarButtonDefinition<T>) buttonDef;
            DropDownHeader subMenuHeader = new DropDownHeader(buttonDef.getText());
            dropDownMenu.add(new Divider());
            subMenuHeader.setVisible(buttonDef.isVisible(getSelectedItems()));
            dropDownMenu.add(subMenuHeader);
            updateContextMenu(dropDownMenu, menuBarDef.getSubActions(), false);
        } else {
            AnchorListItem item = new AnchorListItem(buttonDef.getText());
            item.addClickHandler(e -> {
                buttonDef.onClick(getSelectedItems());
            });
            updateMenuItem(item, buttonDef);
            dropDownMenu.add(item);
        }
    }
    return dropDownMenu;
}
#method_after
private DropDownMenu updateContextMenu(DropDownMenu dropDownMenu, List<ActionButtonDefinition<T>> actions, boolean removeOldItems) {
    if (removeOldItems) {
        ElementTooltipUtils.destroyMenuItemTooltips(dropDownMenu);
        dropDownMenu.clear();
        // Close any other open popups as well.
        closeOtherPopups();
    }
    for (final ActionButtonDefinition<T> buttonDef : actions) {
        if (buttonDef instanceof UiMenuBarButtonDefinition) {
            UiMenuBarButtonDefinition<T> menuBarDef = (UiMenuBarButtonDefinition<T>) buttonDef;
            DropDownHeader subMenuHeader = new DropDownHeader(buttonDef.getText());
            dropDownMenu.add(new Divider());
            subMenuHeader.setVisible(buttonDef.isVisible(getSelectedItems()));
            dropDownMenu.add(subMenuHeader);
            updateContextMenu(dropDownMenu, menuBarDef.getSubActions(), false);
        } else {
            AnchorListItem item = new AnchorListItem(buttonDef.getText());
            item.addClickHandler(e -> buttonDef.onClick(getSelectedItems()));
            updateMenuItem(item, buttonDef);
            dropDownMenu.add(item);
        }
    }
    return dropDownMenu;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    log.info("Creating ImageTransfer entity for command '{}'", getCommandId());
    ImageTransfer entity = new ImageTransfer(getCommandId());
    entity.setCommandType(getActionType());
    entity.setPhase(ImageTransferPhase.INITIALIZING);
    entity.setLastUpdated(new Date());
    entity.setBytesTotal(getParameters().getTransferSize());
    imageTransferDao.save(entity);
    if (isImageProvided()) {
        handleImageIsReadyForTransfer();
    } else {
        if (getParameters().getTransferType() == TransferType.Download) {
            failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD);
            setSucceeded(false);
            return;
        }
        log.info("Creating {} image", getImageType());
        createImage();
    }
    setActionReturnValue(getCommandId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    log.info("Creating ImageTransfer entity for command '{}'", getCommandId());
    ImageTransfer entity = new ImageTransfer(getCommandId());
    entity.setCommandType(getActionType());
    entity.setPhase(ImageTransferPhase.INITIALIZING);
    entity.setType(getParameters().getTransferType());
    entity.setActive(false);
    entity.setLastUpdated(new Date());
    entity.setBytesTotal(getParameters().getTransferSize());
    imageTransferDao.save(entity);
    if (isImageProvided()) {
        handleImageIsReadyForTransfer();
    } else {
        if (getParameters().getTransferType() == TransferType.Download) {
            failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD);
            setSucceeded(false);
            return;
        }
        log.info("Creating {} image", getImageType());
        createImage();
    }
    setActionReturnValue(getCommandId());
    setSucceeded(true);
}
#end_block

#method_before
private void handleTransferring(final StateContext context) {
    // make sure to set it with time to spare.
    if (context.iterationTimestamp >= getParameters().getSessionExpiration() - getHostTicketRefreshAllowance()) {
        log.info("Renewing transfer ticket for {}", getTransferDescription());
        boolean extendSucceeded = extendImageTransferSession(context.entity);
        if (!extendSucceeded) {
            log.info("Failed to renew transfer ticket for {}", getTransferDescription());
            if (getParameters().isExtendTicketFailed()) {
                updateEntityPhase(ImageTransferPhase.PAUSED_SYSTEM);
                getParameters().setExtendTicketFailed(false);
            } else {
                // Set 'extendTicketFailed' flag to true for giving a grace period
                // for another extend attempt.
                getParameters().setExtendTicketFailed(true);
            }
        }
    } else {
        log.debug("Not yet renewing transfer ticket for {}", getTransferDescription());
    }
    resetPeriodicPauseLogTime(0);
}
#method_after
private void handleTransferring(final StateContext context) {
    // make sure to set it with time to spare.
    if (context.iterationTimestamp >= getParameters().getSessionExpiration() - getHostTicketRefreshAllowance()) {
        log.info("Renewing transfer ticket for {}", getTransferDescription());
        boolean extendSucceeded = extendImageTransferSession(context.entity);
        if (!extendSucceeded) {
            log.warn("Failed to renew transfer ticket for {}", getTransferDescription());
            if (getParameters().isRetryExtendTicket()) {
                // Set 'extendTicketFailed' flag to true for giving a grace period
                // for another extend attempt.
                getParameters().setRetryExtendTicket(false);
            } else {
                updateEntityPhase(ImageTransferPhase.PAUSED_SYSTEM);
                getParameters().setRetryExtendTicket(true);
            }
        }
    } else {
        log.debug("Not yet renewing transfer ticket for {}", getTransferDescription());
    }
    resetPeriodicPauseLogTime(0);
    if (getParameters().getTransferType() == TransferType.Download) {
        pollDownloadStatus(context);
    }
}
#end_block

#method_before
private void handleFinalizingFailure(final StateContext context) {
    log.error("Finalizing failed transfer. {}", getTransferDescription());
    stopImageTransferSession(context.entity);
    // (only if not disk snapshot)
    if (Guid.isNullOrEmpty(getParameters().getImageGroupID())) {
        setImageStatus(getParameters().getTransferType() == TransferType.Upload ? ImageStatus.ILLEGAL : ImageStatus.OK);
    }
    updateEntityPhase(ImageTransferPhase.FINISHED_FAILURE);
    setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_FAILURE);
}
#method_after
private void handleFinalizingFailure(final StateContext context) {
    log.error("Finalizing failed transfer. {}", getTransferDescription());
    stopImageTransferSession(context.entity);
    // (only if not disk snapshot)
    if (!Guid.isNullOrEmpty(getParameters().getImageGroupID())) {
        setImageStatus(getParameters().getTransferType() == TransferType.Upload ? ImageStatus.ILLEGAL : ImageStatus.OK);
    }
    updateEntityPhase(ImageTransferPhase.FINISHED_FAILURE);
    setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_FAILURE);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    ImageTransfer other = (ImageTransfer) obj;
    return Objects.equals(commandId, other.commandId) && Objects.equals(phase, other.phase) && type == other.type && Objects.equals(active, other.active) && Objects.equals(lastUpdated, other.lastUpdated) && Objects.equals(message, other.message) && Objects.equals(vdsId, other.vdsId) && Objects.equals(diskId, other.diskId) && Objects.equals(imagedTicketId, other.imagedTicketId) && Objects.equals(proxyUri, other.proxyUri) && Objects.equals(signedTicket, other.signedTicket) && Objects.equals(bytesSent, other.bytesSent) && Objects.equals(bytesTotal, other.bytesTotal);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    ImageTransfer other = (ImageTransfer) obj;
    return Objects.equals(commandId, other.commandId) && Objects.equals(phase, other.phase) && Objects.equals(active, other.active) && Objects.equals(lastUpdated, other.lastUpdated) && Objects.equals(message, other.message) && Objects.equals(vdsId, other.vdsId) && Objects.equals(diskId, other.diskId) && Objects.equals(imagedTicketId, other.imagedTicketId) && Objects.equals(proxyUri, other.proxyUri) && Objects.equals(signedTicket, other.signedTicket) && Objects.equals(bytesSent, other.bytesSent) && Objects.equals(bytesTotal, other.bytesTotal) && type == other.type;
}
#end_block

#method_before
private void pollDownloadStatus(StateContext context) {
    ActionReturnValue returnValue = runInternalAction(ActionType.TransferImageStatus, new TransferImageStatusParameters(getCommandId()));
    if (returnValue != null && returnValue.getSucceeded()) {
        ImageTransfer imageTransfer = returnValue.getActionReturnValue();
        if (imageTransfer.getBytesTotal() != null && // Frontend flow (REST API should close the connection on its own).
        imageTransfer.getBytesTotal().equals(imageTransfer.getBytesSent()) && !imageTransfer.getActive()) {
            // to decrease the chances that the few last packets are still on the way to the client.
            if (!context.entity.getActive()) {
                // This is the second COCO iteration that the transfer is inactive.
                ImageTransfer updates = new ImageTransfer();
                updates.setPhase(ImageTransferPhase.FINALIZING_SUCCESS);
                TransferImageStatusParameters parameters = new TransferImageStatusParameters(getCommandId());
                parameters.setUpdates(updates);
                runInternalAction(ActionType.TransferImageStatus, parameters);
            }
        }
    }
}
#method_after
private void pollDownloadStatus(StateContext context) {
    ActionReturnValue returnValue = runInternalAction(ActionType.TransferImageStatus, new TransferImageStatusParameters(getCommandId()));
    if (returnValue == null || !returnValue.getSucceeded()) {
        log.debug("Failed to poll download status.");
        return;
    }
    ImageTransfer imageTransfer = returnValue.getActionReturnValue();
    // imageTransfer contains the up to date bytesSent and active fields.
    if (imageTransfer.getBytesTotal() != 0 && // Frontend flow (REST API should close the connection on its own).
    imageTransfer.getBytesTotal().equals(imageTransfer.getBytesSent()) && !imageTransfer.getActive()) {
        // to decrease the chances that the few last packets are still on the way to the client.
        if (!context.entity.getActive()) {
            // The entity from the previous COCO iteration.
            // This is the second COCO iteration that the transfer is inactive.
            ImageTransfer updates = new ImageTransfer();
            updates.setPhase(ImageTransferPhase.FINALIZING_SUCCESS);
            TransferImageStatusParameters parameters = new TransferImageStatusParameters(getCommandId());
            parameters.setUpdates(updates);
            runInternalAction(ActionType.TransferImageStatus, parameters);
        }
    }
}
#end_block

#method_before
private void handleFinalizingFailure(final StateContext context) {
    log.error("Finalizing failed transfer. {}", getTransferDescription());
    stopImageTransferSession(context.entity);
    // (only if not disk snapshot)
    if (Guid.isNullOrEmpty(getParameters().getImageGroupID())) {
        setImageStatus(getParameters().getTransferType() == TransferType.Upload ? ImageStatus.ILLEGAL : ImageStatus.OK);
    }
    updateEntityPhase(ImageTransferPhase.FINISHED_FAILURE);
    setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_FAILURE);
}
#method_after
private void handleFinalizingFailure(final StateContext context) {
    log.error("Finalizing failed transfer. {}", getTransferDescription());
    stopImageTransferSession(context.entity);
    // (only if not disk snapshot)
    if (!Guid.isNullOrEmpty(getParameters().getImageGroupID())) {
        setImageStatus(getParameters().getTransferType() == TransferType.Upload ? ImageStatus.ILLEGAL : ImageStatus.OK);
    }
    updateEntityPhase(ImageTransferPhase.FINISHED_FAILURE);
    setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_FAILURE);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getParameters().getTransferImageCommandId() == null && getParameters().getDiskId() == null) {
        log.error("Invalid parameters: command or disk id must be specified");
        setSucceeded(false);
    }
    ImageTransfer entity;
    if (getParameters().getTransferImageCommandId() != null) {
        entity = imageTransferDao.get(getParameters().getTransferImageCommandId());
    } else {
        entity = imageTransferDao.getByDiskId(getParameters().getDiskId());
    }
    if (entity != null) {
        if (entity.getVdsId() != null && entity.getImagedTicketId() != null) {
            ImageTicketInformation ticketInfo = (ImageTicketInformation) runVdsCommand(VDSCommandType.GetImageTicket, new GetImageTicketVDSCommandParameters(entity.getVdsId(), entity.getImagedTicketId())).getReturnValue();
            if (getParameters().getUpdates() == null) {
                getParameters().setUpdates(new ImageTransfer());
            }
            getParameters().getUpdates().setBytesSent(ticketInfo.getTransferred());
        }
        // Always update; this serves as a keepalive
        entity = imageTransferUpdater.updateEntity(getParameters().getUpdates(), entity.getId(), false);
    } else {
        // with phase "UNKNOWN" and the UI will know what to do.
        if (getParameters().getTransferImageCommandId() != null) {
            log.info("TransferImageStatus request for missing or removed entity, command id {}", getParameters().getTransferImageCommandId());
        } else {
            log.info("TransferImageStatus request for missing or removed entity, disk id {}", getParameters().getDiskId());
        }
        entity = new ImageTransfer();
        entity.setId(getParameters().getTransferImageCommandId());
        entity.setPhase(ImageTransferPhase.UNKNOWN);
    }
    setSucceeded(true);
    getReturnValue().setActionReturnValue(entity);
}
#method_after
@Override
protected void executeCommand() {
    if (getParameters().getTransferImageCommandId() == null && getParameters().getDiskId() == null) {
        log.error("Invalid parameters: command or disk id must be specified");
        setSucceeded(false);
    }
    ImageTransfer entity;
    if (getParameters().getTransferImageCommandId() != null) {
        entity = imageTransferDao.get(getParameters().getTransferImageCommandId());
    } else {
        entity = imageTransferDao.getByDiskId(getParameters().getDiskId());
    }
    if (entity != null) {
        if (entity.getVdsId() != null && entity.getImagedTicketId() != null && FeatureSupported.getImageTicketSupported(storagePoolDao.getForVds(entity.getVdsId()).getCompatibilityVersion())) {
            ImageTicketInformation ticketInfo = (ImageTicketInformation) runVdsCommand(VDSCommandType.GetImageTicket, new GetImageTicketVDSCommandParameters(entity.getVdsId(), entity.getImagedTicketId())).getReturnValue();
            if (getParameters().getUpdates() == null) {
                getParameters().setUpdates(new ImageTransfer());
            }
            getParameters().getUpdates().setBytesSent(ticketInfo.getTransferred());
        }
        // Always update; this serves as a keepalive
        entity = imageTransferUpdater.updateEntity(getParameters().getUpdates(), entity.getId(), false);
    } else {
        // with phase "UNKNOWN" and the UI will know what to do.
        if (getParameters().getTransferImageCommandId() != null) {
            log.info("TransferImageStatus request for missing or removed entity, command id {}", getParameters().getTransferImageCommandId());
        } else {
            log.info("TransferImageStatus request for missing or removed entity, disk id {}", getParameters().getDiskId());
        }
        entity = new ImageTransfer();
        entity.setId(getParameters().getTransferImageCommandId());
        entity.setPhase(ImageTransferPhase.UNKNOWN);
    }
    setSucceeded(true);
    getReturnValue().setActionReturnValue(entity);
}
#end_block

#method_before
@Override
protected boolean validate() {
    final ClusterValidator validator = new ClusterValidator(getDbFacade(), getCluster(), getCpuFlagsManagerHandler());
    return validate(validator.nameNotUsed()) && validate(validator.cpuTypeSupportsVirtService()) && validate(validator.versionSupported()) && validate(validator.dataCenterVersionMismatch()) && validate(validator.dataCenterExists()) && validate(validator.localStoragePoolAttachedToSingleCluster()) && validate(validator.clusterServiceDefined()) && validate(validator.mixedClusterServicesSupported()) && validate(validator.attestationServerConfigured()) && validate(validator.migrationSupported(getArchitecture())) && validate(validator.rngSourcesAllowed()) && validateClusterPolicy(null) && validateManagementNetwork() && validate(validator.memoryOptimizationConfiguration()) && validateDefaultNetworkProvider();
}
#method_after
@Override
protected boolean validate() {
    final ClusterValidator validator = new ClusterValidator(dbFacade, getCluster(), getCpuFlagsManagerHandler());
    return validate(validator.nameNotUsed()) && validate(validator.cpuTypeSupportsVirtService()) && validate(validator.versionSupported()) && validate(validator.dataCenterVersionMismatch()) && validate(validator.dataCenterExists()) && validate(validator.localStoragePoolAttachedToSingleCluster()) && validate(validator.clusterServiceDefined()) && validate(validator.mixedClusterServicesSupported()) && validate(validator.attestationServerConfigured()) && validate(validator.migrationSupported(getArchitecture())) && validate(validator.rngSourcesAllowed()) && validateClusterPolicy(null) && validateManagementNetwork() && validate(validator.memoryOptimizationConfiguration()) && validateDefaultNetworkProvider();
}
#end_block

#method_before
protected List<VmTemplate> filterTemplatesInClusterNeedUpdate() {
    if (!VmRngDevice.Source.urandomRandomUpdateRequired(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        return Collections.emptyList();
    }
    return vmTemplateDao.getAllForCluster(getCluster().getId()).stream().filter(template -> template.getCustomCompatibilityVersion() == null).sorted().collect(Collectors.toList());
}
#method_after
protected List<VmTemplate> filterTemplatesInClusterNeedUpdate() {
    return vmTemplateDao.getAllForCluster(getCluster().getId()).stream().filter(template -> template.getCustomCompatibilityVersion() == null).sorted().collect(Collectors.toList());
}
#end_block

#method_before
private boolean updateVms() {
    for (VmStatic vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        upgradeGraphicsDevices(vm, updateParams);
        updateRngDeviceIfNecessary(vm.getId(), vm.getCustomCompatibilityVersion(), updateParams);
        ActionReturnValue result = runInternalAction(ActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type VM");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = Backend.getInstance().getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(vm.getName(), getFailedMessage(messages));
        }
    }
    return true;
}
#method_after
private boolean updateVms() {
    for (VmStatic vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        upgradeGraphicsDevices(vm, updateParams);
        updateResumeBehavior(vm);
        updateRngDeviceIfNecessary(vm.getId(), vm.getCustomCompatibilityVersion(), updateParams);
        ActionReturnValue result = runInternalAction(ActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type VM");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = Backend.getInstance().getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(vm.getName(), getFailedMessage(messages));
        }
    }
    return true;
}
#end_block

#method_before
private boolean updateTemplates() {
    for (VmTemplate template : templatesLockedForUpdate) {
        // the object was loaded in before command execution started and thus the value may be outdated
        template.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
        // Locking by UpdateVmTemplate is disabled since templates are already locked in #getExclusiveLocks method.
        parameters.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        parameters.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        updateRngDeviceIfNecessary(template.getId(), template.getCustomCompatibilityVersion(), parameters);
        if (!parameters.isUpdateRngDevice()) {
            continue;
        }
        final ActionReturnValue result = runInternalAction(ActionType.UpdateVmTemplate, parameters, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type Template");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = Backend.getInstance().getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(template.getName(), getFailedMessage(messages));
        }
    }
    return true;
}
#method_after
private boolean updateTemplates() {
    for (VmTemplate template : templatesLockedForUpdate) {
        // the object was loaded in before command execution started and thus the value may be outdated
        template.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
        // Locking by UpdateVmTemplate is disabled since templates are already locked in #getExclusiveLocks method.
        parameters.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        parameters.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        updateRngDeviceIfNecessary(template.getId(), template.getCustomCompatibilityVersion(), parameters);
        updateResumeBehavior(template);
        final ActionReturnValue result = runInternalAction(ActionType.UpdateVmTemplate, parameters, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type Template");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = Backend.getInstance().getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(template.getName(), getFailedMessage(messages));
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = vdsDao.getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = vmDao.getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result && !oldCluster.getCompatibilityVersion().equals(getCluster().getCompatibilityVersion())) {
        for (VM vm : vmList) {
            if (vm.isPreviewSnapshot()) {
                // can't change cluster version when a VM is in preview
                if (result) {
                    addValidationMessage(EngineMessage.CLUSTER_VERSION_CHANGE_VM_PREVIEW);
                    // and continue with adding validation messages
                    result = false;
                }
                addValidationMessage(vm.getName());
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetwork()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(this, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = storagePoolDao.get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!clusterDao.getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = glusterVolumeDao.getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    ClusterValidator clusterValidator = new ClusterValidator(getDbFacade(), getCluster(), cpuFlagsManagerHandler);
    result = result && validate(clusterValidator.rngSourcesAllowed()) && validate(clusterValidator.memoryOptimizationConfiguration()) && validate(moveMacs.canMigrateMacsToAnotherMacPool(oldCluster, getNewMacPoolId())) && validateDefaultNetworkProvider();
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = vdsDao.getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(dbFacade, oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = vmDao.getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result && !oldCluster.getCompatibilityVersion().equals(getCluster().getCompatibilityVersion())) {
        for (VM vm : vmList) {
            if (vm.isPreviewSnapshot()) {
                // can't change cluster version when a VM is in preview
                if (result) {
                    addValidationMessage(EngineMessage.CLUSTER_VERSION_CHANGE_VM_PREVIEW);
                    // and continue with adding validation messages
                    result = false;
                }
                addValidationMessage(vm.getName());
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetwork()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(this, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = storagePoolDao.get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!clusterDao.getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = glusterVolumeDao.getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    ClusterValidator clusterValidator = new ClusterValidator(dbFacade, getCluster(), cpuFlagsManagerHandler);
    result = result && validate(clusterValidator.rngSourcesAllowed()) && validate(clusterValidator.memoryOptimizationConfiguration()) && validate(moveMacs.canMigrateMacsToAnotherMacPool(oldCluster, getNewMacPoolId())) && validateDefaultNetworkProvider();
    return result;
}
#end_block

#method_before
public static boolean isMemoryDeviceHotUnpluggable(VmDevice memoryDevice) {
    if (!isMemory(memoryDevice)) {
        throw new RuntimeException("Memory device expected but device " + memoryDevice + " obtained.");
    }
    return getSpecParamsIntValue(memoryDevice, SPEC_PARAM_SIZE).isPresent() && getSpecParamsIntValue(memoryDevice, SPEC_PARAM_NODE).isPresent();
}
#method_after
public static boolean isMemoryDeviceHotUnpluggable(VmDevice memoryDevice) {
    if (!isMemory(memoryDevice)) {
        throw new IllegalArgumentException("Memory device expected but device " + memoryDevice + " obtained.");
    }
    return getSpecParamsIntValue(memoryDevice, SPEC_PARAM_SIZE).isPresent() && getSpecParamsIntValue(memoryDevice, SPEC_PARAM_NODE).isPresent();
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    if (isVmExist() && isCompatibilityVersionSupportedByCluster(getEffectiveCompatibilityVersion())) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    vmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    vmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(vmNumaNodeDao.getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !getParameters().isConsoleEnabled()) {
        getParameters().getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
}
#method_after
@Override
protected void init() {
    super.init();
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    if (isVmExist() && isCompatibilityVersionSupportedByCluster(getEffectiveCompatibilityVersion())) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    vmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    vmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    vmHandler.autoSelectResumeBehavior(getParameters().getVmStaticData(), getCluster());
    vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(vmNumaNodeDao.getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !getParameters().isConsoleEnabled()) {
        getParameters().getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
}
#end_block

#method_before
private void hotUnplugMemory(VM newVm) {
    final VM vmFromDb = getVm();
    final List<VmDevice> vmMemoryDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(getVmId(), VmDeviceGeneralType.MEMORY, VmDeviceType.MEMORY);
    final List<VmDevice> memoryDevicesToUnplug = computeMemoryDeviceToHotUnplug(vmMemoryDevices);
    final int oldMemoryMb = vmFromDb.getMemSizeMb();
    final int oldMinMemoryMb = vmFromDb.getMinAllocatedMem();
    if (memoryDevicesToUnplug.isEmpty()) {
        logNoDeviceToHotUnplug(vmMemoryDevices);
        // in vm_static table.
        if (!vmFromDb.isHostedEngine()) {
            newVmStatic.setMemSizeMb(oldMemoryMb);
            newVmStatic.setMinAllocatedMem(oldMinMemoryMb);
        }
        return;
    }
    final int totalHotUnpluggedMemoryMb = memoryDevicesToUnplug.stream().mapToInt(deviceToHotUnplug -> {
        final ActionReturnValue hotUnplugReturnValue = runInternalAction(ActionType.HotUnplugMemoryWithoutVmUpdate, new HotUnplugMemoryWithoutVmUpdateParameters(deviceToHotUnplug.getId(), newVm.getMinAllocatedMem()), cloneContextAndDetachFromParent());
        return hotUnplugReturnValue.getSucceeded() ? VmDeviceCommonUtils.getSizeOfMemoryDeviceMb(deviceToHotUnplug).get() : 0;
    }).sum();
    // in vm_static table.
    if (!vmFromDb.isHostedEngine()) {
        newVmStatic.setMemSizeMb(oldMemoryMb - totalHotUnpluggedMemoryMb);
        newVmStatic.setMinAllocatedMem(// at least one hot unplug succeeded
        totalHotUnpluggedMemoryMb > 0 ? newVm.getMinAllocatedMem() : oldMinMemoryMb);
    }
}
#method_after
private void hotUnplugMemory(VM newVm) {
    final List<VmDevice> vmMemoryDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(getVmId(), VmDeviceGeneralType.MEMORY, VmDeviceType.MEMORY);
    final int oldMemoryMb = oldVm.getMemSizeMb();
    final int oldMinMemoryMb = oldVm.getMinAllocatedMem();
    final List<VmDevice> memoryDevicesToUnplug = MemoryUtils.computeMemoryDevicesToHotUnplug(vmMemoryDevices, oldMemoryMb, getParameters().getVm().getMemSizeMb());
    if (memoryDevicesToUnplug.isEmpty()) {
        logNoDeviceToHotUnplug(vmMemoryDevices);
        // in vm_static table.
        if (!oldVm.isHostedEngine()) {
            newVmStatic.setMemSizeMb(oldMemoryMb);
            newVmStatic.setMinAllocatedMem(oldMinMemoryMb);
        }
        return;
    }
    final int totalHotUnpluggedMemoryMb = memoryDevicesToUnplug.stream().mapToInt(deviceToHotUnplug -> {
        final ActionReturnValue hotUnplugReturnValue = runInternalAction(ActionType.HotUnplugMemoryWithoutVmUpdate, new HotUnplugMemoryWithoutVmUpdateParameters(deviceToHotUnplug.getId(), newVm.getMinAllocatedMem()), cloneContextAndDetachFromParent());
        return hotUnplugReturnValue.getSucceeded() ? VmDeviceCommonUtils.getSizeOfMemoryDeviceMb(deviceToHotUnplug).get() : 0;
    }).sum();
    // in vm_static table.
    if (!oldVm.isHostedEngine()) {
        newVmStatic.setMemSizeMb(oldMemoryMb - totalHotUnpluggedMemoryMb);
        newVmStatic.setMinAllocatedMem(// at least one hot unplug succeeded
        totalHotUnpluggedMemoryMb > 0 ? newVm.getMinAllocatedMem() : oldMinMemoryMb);
    }
}
#end_block

#method_before
private void logNoDeviceToHotUnplug(List<VmDevice> vmMemoryDevices) {
    final AuditLogType message = vmMemoryDevices.isEmpty() ? AuditLogType.NO_MEMORY_DEVICE_TO_HOT_UNPLUG : AuditLogType.NO_SUITABLE_MEMORY_DEVICE_TO_HOT_UNPLUG;
    if (!vmMemoryDevices.isEmpty()) {
        final int originalMemoryMb = getVm().getMemSizeMb();
        addCustomValue(AUDIT_LOG_OLD_MEMORY_MB, String.valueOf(originalMemoryMb));
        addCustomValue(AUDIT_LOG_NEW_MEMORY_MB, String.valueOf(getParameters().getVm().getMemSizeMb()));
        final String unplugOptions = vmMemoryDevices.stream().filter(VmDeviceCommonUtils::isMemoryDeviceHotUnpluggable).map(device -> VmDeviceCommonUtils.getSizeOfMemoryDeviceMb(device).get()).map(deviceSize -> String.format("%dMB (%dMB)", deviceSize, memoryAfterHotUnplug(originalMemoryMb, deviceSize))).collect(Collectors.joining(", "));
        addCustomValue(AUDIT_LOG_MEMORY_HOT_UNPLUG_OPTIONS, unplugOptions);
    }
    auditLogDirector.log(this, message);
}
#method_after
private void logNoDeviceToHotUnplug(List<VmDevice> vmMemoryDevices) {
    final AuditLogType message = vmMemoryDevices.isEmpty() ? AuditLogType.NO_MEMORY_DEVICE_TO_HOT_UNPLUG : AuditLogType.NO_SUITABLE_MEMORY_DEVICE_TO_HOT_UNPLUG;
    if (!vmMemoryDevices.isEmpty()) {
        final int originalMemoryMb = oldVm.getMemSizeMb();
        addCustomValue(AUDIT_LOG_OLD_MEMORY_MB, String.valueOf(originalMemoryMb));
        addCustomValue(AUDIT_LOG_NEW_MEMORY_MB, String.valueOf(getParameters().getVm().getMemSizeMb()));
        final String unplugOptions = vmMemoryDevices.stream().filter(VmDeviceCommonUtils::isMemoryDeviceHotUnpluggable).map(device -> VmDeviceCommonUtils.getSizeOfMemoryDeviceMb(device).get()).map(deviceSize -> String.format("%dMB (%dMB)", deviceSize, memoryAfterHotUnplug(originalMemoryMb, deviceSize))).collect(Collectors.joining(", "));
        addCustomValue(AUDIT_LOG_MEMORY_HOT_UNPLUG_OPTIONS, unplugOptions);
    }
    auditLogDirector.log(this, message);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    return true;
}
#end_block

#method_before
protected boolean isDiskSupportedForPlugUnPlug(DiskVmElement diskVmElement, String diskAlias) {
    if (diskVmElement.getDiskInterface() == DiskInterface.IDE) {
        addValidationMessageVariable("diskAlias", diskAlias);
        addValidationMessageVariable("vmName", getVm().getName());
        return failValidation(EngineMessage.HOT_PLUG_IDE_DISK_IS_NOT_SUPPORTED);
    }
    Set<String> diskHotpluggableInterfaces = osRepository.getDiskHotpluggableInterfaces(getVm().getOs(), getVm().getCompatibilityVersion());
    if (CollectionUtils.isEmpty(diskHotpluggableInterfaces) || !diskHotpluggableInterfaces.contains(diskVmElement.getDiskInterface().name())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    }
    return true;
}
#method_after
protected boolean isDiskSupportedForPlugUnPlug(DiskVmElement diskVmElement, String diskAlias) {
    if (diskVmElement.getDiskInterface() == DiskInterface.IDE) {
        addValidationMessageVariable("diskAlias", diskAlias);
        addValidationMessageVariable("vmName", getVm().getName());
        return failValidation(EngineMessage.HOT_PLUG_IDE_DISK_IS_NOT_SUPPORTED);
    }
    Set<String> diskHotpluggableInterfaces = osRepository.getDiskHotpluggableInterfaces(getVm().getOs(), getVm().getCompatibilityVersion());
    if (CollectionUtils.isEmpty(diskHotpluggableInterfaces) || !diskHotpluggableInterfaces.contains(diskVmElement.getDiskInterface().name())) {
        return failValidation(EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED, String.format("$osName %s", osRepository.getOsName(getVm().getOs())));
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canEdit(ClusterNetworkModel clusterNetworkModel) {
    Version clusterVersion = clusterNetworkModel.getCluster().getCompatibilityVersion();
    boolean defaultRouteSupported = Version.v4_2.lessOrEquals(clusterVersion);
    return defaultRouteSupported && clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal() && (!isMultipleSelectionAllowed() || !clusterNetworkModel.isManagement() || !clusterNetworkModel.getOriginalNetworkCluster().isDefaultRoute());
}
#method_after
@Override
protected boolean canEdit(ClusterNetworkModel clusterNetworkModel) {
    boolean defaultRouteReportedByVdsm = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.DefaultRouteReportedByVdsm, clusterNetworkModel.getCluster().getCompatibilityVersion().getValue());
    return defaultRouteReportedByVdsm && clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal() && (!isMultipleSelectionAllowed() || !clusterNetworkModel.isManagement() || !clusterNetworkModel.getOriginalNetworkCluster().isDefaultRoute());
}
#end_block

#method_before
public ReportedConfigurations reportConfigurationsOnHost() {
    ReportedConfigurations result = new ReportedConfigurations();
    Integer networkMtu = network.getMtu() == 0 ? NetworkUtils.getDefaultMtu() : network.getMtu();
    result.add(ReportedConfigurationType.MTU, iface.getMtu(), networkMtu, isNetworkMtuInSync());
    result.add(ReportedConfigurationType.BRIDGED, iface.isBridged(), network.isVmNetwork());
    result.add(ReportedConfigurationType.VLAN, iface.getVlanId(), network.getVlanId());
    result.add(ReportedConfigurationType.SWITCH_TYPE, iface.getReportedSwitchType(), cluster.getRequiredSwitchTypeForCluster());
    addReportedIpv4Configuration(result);
    /**
     * TODO: YZ - uncomment the method call after v4.0 is branched out.
     *
     * Reporting out-of-sync IPv6 configuration is disabled temporary.
     * It's planned to be re-enabled after v4.0-beta is released.
     *
     * addReportedIpv6Configuration(result);
     */
    boolean reportHostQos = ifaceQos != null || hostNetworkQos != null;
    if (reportHostQos) {
        result.add(OUT_AVERAGE_LINK_SHARE, getOutAverageLinkshare(ifaceQos), getOutAverageLinkshare(hostNetworkQos));
        result.add(OUT_AVERAGE_UPPER_LIMIT, getOutAverageUpperlimit(ifaceQos), getOutAverageUpperlimit(hostNetworkQos));
        result.add(OUT_AVERAGE_REAL_TIME, getOutAverageRealtime(ifaceQos), getOutAverageRealtime(hostNetworkQos));
    }
    addDnsConfiguration(result);
    boolean defaultRouteSupported = FeatureSupported.defaultRouteSupported(cluster.getCompatibilityVersion());
    result.add(DEFAULT_ROUTE, iface.isIpv4DefaultRoute(), !defaultRouteSupported || isDefaultRouteNetwork);
    return result;
}
#method_after
public ReportedConfigurations reportConfigurationsOnHost() {
    ReportedConfigurations result = new ReportedConfigurations();
    Integer networkMtu = network.getMtu() == 0 ? NetworkUtils.getDefaultMtu() : network.getMtu();
    result.add(ReportedConfigurationType.MTU, iface.getMtu(), networkMtu, isNetworkMtuInSync());
    result.add(ReportedConfigurationType.BRIDGED, iface.isBridged(), network.isVmNetwork());
    result.add(ReportedConfigurationType.VLAN, iface.getVlanId(), network.getVlanId());
    result.add(ReportedConfigurationType.SWITCH_TYPE, iface.getReportedSwitchType(), cluster.getRequiredSwitchTypeForCluster());
    addReportedIpv4Configuration(result);
    /**
     * TODO: YZ - uncomment the method call after v4.0 is branched out.
     *
     * Reporting out-of-sync IPv6 configuration is disabled temporary.
     * It's planned to be re-enabled after v4.0-beta is released.
     *
     * addReportedIpv6Configuration(result);
     */
    boolean reportHostQos = ifaceQos != null || hostNetworkQos != null;
    if (reportHostQos) {
        result.add(OUT_AVERAGE_LINK_SHARE, getOutAverageLinkshare(ifaceQos), getOutAverageLinkshare(hostNetworkQos));
        result.add(OUT_AVERAGE_UPPER_LIMIT, getOutAverageUpperlimit(ifaceQos), getOutAverageUpperlimit(hostNetworkQos));
        result.add(OUT_AVERAGE_REAL_TIME, getOutAverageRealtime(ifaceQos), getOutAverageRealtime(hostNetworkQos));
    }
    addDnsConfiguration(result);
    boolean defaultRouteReportedByVdsm = FeatureSupported.isDefaultRouteReportedByVdsm(cluster.getCompatibilityVersion());
    result.add(DEFAULT_ROUTE, iface.isIpv4DefaultRoute(), isDefaultRouteNetwork, !defaultRouteReportedByVdsm || Objects.equals(iface.isIpv4DefaultRoute(), isDefaultRouteNetwork));
    return result;
}
#end_block

#method_before
@Test
public void testDefaultRouteWhenOutOfSyncOnOlderCluster() {
    cluster.setCompatibilityVersion(Version.v4_1);
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    assertThat(createTestedInstance(true, sampleDnsResolverConfiguration).isNetworkInSync(), is(false));
}
#method_after
@Test
public void testDefaultRouteWhenOutOfSyncOnOlderCluster() {
    cluster.setCompatibilityVersion(Version.v4_1);
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    assertThat(createTestedInstance(true, sampleDnsResolverConfiguration).isNetworkInSync(), is(true));
}
#end_block

#method_before
public static Double percent2bytes(Integer speedValueInMegaBits, Double rxTxValueInPrecent) {
    if (speedValueInMegaBits == null || rxTxValueInPrecent == null) {
        return 0.0;
    }
    return megaBitToByte(speedValueInMegaBits * rxTxValueInPrecent / 100);
}
#method_after
public static Double percent2bytes(Integer speedValueInMegaBits, Double rxTxValueInPrecent) {
    return megaBitToByte(percent2megaBits(speedValueInMegaBits, rxTxValueInPrecent));
}
#end_block

#method_before
public static double percent2bits(Integer speedValueInMegaBits, Double rxTxValueInPrecent) {
    if (speedValueInMegaBits == null || rxTxValueInPrecent == null) {
        return 0.0;
    }
    return megaBitToBit(speedValueInMegaBits * rxTxValueInPrecent / 100);
}
#method_after
public static Double percent2bits(Integer speedValueInMegaBits, Double rxTxValueInPercent) {
    return megaBitToBit(percent2megaBits(speedValueInMegaBits, rxTxValueInPercent));
}
#end_block

#method_before
private static double megaBitToBit(double megaBit) {
    return megaBit * 1000000;
}
#method_after
private static double megaBitToBit(double megaBit) {
    return megaBit * 1_000_000;
}
#end_block

#method_before
private void writeHelperInvocation(JavaClassName helperClassName, String parameterName, Name methodName) {
    javaBuffer.addImport(InvocationTargetException.class);
    String helperMethodName = "get" + javaNames.getJavaClassStyleName(methodName) + "Signature";
    javaBuffer.addLine("try {");
    javaBuffer.addLine("return (Response)(" + helperClassName.getSimpleName() + "." + helperMethodName + "(" + parameterName + ").invoke(this, " + parameterName + "));");
    javaBuffer.addLine("}");
    javaBuffer.addLine("catch(IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {");
    javaBuffer.addLine("throw new IllegalStateException(\"Failed to find or invoke API method. The failure is in auto-generated code and indicates a bug in the JAX-RS intrafaces generation process\", e);");
    javaBuffer.addLine("}");
}
#method_after
private void writeHelperInvocation(JavaClassName helperClassName, String parameterName, Name methodName) {
    javaBuffer.addImport(InvocationTargetException.class);
    String helperMethodName = "get" + javaNames.getJavaClassStyleName(methodName) + "Signature";
    javaBuffer.addLine("try {");
    javaBuffer.addLine("return (Response)(" + helperClassName.getSimpleName() + "." + helperMethodName + "(" + parameterName + ").invoke(this, " + parameterName + "));");
    javaBuffer.addLine("}");
    javaBuffer.addLine("catch(InvocationTargetException e) {");
    javaBuffer.addLine("throw (RuntimeException)e.getTargetException();");
    javaBuffer.addLine("}");
    javaBuffer.addLine("catch(IllegalAccessException | NoSuchMethodException | SecurityException e) {");
    javaBuffer.addLine("throw new IllegalStateException(\"Failed to find or invoke API method. The failure is in auto-generated code and indicates a bug in the JAX-RS intrafaces generation process\", e);");
    javaBuffer.addLine("}");
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    or(mandatory(storageDomain().id()), mandatory(storageDomain().name()));
    or(optional(disk().name()), optional(disk().alias()));
}
#method_after
@InputDetail
default void inputDetail() {
    or(mandatory(storageDomain().id()), mandatory(storageDomain().name()));
    or(optional(disk().name()), optional(disk().alias()));
    optional(diskProfile().id());
    optional(quota().id());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    or(mandatory(storageDomain().id()), mandatory(storageDomain().name()));
}
#method_after
@InputDetail
default void inputDetail() {
    or(mandatory(storageDomain().id()), mandatory(storageDomain().name()));
    optional(diskProfile().id());
    optional(quota().id());
}
#end_block

#method_before
@Deprecated
public void addMainTab(String label, String historyToken, String contentUrl, TabOptions options) {
    addMainContentView(label, historyToken, contentUrl, options.getPriority().intValue(), options.getIsDefaultPlace().booleanValue());
}
#method_after
@Deprecated
public void addMainTab(String label, String historyToken, String contentUrl, TabOptions options) {
    addMainContentView(label, historyToken, contentUrl, options.getPriority().intValue(), options.getDefaultPlace().booleanValue());
}
#end_block

#method_before
public void addMainContentView(String label, String historyToken, String contentUrl, int priority, boolean defaultPlace) {
    menuPresenterWidget.addMenuItem(priority, label, historyToken);
    // Not interested in the actual proxy, it will register itself.
    dynamicUrlContentProxyFactory.create(historyToken, contentUrl);
    if (defaultPlace && placeManager instanceof WebAdminPlaceManager) {
        ((WebAdminPlaceManager) placeManager).setDefaultPlace(historyToken);
    }
}
#method_after
public void addMainContentView(String label, String historyToken, String contentUrl, int priority, boolean defaultPlace) {
    menuPresenterWidget.addMenuItem(priority, label, historyToken);
    // Not interested in the actual proxy, it will register itself.
    dynamicUrlContentProxyFactory.create(historyToken, contentUrl);
    placeManager.setDefaultPlace(historyToken);
}
#end_block

#method_before
@Override
public void onUserLoginChange(UserLoginChangeEvent event) {
    PlaceRequest placeRequest = getPlaceFromFragment();
    if (placeRequest == null) {
        placeRequest = getDefaultMainSectionPlace();
    }
    revealPlace(placeRequest);
}
#method_after
@Override
public void onUserLoginChange(UserLoginChangeEvent event) {
    revealCurrentPlace();
}
#end_block

#method_before
public void setModel(M model) {
    this.model = model;
    getModel().getItemsChangedEvent().addListener((ev, sender, args) -> {
        if (selectionChangedHandler != null) {
            selectionChangedHandler.removeHandler();
        }
        // Update the selection model to match the information from the previous selected model.
        getModel().getSelectionModel().clear();
        List<T> items = getModel().getItemsAsList();
        selectedIndexes.forEach(selectedIndex -> {
            if (selectedIndex > -1 && selectedIndex < items.size()) {
                getModel().getSelectionModel().setSelected(items.get(selectedIndex), true);
            }
        });
        updateInfoPanel();
        selectionChangedHandler = selectionModel.addSelectionChangeHandler(e -> processSelectionChanged());
    });
}
#method_after
public void setModel(M model) {
    this.model = model;
    // Remove the handler from the previous model's selection model.
    if (selectionChangedHandler != null) {
        selectionChangedHandler.removeHandler();
    }
    selectionChangedHandler = getSelectionModel().addSelectionChangeHandler(e -> processSelectionChanged());
    getSelectionModel().setDataDisplay(this.hasDataDelegate);
    getSelectionModel().setMultiSelectEnabled(true);
    getModel().getItemsChangedEvent().addListener((ev, sender, args) -> {
        // Update the selection model to match the information from the previous selected model.
        getSelectionModel().clear();
        List<T> items = getModel().getItemsAsList();
        List<Integer> itemsToSelect = selectedIndexes.stream().filter(selectedIndex -> selectedIndex > -1 && selectedIndex < items.size()).collect(Collectors.toList());
        itemsToSelect.forEach(index -> getSelectionModel().setSelected(items.get(index), true));
        updateInfoPanel();
    });
}
#end_block

#method_before
@Override
public SelectionModel<? super T> getSelectionModel() {
    return this.selectionModel;
}
#method_after
private OvirtSelectionModel<T> getSelectionModel() {
    return getModel().getSelectionModel();
}
#end_block

#method_before
@Override
public void onClick(ClickEvent event) {
    if (event.getSource() instanceof ListGroupItem) {
        PatternflyListViewItem<T> clickedItem = null;
        for (PatternflyListViewItem<T> item : currentState) {
            if (item.asListGroupItem() == event.getSource()) {
                clickedItem = item;
                break;
            }
        }
        if (clickedItem != null) {
            if (!event.isControlKeyDown() && !event.isShiftKeyDown()) {
                // A simple click.
                selectionModel.clear();
                selectionModel.setSelected(clickedItem.getEntity(), true);
            } else if (event.isControlKeyDown()) {
                // A control click
                selectionModel.setSelected(clickedItem.getEntity(), !selectionModel.isSelected(clickedItem.getEntity()));
            }
        }
    }
}
#method_after
@Override
public void onClick(ClickEvent event) {
    if (event.getSource() instanceof ListGroupItem) {
        PatternflyListViewItem<T> clickedItem = null;
        for (PatternflyListViewItem<T> item : currentState) {
            if (item.asListGroupItem() == event.getSource()) {
                clickedItem = item;
                break;
            }
        }
        if (clickedItem != null) {
            if (!event.isControlKeyDown() && !event.isShiftKeyDown()) {
                // A simple click.
                getSelectionModel().clear();
                getSelectionModel().setSelected(clickedItem.getEntity(), true);
            } else if (event.isControlKeyDown()) {
                // A control click
                getSelectionModel().setSelected(clickedItem.getEntity(), !getSelectionModel().isSelected(clickedItem.getEntity()));
            }
        }
    }
}
#end_block

#method_before
private void processSelectionChanged() {
    List<T> selectedItems = getSelectedItems();
    selectedIndexes.clear();
    model.getItems().forEach(item -> {
        if (selectedItems.contains(item)) {
            selectedIndexes.add(model.getItemsAsList().indexOf(item));
        }
    });
    updateInfoPanel();
}
#method_after
private void processSelectionChanged() {
    List<T> selectedItems = getSelectionModel().getSelectedObjects();
    selectedIndexes.clear();
    model.getItems().forEach(item -> {
        if (selectedItems.contains(item)) {
            selectedIndexes.add(model.getItemsAsList().indexOf(item));
        }
    });
    updateInfoPanel();
}
#end_block

#method_before
private void synchronizeSelection() {
    if (isSingleSelectionOnly()) {
        setSelectedItem(selectionModel.asSingleSelectionModel().getSelectedObject());
    } else {
        List<T> selectedItems = selectionModel.asMultiSelectionModel().getSelectedList();
        setSelectedItems(selectedItems);
        if (selectedItems.size() == 1) {
            setSelectedItem(selectedItems.get(0));
        }
    }
}
#method_after
private void synchronizeSelection() {
    if (isSingleSelectionOnly()) {
        setSelectedItem(selectionModel.asSingleSelectionModel().getSelectedObject());
    } else {
        List<T> selectedItems = selectionModel.getSelectedObjects();
        setSelectedItems(selectedItems);
        if (selectedItems.size() == 1) {
            setSelectedItem(selectedItems.get(0));
        }
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    GlusterVolumeEntity volumeEntity = getEntity();
    boolean allowRemove = true;
    boolean allowReplace = true;
    boolean allowAdvanced = true;
    boolean allowAdd = true;
    if (volumeEntity == null || volumeEntity.getVolumeType().isDispersedType() || !volumeEntity.getVolumeType().isSupported()) {
        allowRemove = false;
        allowAdd = false;
    }
    if (volumeEntity == null || getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowRemove = false;
        allowReplace = false;
        allowAdvanced = false;
    } else {
        if (getSelectedItems().size() == 1) {
            allowReplace = true;
            allowAdvanced = volumeEntity.isOnline() && getSelectedItems().get(0).isOnline();
        } else {
            allowReplace = false;
            allowAdvanced = false;
        }
        GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
        if (volumeTask != null && (volumeTask.getStatus() == JobExecutionStatus.STARTED || volumeTask.getType() == GlusterTaskType.REMOVE_BRICK && volumeTask.getStatus() == JobExecutionStatus.FINISHED)) {
            allowRemove = false;
            allowReplace = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.STRIPE || getSelectedItems().size() == volumeEntity.getBricks().size()) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && (volumeEntity.getBricks().size() == VolumeListModel.REPLICATE_COUNT_DEFAULT || getSelectedItems().size() > 1)) {
            allowRemove = false;
        }
    }
    getRemoveBricksCommand().setIsExecutionAllowed(allowRemove);
    getReplaceBrickCommand().setIsExecutionAllowed(allowReplace);
    getBrickAdvancedDetailsCommand().setIsExecutionAllowed(allowAdvanced);
    getAddBricksCommand().setIsExecutionAllowed(allowAdd);
}
#method_after
private void updateActionAvailability() {
    GlusterVolumeEntity volumeEntity = getEntity();
    boolean allowRemove = true;
    boolean allowReplace = true;
    boolean allowAdvanced = true;
    boolean allowAdd = true;
    if (volumeEntity == null || volumeEntity.getVolumeType().isDispersedType() || !volumeEntity.getVolumeType().isSupported()) {
        allowRemove = false;
        allowAdd = false;
    }
    if (volumeEntity == null || getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowRemove = false;
        allowReplace = false;
        allowAdvanced = false;
    } else {
        if (getSelectedItems().size() == 1) {
            allowAdvanced = volumeEntity.isOnline() && getSelectedItems().get(0).isOnline();
        } else {
            allowReplace = false;
            allowAdvanced = false;
        }
        GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
        if (volumeTask != null && (volumeTask.getStatus() == JobExecutionStatus.STARTED || volumeTask.getType() == GlusterTaskType.REMOVE_BRICK && volumeTask.getStatus() == JobExecutionStatus.FINISHED)) {
            allowRemove = false;
            allowReplace = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.STRIPE || getSelectedItems().size() == volumeEntity.getBricks().size()) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && (volumeEntity.getBricks().size() == VolumeListModel.REPLICATE_COUNT_DEFAULT || getSelectedItems().size() > 1)) {
            allowRemove = false;
        }
    }
    getRemoveBricksCommand().setIsExecutionAllowed(allowRemove);
    getReplaceBrickCommand().setIsExecutionAllowed(allowReplace);
    getBrickAdvancedDetailsCommand().setIsExecutionAllowed(allowAdvanced);
    getAddBricksCommand().setIsExecutionAllowed(allowAdd);
}
#end_block

#method_before
private void onReplaceBrick() {
    GlusterVolumeEntity volumeEntity = getEntity();
    if (volumeEntity == null) {
        return;
    }
    ReplaceBrickModel replaceBrickModel = (ReplaceBrickModel) getWindow();
    if (replaceBrickModel == null) {
        return;
    }
    GlusterBrickEntity existingBrick = getSelectedItem();
    if (existingBrick == null) {
        return;
    }
    boolean isMultipleBricks = false;
    String selectedHost = replaceBrickModel.getServers().getSelectedItem().getHostName();
    for (String brick : volumeEntity.getBrickDirectories()) {
        if (brick.contains(selectedHost) && selectedHost != existingBrick.getServerName()) {
            // $NON-NLS-1$
            isMultipleBricks = true;
        }
    }
    if (volumeEntity.getVolumeType().isReplicatedType() && isMultipleBricks) {
        ConfirmationModel model = new ConfirmationModel();
        setConfirmWindow(model);
        model.setTitle(ConstantsManager.getInstance().getConstants().replaceBrickTitle());
        model.setMessage(ConstantsManager.getInstance().getConstants().replaceBrickWarning());
        model.setHelpTag(HelpTag.replace_brick);
        // $NON-NLS-1$
        model.setHashName("replace brick");
        // $NON-NLS-1$
        UICommand yesCommand = new UICommand("OnReplaceConfirmation", VolumeBrickListModel.this);
        yesCommand.setTitle(ConstantsManager.getInstance().getConstants().yes());
        model.getCommands().add(yesCommand);
        // $NON-NLS-1$
        UICommand cancelCommand = new UICommand("CancelConfirmation", this);
        cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().no());
        cancelCommand.setIsCancel(true);
        getConfirmWindow().getCommands().add(cancelCommand);
    } else {
        onReplaceConfirmation();
    }
}
#method_after
private void onReplaceBrick() {
    GlusterVolumeEntity volumeEntity = getEntity();
    ReplaceBrickModel replaceBrickModel = (ReplaceBrickModel) getWindow();
    GlusterBrickEntity existingBrick = getSelectedItem();
    if (volumeEntity == null || replaceBrickModel == null || existingBrick == null) {
        return;
    }
    VDS server = replaceBrickModel.getServers().getSelectedItem();
    if (server == null) {
        return;
    }
    String selectedHost = server.getHostName();
    boolean isMultipleBricks = volumeEntity.getBrickDirectories().stream().filter(brick -> brick.contains(selectedHost) && selectedHost != existingBrick.getServerName()).findAny().isPresent();
    if (volumeEntity.getVolumeType().isReplicatedType() && isMultipleBricks) {
        ConfirmationModel model = new ConfirmationModel();
        setConfirmWindow(model);
        model.setTitle(ConstantsManager.getInstance().getConstants().replaceBrickTitle());
        model.setMessage(ConstantsManager.getInstance().getConstants().replaceBrickWarning());
        model.setHelpTag(HelpTag.replace_brick);
        // $NON-NLS-1$
        model.setHashName("replace brick");
        // $NON-NLS-1$
        UICommand yesCommand = new UICommand("OnReplaceConfirmation", VolumeBrickListModel.this);
        yesCommand.setTitle(ConstantsManager.getInstance().getConstants().yes());
        model.getCommands().add(yesCommand);
        // $NON-NLS-1$
        UICommand cancelCommand = new UICommand("CancelConfirmation", this);
        cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().no());
        cancelCommand.setIsCancel(true);
        getConfirmWindow().getCommands().add(cancelCommand);
    } else {
        onReplaceConfirmation();
    }
}
#end_block

#method_before
private void onReplaceConfirmation() {
    cancelConfirmation();
    ReplaceBrickModel replaceBrickModel = (ReplaceBrickModel) getWindow();
    if (replaceBrickModel == null) {
        return;
    }
    if (!replaceBrickModel.validate()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    if (volumeEntity == null) {
        return;
    }
    GlusterBrickEntity existingBrick = getSelectedItem();
    if (existingBrick == null) {
        return;
    }
    VDS server = replaceBrickModel.getServers().getSelectedItem();
    GlusterBrickEntity newBrick = new GlusterBrickEntity();
    newBrick.setVolumeId(volumeEntity.getId());
    newBrick.setServerId(server.getId());
    newBrick.setServerName(server.getHostName());
    newBrick.setBrickDirectory(replaceBrickModel.getBrickDirectory().getEntity());
    replaceBrickModel.startProgress();
    GlusterVolumeReplaceBrickActionParameters parameter = new GlusterVolumeReplaceBrickActionParameters(volumeEntity.getId(), existingBrick, newBrick);
    Frontend.getInstance().runAction(ActionType.ReplaceGlusterVolumeBrick, parameter, result -> {
        ReplaceBrickModel localModel = (ReplaceBrickModel) result.getState();
        localModel.stopProgress();
        setWindow(null);
    }, replaceBrickModel);
}
#method_after
private void onReplaceConfirmation() {
    cancelConfirmation();
    ReplaceBrickModel replaceBrickModel = (ReplaceBrickModel) getWindow();
    GlusterVolumeEntity volumeEntity = getEntity();
    GlusterBrickEntity existingBrick = getSelectedItem();
    if (replaceBrickModel == null || volumeEntity == null || existingBrick == null) {
        return;
    }
    if (!replaceBrickModel.validate()) {
        return;
    }
    VDS server = replaceBrickModel.getServers().getSelectedItem();
    if (server == null) {
        return;
    }
    GlusterBrickEntity newBrick = new GlusterBrickEntity();
    newBrick.setVolumeId(volumeEntity.getId());
    newBrick.setServerId(server.getId());
    newBrick.setServerName(server.getHostName());
    newBrick.setBrickDirectory(replaceBrickModel.getBrickDirectory().getEntity());
    replaceBrickModel.startProgress();
    GlusterVolumeReplaceBrickActionParameters parameter = new GlusterVolumeReplaceBrickActionParameters(volumeEntity.getId(), existingBrick, newBrick);
    Frontend.getInstance().runAction(ActionType.ReplaceGlusterVolumeBrick, parameter, result -> {
        ReplaceBrickModel localModel = (ReplaceBrickModel) result.getState();
        localModel.stopProgress();
        setWindow(null);
    }, replaceBrickModel);
}
#end_block

#method_before
@Override
protected void readAffinityGroupsSection(XmlNode section) {
    XmlNodeList list = selectNodes(section, "AffinityGroup");
    List<AffinityGroup> affinityGroups = new ArrayList<>();
    for (XmlNode node : list) {
        String affinityGroupName = node.attributes.get("ovf:name").innerText;
        AffinityGroup affinityGroup = new AffinityGroup();
        affinityGroup.setName(affinityGroupName);
        affinityGroups.add(affinityGroup);
    }
    fullEntityOvfData.setAffinityGroups(affinityGroups);
}
#method_after
@Override
protected void readAffinityGroupsSection(XmlNode section) {
    XmlNodeList list = selectNodes(section, OvfProperties.AFFINITY_GROUP);
    List<AffinityGroup> affinityGroups = new ArrayList<>();
    for (XmlNode node : list) {
        String affinityGroupName = node.attributes.get("ovf:name").innerText;
        AffinityGroup affinityGroup = new AffinityGroup();
        affinityGroup.setName(affinityGroupName);
        affinityGroups.add(affinityGroup);
    }
    fullEntityOvfData.setAffinityGroups(affinityGroups);
}
#end_block

#method_before
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#method_after
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            mapCluster(fullEntityOvfData.getClusterName());
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setAffinityGroups(fullEntityOvfData.getAffinityGroups());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
            mapExternalLunDisks(DisksFilter.filterLunDisks(vmFromConfiguration.getDiskMap().values()));
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
@Override
protected List<AffinityGroup> mapAffinityGroups() {
    List<AffinityGroup> affinityGroups = new ArrayList<>();
    fullEntityOvfData.getAffinityGroups().forEach(affinityGroup -> {
        Map<String, String> affinityGroupMap = getParameters().getAffinityGroupMap();
        AffinityGroup originalAffinityGroup = affinityGroupDao.getByName(affinityGroup.getName());
        if (affinityGroupMap != null) {
            String destName = affinityGroupMap.get(affinityGroup.getName());
            if (destName != null) {
                AffinityGroup destAffinityGroup = affinityGroupDao.getByName(destName);
                affinityGroups.add(destAffinityGroup);
            } else if (originalAffinityGroup != null) {
                affinityGroups.add(originalAffinityGroup);
            }
        } else if (originalAffinityGroup != null) {
            affinityGroups.add(originalAffinityGroup);
        }
    });
    return affinityGroups;
}
#method_after
@Override
protected List<AffinityGroup> mapAffinityGroups() {
    List<AffinityGroup> affinityGroups = new ArrayList<>();
    Map<String, String> affinityGroupMap = getParameters().getAffinityGroupMap();
    getParameters().getAffinityGroups().forEach(affinityGroup -> {
        AffinityGroup originalAffinityGroup = affinityGroupDao.getByName(affinityGroup.getName());
        if (affinityGroupMap != null) {
            String destName = affinityGroupMap.get(affinityGroup.getName());
            if (destName != null) {
                AffinityGroup destAffinityGroup = affinityGroupDao.getByName(destName);
                addAffinityGroup(affinityGroups, destAffinityGroup, originalAffinityGroup);
            } else {
                addAffinityGroup(affinityGroups, originalAffinityGroup, null);
            }
        } else {
            addAffinityGroup(affinityGroups, originalAffinityGroup, null);
        }
    });
    return affinityGroups;
}
#end_block

#method_before
@Override
public void addVmToAffinityGroups() {
    mapAffinityGroups().forEach(affinityGroup -> {
        affinityGroup.setClusterId(getParameters().getClusterId());
        affinityGroup.getVmIds().add(getParameters().getVm().getId());
        affinityGroupDao.update(affinityGroup);
    });
}
#method_after
@Override
public void addVmToAffinityGroups() {
    mapAffinityGroups().forEach(affinityGroup -> {
        affinityGroup.setClusterId(getParameters().getClusterId());
        Set<Guid> vmIds = new HashSet<>(affinityGroup.getVmIds());
        vmIds.add(getParameters().getVm().getId());
        affinityGroup.setVmIds(vmIds.stream().collect(Collectors.toList()));
        affinityGroupDao.update(affinityGroup);
    });
}
#end_block

#method_before
private AuditLogType attemptToAttachDisksToImportedVm(Collection<Disk> disks) {
    List<String> failedDisks = new LinkedList<>();
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElements().iterator().next();
        AttachDetachVmDiskParameters params = new AttachDetachVmDiskParameters(new DiskVmElement(disk.getId(), getVm().getId()), dve.isPlugged());
        ActionReturnValue returnVal = runInternalAction(ActionType.AttachDiskToVm, params, cloneContextAndDetachFromParent());
        if (!returnVal.getSucceeded()) {
            failedDisks.add(disk.getDiskAlias());
        }
    }
    if (!failedDisks.isEmpty()) {
        this.addCustomValue("DiskAliases", StringUtils.join(failedDisks, ","));
        return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_ATTACH_DISKS_FAILED;
    }
    return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_EXECUTED_SUCCESSFULLY;
}
#method_after
private AuditLogType attemptToAttachDisksToImportedVm(Collection<Disk> disks) {
    List<String> failedDisks = new LinkedList<>();
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElements().iterator().next();
        AttachDetachVmDiskParameters params = new AttachDetachVmDiskParameters(dve, dve.isPlugged());
        ActionReturnValue returnVal = runInternalAction(ActionType.AttachDiskToVm, params, cloneContextAndDetachFromParent());
        if (!returnVal.getSucceeded()) {
            failedDisks.add(disk.getDiskAlias());
        }
    }
    if (!failedDisks.isEmpty()) {
        this.addCustomValue("DiskAliases", StringUtils.join(failedDisks, ","));
        return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_ATTACH_DISKS_FAILED;
    }
    return AuditLogType.VM_IMPORT_FROM_CONFIGURATION_EXECUTED_SUCCESSFULLY;
}
#end_block

#method_before
public void addVmToAffinityGroups() {
}
#method_after
public void addVmToAffinityGroups() {
// Left empty to override in ImportVmFromConfiguration
}
#end_block

#method_before
private void writeAffinityGroups() {
    List<AffinityGroup> affinityGroups = fullEntityOvfData.getAffinityGroups();
    if (affinityGroups == null || affinityGroups.isEmpty()) {
        return;
    }
    _writer.writeStartElement("Section");
    _writer.writeAttributeString(XSI_URI, "type", "ovf:AffinityGroupsSection_Type");
    affinityGroups.forEach(affinityGroup -> {
        _writer.writeStartElement("AffinityGroup");
        _writer.writeAttributeString(OVF_URI, "name", affinityGroup.getName());
        _writer.writeEndElement();
    });
    _writer.writeEndElement();
}
#method_after
private void writeAffinityGroups() {
    List<AffinityGroup> affinityGroups = fullEntityOvfData.getAffinityGroups();
    if (affinityGroups == null || affinityGroups.isEmpty()) {
        return;
    }
    _writer.writeStartElement("Section");
    _writer.writeAttributeString(XSI_URI, "type", "ovf:AffinityGroupsSection_Type");
    affinityGroups.forEach(affinityGroup -> {
        _writer.writeStartElement(OvfProperties.AFFINITY_GROUP);
        _writer.writeAttributeString(OVF_URI, "name", affinityGroup.getName());
        _writer.writeEndElement();
    });
    _writer.writeEndElement();
}
#end_block

#method_before
protected List<DiskImage> createDiskDummiesForSpaceValidations(List<DiskImage> disksList) {
    List<DiskImage> dummies = new ArrayList<>(disksList.size());
    for (DiskImage image : disksList) {
        Guid targetSdId = imageToDestinationDomainMap.get(image.getId());
        DiskImage dummy = imagesHandler.createDiskImageWithExcessData(image, targetSdId);
        dummies.add(dummy);
    }
    return dummies;
}
#method_after
protected List<DiskImage> createDiskDummiesForSpaceValidations(List<DiskImage> disksList) {
    return disksList.stream().map(image -> imagesHandler.createDiskImageWithExcessData(image, imageToDestinationDomainMap.get(image.getId()))).collect(Collectors.toList());
}
#end_block

#method_before
private List<DiskImage> getMemoryVolumes() {
    int numOfSnapshots = snapshotsWithMemory.size();
    long memorySize = numOfSnapshots * vmOverheadCalculator.getSnapshotMemorySizeInBytes(getVm());
    long metadataSize = numOfSnapshots * MemoryUtils.METADATA_SIZE_IN_BYTES;
    List<DiskImage> memoryDisksList = MemoryUtils.createDiskDummies(memorySize, metadataSize);
    // Set target domain in memory disks
    ArrayList<Guid> sdId = new ArrayList<>(Collections.singletonList(getStorageDomainId()));
    for (DiskImage diskImage : memoryDisksList) {
        diskImage.setStorageIds(sdId);
    }
    return memoryDisksList;
}
#method_after
private List<DiskImage> getMemoryVolumes() {
    int numOfSnapshots = snapshotsWithMemory.size();
    long memorySize = numOfSnapshots * vmOverheadCalculator.getSnapshotMemorySizeInBytes(getVm());
    long metadataSize = numOfSnapshots * MemoryUtils.METADATA_SIZE_IN_BYTES;
    List<DiskImage> memoryDisksList = MemoryUtils.createDiskDummies(memorySize, metadataSize);
    // Set target domain in memory disks
    memoryDisksList.stream().forEach(d -> d.setStorageIds(Collections.singletonList(getStorageDomainId())));
    return memoryDisksList;
}
#end_block

#method_before
private Collection<Snapshot> getSnapshotsToBeExportedWithMemory() {
    if (getParameters().getCopyCollapse()) {
        Snapshot activeSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
        return !activeSnapshot.getMemoryVolume().isEmpty() ? Collections.singleton(activeSnapshot) : Collections.emptyList();
    } else {
        Map<String, Snapshot> memory2snapshot = new HashMap<>();
        for (Snapshot snapshot : snapshotDao.getAll(getVmId())) {
            memory2snapshot.put(snapshot.getMemoryVolume(), snapshot);
        }
        memory2snapshot.remove(StringUtils.EMPTY);
        return memory2snapshot.values();
    }
}
#method_after
private Collection<Snapshot> getSnapshotsToBeExportedWithMemory() {
    if (getParameters().getCopyCollapse()) {
        Snapshot activeSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
        return !activeSnapshot.getMemoryVolume().isEmpty() ? Collections.singleton(activeSnapshot) : Collections.emptyList();
    } else {
        return snapshotDao.getAll(getVmId()).stream().filter(s -> !StringUtils.EMPTY.equals(s.getMemoryVolume())).collect(Collectors.toList());
    }
}
#end_block

#method_before
private boolean updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<>();
    List<DiskImage> vmImages = new ArrayList<>();
    List<LunDisk> lunDisks = new ArrayList<>();
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    List<AffinityGroup> affinityGroups = affinityGroupDao.getAllAffinityGroupsByVmId(vm.getId());
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(vmNetworkInterfaceDao.getAllForVm(vm.getId()));
    }
    List<Guid> imageGroupIds = new ArrayList<>();
    for (Disk disk : getDisksBasedOnImage()) {
        DiskImage diskImage = (DiskImage) disk;
        diskImage.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomainId)));
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
        diskImage.setVolumeFormat(diskForVolumeInfo.getVolumeFormat());
        diskImage.setVolumeType(diskForVolumeInfo.getVolumeType());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
            diskImage.setActualSizeInBytes(fromVdsm.getActualSizeInBytes());
        }
        vmImages.add(diskImage);
        imageGroupIds.add(disk.getId());
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = vmTemplateDao.get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    lunDisks.addAll(DisksFilter.filterLunDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE));
    lunDisks.forEach(lun -> lun.getLun().setLunConnections(new ArrayList<>(storageServerConnectionDao.getAllForLun(lun.getLun().getId()))));
    getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(vm);
    fullEntityOvfData.setClusterName(vm.getClusterName());
    fullEntityOvfData.setDiskImages(vmImages);
    fullEntityOvfData.setLunDisks(lunDisks);
    fullEntityOvfData.setAffinityGroups(affinityGroups);
    String vmMeta = ovfManager.exportVm(vm, fullEntityOvfData, clusterUtils.getCompatibilityVersion(vm));
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return runVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#method_after
private void updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<>();
    List<DiskImage> vmImages = new ArrayList<>();
    List<LunDisk> lunDisks = new ArrayList<>();
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    List<AffinityGroup> affinityGroups = affinityGroupDao.getAllAffinityGroupsByVmId(vm.getId());
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(vmNetworkInterfaceDao.getAllForVm(vm.getId()));
    }
    List<Guid> imageGroupIds = new ArrayList<>();
    for (Disk disk : getDisksBasedOnImage()) {
        DiskImage diskImage = (DiskImage) disk;
        diskImage.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomainId)));
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
        diskImage.setVolumeFormat(diskForVolumeInfo.getVolumeFormat());
        diskImage.setVolumeType(diskForVolumeInfo.getVolumeType());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
            diskImage.setActualSizeInBytes(fromVdsm.getActualSizeInBytes());
        }
        vmImages.add(diskImage);
        imageGroupIds.add(disk.getId());
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = vmTemplateDao.get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    lunDisks.addAll(DisksFilter.filterLunDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE));
    lunDisks.forEach(lun -> lun.getLun().setLunConnections(new ArrayList<>(storageServerConnectionDao.getAllForLun(lun.getLun().getId()))));
    getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(vm);
    fullEntityOvfData.setClusterName(vm.getClusterName());
    fullEntityOvfData.setDiskImages(vmImages);
    fullEntityOvfData.setLunDisks(lunDisks);
    fullEntityOvfData.setAffinityGroups(affinityGroups);
    String vmMeta = ovfManager.exportVm(vm, fullEntityOvfData, clusterUtils.getCompatibilityVersion(vm));
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    runVdsCommand(VDSCommandType.UpdateVM, tempVar);
}
#end_block

#method_before
protected boolean updateVmInSpm() {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<>();
    ovfUpdateProcessHelper.loadVmData(getVm());
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(getVm());
    fullEntityOvfData.setClusterName(getVm().getClusterName());
    fullEntityOvfData.setDiskImages(ovfUpdateProcessHelper.getVmImagesFromDb(getVm()));
    fullEntityOvfData.setAffinityGroups(affinityGroupDao.getAllAffinityGroupsByVmId(getVmId()));
    ovfUpdateProcessHelper.buildMetadataDictionaryForVm(getVm(), metaDictionary, fullEntityOvfData);
    return ovfUpdateProcessHelper.executeUpdateVmInSpmCommand(getVm().getStoragePoolId(), metaDictionary, getParameters().getStorageDomainId());
}
#method_after
protected void updateVmInSpm() {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<>();
    ovfUpdateProcessHelper.loadVmData(getVm());
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(getVm());
    fullEntityOvfData.setClusterName(getVm().getClusterName());
    fullEntityOvfData.setDiskImages(ovfUpdateProcessHelper.getVmImagesFromDb(getVm()));
    fullEntityOvfData.setAffinityGroups(affinityGroupDao.getAllAffinityGroupsByVmId(getVmId()));
    ovfUpdateProcessHelper.buildMetadataDictionaryForVm(getVm(), metaDictionary, fullEntityOvfData);
    ovfUpdateProcessHelper.executeUpdateVmInSpmCommand(getVm().getStoragePoolId(), metaDictionary, getParameters().getStorageDomainId());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    StoragePoolParametersBase parameters = new StoragePoolParametersBase(getStoragePoolId());
    ActionReturnValue actionReturnValue = runInternalAction(ActionType.ProcessOvfUpdateForStoragePool, parameters, getContext());
    HashSet<Guid> proccessedDomains = actionReturnValue.getActionReturnValue();
    if (!proccessedDomains.isEmpty()) {
        runInternalActionWithTasksContext(ActionType.ProcessOvfUpdateForStorageDomain, createProcessOvfUpdateForDomainParams());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid storageDomainId = getStorageDomainId();
    StoragePoolParametersBase parameters = new StoragePoolParametersBase(getStoragePoolId());
    ActionReturnValue actionReturnValue = runInternalAction(ActionType.ProcessOvfUpdateForStoragePool, parameters, getContext());
    Set<Guid> proccessedDomains = actionReturnValue.getActionReturnValue();
    if (actionReturnValue.getSucceeded() && proccessedDomains != null && proccessedDomains.contains(storageDomainId)) {
        runInternalActionWithTasksContext(ActionType.ProcessOvfUpdateForStorageDomain, createProcessOvfUpdateForDomainParams());
    } else {
        log.info("OVFs update was ignored - nothing to update for storage domain '{}'", storageDomainId);
    }
    setSucceeded(true);
}
#end_block

#method_before
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    registerIconDefaultsProvider();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        macPoolPerCluster.logFreeMacs();
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmsMonitoring.class);
    serviceLoader.load(VmDevicesMonitoring.class);
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    serviceLoader.load(VmMigrationProgressMonitoring.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        macPoolPerCluster.logFreeMacs();
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmsMonitoring.class);
    serviceLoader.load(VmDevicesMonitoring.class);
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    serviceLoader.load(VmMigrationProgressMonitoring.class);
    // initializes attestation
    initAttestation();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    if (isVmExist() && isCompatibilityVersionSupportedByCluster(getEffectiveCompatibilityVersion())) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    vmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    vmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    // needs this autoselection in order to not to break the API
    vmHandler.autoSelectResumeBehavior(getParameters().getVmStaticData(), getCluster());
    vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(vmNumaNodeDao.getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !getParameters().isConsoleEnabled()) {
        getParameters().getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
}
#method_after
@Override
protected void init() {
    super.init();
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    if (isVmExist() && isCompatibilityVersionSupportedByCluster(getEffectiveCompatibilityVersion())) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    vmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    vmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    vmHandler.autoSelectResumeBehavior(getParameters().getVmStaticData(), getCluster());
    vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(vmNumaNodeDao.getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !getParameters().isConsoleEnabled()) {
        getParameters().getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    getModel().getIsVirtioScsiEnabled().setIsAvailable(true);
    getModel().getIsVirtioScsiEnabled().setEntity(false);
    getModel().getLease().setIsAvailable(false);
    getModel().getMemoryBalloonDeviceEnabled().setIsAvailable(true);
    getModel().updateWatchdogItems(new HashSet<>(Arrays.asList(VmWatchdogType.values())));
    // no cluster data - init list to 'use cluster default' option
    // $NON-NLS-1$
    getModel().getEmulatedMachine().setItems(Arrays.asList(""));
    // $NON-NLS-1$
    getModel().getCustomCpu().setItems(Arrays.asList(""));
    getModel().getResumeBehavior().setItems(Arrays.asList(ResumeBehavior.values()), ResumeBehavior.AUTO_RESUME);
}
#method_after
@Override
public void initialize() {
    super.initialize();
    getModel().getIsVirtioScsiEnabled().setIsAvailable(true);
    getModel().getIsVirtioScsiEnabled().setEntity(false);
    getModel().getLease().setIsAvailable(false);
    getModel().getMemoryBalloonDeviceEnabled().setIsAvailable(true);
    getModel().updateWatchdogItems(new HashSet<>(Arrays.asList(VmWatchdogType.values())));
    // no cluster data - init list to 'use cluster default' option
    // $NON-NLS-1$
    getModel().getEmulatedMachine().setItems(Arrays.asList(""));
    // $NON-NLS-1$
    getModel().getCustomCpu().setItems(Arrays.asList(""));
    getModel().getResumeBehavior().setItems(Arrays.asList(VmResumeBehavior.values()));
}
#end_block

#method_before
public ListModel<ResumeBehavior> getResumeBehavior() {
    return resumeBehavior;
}
#method_after
public ListModel<VmResumeBehavior> getResumeBehavior() {
    return resumeBehavior;
}
#end_block

#method_before
public void setResumeBehavior(NotChangableForVmInPoolListModel<ResumeBehavior> resumeBehavior) {
    this.resumeBehavior = resumeBehavior;
}
#method_after
public void setResumeBehavior(NotChangableForVmInPoolListModel<VmResumeBehavior> resumeBehavior) {
    this.resumeBehavior = resumeBehavior;
}
#end_block

#method_before
private void updateResumeBehavior() {
    if (getSelectedCluster() == null) {
        return;
    }
    getResumeBehavior().updateChangeability(ConfigValues.ResumeBehaviorSupported, getCompatibilityVersion());
    if (!getResumeBehavior().getIsChangable()) {
        getResumeBehavior().setSelectedItem(null);
        return;
    }
    ResumeBehavior prevSelected = getResumeBehavior().getSelectedItem();
    boolean haWithLease = getIsHighlyAvailable().getEntity() != null && getIsHighlyAvailable().getEntity() && getLease().getIsAvailable() && getLease().getSelectedItem() != null;
    if (haWithLease) {
        getResumeBehavior().setItems(Arrays.asList(ResumeBehavior.KILL), ResumeBehavior.KILL);
    } else {
        getResumeBehavior().setItems(Arrays.asList(ResumeBehavior.values()), prevSelected);
    }
}
#method_after
private void updateResumeBehavior() {
    if (getSelectedCluster() == null) {
        return;
    }
    getResumeBehavior().updateChangeability(ConfigValues.ResumeBehaviorSupported, getCompatibilityVersion());
    if (!getResumeBehavior().getIsChangable()) {
        getResumeBehavior().setSelectedItem(null);
        return;
    }
    VmResumeBehavior prevSelected = getResumeBehavior().getSelectedItem();
    boolean haWithLease = getIsHighlyAvailable().getEntity() != null && getIsHighlyAvailable().getEntity() && getLease().getIsAvailable() && getLease().getSelectedItem() != null;
    if (haWithLease) {
        getResumeBehavior().setItems(Arrays.asList(VmResumeBehavior.KILL), VmResumeBehavior.KILL);
    } else {
        getResumeBehavior().setItems(Arrays.asList(VmResumeBehavior.values()), prevSelected);
    }
}
#end_block

#method_before
@Override
public void buildReference() {
    _writer.writeStartElement("References");
    _images.forEach(image -> {
        _writer.writeStartElement("File");
        writeFile(image);
        _writer.writeEndElement();
    });
    _writer.writeEndElement();
}
#method_after
@Override
public void buildReference() {
    _writer.writeStartElement("References");
    _images.forEach(image -> {
        _writer.writeStartElement("File");
        writeFile(image);
        _writer.writeEndElement();
    });
    lunDisks.forEach(lun -> {
        _writer.writeStartElement("File");
        writeFileForLunDisk(lun);
        _writer.writeEndElement();
    });
    _writer.writeEndElement();
}
#end_block

#method_before
@Override
public void buildDisk() {
    startDiskSection();
    _writer.writeElement("Info", "List of Virtual Disks");
    _images.forEach(image -> {
        _writer.writeStartElement("Disk");
        writeDisk(image);
        _writer.writeEndElement();
    });
    _writer.writeEndElement();
}
#method_after
@Override
public void buildDisk() {
    startDiskSection();
    _writer.writeElement("Info", "List of Virtual Disks");
    _images.forEach(image -> {
        _writer.writeStartElement("Disk");
        writeDisk(image);
        _writer.writeEndElement();
    });
    lunDisks.forEach(lun -> {
        _writer.writeStartElement("Disk");
        writeLunDisk(lun);
        _writer.writeEndElement();
    });
    _writer.writeEndElement();
}
#end_block

#method_before
protected void writeGeneralData() {
    _writer.writeElement(NAME, vmBase.getName());
    if (vmBase.getDescription() != null) {
        _writer.writeElement(DESCRIPTION, vmBase.getDescription());
    }
    if (vmBase.getComment() != null) {
        _writer.writeElement(COMMENT, vmBase.getComment());
    }
    _writer.writeElement(CREATION_DATE, OvfParser.localDateToUtcDateString(vmBase.getCreationDate()));
    _writer.writeElement(EXPORT_DATE, OvfParser.localDateToUtcDateString(new Date()));
    _writer.writeElement(DELETE_PROTECTED, String.valueOf(vmBase.isDeleteProtected()));
    if (vmBase.getSsoMethod() != null) {
        _writer.writeElement(SSO_METHOD, vmBase.getSsoMethod().toString());
    }
    _writer.writeElement(IS_SMARTCARD_ENABLED, String.valueOf(vmBase.isSmartcardEnabled()));
    if (vmBase.getNumOfIoThreads() != 0) {
        _writer.writeElement(NUM_OF_IOTHREADS, String.valueOf(vmBase.getNumOfIoThreads()));
    }
    _writer.writeElement(TIMEZONE, vmBase.getTimeZone());
    _writer.writeElement(DEFAULT_BOOT_SEQUENCE, String.valueOf(vmBase.getDefaultBootSequence().getValue()));
    if (!StringUtils.isBlank(vmBase.getInitrdUrl())) {
        _writer.writeElement(INITRD_URL, vmBase.getInitrdUrl());
    }
    if (!StringUtils.isBlank(vmBase.getKernelUrl())) {
        _writer.writeElement(KERNEL_URL, vmBase.getKernelUrl());
    }
    if (!StringUtils.isBlank(vmBase.getKernelParams())) {
        _writer.writeElement(KERNEL_PARAMS, vmBase.getKernelParams());
    }
    _writer.writeElement(GENERATION, String.valueOf(vmBase.getDbGeneration()));
    if (vmBase.getCustomCompatibilityVersion() != null) {
        _writer.writeElement(CUSTOM_COMPATIBILITY_VERSION, String.valueOf(vmBase.getCustomCompatibilityVersion()));
    }
    // cluster version the VM/Snapshot
    _writer.writeElement(CLUSTER_COMPATIBILITY_VERSION, String.valueOf(version));
    // originates from
    _writer.writeElement(VM_TYPE, String.valueOf(vmBase.getVmType().getValue()));
    if (vmBase.getResumeBehavior() != null) {
        _writer.writeElement(RESUME_BEHAVIOR, String.valueOf(vmBase.getResumeBehavior()));
    }
    if (vmBase.getTunnelMigration() != null) {
        _writer.writeElement(TUNNEL_MIGRATION, String.valueOf(vmBase.getTunnelMigration()));
    }
    if (vmBase.getVncKeyboardLayout() != null) {
        _writer.writeElement(VNC_KEYBOARD_LAYOUT, vmBase.getVncKeyboardLayout());
    }
    _writer.writeElement(MIN_ALLOCATED_MEMORY, String.valueOf(vmBase.getMinAllocatedMem()));
    _writer.writeElement(IS_STATELESS, String.valueOf(vmBase.isStateless()));
    _writer.writeElement(IS_RUN_AND_PAUSE, String.valueOf(vmBase.isRunAndPause()));
    _writer.writeElement(AUTO_STARTUP, String.valueOf(vmBase.isAutoStartup()));
    _writer.writeElement(PRIORITY, String.valueOf(vmBase.getPriority()));
    if (vmBase.getCreatedByUserId() != null) {
        _writer.writeElement(CREATED_BY_USER_ID, String.valueOf(vmBase.getCreatedByUserId()));
    }
    if (vmBase.getMigrationDowntime() != null) {
        _writer.writeElement(MIGRATION_DOWNTIME, String.valueOf(vmBase.getMigrationDowntime()));
    }
    writeVmInit();
    if (vmBase.getMigrationSupport() != null) {
        _writer.writeElement(MIGRATION_SUPPORT, String.valueOf(vmBase.getMigrationSupport().getValue()));
    }
    // TODO dedicated to multiple hosts - are we breaking any standard here?
    if (vmBase.getDedicatedVmForVdsList().size() > 0) {
        for (Guid hostId : vmBase.getDedicatedVmForVdsList()) {
            _writer.writeElement(DEDICATED_VM_FOR_VDS, String.valueOf(hostId));
        }
    }
    if (vmBase.getSerialNumberPolicy() != null) {
        _writer.writeElement(SERIAL_NUMBER_POLICY, String.valueOf(vmBase.getSerialNumberPolicy().getValue()));
    }
    if (vmBase.getCustomSerialNumber() != null) {
        _writer.writeElement(CUSTOM_SERIAL_NUMBER, vmBase.getCustomSerialNumber());
    }
    _writer.writeElement(IS_BOOT_MENU_ENABLED, String.valueOf(vmBase.isBootMenuEnabled()));
    _writer.writeElement(IS_SPICE_FILE_TRANSFER_ENABLED, String.valueOf(vmBase.isSpiceFileTransferEnabled()));
    _writer.writeElement(IS_SPICE_COPY_PASTE_ENABLED, String.valueOf(vmBase.isSpiceCopyPasteEnabled()));
    _writer.writeElement(ALLOW_CONSOLE_RECONNECT, String.valueOf(vmBase.isAllowConsoleReconnect()));
    if (vmBase.getAutoConverge() != null) {
        _writer.writeElement(IS_AUTO_CONVERGE, String.valueOf(vmBase.getAutoConverge()));
    }
    if (vmBase.getMigrateCompressed() != null) {
        _writer.writeElement(IS_MIGRATE_COMPRESSED, String.valueOf(vmBase.getMigrateCompressed()));
    }
    if (vmBase.getMigrationPolicyId() != null) {
        _writer.writeElement(MIGRATION_POLICY_ID, String.valueOf(vmBase.getMigrationPolicyId()));
    }
    writeCustomEmulatedMachine();
    writeCustomCpuName();
    _writer.writeElement(PREDEFINED_PROPERTIES, vmBase.getPredefinedProperties());
    _writer.writeElement(USER_DEFINED_PROPERTIES, vmBase.getUserDefinedProperties());
    _writer.writeElement(MAX_MEMORY_SIZE_MB, String.valueOf(vmBase.getMaxMemorySizeMb()));
    if (vmBase.getLeaseStorageDomainId() != null) {
        _writer.writeElement(VM_LEASE, vmBase.getLeaseStorageDomainId().toString());
    }
}
#method_after
protected void writeGeneralData() {
    _writer.writeElement(NAME, vmBase.getName());
    if (vmBase.getDescription() != null) {
        _writer.writeElement(DESCRIPTION, vmBase.getDescription());
    }
    if (vmBase.getComment() != null) {
        _writer.writeElement(COMMENT, vmBase.getComment());
    }
    _writer.writeElement(CREATION_DATE, OvfParser.localDateToUtcDateString(vmBase.getCreationDate()));
    _writer.writeElement(EXPORT_DATE, OvfParser.localDateToUtcDateString(new Date()));
    _writer.writeElement(DELETE_PROTECTED, String.valueOf(vmBase.isDeleteProtected()));
    if (vmBase.getSsoMethod() != null) {
        _writer.writeElement(SSO_METHOD, vmBase.getSsoMethod().toString());
    }
    _writer.writeElement(IS_SMARTCARD_ENABLED, String.valueOf(vmBase.isSmartcardEnabled()));
    if (vmBase.getNumOfIoThreads() != 0) {
        _writer.writeElement(NUM_OF_IOTHREADS, String.valueOf(vmBase.getNumOfIoThreads()));
    }
    _writer.writeElement(TIMEZONE, vmBase.getTimeZone());
    _writer.writeElement(DEFAULT_BOOT_SEQUENCE, String.valueOf(vmBase.getDefaultBootSequence().getValue()));
    if (!StringUtils.isBlank(vmBase.getInitrdUrl())) {
        _writer.writeElement(INITRD_URL, vmBase.getInitrdUrl());
    }
    if (!StringUtils.isBlank(vmBase.getKernelUrl())) {
        _writer.writeElement(KERNEL_URL, vmBase.getKernelUrl());
    }
    if (!StringUtils.isBlank(vmBase.getKernelParams())) {
        _writer.writeElement(KERNEL_PARAMS, vmBase.getKernelParams());
    }
    _writer.writeElement(GENERATION, String.valueOf(vmBase.getDbGeneration()));
    if (vmBase.getCustomCompatibilityVersion() != null) {
        _writer.writeElement(CUSTOM_COMPATIBILITY_VERSION, String.valueOf(vmBase.getCustomCompatibilityVersion()));
    }
    // cluster version the VM/Snapshot
    _writer.writeElement(CLUSTER_COMPATIBILITY_VERSION, String.valueOf(version));
    // originates from
    _writer.writeElement(VM_TYPE, String.valueOf(vmBase.getVmType().getValue()));
    _writer.writeElement(RESUME_BEHAVIOR, String.valueOf(vmBase.getResumeBehavior()));
    if (vmBase.getTunnelMigration() != null) {
        _writer.writeElement(TUNNEL_MIGRATION, String.valueOf(vmBase.getTunnelMigration()));
    }
    if (vmBase.getVncKeyboardLayout() != null) {
        _writer.writeElement(VNC_KEYBOARD_LAYOUT, vmBase.getVncKeyboardLayout());
    }
    _writer.writeElement(MIN_ALLOCATED_MEMORY, String.valueOf(vmBase.getMinAllocatedMem()));
    _writer.writeElement(IS_STATELESS, String.valueOf(vmBase.isStateless()));
    _writer.writeElement(IS_RUN_AND_PAUSE, String.valueOf(vmBase.isRunAndPause()));
    _writer.writeElement(AUTO_STARTUP, String.valueOf(vmBase.isAutoStartup()));
    _writer.writeElement(PRIORITY, String.valueOf(vmBase.getPriority()));
    if (vmBase.getCreatedByUserId() != null) {
        _writer.writeElement(CREATED_BY_USER_ID, String.valueOf(vmBase.getCreatedByUserId()));
    }
    if (vmBase.getMigrationDowntime() != null) {
        _writer.writeElement(MIGRATION_DOWNTIME, String.valueOf(vmBase.getMigrationDowntime()));
    }
    writeVmInit();
    if (vmBase.getMigrationSupport() != null) {
        _writer.writeElement(MIGRATION_SUPPORT, String.valueOf(vmBase.getMigrationSupport().getValue()));
    }
    // TODO dedicated to multiple hosts - are we breaking any standard here?
    if (vmBase.getDedicatedVmForVdsList().size() > 0) {
        for (Guid hostId : vmBase.getDedicatedVmForVdsList()) {
            _writer.writeElement(DEDICATED_VM_FOR_VDS, String.valueOf(hostId));
        }
    }
    if (vmBase.getSerialNumberPolicy() != null) {
        _writer.writeElement(SERIAL_NUMBER_POLICY, String.valueOf(vmBase.getSerialNumberPolicy().getValue()));
    }
    if (vmBase.getCustomSerialNumber() != null) {
        _writer.writeElement(CUSTOM_SERIAL_NUMBER, vmBase.getCustomSerialNumber());
    }
    _writer.writeElement(IS_BOOT_MENU_ENABLED, String.valueOf(vmBase.isBootMenuEnabled()));
    _writer.writeElement(IS_SPICE_FILE_TRANSFER_ENABLED, String.valueOf(vmBase.isSpiceFileTransferEnabled()));
    _writer.writeElement(IS_SPICE_COPY_PASTE_ENABLED, String.valueOf(vmBase.isSpiceCopyPasteEnabled()));
    _writer.writeElement(ALLOW_CONSOLE_RECONNECT, String.valueOf(vmBase.isAllowConsoleReconnect()));
    if (vmBase.getAutoConverge() != null) {
        _writer.writeElement(IS_AUTO_CONVERGE, String.valueOf(vmBase.getAutoConverge()));
    }
    if (vmBase.getMigrateCompressed() != null) {
        _writer.writeElement(IS_MIGRATE_COMPRESSED, String.valueOf(vmBase.getMigrateCompressed()));
    }
    if (vmBase.getMigrationPolicyId() != null) {
        _writer.writeElement(MIGRATION_POLICY_ID, String.valueOf(vmBase.getMigrationPolicyId()));
    }
    writeCustomEmulatedMachine();
    writeCustomCpuName();
    _writer.writeElement(PREDEFINED_PROPERTIES, vmBase.getPredefinedProperties());
    _writer.writeElement(USER_DEFINED_PROPERTIES, vmBase.getUserDefinedProperties());
    _writer.writeElement(MAX_MEMORY_SIZE_MB, String.valueOf(vmBase.getMaxMemorySizeMb()));
    if (vmBase.getLeaseStorageDomainId() != null) {
        _writer.writeElement(VM_LEASE, vmBase.getLeaseStorageDomainId().toString());
    }
}
#end_block

#method_before
protected void setUpVm(VmBase vm) {
    vm.setName(VM_NAME);
    vm.setDescription(DESCRIPTION);
    vm.setComment(COMMENT);
    vm.setOsId(OS_TYPE);
    vm.setMemSizeMb(MEM_SIZE);
    vm.setMinAllocatedMem(MIN_MEM);
    vm.setUsbPolicy(USB_POLICY);
    vm.setNumOfMonitors(NUM_OF_MONITORS);
    vm.setNumOfSockets(NUM_OF_SOCKETS);
    vm.setCpuPerSocket(TOTAL_CPU / NUM_OF_SOCKETS);
    vm.setAllowConsoleReconnect(true);
    vm.setStateless(true);
    vm.setRunAndPause(true);
    vm.setBootMenuEnabled(true);
    vm.setVncKeyboardLayout(VNC_KEYBOARD_LAYOUT);
    vm.setDeleteProtected(true);
    vm.setSsoMethod(SsoMethod.GUEST_AGENT);
    vm.setKernelParams(KERNEL_PARAMS);
    vm.setKernelUrl(KERNEL_PATH);
    vm.setInitrdUrl(INITRD_PATH);
    vm.setSerialNumberPolicy(SerialNumberPolicy.CUSTOM);
    vm.setCustomSerialNumber(CUSTOM_SERIAL_NUMBER);
    vm.setSpiceCopyPasteEnabled(true);
    vm.setSpiceFileTransferEnabled(true);
    vm.setMigrationDowntime(MIGRATION_DOWNTIME);
    vm.setSmartcardEnabled(true);
    vm.setDefaultBootSequence(BOOT_SEQUENCE);
    vm.setSingleQxlPci(true);
    vm.setAutoConverge(true);
    vm.setMigrateCompressed(true);
    vm.setLargeIconId(LARGE_ICON_ID);
    vm.setSmallIconId(SMALL_ICON_ID);
    vm.setNumOfIoThreads(NUM_OF_IO_THREADS);
    vm.setConsoleDisconnectAction(ConsoleDisconnectAction.LOCK_SCREEN);
    vm.setResumeBehavior(ResumeBehavior.KILL);
}
#method_after
protected void setUpVm(VmBase vm) {
    vm.setName(VM_NAME);
    vm.setDescription(DESCRIPTION);
    vm.setComment(COMMENT);
    vm.setOsId(OS_TYPE);
    vm.setMemSizeMb(MEM_SIZE);
    vm.setMinAllocatedMem(MIN_MEM);
    vm.setUsbPolicy(USB_POLICY);
    vm.setNumOfMonitors(NUM_OF_MONITORS);
    vm.setNumOfSockets(NUM_OF_SOCKETS);
    vm.setCpuPerSocket(TOTAL_CPU / NUM_OF_SOCKETS);
    vm.setAllowConsoleReconnect(true);
    vm.setStateless(true);
    vm.setRunAndPause(true);
    vm.setBootMenuEnabled(true);
    vm.setVncKeyboardLayout(VNC_KEYBOARD_LAYOUT);
    vm.setDeleteProtected(true);
    vm.setSsoMethod(SsoMethod.GUEST_AGENT);
    vm.setKernelParams(KERNEL_PARAMS);
    vm.setKernelUrl(KERNEL_PATH);
    vm.setInitrdUrl(INITRD_PATH);
    vm.setSerialNumberPolicy(SerialNumberPolicy.CUSTOM);
    vm.setCustomSerialNumber(CUSTOM_SERIAL_NUMBER);
    vm.setSpiceCopyPasteEnabled(true);
    vm.setSpiceFileTransferEnabled(true);
    vm.setMigrationDowntime(MIGRATION_DOWNTIME);
    vm.setSmartcardEnabled(true);
    vm.setDefaultBootSequence(BOOT_SEQUENCE);
    vm.setSingleQxlPci(true);
    vm.setAutoConverge(true);
    vm.setMigrateCompressed(true);
    vm.setLargeIconId(LARGE_ICON_ID);
    vm.setSmallIconId(SMALL_ICON_ID);
    vm.setNumOfIoThreads(NUM_OF_IO_THREADS);
    vm.setConsoleDisconnectAction(ConsoleDisconnectAction.LOCK_SCREEN);
    vm.setResumeBehavior(VmResumeBehavior.KILL);
}
#end_block

#method_before
protected void verifyBuiltCore(UnitVmModel model) {
    verifyBuiltKernelParams(model);
    verifyBuiltSerialNumber(model);
    assertTrue(model.getBootMenuEnabled().getEntity());
    assertEquals(VNC_KEYBOARD_LAYOUT, model.getVncKeyboardLayout().getSelectedItem());
    assertTrue(model.getIsDeleteProtected().getEntity());
    assertTrue(model.getSsoMethodGuestAgent().getEntity());
    assertTrue(model.getSpiceFileTransferEnabled().getEntity());
    assertTrue(model.getSpiceCopyPasteEnabled().getEntity());
    assertTrue(model.getAutoConverge().getSelectedItem());
    assertTrue(model.getMigrateCompressed().getSelectedItem());
    assertEquals(LARGE_ICON_DATA, model.getIcon().getEntity().getIcon());
    assertEquals(LARGE_OS_DEFAULT_ICON_DATA, model.getIcon().getEntity().getOsDefaultIcon());
    assertEquals(ConsoleDisconnectAction.LOCK_SCREEN, model.getConsoleDisconnectAction().getSelectedItem());
    assertEquals(ResumeBehavior.KILL, model.getResumeBehavior().getSelectedItem());
}
#method_after
protected void verifyBuiltCore(UnitVmModel model) {
    verifyBuiltKernelParams(model);
    verifyBuiltSerialNumber(model);
    assertTrue(model.getBootMenuEnabled().getEntity());
    assertEquals(VNC_KEYBOARD_LAYOUT, model.getVncKeyboardLayout().getSelectedItem());
    assertTrue(model.getIsDeleteProtected().getEntity());
    assertTrue(model.getSsoMethodGuestAgent().getEntity());
    assertTrue(model.getSpiceFileTransferEnabled().getEntity());
    assertTrue(model.getSpiceCopyPasteEnabled().getEntity());
    assertTrue(model.getAutoConverge().getSelectedItem());
    assertTrue(model.getMigrateCompressed().getSelectedItem());
    assertEquals(LARGE_ICON_DATA, model.getIcon().getEntity().getIcon());
    assertEquals(LARGE_OS_DEFAULT_ICON_DATA, model.getIcon().getEntity().getOsDefaultIcon());
    assertEquals(ConsoleDisconnectAction.LOCK_SCREEN, model.getConsoleDisconnectAction().getSelectedItem());
    assertEquals(VmResumeBehavior.KILL, model.getResumeBehavior().getSelectedItem());
}
#end_block

#method_before
@SuppressWarnings("incomplete-switch")
private void writeCpu() {
    writer.writeStartElement("cpu");
    String cpuType = createInfo.get(VdsProperties.cpuType).toString();
    switch(vm.getClusterArch().getFamily()) {
        case x86:
            writer.writeAttributeString("match", "exact");
            // is this a list of strings??..
            switch(cpuType) {
                case "hostPassthrough":
                    writer.writeAttributeString("mode", "host-passthrough");
                    break;
                case "hostModel":
                    writer.writeAttributeString("mode", "host-model");
                    break;
                default:
                    writer.writeStartElement("model");
                    writer.writeRaw(cpuType);
                    // TODO: features
                    writer.writeEndElement();
                    break;
            }
            break;
        case ppc:
            writer.writeStartElement("model");
            writer.writeRaw(cpuType);
            writer.writeEndElement();
    }
    if ((boolean) Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        writer.writeStartElement("topology");
        writer.writeAttributeString("cores", Integer.toString(vm.getCpuPerSocket()));
        writer.writeAttributeString("threads", Integer.toString(vm.getThreadsPerCpu()));
        int vcpus = FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch()) ? VmCpuCountHelper.calcMaxVCpu(vm, vm.getClusterCompatibilityVersion()) : vm.getNumOfCpus();
        writer.writeAttributeString("sockets", String.valueOf(vcpus / vm.getCpuPerSocket() / vm.getThreadsPerCpu()));
        writer.writeEndElement();
    }
    if (createInfo.containsKey(VdsProperties.VM_NUMA_NODES)) {
        writer.writeStartElement("numa");
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> createVmNumaNodes = (List<Map<String, Object>>) createInfo.get(VdsProperties.VM_NUMA_NODES);
        for (Map<String, Object> vmNumaNode : createVmNumaNodes) {
            writer.writeStartElement("cell");
            writer.writeAttributeString("cpus", vmNumaNode.get(VdsProperties.NUMA_NODE_CPU_LIST).toString());
            writer.writeAttributeString("memory", String.valueOf(Integer.parseInt((String) vmNumaNode.get(VdsProperties.VM_NUMA_NODE_MEM)) * 1024));
            writer.writeEndElement();
        }
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
@SuppressWarnings("incomplete-switch")
private void writeCpu() {
    writer.writeStartElement("cpu");
    String cpuType = createInfo.get(VdsProperties.cpuType).toString();
    switch(vm.getClusterArch().getFamily()) {
        case x86:
            writer.writeAttributeString("match", "exact");
            // is this a list of strings??..
            switch(cpuType) {
                case "hostPassthrough":
                    writer.writeAttributeString("mode", "host-passthrough");
                    break;
                case "hostModel":
                    writer.writeAttributeString("mode", "host-model");
                    break;
                default:
                    writer.writeStartElement("model");
                    writer.writeRaw(cpuType);
                    // TODO: features
                    writer.writeEndElement();
                    break;
            }
            break;
        case ppc:
            writer.writeStartElement("model");
            writer.writeRaw(cpuType);
            writer.writeEndElement();
    }
    if ((boolean) Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        writer.writeStartElement("topology");
        writer.writeAttributeString("cores", Integer.toString(vm.getCpuPerSocket()));
        writer.writeAttributeString("threads", Integer.toString(vm.getThreadsPerCpu()));
        int vcpus = FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch()) ? VmCpuCountHelper.calcMaxVCpu(vm, vm.getClusterCompatibilityVersion()) : vm.getNumOfCpus();
        writer.writeAttributeString("sockets", String.valueOf(vcpus / vm.getCpuPerSocket() / vm.getThreadsPerCpu()));
        writer.writeEndElement();
    }
    if (createInfo.containsKey(VdsProperties.VM_NUMA_NODES)) {
        writer.writeStartElement("numa");
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> createVmNumaNodes = (List<Map<String, Object>>) createInfo.get(VdsProperties.VM_NUMA_NODES);
        for (Map<String, Object> vmNumaNode : createVmNumaNodes) {
            writer.writeStartElement("cell");
            writer.writeAttributeString("cpus", vmNumaNode.get(VdsProperties.NUMA_NODE_CPU_LIST).toString());
            writer.writeAttributeString("memory", String.valueOf(Integer.parseInt((String) vmNumaNode.get(VdsProperties.VM_NUMA_NODE_MEM)) * 1024));
            writer.writeEndElement();
        }
        writer.writeEndElement();
    }
    if (vm.getVmType() == VmType.HighPerformance) {
        writer.writeStartElement("cache");
        writer.writeAttributeString("level", "3");
        writer.writeAttributeString("mode", "emulate");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeCpuTune() {
    writer.writeStartElement("cputune");
    @SuppressWarnings("unchecked")
    Map<String, Object> cpuPinning = (Map<String, Object>) createInfo.get(VdsProperties.cpuPinning);
    if (cpuPinning != null) {
        cpuPinning.forEach((vcpu, cpuset) -> {
            writer.writeStartElement("vcpupin");
            writer.writeAttributeString("vcpu", vcpu);
            writer.writeAttributeString("cpuset", (String) cpuset);
            writer.writeEndElement();
        });
    }
    if (vm.getCpuShares() > 0) {
        writer.writeElement("shares", String.valueOf(vm.getCpuShares()));
    }
    writer.writeEndElement();
}
#method_after
private void writeCpuTune() {
    writer.writeStartElement("cputune");
    @SuppressWarnings("unchecked")
    Map<String, Object> cpuPinning = (Map<String, Object>) createInfo.get(VdsProperties.cpuPinning);
    if (cpuPinning != null) {
        cpuPinning.forEach((vcpu, cpuset) -> {
            writer.writeStartElement("vcpupin");
            writer.writeAttributeString("vcpu", vcpu);
            writer.writeAttributeString("cpuset", (String) cpuset);
            writer.writeEndElement();
        });
    }
    if (vm.getCpuShares() > 0) {
        writer.writeElement("shares", String.valueOf(vm.getCpuShares()));
    }
    // iothreadpin + emulatorpin
    String ioEmulatorCpus = vmInfoBuildUtils.getIoThreadsAndEmulatorPinningCpus(vm, hostNumaNodesSupplier, vdsCpuThreads);
    if (ioEmulatorCpus != null) {
        for (int i = 0; i < vm.getNumOfIoThreads(); i++) {
            writer.writeStartElement("iothreadpin");
            writer.writeAttributeString("iothread", String.valueOf(i + 1));
            writer.writeAttributeString("cpuset", ioEmulatorCpus);
            writer.writeEndElement();
        }
        writer.writeStartElement("emulatorpin");
        writer.writeAttributeString("cpuset", ioEmulatorCpus);
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeVmMetadata() {
    writer.writeStartElement(OVIRT_VM_URI, "vm");
    writeMinGuaranteedMemoryMetadata();
    writeClusterVersionMetadata();
    writeVmCustomMetadata();
    writeNetworkInterfaceMetadata();
    writeDiskMetadata();
    writeRunAndPauseMetadata();
    writeResumeBehaviorMetadata();
    writer.writeEndElement();
}
#method_after
private void writeVmMetadata() {
    writer.writeStartElement(OVIRT_VM_URI, "vm");
    writeMinGuaranteedMemoryMetadata();
    writeClusterVersionMetadata();
    writeVmCustomMetadata();
    writeNetworkInterfaceMetadata();
    writeDiskMetadata();
    writeRunAndPauseMetadata();
    writePayloadMetadata();
    writeResumeBehaviorMetadata();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeResumeBehaviorMetadata() {
    if (vm.getResumeBehavior() != null && FeatureSupported.isResumeBehaviorSupported(vm.getCompatibilityVersion())) {
        writer.writeElement("resumeBehavior", String.valueOf(vm.getResumeBehavior()).toLowerCase());
    }
}
#method_after
private void writeResumeBehaviorMetadata() {
    if (FeatureSupported.isResumeBehaviorSupported(vm.getCompatibilityVersion())) {
        writer.writeElement("resumeBehavior", String.valueOf(vm.getResumeBehavior()).toLowerCase());
    }
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    writer.writeStartElement("devices");
    writeInput();
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if (device.getSpecParams() != null && "serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmDevicesMonitoring.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    writer.writeStartElement("devices");
    writeInput();
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if (device.getSpecParams() != null && "serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmDevicesMonitoring.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#end_block

#method_before
private List<VmDevice> overrideDevicesForRunOnce(List<VmDevice> devices) {
    if (!vm.isRunOnce()) {
        return devices;
    }
    // video device handling
    DisplayType displayType = vm.getDefaultDisplayType();
    if (displayType != null) {
        // remove existing video device
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.VIDEO).collect(Collectors.toList());
        // add new video device
        if (displayType != DisplayType.none) {
            devices.add(vmInfoBuildUtils.createVideoDeviceByDisplayType(displayType, vm.getId()));
        }
    }
    // graphics device handling
    if (displayType == DisplayType.none || (vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty())) {
        // remove existing graphics devices
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.GRAPHICS).collect(Collectors.toList());
        if (displayType != DisplayType.none) {
            // add new graphics devices
            Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
            Map<String, Object> specParamsFromVm = new HashMap<>();
            vmInfoBuildUtils.addVmGraphicsOptions(infos, specParamsFromVm, vm);
            devices.addAll(vmInfoBuildUtils.createGraphicsDevices(infos, specParamsFromVm, vm.getId()));
        }
    }
    if (runOncePayload != null) {
        devices = devices.stream().filter(dev -> !VmPayload.isPayload(dev.getSpecParams())).collect(Collectors.toList());
        devices.add(runOncePayload);
    }
    // the user may specify floppy path while there is no device in the database
    if (!StringUtils.isEmpty(vm.getFloppyPath()) && !devices.stream().anyMatch(dev -> !dev.getDevice().equals(VmDeviceType.FLOPPY.getName()))) {
        devices.add(vmInfoBuildUtils.createFloppyDevice(vm));
    }
    return devices;
}
#method_after
private List<VmDevice> overrideDevicesForRunOnce(List<VmDevice> devices) {
    if (!vm.isRunOnce()) {
        return devices;
    }
    // video device handling
    DisplayType displayType = vm.getDefaultDisplayType();
    if (displayType != null) {
        // remove existing video device
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.VIDEO).collect(Collectors.toList());
        // add new video device
        if (displayType != DisplayType.none) {
            devices.add(vmInfoBuildUtils.createVideoDeviceByDisplayType(displayType, vm.getId()));
        }
    }
    // graphics device handling
    if (displayType == DisplayType.none || (vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty())) {
        // remove existing graphics devices
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.GRAPHICS).collect(Collectors.toList());
        if (displayType != DisplayType.none) {
            // add new graphics devices
            Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
            Map<String, Object> specParamsFromVm = new HashMap<>();
            vmInfoBuildUtils.addVmGraphicsOptions(infos, specParamsFromVm, vm);
            devices.addAll(vmInfoBuildUtils.createGraphicsDevices(infos, specParamsFromVm, vm.getId()));
        }
    }
    // the user may specify floppy path while there is no device in the database
    if (!StringUtils.isEmpty(vm.getFloppyPath()) && !devices.stream().anyMatch(dev -> !dev.getDevice().equals(VmDeviceType.FLOPPY.getName()))) {
        devices.add(vmInfoBuildUtils.createFloppyDevice(vm));
    }
    return devices;
}
#end_block

#method_before
private void writeFloppy(VmDevice device) {
    if (device == null) {
        return;
    }
    // <disk device="floppy" snapshot="no" type="file">
    // <source file="/var/run/vdsm/payload/8b5fa6b8-9c57-4d7c-80cb-64537eea560f.6e38a5ccb3c6b2b674086e9d07126a03.img" startupPolicy="optional" />
    // <target bus="fdc" dev="fda" />
    // <readonly />
    // </disk>
    writer.writeStartElement("disk");
    writer.writeAttributeString("type", "file");
    writer.writeAttributeString("device", "floppy");
    writer.writeAttributeString("snapshot", "no");
    writer.writeStartElement("source");
    writer.writeAttributeString("file", VmPayload.isPayload(device.getSpecParams()) ? "PAYLOAD:" : vm.getFloppyPath());
    writer.writeAttributeString("startupPolicy", "optional");
    writer.writeEndElement();
    writer.writeStartElement("target");
    // IDE slot 2 is reserved by VDSM to CDROM
    writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(VdsProperties.Fdc, 0));
    writer.writeAttributeString("bus", VdsProperties.Fdc);
    writer.writeEndElement();
    writer.writeElement("readonly");
    writeAddress(device);
    writer.writeEndElement();
}
#method_after
private void writeFloppy(VmDevice device) {
    if (device == null) {
        return;
    }
    // <disk device="floppy" snapshot="no" type="file">
    // <source file="/var/run/vdsm/payload/8b5fa6b8-9c57-4d7c-80cb-64537eea560f.6e38a5ccb3c6b2b674086e9d07126a03.img" startupPolicy="optional" />
    // <target bus="fdc" dev="fda" />
    // <readonly />
    // </disk>
    writer.writeStartElement("disk");
    writer.writeAttributeString("type", "file");
    writer.writeAttributeString("device", "floppy");
    writer.writeAttributeString("snapshot", "no");
    writer.writeStartElement("source");
    writer.writeAttributeString("file", VmPayload.isPayload(device.getSpecParams()) ? "PAYLOAD:" : vm.getFloppyPath());
    writer.writeAttributeString("startupPolicy", "optional");
    writer.writeEndElement();
    writer.writeStartElement("target");
    // IDE slot 2 is reserved by VDSM to CDROM
    String name = vmInfoBuildUtils.makeDiskName(VdsProperties.Fdc, 0);
    writer.writeAttributeString("dev", name);
    writer.writeAttributeString("bus", VdsProperties.Fdc);
    writer.writeEndElement();
    writer.writeElement("readonly");
    writeAddress(device);
    payloadMetadata = new Pair<>(name, new VmPayload(device));
    writer.writeEndElement();
}
#end_block

#method_before
private void writeCdRom(List<VmDevice> devices) {
    // <disk type='file' device='cdrom' snapshot='no'>
    // <driver name='qemu' type='raw' error_policy='report' />
    // <source file='<path>' startupPolicy='optional'/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    devices.stream().filter(d -> VmPayload.isPayload(d.getSpecParams())).forEach(device -> {
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", "PAYLOAD:");
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        payloadIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, payloadIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if ("scsi".equals(cdInterface)) {
            int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
            writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
        writer.writeEndElement();
    });
    VmDevice nonPayload = devices.stream().filter(d -> !VmPayload.isPayload(d.getSpecParams())).findAny().orElse(null);
    if (nonPayload != null || (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath()))) {
        // add a device that points to vm.getCdPath()
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", vm.getCdPath());
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if (nonPayload != null) {
            writeAddress(nonPayload);
            writeBootOrder(nonPayload.getBootOrder());
        }
        writer.writeEndElement();
    }
}
#method_after
private void writeCdRom(List<VmDevice> devices) {
    // <disk type='file' device='cdrom' snapshot='no'>
    // <driver name='qemu' type='raw' error_policy='report' />
    // <source file='<path>' startupPolicy='optional'/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    devices.stream().filter(d -> VmPayload.isPayload(d.getSpecParams())).forEach(device -> {
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", "PAYLOAD:");
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        payloadIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        String name = vmInfoBuildUtils.makeDiskName(cdInterface, payloadIndex);
        writer.writeAttributeString("dev", name);
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if ("scsi".equals(cdInterface)) {
            int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
            writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
        payloadMetadata = new Pair<>(name, new VmPayload(device));
        writer.writeEndElement();
    });
    VmDevice nonPayload = devices.stream().filter(d -> !VmPayload.isPayload(d.getSpecParams())).findAny().orElse(null);
    if (nonPayload != null || (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath()))) {
        // add a device that points to vm.getCdPath()
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", vm.getCdPath());
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if (nonPayload != null) {
            writeAddress(nonPayload);
            writeBootOrder(nonPayload.getBootOrder());
        }
        writer.writeEndElement();
    }
}
#end_block

#method_before
public void autoSelectResumeBehavior(VmStatic vmStaticData, Cluster cluster) {
    Version version = vmStaticData.getCustomCompatibilityVersion() == null ? cluster.getCompatibilityVersion() : vmStaticData.getCustomCompatibilityVersion();
    if (Version.v4_2.greaterOrEquals(version)) {
        if (vmStaticData.isAutoStartup() && vmStaticData.getLeaseStorageDomainId() != null) {
            // since 4.2 the only supported resume behavior for HA vms with lease is kill
            vmStaticData.setResumeBehavior(ResumeBehavior.KILL);
        }
    }
}
#method_after
public void autoSelectResumeBehavior(VmBase vmBase, Cluster cluster) {
    if (cluster == null) {
        return;
    }
    autoSelectResumeBehavior(vmBase, cluster.getCompatibilityVersion());
}
#end_block

#method_before
public String getName() {
    return name;
}
#method_after
public String getName() {
    return StringUtils.isNotEmpty(vmBase.getName()) ? vmBase.getName() : EmptyName;
}
#end_block

#method_before
private void readHeader() {
    XmlNode node = selectSingleNode(_document, "//ovf:Envelope", _xmlNS);
    if (node == null) {
        node = selectSingleNode(_document, "//Envelope", _xmlNS);
    }
    version = node != null ? node.attributes.get("ovf:version").getValue() : "";
}
#method_after
protected void readHeader(XmlNode header) {
}
#end_block

#method_before
@Override
public void buildReference() {
    buildFileReference();
    buildNicReference();
}
#method_after
@Override
public void buildReference() {
    buildFileReference();
}
#end_block

#method_before
protected void readHardwareSection(XmlNode section) {
    boolean readVirtioSerial = false;
    for (XmlNode node : selectNodes(section, "Item")) {
        switch(selectSingleNode(node, "rasd:ResourceType", _xmlNS).innerText) {
            case OvfHardware.CPU:
                readCpuItem(node);
                break;
            case OvfHardware.Memory:
                readMemoryItem(node);
                break;
            case OvfHardware.DiskImage:
                readDiskImageItem(node);
                break;
            case OvfHardware.Network:
                readNetworkItem(node);
                break;
            case OvfHardware.USB:
                readUsbItem(node);
                break;
            case OvfHardware.Monitor:
                readMonitorItem(node);
                break;
            case OvfHardware.Graphics:
                // so far graphics doesn't contain anything special
                readManagedVmDevice(node, Guid.newGuid());
                break;
            case OvfHardware.CD:
                readCdItem(node);
                break;
            case OvfHardware.OTHER:
                VmDevice vmDevice = readOtherHardwareItem(node);
                readVirtioSerial = readVirtioSerial || VmDeviceType.VIRTIOSERIAL.getName().equals(vmDevice.getDevice());
                break;
        }
    }
    if (!readVirtioSerial) {
        addManagedVmDevice(VmDeviceCommonUtils.createVirtioSerialDeviceForVm(vmBase.getId()));
    }
}
#method_after
protected void readHardwareSection(XmlNode section) {
    boolean readVirtioSerial = false;
    int nicIdx = 0;
    for (XmlNode node : selectNodes(section, "Item")) {
        switch(selectSingleNode(node, "rasd:ResourceType", _xmlNS).innerText) {
            case OvfHardware.CPU:
                readCpuItem(node);
                break;
            case OvfHardware.Memory:
                readMemoryItem(node);
                break;
            case OvfHardware.DiskImage:
                readDiskImageItem(node);
                break;
            case OvfHardware.Network:
                readNetworkItem(node, ++nicIdx);
                break;
            case OvfHardware.USB:
                readUsbItem(node);
                break;
            case OvfHardware.Monitor:
                readMonitorItem(node);
                break;
            case OvfHardware.Graphics:
                // so far graphics doesn't contain anything special
                readManagedVmDevice(node, Guid.newGuid());
                break;
            case OvfHardware.CD:
                readCdItem(node);
                break;
            case OvfHardware.OTHER:
                VmDevice vmDevice = readOtherHardwareItem(node);
                readVirtioSerial = readVirtioSerial || VmDeviceType.VIRTIOSERIAL.getName().equals(vmDevice.getDevice());
                break;
        }
    }
    if (!readVirtioSerial) {
        addManagedVmDevice(VmDeviceCommonUtils.createVirtioSerialDeviceForVm(vmBase.getId()));
    }
}
#end_block

#method_before
private void readCpuItem(XmlNode node) {
    vmBase.setNumOfSockets(Integer.parseInt(selectSingleNode(node, "rasd:num_of_sockets", _xmlNS).innerText));
    vmBase.setCpuPerSocket(Integer.parseInt(selectSingleNode(node, "rasd:cpu_per_socket", _xmlNS).innerText));
    vmBase.setThreadsPerCpu(parseNodeInteger(node, "rasd:threads_per_cpu", 1));
}
#method_after
protected void readCpuItem(XmlNode node) {
    vmBase.setNumOfSockets(Integer.parseInt(selectSingleNode(node, "rasd:num_of_sockets", _xmlNS).innerText));
    vmBase.setCpuPerSocket(Integer.parseInt(selectSingleNode(node, "rasd:cpu_per_socket", _xmlNS).innerText));
    vmBase.setThreadsPerCpu(parseNodeInteger(node, "rasd:threads_per_cpu", 1));
}
#end_block

#method_before
private void readNetworkItem(XmlNode node) {
    VmNetworkInterface iface = getNetworkInterface(node);
    updateSingleNic(node, iface);
    vmBase.getInterfaces().add(iface);
    readManagedVmDevice(node, iface.getId());
}
#method_after
private void readNetworkItem(XmlNode node, int nicIdx) {
    VmNetworkInterface iface = getNetworkInterface(node);
    updateSingleNic(node, iface, nicIdx);
    readManagedVmDevice(node, iface.getId());
}
#end_block

#method_before
protected void readGeneralData() {
    XmlNode content = selectSingleNode(_document, "//*/Content");
    XmlNode node;
    vmBase.setVmInit(new VmInit());
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    consumeReadProperty(content, DESCRIPTION, val -> vmBase.setDescription(val));
    consumeReadProperty(content, COMMENT, val -> vmBase.setComment(val));
    consumeReadProperty(content, DOMAIN, val -> vmBase.getVmInit().setDomain(val));
    consumeReadProperty(content, CREATION_DATE, val -> vmBase.setCreationDate(OvfParser.utcDateStringToLocalDate(val)));
    consumeReadProperty(content, EXPORT_DATE, val -> vmBase.setExportDate(OvfParser.utcDateStringToLocalDate(val)));
    consumeReadProperty(content, DEFAULT_BOOT_SEQUENCE, val -> vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, INITRD_URL, val -> vmBase.setInitrdUrl(val));
    consumeReadProperty(content, KERNEL_URL, val -> vmBase.setKernelUrl(val));
    consumeReadProperty(content, KERNEL_PARAMS, val -> vmBase.setKernelParams(val));
    consumeReadProperty(content, GENERATION, val -> vmBase.setDbGeneration(Long.parseLong(val)), () -> vmBase.setDbGeneration(1L));
    node = selectSingleNode(content, CUSTOM_COMPATIBILITY_VERSION);
    if (node != null) {
        vmBase.setCustomCompatibilityVersion(new Version(node.innerText));
    }
    // the originating ENGINE version
    Version originVersion = new Version(getVersion());
    node = selectSingleNode(content, CLUSTER_COMPATIBILITY_VERSION);
    if (node != null) {
        originVersion = new Version(node.innerText);
    }
    vmBase.setClusterCompatibilityVersionOrigin(originVersion);
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    consumeReadProperty(content, getDefaultDisplayTypeStringRepresentation(), val -> vmBase.setDefaultDisplayType(DisplayType.forValue(Integer.parseInt(val))));
    XmlNodeList list = selectNodes(content, "Section");
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || vmBase.getDefaultDisplayType() != DisplayType.qxl) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    // after reading the hardware section, if graphics device is still absent, add a default one
    addDefaultGraphicsDevice();
    fixDiskVmElements();
    // due to dependency on vmBase.getOsId() must be read AFTER readOsSection
    consumeReadProperty(content, TIMEZONE, val -> vmBase.setTimeZone(val), () -> {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    });
    consumeReadProperty(content, ORIGIN, val -> vmBase.setOrigin(OriginType.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, VM_TYPE, val -> vmBase.setVmType(VmType.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, RESUME_BEHAVIOR, val -> vmBase.setResumeBehavior(ResumeBehavior.valueOf(val)));
    consumeReadProperty(content, IS_SMARTCARD_ENABLED, val -> vmBase.setSmartcardEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, NUM_OF_IOTHREADS, val -> vmBase.setNumOfIoThreads(Integer.parseInt(val)));
    consumeReadProperty(content, DELETE_PROTECTED, val -> vmBase.setDeleteProtected(Boolean.parseBoolean(val)));
    consumeReadProperty(content, SSO_METHOD, val -> vmBase.setSsoMethod(SsoMethod.fromString(val)));
    consumeReadProperty(content, TUNNEL_MIGRATION, val -> vmBase.setTunnelMigration(Boolean.parseBoolean(val)));
    consumeReadProperty(content, VNC_KEYBOARD_LAYOUT, val -> vmBase.setVncKeyboardLayout(val));
    consumeReadProperty(content, MIN_ALLOCATED_MEMORY, val -> vmBase.setMinAllocatedMem(Integer.parseInt(val)));
    consumeReadProperty(content, IS_STATELESS, val -> vmBase.setStateless(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_RUN_AND_PAUSE, val -> vmBase.setRunAndPause(Boolean.parseBoolean(val)));
    consumeReadProperty(content, CREATED_BY_USER_ID, val -> vmBase.setCreatedByUserId(Guid.createGuidFromString(val)));
    consumeReadProperty(content, MIGRATION_DOWNTIME, val -> vmBase.setMigrationDowntime(Integer.parseInt(val)));
    consumeReadProperty(content, MIGRATION_SUPPORT, val -> vmBase.setMigrationSupport(MigrationSupport.forValue(Integer.parseInt(val))));
    // TODO dedicated to multiple hosts
    readDedicatedHostsList();
    consumeReadProperty(content, SERIAL_NUMBER_POLICY, val -> vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, CUSTOM_SERIAL_NUMBER, val -> vmBase.setCustomSerialNumber(val));
    consumeReadProperty(content, AUTO_STARTUP, val -> vmBase.setAutoStartup(Boolean.parseBoolean(val)));
    consumeReadProperty(content, PRIORITY, val -> vmBase.setPriority(Integer.parseInt(val)));
    consumeReadProperty(content, IS_BOOT_MENU_ENABLED, val -> vmBase.setBootMenuEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_SPICE_FILE_TRANSFER_ENABLED, val -> vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_SPICE_COPY_PASTE_ENABLED, val -> vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, ALLOW_CONSOLE_RECONNECT, val -> vmBase.setAllowConsoleReconnect(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_AUTO_CONVERGE, val -> vmBase.setAutoConverge(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_MIGRATE_COMPRESSED, val -> vmBase.setMigrateCompressed(Boolean.parseBoolean(val)));
    consumeReadProperty(content, MIGRATION_POLICY_ID, val -> vmBase.setMigrationPolicyId(Guid.createGuidFromString(val)));
    consumeReadProperty(content, CUSTOM_EMULATED_MACHINE, val -> vmBase.setCustomEmulatedMachine(val));
    consumeReadProperty(content, CUSTOM_CPU_NAME, val -> vmBase.setCustomCpuName(val));
    consumeReadProperty(content, PREDEFINED_PROPERTIES, val -> vmBase.setPredefinedProperties(val));
    consumeReadProperty(content, USER_DEFINED_PROPERTIES, val -> vmBase.setUserDefinedProperties(val));
    consumeReadProperty(content, MAX_MEMORY_SIZE_MB, val -> vmBase.setMaxMemorySizeMb(Integer.parseInt(val)));
    vmBase.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(vmBase.getPredefinedProperties(), vmBase.getUserDefinedProperties()));
    consumeReadProperty(content, VM_LEASE, val -> vmBase.setLeaseStorageDomainId(new Guid(val)));
    readGeneralData(content);
    readVmInit(content);
}
#method_after
protected void readGeneralData(XmlNode content) {
    vmBase.setVmInit(new VmInit());
    consumeReadProperty(content, DESCRIPTION, val -> vmBase.setDescription(val));
    consumeReadProperty(content, COMMENT, val -> vmBase.setComment(val));
    consumeReadProperty(content, DOMAIN, val -> vmBase.getVmInit().setDomain(val));
    consumeReadProperty(content, CREATION_DATE, val -> vmBase.setCreationDate(OvfParser.utcDateStringToLocalDate(val)));
    consumeReadProperty(content, EXPORT_DATE, val -> vmBase.setExportDate(OvfParser.utcDateStringToLocalDate(val)));
    consumeReadProperty(content, DEFAULT_BOOT_SEQUENCE, val -> vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, INITRD_URL, val -> vmBase.setInitrdUrl(val));
    consumeReadProperty(content, KERNEL_URL, val -> vmBase.setKernelUrl(val));
    consumeReadProperty(content, KERNEL_PARAMS, val -> vmBase.setKernelParams(val));
    consumeReadProperty(content, GENERATION, val -> vmBase.setDbGeneration(Long.parseLong(val)), () -> vmBase.setDbGeneration(1L));
    XmlNode node = selectSingleNode(content, CUSTOM_COMPATIBILITY_VERSION);
    if (node != null) {
        vmBase.setCustomCompatibilityVersion(new Version(node.innerText));
    }
    // the originating ENGINE version
    Version originVersion = new Version(getVersion());
    node = selectSingleNode(content, CLUSTER_COMPATIBILITY_VERSION);
    if (node != null) {
        originVersion = new Version(node.innerText);
    }
    vmBase.setClusterCompatibilityVersionOrigin(originVersion);
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    consumeReadProperty(content, getDefaultDisplayTypeStringRepresentation(), val -> vmBase.setDefaultDisplayType(DisplayType.forValue(Integer.parseInt(val))));
    // after reading the hardware section, if graphics device is still absent, add a default one
    addDefaultGraphicsDevice();
    fixDiskVmElements();
    // due to dependency on vmBase.getOsId() must be read AFTER readOsSection
    consumeReadProperty(content, TIMEZONE, val -> vmBase.setTimeZone(val), () -> {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    });
    consumeReadProperty(content, ORIGIN, val -> vmBase.setOrigin(OriginType.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, VM_TYPE, val -> vmBase.setVmType(VmType.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, RESUME_BEHAVIOR, val -> vmBase.setResumeBehavior(VmResumeBehavior.valueOf(val)));
    consumeReadProperty(content, IS_SMARTCARD_ENABLED, val -> vmBase.setSmartcardEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, NUM_OF_IOTHREADS, val -> vmBase.setNumOfIoThreads(Integer.parseInt(val)));
    consumeReadProperty(content, DELETE_PROTECTED, val -> vmBase.setDeleteProtected(Boolean.parseBoolean(val)));
    consumeReadProperty(content, SSO_METHOD, val -> vmBase.setSsoMethod(SsoMethod.fromString(val)));
    consumeReadProperty(content, TUNNEL_MIGRATION, val -> vmBase.setTunnelMigration(Boolean.parseBoolean(val)));
    consumeReadProperty(content, VNC_KEYBOARD_LAYOUT, val -> vmBase.setVncKeyboardLayout(val));
    consumeReadProperty(content, MIN_ALLOCATED_MEMORY, val -> vmBase.setMinAllocatedMem(Integer.parseInt(val)));
    consumeReadProperty(content, IS_STATELESS, val -> vmBase.setStateless(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_RUN_AND_PAUSE, val -> vmBase.setRunAndPause(Boolean.parseBoolean(val)));
    consumeReadProperty(content, CREATED_BY_USER_ID, val -> vmBase.setCreatedByUserId(Guid.createGuidFromString(val)));
    consumeReadProperty(content, MIGRATION_DOWNTIME, val -> vmBase.setMigrationDowntime(Integer.parseInt(val)));
    consumeReadProperty(content, MIGRATION_SUPPORT, val -> vmBase.setMigrationSupport(MigrationSupport.forValue(Integer.parseInt(val))));
    // TODO dedicated to multiple hosts
    readDedicatedHostsList();
    consumeReadProperty(content, SERIAL_NUMBER_POLICY, val -> vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, CUSTOM_SERIAL_NUMBER, val -> vmBase.setCustomSerialNumber(val));
    consumeReadProperty(content, AUTO_STARTUP, val -> vmBase.setAutoStartup(Boolean.parseBoolean(val)));
    consumeReadProperty(content, PRIORITY, val -> vmBase.setPriority(Integer.parseInt(val)));
    consumeReadProperty(content, IS_BOOT_MENU_ENABLED, val -> vmBase.setBootMenuEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_SPICE_FILE_TRANSFER_ENABLED, val -> vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_SPICE_COPY_PASTE_ENABLED, val -> vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, ALLOW_CONSOLE_RECONNECT, val -> vmBase.setAllowConsoleReconnect(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_AUTO_CONVERGE, val -> vmBase.setAutoConverge(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_MIGRATE_COMPRESSED, val -> vmBase.setMigrateCompressed(Boolean.parseBoolean(val)));
    consumeReadProperty(content, MIGRATION_POLICY_ID, val -> vmBase.setMigrationPolicyId(Guid.createGuidFromString(val)));
    consumeReadProperty(content, CUSTOM_EMULATED_MACHINE, val -> vmBase.setCustomEmulatedMachine(val));
    consumeReadProperty(content, CUSTOM_CPU_NAME, val -> vmBase.setCustomCpuName(val));
    consumeReadProperty(content, PREDEFINED_PROPERTIES, val -> vmBase.setPredefinedProperties(val));
    consumeReadProperty(content, USER_DEFINED_PROPERTIES, val -> vmBase.setUserDefinedProperties(val));
    consumeReadProperty(content, MAX_MEMORY_SIZE_MB, val -> vmBase.setMaxMemorySizeMb(Integer.parseInt(val)));
    vmBase.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(vmBase.getPredefinedProperties(), vmBase.getUserDefinedProperties()));
    consumeReadProperty(content, VM_LEASE, val -> vmBase.setLeaseStorageDomainId(new Guid(val)));
    readVmInit(content);
}
#end_block

#method_before
protected void consumeReadProperty(XmlNode content, String propertyKey, Consumer<String> then, Runnable orElse) {
    XmlNode node = selectSingleNode(content, propertyKey);
    if (node != null && StringUtils.isNotEmpty(node.innerText)) {
        then.accept(node.innerText);
        return;
    }
    if (orElse != null) {
        orElse.run();
    }
}
#method_after
protected void consumeReadProperty(XmlNode content, String propertyKey, Consumer<String> then, Runnable orElse) {
    XmlNode node = selectSingleNode(content, propertyKey);
    acceptNode(then, orElse, node);
}
#end_block

#method_before
protected void updateSingleNic(XmlNode node, VmNetworkInterface iface) {
    String networkName = selectSingleNode(node, VMD_CONNECTION, _xmlNS).innerText;
    iface.setNetworkName(StringUtils.defaultIfEmpty(networkName, null));
    XmlNode vnicProfileNameNode = selectSingleNode(node, VMD_VNIC_PROFILE_NAME, _xmlNS);
    iface.setVnicProfileName(vnicProfileNameNode == null ? null : StringUtils.defaultIfEmpty(vnicProfileNameNode.innerText, null));
    XmlNode linkedNode = selectSingleNode(node, VMD_LINKED, _xmlNS);
    iface.setLinked(linkedNode == null ? true : Boolean.valueOf(linkedNode.innerText));
    iface.setName(selectSingleNode(node, VMD_NAME, _xmlNS).innerText);
    String resourceSubType = selectSingleNode(node, "rasd:ResourceSubType", _xmlNS).innerText;
    if (StringUtils.isNotEmpty(resourceSubType)) {
        iface.setType(Integer.parseInt(resourceSubType));
    }
    XmlNode speed = selectSingleNode(node, "rasd:speed", _xmlNS);
    iface.setSpeed((speed != null) ? Integer.parseInt(speed.innerText) : VmInterfaceType.forValue(iface.getType()).getSpeed());
}
#method_after
protected void updateSingleNic(XmlNode node, VmNetworkInterface iface, int nicIdx) {
    String networkName = selectSingleNode(node, VMD_CONNECTION, _xmlNS).innerText;
    iface.setRemoteNetworkName(networkName);
    iface.setNetworkName(StringUtils.defaultIfEmpty(networkName, null));
    XmlNode vnicProfileNameNode = selectSingleNode(node, VMD_VNIC_PROFILE_NAME, _xmlNS);
    iface.setVnicProfileName(vnicProfileNameNode == null ? null : StringUtils.defaultIfEmpty(vnicProfileNameNode.innerText, null));
    XmlNode linkedNode = selectSingleNode(node, VMD_LINKED, _xmlNS);
    iface.setLinked(linkedNode == null ? true : Boolean.valueOf(linkedNode.innerText));
    XmlNode nameNode = selectSingleNode(node, VMD_NAME, _xmlNS);
    iface.setName(nameNode != null ? nameNode.innerText : String.format("nic%d", nicIdx));
    XmlNode resourceSubTypeNode = selectSingleNode(node, "rasd:ResourceSubType", _xmlNS);
    iface.setType(getVmInterfaceType(resourceSubTypeNode));
    XmlNode speed = selectSingleNode(node, "rasd:speed", _xmlNS);
    iface.setSpeed(speed != null ? Integer.parseInt(speed.innerText) : VmInterfaceType.forValue(iface.getType()).getSpeed());
}
#end_block

#method_before
private void setDeviceByResource(XmlNode node, VmDevice vmDevice) {
    int resourceType = getResourceType(node, VMD_RESOURCE_TYPE);
    int resourceSubType = getResourceType(node, VMD_SUB_RESOURCE_TYPE);
    if (resourceSubType == -1) {
        // we need special handling for Monitor to define it as vnc or spice
        if (Integer.parseInt(OvfHardware.Monitor) == resourceType) {
            // get number of monitors from VirtualQuantity in OVF
            if (selectSingleNode(node, VMD_VIRTUAL_QUANTITY, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, VMD_VIRTUAL_QUANTITY, _xmlNS).innerText)) {
                int virtualQuantity = Integer.parseInt(selectSingleNode(node, VMD_VIRTUAL_QUANTITY, _xmlNS).innerText);
                if (virtualQuantity > 1) {
                    vmDevice.setDevice(VmDeviceType.QXL.getName());
                } else {
                    // get first supported display device
                    List<Pair<GraphicsType, DisplayType>> supportedGraphicsAndDisplays = osRepository.getGraphicsAndDisplays(vmBase.getOsId(), new Version(getVersion()));
                    if (!supportedGraphicsAndDisplays.isEmpty()) {
                        DisplayType firstDisplayType = supportedGraphicsAndDisplays.get(0).getSecond();
                        vmDevice.setDevice(firstDisplayType.getDefaultVmDeviceType().getName());
                    } else {
                        vmDevice.setDevice(VmDeviceType.QXL.getName());
                    }
                }
            } else {
                // default to spice if quantity not found
                vmDevice.setDevice(VmDeviceType.QXL.getName());
            }
        } else {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    } else if (Integer.parseInt(OvfHardware.Network) == resourceType) {
        // handle interfaces with different sub types : we have 0-5 as the VmInterfaceType enum
        VmInterfaceType nicType = VmInterfaceType.forValue(resourceSubType);
        if (nicType != null) {
            if (nicType == VmInterfaceType.pciPassthrough) {
                vmDevice.setDevice(VmDeviceType.HOST_DEVICE.getName());
            } else {
                vmDevice.setDevice(VmDeviceType.BRIDGE.getName());
            }
        } else {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    }
}
#method_after
private void setDeviceByResource(XmlNode node, VmDevice vmDevice) {
    String resourceType = selectSingleNode(node, VMD_RESOURCE_TYPE, _xmlNS).innerText;
    XmlNode resourceSubTypeNode = selectSingleNode(node, VMD_SUB_RESOURCE_TYPE, _xmlNS);
    if (resourceSubTypeNode == null) {
        // we need special handling for Monitor to define it as vnc or spice
        if (OvfHardware.Monitor.equals(resourceType)) {
            // get number of monitors from VirtualQuantity in OVF
            if (selectSingleNode(node, VMD_VIRTUAL_QUANTITY, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, VMD_VIRTUAL_QUANTITY, _xmlNS).innerText)) {
                int virtualQuantity = Integer.parseInt(selectSingleNode(node, VMD_VIRTUAL_QUANTITY, _xmlNS).innerText);
                if (virtualQuantity > 1) {
                    vmDevice.setDevice(VmDeviceType.QXL.getName());
                } else {
                    // get first supported display device
                    List<Pair<GraphicsType, DisplayType>> supportedGraphicsAndDisplays = osRepository.getGraphicsAndDisplays(vmBase.getOsId(), new Version(getVersion()));
                    if (!supportedGraphicsAndDisplays.isEmpty()) {
                        DisplayType firstDisplayType = supportedGraphicsAndDisplays.get(0).getSecond();
                        vmDevice.setDevice(firstDisplayType.getDefaultVmDeviceType().getName());
                    } else {
                        vmDevice.setDevice(VmDeviceType.QXL.getName());
                    }
                }
            } else {
                // default to spice if quantity not found
                vmDevice.setDevice(VmDeviceType.QXL.getName());
            }
        } else {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(Integer.parseInt(resourceType)).getName());
        }
    } else if (OvfHardware.Network.equals(resourceType)) {
        // handle interfaces with different sub types : we have 0-5 as the VmInterfaceType enum
        Integer nicTypeValue = getVmInterfaceType(resourceSubTypeNode);
        VmInterfaceType nicType = nicTypeValue != null ? VmInterfaceType.forValue(nicTypeValue) : null;
        if (nicType != null) {
            if (nicType == VmInterfaceType.pciPassthrough) {
                vmDevice.setDevice(VmDeviceType.HOST_DEVICE.getName());
            } else {
                vmDevice.setDevice(VmDeviceType.BRIDGE.getName());
            }
        } else {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(Integer.parseInt(resourceType)).getName());
        }
    }
}
#end_block

#method_before
private void fixDiskVmElements() {
    // the wrong VM ID this part sets them to the correct VM ID
    for (DiskImage disk : _images) {
        disk.getDiskVmElements().forEach(dve -> dve.setId(new VmDeviceId(disk.getId(), vmBase.getId())));
        disk.setDiskVmElements(disk.getDiskVmElements());
    }
}
#method_after
private void fixDiskVmElements() {
    // the wrong VM ID this part sets them to the correct VM ID
    for (DiskImage disk : _images) {
        disk.getDiskVmElements().forEach(dve -> dve.setId(new VmDeviceId(disk.getId(), vmBase.getId())));
        disk.setDiskVmElements(disk.getDiskVmElements());
    }
    for (LunDisk lunDisk : luns) {
        lunDisk.getDiskVmElements().forEach(dve -> dve.setId(new VmDeviceId(lunDisk.getId(), vmBase.getId())));
        lunDisk.setDiskVmElements(lunDisk.getDiskVmElements());
    }
}
#end_block

#method_before
protected MapSqlParameterSource createBaseParametersMapper(T entity) {
    return createIdParameterMapper(entity.getId()).addValue("description", entity.getDescription()).addValue("free_text_comment", entity.getComment()).addValue("creation_date", entity.getCreationDate()).addValue("mem_size_mb", entity.getMemSizeMb()).addValue("max_memory_size_mb", entity.getMaxMemorySizeMb()).addValue("num_of_io_threads", entity.getNumOfIoThreads()).addValue("vnc_keyboard_layout", entity.getVncKeyboardLayout()).addValue("tunnel_migration", entity.getTunnelMigration()).addValue("cluster_id", entity.getClusterId()).addValue("num_of_sockets", entity.getNumOfSockets()).addValue("cpu_per_socket", entity.getCpuPerSocket()).addValue("threads_per_cpu", entity.getThreadsPerCpu()).addValue("os", entity.getOsId()).addValue("num_of_monitors", entity.getNumOfMonitors()).addValue("single_qxl_pci", entity.getSingleQxlPci()).addValue("allow_console_reconnect", entity.isAllowConsoleReconnect()).addValue("vm_type", entity.getVmType()).addValue("priority", entity.getPriority()).addValue("auto_startup", entity.isAutoStartup()).addValue("is_stateless", entity.isStateless()).addValue("is_smartcard_enabled", entity.isSmartcardEnabled()).addValue("is_delete_protected", entity.isDeleteProtected()).addValue("sso_method", entity.getSsoMethod().toString()).addValue("iso_path", entity.getIsoPath()).addValue("usb_policy", entity.getUsbPolicy()).addValue("time_zone", entity.getTimeZone()).addValue("fail_back", entity.isFailBack()).addValue("nice_level", entity.getNiceLevel()).addValue("cpu_shares", entity.getCpuShares()).addValue("default_boot_sequence", entity.getDefaultBootSequence()).addValue("default_display_type", entity.getDefaultDisplayType()).addValue("origin", entity.getOrigin()).addValue("initrd_url", entity.getInitrdUrl()).addValue("kernel_url", entity.getKernelUrl()).addValue("kernel_params", entity.getKernelParams()).addValue("quota_id", entity.getQuotaId()).addValue("migration_support", entity.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", entity.getDedicatedVmForVdsList().isEmpty() ? null : StringUtils.join(entity.getDedicatedVmForVdsList(), BaseDao.SEPARATOR)).addValue("min_allocated_mem", entity.getMinAllocatedMem()).addValue("is_run_and_pause", entity.isRunAndPause()).addValue("created_by_user_id", entity.getCreatedByUserId()).addValue("migration_downtime", entity.getMigrationDowntime()).addValue("serial_number_policy", entity.getSerialNumberPolicy() == null ? null : entity.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", entity.getCustomSerialNumber()).addValue("is_boot_menu_enabled", entity.isBootMenuEnabled()).addValue("is_spice_file_transfer_enabled", entity.isSpiceFileTransferEnabled()).addValue("is_spice_copy_paste_enabled", entity.isSpiceCopyPasteEnabled()).addValue("cpu_profile_id", entity.getCpuProfileId()).addValue("numatune_mode", entity.getNumaTuneMode().getValue()).addValue("is_auto_converge", entity.getAutoConverge()).addValue("is_migrate_compressed", entity.getMigrateCompressed()).addValue("predefined_properties", entity.getPredefinedProperties()).addValue("userdefined_properties", entity.getUserDefinedProperties()).addValue("custom_emulated_machine", entity.getCustomEmulatedMachine()).addValue("custom_cpu_name", entity.getCustomCpuName()).addValue(SMALL_ICON_ID_COLUMN, entity.getSmallIconId()).addValue(LARGE_ICON_ID_COLUMN, entity.getLargeIconId()).addValue("console_disconnect_action", entity.getConsoleDisconnectAction().toString()).addValue("resume_behavior", entity.getResumeBehavior() == null ? null : entity.getResumeBehavior().toString()).addValue("custom_compatibility_version", entity.getCustomCompatibilityVersion()).addValue("migration_policy_id", entity.getMigrationPolicyId()).addValue("lease_sd_id", entity.getLeaseStorageDomainId());
}
#method_after
protected MapSqlParameterSource createBaseParametersMapper(T entity) {
    return createIdParameterMapper(entity.getId()).addValue("description", entity.getDescription()).addValue("free_text_comment", entity.getComment()).addValue("creation_date", entity.getCreationDate()).addValue("mem_size_mb", entity.getMemSizeMb()).addValue("max_memory_size_mb", entity.getMaxMemorySizeMb()).addValue("num_of_io_threads", entity.getNumOfIoThreads()).addValue("vnc_keyboard_layout", entity.getVncKeyboardLayout()).addValue("tunnel_migration", entity.getTunnelMigration()).addValue("cluster_id", entity.getClusterId()).addValue("num_of_sockets", entity.getNumOfSockets()).addValue("cpu_per_socket", entity.getCpuPerSocket()).addValue("threads_per_cpu", entity.getThreadsPerCpu()).addValue("os", entity.getOsId()).addValue("num_of_monitors", entity.getNumOfMonitors()).addValue("single_qxl_pci", entity.getSingleQxlPci()).addValue("allow_console_reconnect", entity.isAllowConsoleReconnect()).addValue("vm_type", entity.getVmType()).addValue("priority", entity.getPriority()).addValue("auto_startup", entity.isAutoStartup()).addValue("is_stateless", entity.isStateless()).addValue("is_smartcard_enabled", entity.isSmartcardEnabled()).addValue("is_delete_protected", entity.isDeleteProtected()).addValue("sso_method", entity.getSsoMethod().toString()).addValue("iso_path", entity.getIsoPath()).addValue("usb_policy", entity.getUsbPolicy()).addValue("time_zone", entity.getTimeZone()).addValue("fail_back", entity.isFailBack()).addValue("nice_level", entity.getNiceLevel()).addValue("cpu_shares", entity.getCpuShares()).addValue("default_boot_sequence", entity.getDefaultBootSequence()).addValue("default_display_type", entity.getDefaultDisplayType()).addValue("origin", entity.getOrigin()).addValue("initrd_url", entity.getInitrdUrl()).addValue("kernel_url", entity.getKernelUrl()).addValue("kernel_params", entity.getKernelParams()).addValue("quota_id", entity.getQuotaId()).addValue("migration_support", entity.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", entity.getDedicatedVmForVdsList().isEmpty() ? null : StringUtils.join(entity.getDedicatedVmForVdsList(), BaseDao.SEPARATOR)).addValue("min_allocated_mem", entity.getMinAllocatedMem()).addValue("is_run_and_pause", entity.isRunAndPause()).addValue("created_by_user_id", entity.getCreatedByUserId()).addValue("migration_downtime", entity.getMigrationDowntime()).addValue("serial_number_policy", entity.getSerialNumberPolicy() == null ? null : entity.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", entity.getCustomSerialNumber()).addValue("is_boot_menu_enabled", entity.isBootMenuEnabled()).addValue("is_spice_file_transfer_enabled", entity.isSpiceFileTransferEnabled()).addValue("is_spice_copy_paste_enabled", entity.isSpiceCopyPasteEnabled()).addValue("cpu_profile_id", entity.getCpuProfileId()).addValue("numatune_mode", entity.getNumaTuneMode().getValue()).addValue("is_auto_converge", entity.getAutoConverge()).addValue("is_migrate_compressed", entity.getMigrateCompressed()).addValue("predefined_properties", entity.getPredefinedProperties()).addValue("userdefined_properties", entity.getUserDefinedProperties()).addValue("custom_emulated_machine", entity.getCustomEmulatedMachine()).addValue("custom_cpu_name", entity.getCustomCpuName()).addValue(SMALL_ICON_ID_COLUMN, entity.getSmallIconId()).addValue(LARGE_ICON_ID_COLUMN, entity.getLargeIconId()).addValue("console_disconnect_action", entity.getConsoleDisconnectAction().toString()).addValue("resume_behavior", entity.getResumeBehavior().toString()).addValue("custom_compatibility_version", entity.getCustomCompatibilityVersion()).addValue("migration_policy_id", entity.getMigrationPolicyId()).addValue("lease_sd_id", entity.getLeaseStorageDomainId());
}
#end_block

#method_before
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setMaxMemorySizeMb(rs.getInt("max_memory_size_mb"));
    entity.setNumOfIoThreads(rs.getInt("num_of_io_threads"));
    entity.setOsId(rs.getInt("os"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setThreadsPerCpu(rs.getInt("threads_per_cpu"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.setBootMenuEnabled(rs.getBoolean("is_boot_menu_enabled"));
    entity.setSpiceFileTransferEnabled(rs.getBoolean("is_spice_file_transfer_enabled"));
    entity.setSpiceCopyPasteEnabled(rs.getBoolean("is_spice_copy_paste_enabled"));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVdsList(Guid.createGuidListFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuProfileId(getGuid(rs, "cpu_profile_id"));
    entity.setNumaTuneMode(NumaTuneMode.forValue(rs.getString("numatune_mode")));
    entity.setAutoConverge((Boolean) rs.getObject("is_auto_converge"));
    entity.setMigrateCompressed((Boolean) rs.getObject("is_migrate_compressed"));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setCustomEmulatedMachine(rs.getString("custom_emulated_machine"));
    entity.setCustomCpuName(rs.getString("custom_cpu_name"));
    entity.setSmallIconId(getGuid(rs, SMALL_ICON_ID_COLUMN));
    entity.setLargeIconId(getGuid(rs, LARGE_ICON_ID_COLUMN));
    entity.setConsoleDisconnectAction(ConsoleDisconnectAction.fromDbString(rs.getString("console_disconnect_action")));
    String resumeBehavior = rs.getString("resume_behavior");
    entity.setResumeBehavior(resumeBehavior == null ? null : ResumeBehavior.valueOf(resumeBehavior));
    entity.setCustomCompatibilityVersion(new VersionRowMapper("custom_compatibility_version").mapRow(rs, 0));
    entity.setLeaseStorageDomainId(getGuid(rs, "lease_sd_id"));
    entity.setMigrationPolicyId(getGuid(rs, "migration_policy_id"));
}
#method_after
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setMaxMemorySizeMb(rs.getInt("max_memory_size_mb"));
    entity.setNumOfIoThreads(rs.getInt("num_of_io_threads"));
    entity.setOsId(rs.getInt("os"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setThreadsPerCpu(rs.getInt("threads_per_cpu"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.setBootMenuEnabled(rs.getBoolean("is_boot_menu_enabled"));
    entity.setSpiceFileTransferEnabled(rs.getBoolean("is_spice_file_transfer_enabled"));
    entity.setSpiceCopyPasteEnabled(rs.getBoolean("is_spice_copy_paste_enabled"));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVdsList(Guid.createGuidListFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuProfileId(getGuid(rs, "cpu_profile_id"));
    entity.setNumaTuneMode(NumaTuneMode.forValue(rs.getString("numatune_mode")));
    entity.setAutoConverge((Boolean) rs.getObject("is_auto_converge"));
    entity.setMigrateCompressed((Boolean) rs.getObject("is_migrate_compressed"));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setCustomEmulatedMachine(rs.getString("custom_emulated_machine"));
    entity.setCustomCpuName(rs.getString("custom_cpu_name"));
    entity.setSmallIconId(getGuid(rs, SMALL_ICON_ID_COLUMN));
    entity.setLargeIconId(getGuid(rs, LARGE_ICON_ID_COLUMN));
    entity.setConsoleDisconnectAction(ConsoleDisconnectAction.fromDbString(rs.getString("console_disconnect_action")));
    String resumeBehavior = rs.getString("resume_behavior");
    entity.setResumeBehavior(resumeBehavior == null ? null : VmResumeBehavior.valueOf(resumeBehavior));
    entity.setCustomCompatibilityVersion(new VersionRowMapper("custom_compatibility_version").mapRow(rs, 0));
    entity.setLeaseStorageDomainId(getGuid(rs, "lease_sd_id"));
    entity.setMigrationPolicyId(getGuid(rs, "migration_policy_id"));
}
#end_block

#method_before
@Override
protected void init() {
    if (Guid.isNullOrEmpty(getParameters().getVmTemplateId())) {
        getParameters().setVmTemplateId(Guid.newGuid());
    }
    setVmTemplateId(getParameters().getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    setVmTemplateName(getParameters().getName());
    VmStatic masterVm = getParameters().getMasterVm();
    if (masterVm != null) {
        setVmId(masterVm.getId());
        setClusterId(masterVm.getClusterId());
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(masterVm, getMasterVmCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            getParameters().setSoundDeviceEnabled(true);
        }
        if (getParameters().isSoundDeviceEnabled() == null) {
            getParameters().setSoundDeviceEnabled(false);
        }
        if (getParameters().isConsoleEnabled() == null) {
            getParameters().setConsoleEnabled(false);
        }
        vmHandler.updateDefaultTimeZone(masterVm);
        vmHandler.autoSelectUsbPolicy(masterVm);
        vmHandler.autoSelectDefaultDisplayType(getVmId(), masterVm, getCluster(), getParameters().getGraphicsDevices());
        vmHandler.autoSelectGraphicsDevice(getVmId(), masterVm, getCluster(), getParameters().getGraphicsDevices(), getMasterVmCompatibilityVersion());
        separateCustomProperties(masterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && masterVm != null) {
        VM vm = new VM(masterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    generateTargetDiskIds();
    getParameters().setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#method_after
@Override
protected void init() {
    if (Guid.isNullOrEmpty(getParameters().getVmTemplateId())) {
        getParameters().setVmTemplateId(Guid.newGuid());
    }
    setVmTemplateId(getParameters().getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    setVmTemplateName(getParameters().getName());
    VmStatic masterVm = getParameters().getMasterVm();
    if (masterVm != null) {
        setVmId(masterVm.getId());
        setClusterId(masterVm.getClusterId());
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(masterVm, getMasterVmCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            getParameters().setSoundDeviceEnabled(true);
        }
        if (getParameters().isSoundDeviceEnabled() == null) {
            getParameters().setSoundDeviceEnabled(false);
        }
        if (getParameters().isConsoleEnabled() == null) {
            getParameters().setConsoleEnabled(false);
        }
        vmHandler.updateDefaultTimeZone(masterVm);
        vmHandler.autoSelectUsbPolicy(masterVm);
        vmHandler.autoSelectDefaultDisplayType(getVmId(), masterVm, getCluster(), getParameters().getGraphicsDevices());
        vmHandler.autoSelectGraphicsDevice(getVmId(), masterVm, getCluster(), getParameters().getGraphicsDevices(), getMasterVmCompatibilityVersion());
        vmHandler.autoSelectResumeBehavior(masterVm, getCluster());
        separateCustomProperties(masterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && masterVm != null) {
        VM vm = new VM(masterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    generateTargetDiskIds();
    getParameters().setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#end_block

#method_before
private void updateDiskInfoDestinationMap() {
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    sourceImageDomainsImageMap = new HashMap<>();
    for (DiskImage image : images) {
        MultiValueMapUtils.addToMap(image.getStorageIds().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            // The volume's format and type were not specified and thus should be null.
            image.setVolumeFormat(null);
            image.setVolumeType(null);
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
}
#method_after
private void updateDiskInfoDestinationMap() {
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    sourceImageDomainsImageMap = new HashMap<>();
    for (DiskImage image : images) {
        sourceImageDomainsImageMap.computeIfAbsent(image.getStorageIds().get(0), k -> new ArrayList<>()).add(image);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            // The volume's format and type were not specified and thus should be null.
            image.setVolumeFormat(null);
            image.setVolumeType(null);
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
}
#end_block

#method_before
public ResumeBehavior getResumeBehavior() {
    return vmStatic.getResumeBehavior();
}
#method_after
public VmResumeBehavior getResumeBehavior() {
    return vmStatic.getResumeBehavior();
}
#end_block

#method_before
public void setResumeBehavior(ResumeBehavior resumeBehavior) {
    vmStatic.setResumeBehavior(resumeBehavior);
}
#method_after
public void setResumeBehavior(VmResumeBehavior resumeBehavior) {
    vmStatic.setResumeBehavior(resumeBehavior);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, autoStartup, cpuPerSocket, threadsPerCpu, creationDate, defaultBootSequence, description, failBack, initrdUrl, isoPath, kernelParams, kernelUrl, osId, memSizeMb, maxMemorySizeMb, niceLevel, cpuShares, numOfSockets, numOfMonitors, origin, priority, stateless, smartcardEnabled, timeZone, usbPolicy, clusterId, vmType, quotaId, allowConsoleReconnect, dedicatedVmForVdsList, migrationSupport, tunnelMigration, vncKeyboardLayout, createdByUserId, defaultDisplayType, migrationDowntime, serialNumberPolicy, customSerialNumber, bootMenuEnabled, spiceFileTransferEnabled, spiceCopyPasteEnabled, cpuProfileId, numaTuneMode, vNumaNodeList, autoConverge, migrateCompressed, predefinedProperties, userDefinedProperties, customEmulatedMachine, customCpuName, smallIconId, largeIconId, consoleDisconnectAction, customCompatibilityVersion);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, autoStartup, cpuPerSocket, threadsPerCpu, creationDate, defaultBootSequence, description, failBack, initrdUrl, isoPath, kernelParams, kernelUrl, osId, memSizeMb, maxMemorySizeMb, niceLevel, cpuShares, numOfSockets, numOfMonitors, origin, priority, stateless, smartcardEnabled, timeZone, usbPolicy, clusterId, vmType, quotaId, allowConsoleReconnect, dedicatedVmForVdsList, migrationSupport, tunnelMigration, vncKeyboardLayout, createdByUserId, defaultDisplayType, migrationDowntime, serialNumberPolicy, customSerialNumber, bootMenuEnabled, spiceFileTransferEnabled, spiceCopyPasteEnabled, cpuProfileId, numaTuneMode, vNumaNodeList, autoConverge, migrateCompressed, predefinedProperties, userDefinedProperties, customEmulatedMachine, customCpuName, smallIconId, largeIconId, consoleDisconnectAction, customCompatibilityVersion, resumeBehavior);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return Objects.equals(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && Objects.equals(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && Objects.equals(description, other.description) && failBack == other.failBack && Objects.equals(initrdUrl, other.initrdUrl) && Objects.equals(isoPath, other.isoPath) && Objects.equals(kernelParams, other.kernelParams) && Objects.equals(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && maxMemorySizeMb == other.maxMemorySizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && threadsPerCpu == other.threadsPerCpu && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && Objects.equals(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && Objects.equals(clusterId, other.clusterId) && vmType == other.vmType && Objects.equals(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && Objects.equals(dedicatedVmForVdsList, other.dedicatedVmForVdsList) && migrationSupport == other.migrationSupport && Objects.equals(tunnelMigration, other.tunnelMigration) && Objects.equals(vncKeyboardLayout, other.vncKeyboardLayout) && Objects.equals(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && Objects.equals(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && Objects.equals(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && Objects.equals(cpuProfileId, other.cpuProfileId) && Objects.equals(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && Objects.equals(vNumaNodeList, other.vNumaNodeList) && Objects.equals(autoConverge, other.autoConverge) && Objects.equals(migrateCompressed, other.migrateCompressed) && Objects.equals(predefinedProperties, other.predefinedProperties) && Objects.equals(userDefinedProperties, other.userDefinedProperties) && Objects.equals(customEmulatedMachine, other.customEmulatedMachine) && Objects.equals(customCpuName, other.customCpuName) && Objects.equals(smallIconId, other.smallIconId) && Objects.equals(largeIconId, other.largeIconId) && Objects.equals(consoleDisconnectAction, other.consoleDisconnectAction) && Objects.equals(customCompatibilityVersion, other.customCompatibilityVersion);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return Objects.equals(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && Objects.equals(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && Objects.equals(description, other.description) && failBack == other.failBack && Objects.equals(initrdUrl, other.initrdUrl) && Objects.equals(isoPath, other.isoPath) && Objects.equals(kernelParams, other.kernelParams) && Objects.equals(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && maxMemorySizeMb == other.maxMemorySizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && threadsPerCpu == other.threadsPerCpu && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && Objects.equals(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && Objects.equals(clusterId, other.clusterId) && vmType == other.vmType && Objects.equals(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && Objects.equals(dedicatedVmForVdsList, other.dedicatedVmForVdsList) && migrationSupport == other.migrationSupport && Objects.equals(tunnelMigration, other.tunnelMigration) && Objects.equals(vncKeyboardLayout, other.vncKeyboardLayout) && Objects.equals(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && Objects.equals(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && Objects.equals(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && Objects.equals(cpuProfileId, other.cpuProfileId) && Objects.equals(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && Objects.equals(vNumaNodeList, other.vNumaNodeList) && Objects.equals(autoConverge, other.autoConverge) && Objects.equals(migrateCompressed, other.migrateCompressed) && Objects.equals(predefinedProperties, other.predefinedProperties) && Objects.equals(userDefinedProperties, other.userDefinedProperties) && Objects.equals(customEmulatedMachine, other.customEmulatedMachine) && Objects.equals(customCpuName, other.customCpuName) && Objects.equals(smallIconId, other.smallIconId) && Objects.equals(largeIconId, other.largeIconId) && Objects.equals(consoleDisconnectAction, other.consoleDisconnectAction) && Objects.equals(resumeBehavior, other.resumeBehavior) && Objects.equals(customCompatibilityVersion, other.customCompatibilityVersion);
}
#end_block

#method_before
public ResumeBehavior getResumeBehavior() {
    return resumeBehavior;
}
#method_after
public VmResumeBehavior getResumeBehavior() {
    return resumeBehavior;
}
#end_block

#method_before
public void setResumeBehavior(ResumeBehavior resumeBehavior) {
    this.resumeBehavior = resumeBehavior;
}
#method_after
public void setResumeBehavior(VmResumeBehavior resumeBehavior) {
    this.resumeBehavior = resumeBehavior;
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = vmTemplateDao.getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for validate to run with correct values, has to come before init-disks
    if (isCompatibilityVersionSupportedByCluster(getEffectiveCompatibilityVersion())) {
        updateVmObject();
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !parameters.isConsoleEnabled()) {
        parameters.getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    vmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // needs this autoselection in order to not to break the API
    vmHandler.autoSelectResumeBehavior(getParameters().getVmStaticData(), getCluster());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
    if (vmDisksSource != null) {
        parameters.setUseCinderCommandCallback(!vmDisksSource.getDiskTemplateMap().isEmpty());
    }
}
#method_after
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = vmTemplateDao.getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for validate to run with correct values, has to come before init-disks
    if (isCompatibilityVersionSupportedByCluster(getEffectiveCompatibilityVersion())) {
        updateVmObject();
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !parameters.isConsoleEnabled()) {
        parameters.getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    vmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    vmHandler.autoSelectResumeBehavior(getParameters().getVmStaticData(), getCluster());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
    if (vmDisksSource != null) {
        parameters.setUseCinderCommandCallback(!vmDisksSource.getDiskTemplateMap().isEmpty());
    }
}
#end_block

#method_before
protected List<VmTemplate> filterTemplatesInClusterNeedUpdate() {
    if (!VmRngDevice.Source.urandomRandomUpdateRequired(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        return Collections.emptyList();
    }
    return vmTemplateDao.getAllForCluster(getCluster().getId()).stream().filter(template -> template.getCustomCompatibilityVersion() == null).sorted().collect(Collectors.toList());
}
#method_after
protected List<VmTemplate> filterTemplatesInClusterNeedUpdate() {
    return vmTemplateDao.getAllForCluster(getCluster().getId()).stream().filter(template -> template.getCustomCompatibilityVersion() == null).sorted().collect(Collectors.toList());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid newMacPoolId = getNewMacPoolId();
    moveMacs.migrateMacsToAnotherMacPool(oldCluster, newMacPoolId, getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    setDefaultFirewallTypeIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    clusterDao.update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
        // update gluster parameters on all hosts
        updateGlusterHosts();
    }
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        final NetworkCluster managementNetworkCluster = createManagementNetworkCluster();
        networkClusterDao.save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    updateVms();
    updateTemplates();
    if (!failedUpgradeEntities.isEmpty()) {
        logFailedUpgrades();
        failValidation(Arrays.asList(EngineMessage.CLUSTER_CANNOT_UPDATE_CLUSTER_FAILED_TO_UPDATE_VMS), "$VmList " + StringUtils.join(failedUpgradeEntities.keySet(), ", "));
        getReturnValue().setValid(false);
        setSucceeded(false);
        return;
    }
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid newMacPoolId = getNewMacPoolId();
    moveMacs.migrateMacsToAnotherMacPool(oldCluster, newMacPoolId, getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    setDefaultFirewallTypeIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    clusterDao.update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
        // update gluster parameters on all hosts
        updateGlusterHosts();
    }
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        final NetworkCluster managementNetworkCluster = createManagementNetworkCluster();
        networkClusterDao.save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    updateVms();
    updateTemplates();
    if (getCluster().getFirewallType() != getPrevCluster().getFirewallType()) {
        markHostsForReinstall();
    }
    if (!failedUpgradeEntities.isEmpty()) {
        logFailedUpgrades();
        failValidation(Arrays.asList(EngineMessage.CLUSTER_CANNOT_UPDATE_CLUSTER_FAILED_TO_UPDATE_VMS), "$VmList " + StringUtils.join(failedUpgradeEntities.keySet(), ", "));
        getReturnValue().setValid(false);
        setSucceeded(false);
        return;
    }
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
    }
    setSucceeded(true);
}
#end_block

#method_before
private boolean updateTemplates() {
    for (VmTemplate template : templatesLockedForUpdate) {
        // the object was loaded in before command execution started and thus the value may be outdated
        template.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
        // Locking by UpdateVmTemplate is disabled since templates are already locked in #getExclusiveLocks method.
        parameters.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        parameters.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        updateRngDeviceIfNecessary(template.getId(), template.getCustomCompatibilityVersion(), parameters);
        if (!parameters.isUpdateRngDevice()) {
            continue;
        }
        final ActionReturnValue result = runInternalAction(ActionType.UpdateVmTemplate, parameters, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type Template");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = Backend.getInstance().getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(template.getName(), getFailedMessage(messages));
        }
    }
    return true;
}
#method_after
private boolean updateTemplates() {
    for (VmTemplate template : templatesLockedForUpdate) {
        // the object was loaded in before command execution started and thus the value may be outdated
        template.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
        // Locking by UpdateVmTemplate is disabled since templates are already locked in #getExclusiveLocks method.
        parameters.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        parameters.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        updateRngDeviceIfNecessary(template.getId(), template.getCustomCompatibilityVersion(), parameters);
        updateResumeBehavior(template);
        final ActionReturnValue result = runInternalAction(ActionType.UpdateVmTemplate, parameters, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type Template");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = Backend.getInstance().getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(template.getName(), getFailedMessage(messages));
        }
    }
    return true;
}
#end_block

#method_before
private void updateResumeBehavior(VmStatic vm) {
    vmHandler.autoSelectResumeBehavior(vm, getCluster());
}
#method_after
private void updateResumeBehavior(VmBase vmBase) {
    vmHandler.autoSelectResumeBehavior(vmBase, getCluster());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final int oldMemoryMb = getVm().getMemSizeMb();
    final int oldMinAllocatedMemoryMb = getVm().getMinAllocatedMem();
    final int unpluggedSizeMB = VmDeviceCommonUtils.getSizeOfMemoryDeviceMb(getDeviceToHotUnplug()).get();
    final int decrementedMemoryMb = oldMemoryMb - unpluggedSizeMB;
    /*
         * Amount of unplugged memory can't be just subtracted since in combination with delayed (not reported)
         * failures of memory hot unplugs it can led negative values of memory and minMemory.
         */
    final int minMemoryAfterHotUnplugMb = decrementedMemoryMb > oldMinAllocatedMemoryMb ? oldMinAllocatedMemoryMb : Math.max(0, decrementedMemoryMb);
    final int memoryAfterHotUnplugMb = decrementedMemoryMb >= minMemoryAfterHotUnplugMb && decrementedMemoryMb > 0 ? decrementedMemoryMb : oldMemoryMb;
    addCustomValue(AUDIT_LOG_VAR_NEW_MEMORY_MB, String.valueOf(memoryAfterHotUnplugMb));
    addCustomValue(AUDIT_LOG_VAR_OLD_MEMORY_MB, String.valueOf(oldMemoryMb));
    final VDSReturnValue vdsReturnValue = executeHotUnplug(minMemoryAfterHotUnplugMb);
    final boolean memoryChanged = memoryAfterHotUnplugMb != oldMemoryMb || minMemoryAfterHotUnplugMb != oldMinAllocatedMemoryMb;
    if (vdsReturnValue.getSucceeded() && memoryChanged) {
        updateVm(memoryAfterHotUnplugMb, minMemoryAfterHotUnplugMb);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final int oldMemoryMb = getVm().getMemSizeMb();
    final int oldMinAllocatedMemoryMb = getVm().getMinAllocatedMem();
    final int decrementedMemoryMb = oldMemoryMb - getUnpluggedDeviceSize();
    /*
         * Amount of unplugged memory can't be just subtracted since in combination with delayed (not reported)
         * failures of memory hot unplugs it can led negative values of memory and minMemory.
         */
    final int minMemoryAfterHotUnplugMb = decrementedMemoryMb > oldMinAllocatedMemoryMb ? oldMinAllocatedMemoryMb : Math.max(0, decrementedMemoryMb);
    final int memoryAfterHotUnplugMb = decrementedMemoryMb >= minMemoryAfterHotUnplugMb && decrementedMemoryMb > 0 ? decrementedMemoryMb : oldMemoryMb;
    addCustomValue(AUDIT_LOG_VAR_NEW_MEMORY_MB, String.valueOf(memoryAfterHotUnplugMb));
    addCustomValue(AUDIT_LOG_VAR_OLD_MEMORY_MB, String.valueOf(oldMemoryMb));
    final VDSReturnValue vdsReturnValue = executeHotUnplug(minMemoryAfterHotUnplugMb);
    final boolean memoryChanged = memoryAfterHotUnplugMb != oldMemoryMb || minMemoryAfterHotUnplugMb != oldMinAllocatedMemoryMb;
    if (vdsReturnValue.getSucceeded() && memoryChanged) {
        updateVm(memoryAfterHotUnplugMb, minMemoryAfterHotUnplugMb);
    }
    setSucceeded(true);
}
#end_block

#method_before
public List<OvfEntityData> getOvfEntities(byte[] tar, List<UnregisteredDisk> unregisteredDisks, List<StorageOvfExtraData> storageExtraData, Guid storageDomainId) {
    List<OvfEntityData> ovfEntityDataFromTar = new ArrayList<>();
    InputStream is = new ByteArrayInputStream(tar);
    log.info("Start fetching files from tar file");
    Map<String, ByteBuffer> filesFromTar;
    try (TarInMemoryExport memoryTar = new TarInMemoryExport(is)) {
        filesFromTar = memoryTar.unTar();
    } catch (IOException e) {
        throw new RuntimeException(String.format("Exception while getting OVFs files from tar file for domain %s", storageDomainId), e);
    }
    for (Entry<String, ByteBuffer> fileEntry : filesFromTar.entrySet()) {
        if (fileEntry.getKey().endsWith(OVF_FILE_EXT)) {
            analyzeOvfFile(unregisteredDisks, storageDomainId, ovfEntityDataFromTar, fileEntry);
        } else if (fileEntry.getKey().equals(OvfInfoFileConstants.MetaDataFileName)) {
            initStorageOvfExtraData(storageDomainId, storageExtraData, fileEntry);
        } else {
            log.info("File '{}' is not an OVF file, will be ignored.", fileEntry.getKey());
        }
    }
    log.info("Finish to fetch OVF files from tar file. The number of OVF entities are {}", ovfEntityDataFromTar.size());
    return ovfEntityDataFromTar;
}
#method_after
public List<OvfEntityData> getOvfEntities(byte[] tar, List<UnregisteredDisk> unregisteredDisks, Guid storageDomainId) {
    List<OvfEntityData> ovfEntityDataFromTar = new ArrayList<>();
    InputStream is = new ByteArrayInputStream(tar);
    log.info("Start fetching files from tar file");
    Map<String, ByteBuffer> filesFromTar;
    try (TarInMemoryExport memoryTar = new TarInMemoryExport(is)) {
        filesFromTar = memoryTar.unTar();
    } catch (IOException e) {
        throw new RuntimeException(String.format("Exception while getting OVFs files from tar file for domain %s", storageDomainId), e);
    }
    Entry<String, ByteBuffer> metaDataFileEntry = null;
    for (Entry<String, ByteBuffer> fileEntry : filesFromTar.entrySet()) {
        if (fileEntry.getKey().endsWith(OVF_FILE_EXT)) {
            analyzeOvfFile(unregisteredDisks, storageDomainId, ovfEntityDataFromTar, fileEntry);
        } else if (fileEntry.getKey().equals(OvfInfoFileConstants.MetaDataFileName)) {
            metaDataFileEntry = fileEntry;
        } else {
            log.info("File '{}' is not an OVF file, will be ignored.", fileEntry.getKey());
        }
    }
    analyzeOvfMetaDataFile(storageDomainId, ovfEntityDataFromTar, metaDataFileEntry);
    log.info("Finish to fetch OVF files from tar file. The number of OVF entities are {}", ovfEntityDataFromTar.size());
    return ovfEntityDataFromTar;
}
#end_block

#method_before
private void initStorageOvfExtraData(Guid storageDomainId, List<StorageOvfExtraData> storageExtraData, Entry<String, ByteBuffer> fileEntry) {
    Map<String, Object> diskDescriptionMap;
    log.info("Start to analyze metadata File '{}'.", fileEntry.getKey());
    String storageMetaData = new String(fileEntry.getValue().array());
    try {
        diskDescriptionMap = JsonHelper.jsonToMap(storageMetaData);
    } catch (IOException e) {
        log.error("Failed to convert storage ovf extra data from json to map: '{}'.", storageMetaData);
        e.printStackTrace();
        return;
    }
    fetchStorageStatus(storageDomainId, storageExtraData, diskDescriptionMap);
    fetchVmsStatus(storageDomainId, storageExtraData, diskDescriptionMap);
    log.info("Finish to analyze metadata File '{}'.", fileEntry.getKey());
}
#method_after
private void initStorageOvfExtraData(Guid storageDomainId, List<OvfEntityData> ovfEntityDataFromTar, ByteBuffer metaDataBuffer) {
    Map<String, Object> diskDescriptionMap;
    String storageMetaData = new String(metaDataBuffer.array());
    try {
        diskDescriptionMap = JsonHelper.jsonToMap(storageMetaData);
    } catch (IOException e) {
        log.error("Failed to convert storage ovf extra data from json to map: '{}'.", storageMetaData);
        e.printStackTrace();
        return;
    }
    setVmsStatus(storageDomainId, diskDescriptionMap, ovfEntityDataFromTar);
}
#end_block

#method_before
public void updateUnregisteredDisksWithVMs(List<UnregisteredDisk> unregisteredDisks, Guid entityId, String vmName, XmlDocument xmlDocument) {
    for (Guid diskId : fetchVmDisks(xmlDocument)) {
        UnregisteredDisk unregisterDisk = unregisteredDisks.stream().filter(unregrDisk -> diskId.equals(unregrDisk.getId())).findAny().orElse(null);
        VmBase vm = new VmBase();
        vm.setId(entityId);
        vm.setName(vmName);
        if (unregisterDisk != null) {
            unregisterDisk.getVms().add(vm);
        }
    }
}
#method_after
public void updateUnregisteredDisksWithVMs(List<UnregisteredDisk> unregisteredDisks, Guid entityId, String vmName, XmlDocument xmlDocument) {
    for (Guid diskId : fetchVmDisks(xmlDocument)) {
        UnregisteredDisk unregisterDisk = unregisteredDisks.stream().filter(unregrDisk -> diskId.equals(unregrDisk.getDiskId())).findAny().orElse(null);
        VmBase vm = new VmBase();
        vm.setId(entityId);
        vm.setName(vmName);
        if (unregisterDisk != null) {
            unregisterDisk.getVms().add(vm);
        }
    }
}
#end_block

#method_before
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // Load the thread pools
    serviceLoader.load(EngineThreadPools.class);
    // Load the thread monitoring service
    serviceLoader.load(ThreadPoolMonitoringService.class);
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    serviceLoader.load(AsyncTaskManager.class);
    serviceLoader.load(CommandCoordinatorUtil.class);
    serviceLoader.load(CommandCallbacksPoller.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    serviceLoader.load(VmMigrationProgressMonitoring.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // Load the thread pools
    serviceLoader.load(EngineThreadPools.class);
    // Load the thread monitoring service
    serviceLoader.load(ThreadPoolMonitoringService.class);
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        macPoolPerCluster.logFreeMacs();
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    serviceLoader.load(AsyncTaskManager.class);
    serviceLoader.load(CommandCoordinatorUtil.class);
    serviceLoader.load(CommandCallbacksPoller.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    serviceLoader.load(VmMigrationProgressMonitoring.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
@Override
protected void executeIrsBrokerCommand() {
    storageDomainHelper.checkNumberOfLVsForBlockDomain(getParameters().getStorageDomainId());
    setReturnValue(Guid.Empty);
    log.info("-- executeIrsBrokerCommand: calling 'createVolume' with two new parameters: description and UUID");
    // NOTE: The 'uuidReturn' variable will contain the taskID and not
    // the created image id!
    String imageInitSize = null;
    if (getParameters().getImageInitialSizeInBytes() != 0) {
        imageInitSize = String.valueOf(getParameters().getImageInitialSizeInBytes());
    }
    uuidReturn = getIrsProxy().createVolume(getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString(), getParameters().getImageGroupId().toString(), Long.valueOf(getParameters().getImageSizeInBytes()).toString(), getParameters().getVolumeFormat().getValue(), getParameters().getImageType().getValue(), DiskContentType.DATA.getStorageValue(), getParameters().getNewImageID().toString(), getParameters().getNewImageDescription(), getParameters().getSourceImageGroupId().toString(), getParameters().getImageId().toString(), imageInitSize);
    proceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.uuid);
    createdImageId = getParameters().getNewImageID().toString();
    setReturnValue(new Guid(createdImageId));
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.createVolume, getParameters().getStoragePoolId()));
}
#method_after
@Override
protected void executeIrsBrokerCommand() {
    storageDomainHelper.checkNumberOfLVsForBlockDomain(getParameters().getStorageDomainId());
    setReturnValue(Guid.Empty);
    log.info("-- executeIrsBrokerCommand: calling 'createVolume' with two new parameters: description and UUID");
    // NOTE: The 'uuidReturn' variable will contain the taskID and not
    // the created image id!
    String imageInitSize = null;
    if (getParameters().getImageInitialSizeInBytes() != 0) {
        imageInitSize = String.valueOf(getParameters().getImageInitialSizeInBytes());
    }
    String diskType = FeatureSupported.isContentTypeSupported(getParameters().getPoolCompatibilityVersion()) ? getParameters().getDiskContentType().getStorageValue() : DiskContentType.LEGACY_DISK_TYPE;
    uuidReturn = getIrsProxy().createVolume(getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString(), getParameters().getImageGroupId().toString(), Long.valueOf(getParameters().getImageSizeInBytes()).toString(), getParameters().getVolumeFormat().getValue(), getParameters().getImageType().getValue(), diskType, getParameters().getNewImageID().toString(), getParameters().getNewImageDescription(), getParameters().getSourceImageGroupId().toString(), getParameters().getImageId().toString(), imageInitSize);
    proceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.uuid);
    createdImageId = getParameters().getNewImageID().toString();
    setReturnValue(new Guid(createdImageId));
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.createVolume, getParameters().getStoragePoolId()));
}
#end_block

#method_before
@Override
protected void executeIrsBrokerCommand() {
    storageDomainHelper.checkNumberOfLVsForBlockDomain(getParameters().getStorageDomainId());
    setReturnValue(Guid.Empty);
    log.info("-- executeIrsBrokerCommand: calling 'createVolume' with two new parameters: description and UUID");
    // NOTE: The 'uuidReturn' variable will contain the taskID and not the
    // created image id!
    String imageInitSize = null;
    if (getParameters().getImageInitialSizeInBytes() != 0) {
        imageInitSize = Long.valueOf(getParameters().getImageInitialSizeInBytes()).toString();
    }
    String diskType = FeatureSupported.isContentTypeSupported(getParameters().getCompatibilityVersion()) ? getParameters().getDiskContentType().getStorageValue() : "2";
    uuidReturn = getIrsProxy().createVolume(getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString(), getParameters().getImageGroupId().toString(), Long.valueOf(getParameters().getImageSizeInBytes()).toString(), getParameters().getVolumeFormat().getValue(), getParameters().getImageType().getValue(), diskType, getParameters().getNewImageID().toString(), getParameters().getNewImageDescription(), Guid.Empty.toString(), Guid.Empty.toString(), imageInitSize);
    proceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.uuid);
    createdImageId = getParameters().getNewImageID().toString();
    setReturnValue(new Guid(createdImageId));
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.createVolume, getParameters().getStoragePoolId()));
}
#method_after
@Override
protected void executeIrsBrokerCommand() {
    storageDomainHelper.checkNumberOfLVsForBlockDomain(getParameters().getStorageDomainId());
    setReturnValue(Guid.Empty);
    log.info("-- executeIrsBrokerCommand: calling 'createVolume' with two new parameters: description and UUID");
    // NOTE: The 'uuidReturn' variable will contain the taskID and not the
    // created image id!
    String imageInitSize = null;
    if (getParameters().getImageInitialSizeInBytes() != 0) {
        imageInitSize = Long.valueOf(getParameters().getImageInitialSizeInBytes()).toString();
    }
    String diskType = FeatureSupported.isContentTypeSupported(getParameters().getPoolCompatibilityVersion()) ? getParameters().getDiskContentType().getStorageValue() : DiskContentType.LEGACY_DISK_TYPE;
    uuidReturn = getIrsProxy().createVolume(getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString(), getParameters().getImageGroupId().toString(), Long.valueOf(getParameters().getImageSizeInBytes()).toString(), getParameters().getVolumeFormat().getValue(), getParameters().getImageType().getValue(), diskType, getParameters().getNewImageID().toString(), getParameters().getNewImageDescription(), Guid.Empty.toString(), Guid.Empty.toString(), imageInitSize);
    proceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.uuid);
    createdImageId = getParameters().getNewImageID().toString();
    setReturnValue(new Guid(createdImageId));
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.createVolume, getParameters().getStoragePoolId()));
}
#end_block

#method_before
@Test
public void testStorageNameLength() {
    for (DiskContentType d : DiskContentType.values()) {
        if (d != DiskContentType.LEGACY) {
            assertEquals(4, d.getStorageValue().length());
        }
    }
}
#method_after
@Test
public void testStorageNameLength() {
    for (DiskContentType d : DiskContentType.values()) {
        assertEquals(4, d.getStorageValue().length());
    }
}
#end_block

#method_before
@Override
protected boolean performImageVdsmOperation() {
    setDestinationImageId(Guid.newGuid());
    persistCommandIfNeeded();
    newDiskImage = cloneDiskImage(getDestinationImageId());
    newDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(getDestinationStorageDomainId())));
    setStoragePoolId(newDiskImage.getStoragePoolId() != null ? newDiskImage.getStoragePoolId() : Guid.Empty);
    getParameters().setStoragePoolId(getStoragePoolId());
    // override volume type and volume format to sparse and cow according to
    // storage team request
    newDiskImage.setVolumeType(VolumeType.Sparse);
    newDiskImage.setVolumeFormat(VolumeFormat.COW);
    try {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CreateSnapshot, new CreateSnapshotVDSCommandParameters(getStoragePoolId(), getDestinationStorageDomainId(), getImageGroupId(), getImage().getImageId(), getDiskImage().getSize(), newDiskImage.getVolumeType(), newDiskImage.getVolumeFormat(), getDiskImage().getId(), getDestinationImageId(), "", getStoragePool().getCompatibilityVersion(), getDiskImage().getContentType()));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            getParameters().setVdsmTaskIds(new ArrayList<>());
            getParameters().getVdsmTaskIds().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationImageId()));
            getReturnValue().getInternalVdsmTaskIdList().add(getParameters().getVdsmTaskIds().get(0));
            // Shouldn't happen anymore:
            if (getDestinationImageId().equals(Guid.Empty)) {
                throw new RuntimeException();
            }
            return true;
        }
    } catch (Exception e) {
        log.error("Failed creating snapshot from image id '{}'", getImage().getImageId());
        commandCoordinatorUtil.logAndFailTaskOfCommandWithEmptyVdsmId(getAsyncTaskId(), "Create snapshot failed at VDSM. DB task ID is " + getAsyncTaskId());
        throw new EngineException(EngineError.VolumeCreationError);
    }
    return false;
}
#method_after
@Override
protected boolean performImageVdsmOperation() {
    setDestinationImageId(Guid.isNullOrEmpty(getParameters().getDestinationImageId()) ? Guid.newGuid() : getParameters().getDestinationImageId());
    persistCommandIfNeeded();
    newDiskImage = cloneDiskImage(getDestinationImageId());
    newDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(getDestinationStorageDomainId())));
    setStoragePoolId(newDiskImage.getStoragePoolId() != null ? newDiskImage.getStoragePoolId() : Guid.Empty);
    getParameters().setStoragePoolId(getStoragePoolId());
    // override volume type and volume format to sparse and cow according to
    // storage team request
    newDiskImage.setVolumeType(VolumeType.Sparse);
    newDiskImage.setVolumeFormat(VolumeFormat.COW);
    try {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CreateSnapshot, new CreateSnapshotVDSCommandParameters(getStoragePoolId(), getDestinationStorageDomainId(), getImageGroupId(), getImage().getImageId(), getDiskImage().getSize(), newDiskImage.getVolumeType(), newDiskImage.getVolumeFormat(), getDiskImage().getId(), getDestinationImageId(), "", getStoragePool().getCompatibilityVersion(), getDiskImage().getContentType()));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            getParameters().setVdsmTaskIds(new ArrayList<>());
            getParameters().getVdsmTaskIds().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationImageId()));
            getReturnValue().getInternalVdsmTaskIdList().add(getParameters().getVdsmTaskIds().get(0));
            // Shouldn't happen anymore:
            if (getDestinationImageId().equals(Guid.Empty)) {
                throw new RuntimeException();
            }
            return true;
        }
    } catch (Exception e) {
        log.error("Failed creating snapshot from image id '{}'", getImage().getImageId());
        commandCoordinatorUtil.logAndFailTaskOfCommandWithEmptyVdsmId(getAsyncTaskId(), "Create snapshot failed at VDSM. DB task ID is " + getAsyncTaskId());
        throw new EngineException(EngineError.VolumeCreationError);
    }
    return false;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    vmStaticDao.incrementDbGeneration(getVm().getId());
    endActionOnDisks();
    if (getVm() != null) {
        vmHandler.unlockVm(getVm(), getCompensationContext());
        restoreVmConfigFromSnapshot();
        // disks and configuration is restored, let's set CCV if the snapshot originates in older Cluster version
        if (!updateClusterCompatibilityVersionToOldCluster(false)) {
            log.warn("Failed to set the Cluster Compatibility Version to the cluster version the snapshot originates from.");
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VM is null, not performing endAction");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    vmStaticDao.incrementDbGeneration(getVm().getId());
    endActionOnDisks();
    boolean succeeded = false;
    if (getVm() != null) {
        vmHandler.unlockVm(getVm(), getCompensationContext());
        try {
            restoreVmConfigFromSnapshot();
            // disks and configuration is restored, let's set CCV if the snapshot originates in older Cluster version
            if (!updateClusterCompatibilityVersionToOldCluster(false)) {
                log.warn("Failed to set the Cluster Compatibility Version to the cluster version the snapshot originates from.");
            }
            succeeded = true;
        } catch (EngineException ex) {
            getReturnValue().setEndActionTryAgain(false);
            log.error("Unable to restore VM configuration from snapshot: {}, undoing preview.", ExceptionUtils.getRootCauseMessage(ex));
            commandCoordinatorUtil.executeAsyncCommand(ActionType.RestoreAllSnapshots, new RestoreAllSnapshotsParameters(getVm().getId(), SnapshotActionEnum.UNDO), CommandContext.createContext(getParameters().getSessionId()));
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VM is null, not performing endAction");
        succeeded = true;
    }
    setSucceeded(succeeded);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = isRestoreMemory();
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    log.info("Previewing snapshot {} with disk name(s) {} to image ID(s) {}", getSnapshotName(), filteredImages.stream().map(DiskImage::getName).collect(Collectors.joining(", ")), filteredImages.stream().map(DiskImage::getImageId).map(Guid::toString).collect(Collectors.joining(", ")));
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        snapshotDao.remove(previousActiveSnapshotId);
        getSnapshotsManager().addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
        getSnapshotsManager().addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, snapshotToBePreviewed.getCreationDate(), images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    if (!filteredImages.isEmpty()) {
        vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    ActionReturnValue actionReturnValue = runInternalActionWithTasksContext(ActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (actionReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
                    } else if (actionReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(actionReturnValue.getFault().getError(), actionReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(ActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    } else {
        // if there are no disks to restore, no compensation context is saved and the VM Configuration
        // (including clusterCompatibilityVersionOrigin) is already restored at this point. Otherwise,
        // if disks are being restored, the VM Configuration is restored later in endSuccessfully()
        updateClusterCompatibilityVersionToOldCluster(true);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = isRestoreMemory();
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    if (log.isInfoEnabled()) {
        log.info("Previewing snapshot {} with the disks:\n{}", getSnapshotName(), filteredImages.stream().map(disk -> String.format("%s (%s) to imageId %s", disk.getName(), disk.getId().toString(), disk.getImageId().toString())).collect(Collectors.joining("\n")));
    }
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        snapshotDao.remove(previousActiveSnapshotId);
        getSnapshotsManager().addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
        getSnapshotsManager().addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, snapshotToBePreviewed.getCreationDate(), images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    if (!filteredImages.isEmpty()) {
        vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    ActionReturnValue actionReturnValue = runInternalActionWithTasksContext(ActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (actionReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
                    } else if (actionReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(actionReturnValue.getFault().getError(), actionReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(ActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    } else {
        // if there are no disks to restore, no compensation context is saved and the VM Configuration
        // (including clusterCompatibilityVersionOrigin) is already restored at this point. Otherwise,
        // if disks are being restored, the VM Configuration is restored later in endSuccessfully()
        updateClusterCompatibilityVersionToOldCluster(true);
    }
    setSucceeded(true);
}
#end_block

#method_before
private boolean validateMemoryTakenInSupportedVersion() {
    VM vmFromSnapshot = null;
    try {
        vmFromSnapshot = ovfHelper.readVmFromOvf(getDstSnapshot().getVmConfiguration());
    } catch (OvfReaderException e) {
        // should never happen since the OVF was created by us
        log.error("Failed to parse a given ovf configuration: {}", e.getMessage());
        return false;
    }
    Version originalClusterVersion = vmFromSnapshot.getClusterCompatibilityVersionOrigin();
    if (Version.getLowest().greater(originalClusterVersion)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_TOO_OLD, String.format("$Cv %s", originalClusterVersion != null ? originalClusterVersion : "N/A"));
    }
    return true;
}
#method_after
private boolean validateMemoryTakenInSupportedVersion() {
    VM vmFromSnapshot = null;
    try {
        vmFromSnapshot = ovfHelper.readVmFromOvf(getDstSnapshot().getVmConfiguration()).getVm();
    } catch (OvfReaderException e) {
        // should never happen since the OVF was created by us
        log.error("Failed to parse a given ovf configuration: {}", e.getMessage());
        return false;
    }
    Version originalClusterVersion = vmFromSnapshot.getClusterCompatibilityVersionOrigin();
    if (Version.getLowest().greater(originalClusterVersion)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_TOO_OLD, String.format("$Cv %s", originalClusterVersion != null ? originalClusterVersion : "N/A"));
    }
    return true;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getSucceeded()) {
                if (getParameters().getSnapshotAction() == SnapshotActionEnum.UNDO) {
                    return AuditLogType.USER_UNDO_RESTORE_FROM_SNAPSHOT_START;
                } else {
                    return AuditLogType.USER_COMMIT_RESTORE_FROM_SNAPSHOT_START;
                }
            } else {
                if (getParameters().getSnapshotAction() == SnapshotActionEnum.UNDO) {
                    return AuditLogType.USER_UNDO_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE;
                } else {
                    return AuditLogType.USER_COMMIT_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE;
                }
            }
        default:
            if (getParameters().getSnapshotAction() == SnapshotActionEnum.UNDO) {
                return AuditLogType.USER_UNDO_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS;
            } else {
                return AuditLogType.USER_COMMIT_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS;
            }
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getSucceeded()) {
                if (getParameters().getSnapshotAction() == SnapshotActionEnum.UNDO) {
                    return AuditLogType.USER_UNDO_RESTORE_FROM_SNAPSHOT_START;
                }
                return AuditLogType.USER_COMMIT_RESTORE_FROM_SNAPSHOT_START;
            }
            if (getParameters().getSnapshotAction() == SnapshotActionEnum.UNDO) {
                return AuditLogType.USER_UNDO_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE;
            }
            return AuditLogType.USER_COMMIT_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE;
        default:
            if (getParameters().getSnapshotAction() == SnapshotActionEnum.UNDO) {
                return AuditLogType.USER_UNDO_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS;
            }
            return AuditLogType.USER_COMMIT_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS;
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    try {
        addVmToDb();
        processImages();
        vmHandler.addVmInitToDB(getVm().getStaticData().getVmInit());
        discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmId());
    } catch (RuntimeException e) {
        macPool.freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
    getReturnValue().setActionReturnValue(getVm());
}
#method_after
@Override
protected void executeVmCommand() {
    try {
        addVmToDb();
        addVmToAffinityGroups();
        processImages();
        vmHandler.addVmInitToDB(getVm().getStaticData().getVmInit());
        discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmId());
    } catch (RuntimeException e) {
        macPool.freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
    getReturnValue().setActionReturnValue(getVm());
}
#end_block

#method_before
private boolean shouldReassignMac(VmNetworkInterface iface) {
    return (getParameters().isReassignBadMacs() && vNicHasBadMac(iface)) || getParameters().isImportAsNewEntity() || StringUtils.isEmpty(iface.getMacAddress());
}
#method_after
private boolean shouldReassignMac(VmNetworkInterface iface) {
    return StringUtils.isEmpty(iface.getMacAddress()) || (getParameters().isReassignBadMacs() && vNicHasBadMac(iface)) || getParameters().isImportAsNewEntity();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStorageDomain().getStorageType().isFileDomain()) {
        log.info("Reduce image isn't supported on file base domains");
        setSucceeded(true);
        return;
    }
    if (!isReduceVolumeSupported()) {
        log.info("Reduce image isn't supported in {}", getStoragePool().getCompatibilityVersion());
        setSucceeded(true);
        return;
    }
    if (!isInternalMerge()) {
        log.info("Reduce image isn't supported for active image merge");
        setSucceeded(true);
        return;
    }
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupId()));
    boolean prepareImageSucceeded = false;
    boolean reduceImageSucceeded = false;
    if (!getParameters().isVmRunningOnSpm()) {
        // The VM isn't running on the SPM but the reduce command is performed on the SPM, hence
        // we have to prepare the image on the SPM
        log.debug("Preparing image {}/{} on the SPM", getParameters().getImageGroupId(), getParameters().getImageId());
        try {
            prepareImage();
            prepareImageSucceeded = true;
        } catch (EngineException e) {
            log.error("Failed to prepare image {}/{} on the SPM", getParameters().getImageGroupId(), getParameters().getImageId());
        }
    }
    if (!getParameters().isVmRunningOnSpm() && !prepareImageSucceeded) {
        // As we don't want to fail the live merge because of a failure to reduce the image, we still mark the
        // command as succeeded.
        setSucceeded(true);
        return;
    }
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ReduceImage, creaeteReduceImageVDSCommandParameters());
        if (vdsReturnValue.getSucceeded()) {
            Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
            getTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
            reduceImageSucceeded = true;
        }
    } catch (EngineException e) {
        log.error("Reducing image {}/{} failed", getParameters().getImageGroupId(), getParameters().getImageId());
    }
    if (prepareImageSucceeded && !reduceImageSucceeded) {
        try {
            teardownImage();
        } catch (EngineException e) {
            log.error("Failed to teardown image {}/{} on the SPM", getParameters().getImageGroupId(), getParameters().getImageId());
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getStorageDomain().getStorageType().isFileDomain()) {
        log.info("Reduce image isn't required for file based domains");
        setSucceeded(true);
        return;
    }
    if (!isReduceVolumeSupported()) {
        log.info("Reduce image isn't supported in {}", getStoragePool().getCompatibilityVersion());
        setSucceeded(true);
        return;
    }
    if (!isInternalMerge()) {
        log.info("Reduce image isn't supported for active image merge");
        setSucceeded(true);
        return;
    }
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupId()));
    boolean prepareImageSucceeded = false;
    boolean reduceImageSucceeded = false;
    if (!getParameters().isVmRunningOnSpm()) {
        // The VM isn't running on the SPM but the reduce command is performed on the SPM, hence
        // we have to prepare the image on the SPM
        log.debug("Preparing image {}/{} on the SPM", getParameters().getImageGroupId(), getParameters().getImageId());
        try {
            prepareImage();
            prepareImageSucceeded = true;
        } catch (EngineException e) {
            log.error("Failed to prepare image {}/{} on the SPM", getParameters().getImageGroupId(), getParameters().getImageId());
        }
    }
    if (!getParameters().isVmRunningOnSpm() && !prepareImageSucceeded) {
        // As we don't want to fail the live merge because of a failure to reduce the image, we still mark the
        // command as succeeded.
        setSucceeded(true);
        return;
    }
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ReduceImage, creaeteReduceImageVDSCommandParameters());
        if (vdsReturnValue.getSucceeded()) {
            Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
            getTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
            reduceImageSucceeded = true;
        }
    } catch (EngineException e) {
        log.error("Reducing image {}/{} failed", getParameters().getImageGroupId(), getParameters().getImageId());
    }
    if (prepareImageSucceeded && !reduceImageSucceeded) {
        try {
            teardownImage();
        } catch (EngineException e) {
            log.error("Failed to teardown image {}/{} on the SPM", getParameters().getImageGroupId(), getParameters().getImageId());
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    or(mandatory(cluster().id()), mandatory(cluster().name()));
    optional(clone());
    optional(exclusive());
    optional(template().name());
}
#method_after
@InputDetail
default void inputDetail() {
    or(mandatory(cluster().id()), mandatory(cluster().name()));
    optional(clone());
    optional(exclusive());
    optional(template().name());
    optional(registrationConfiguration());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    // DEPRECATED
    mandatory(host().rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(host().ssh().authenticationMethod());
    mandatory(host().ssh().user().password());
    mandatory(host().ssh().user().userName());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(ssh().authenticationMethod());
    optional(ssh().fingerprint());
    optional(ssh().port());
    optional(ssh().user().password());
    optional(ssh().user().userName());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    mandatory(disk().format());
    mandatory(disk()._interface());
    optional(disk().alias());
    optional(disk().bootable());
    optional(disk().description());
    optional(disk().propagateErrors());
    optional(disk().quota().id());
    optional(disk().shareable());
    optional(disk().sparse());
    optional(disk().wipeAfterDelete());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(disk().format());
    mandatory(disk()._interface());
    optional(disk().alias());
    optional(disk().bootable());
    optional(disk().description());
    optional(disk().propagateErrors());
    optional(disk().quota().id());
    optional(disk().shareable());
    optional(disk().sparse());
    optional(disk().wipeAfterDelete());
    optional(disk().id());
    optional(disk().imageId());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", VmInterfaceType.forValue(getInterface().getType()).getDescription().toString());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (isVnicProfileChanged(oldIface, getInterface())) {
            Network newNetwork = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
            Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
            if (!Objects.equals(oldNetwork, newNetwork)) {
                new ExternalNetworkManager(oldIface).deallocateIfExternal();
            }
        }
        if (macShouldBeChanged) {
            macAddedToPool = addMacToPool(getMacAddress());
        }
        if (mustChangeAddress(oldIface.getType(), getInterface().getType())) {
            vmDeviceDao.clearDeviceAddress(getInterface().getId());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        TransactionSupport.executeInNewTransaction(() -> {
            bumpVmVersion();
            updatePassthoughDeviceIfNeeded();
            getCompensationContext().snapshotEntity(oldIface);
            vmNicDao.update(getInterface());
            getCompensationContext().stateChanged();
            return null;
        });
        succeeded = updateHost();
    } finally {
        setSucceeded(succeeded);
        MacPool macPool = getMacPool();
        if (macAddedToPool) {
            if (succeeded) {
                macPool.freeMac(oldIface.getMacAddress());
            } else {
                macPool.freeMac(getMacAddress());
            }
        }
    }
}
#method_after
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", VmInterfaceType.forValue(getInterface().getType()).getDescription().toString());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (isVnicProfileChanged(oldIface, getInterface())) {
            Network newNetwork = networkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
            Network oldNetwork = networkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
            if (!Objects.equals(oldNetwork, newNetwork)) {
                externalNetworkManagerFactory.create(oldIface).deallocateIfExternal();
            }
        }
        macAddedToPool = allocateMacFromRequest();
        if (mustChangeAddress(oldIface.getType(), getInterface().getType())) {
            vmDeviceDao.clearDeviceAddress(getInterface().getId());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        TransactionSupport.executeInNewTransaction(() -> {
            bumpVmVersion();
            updatePassthoughDeviceIfNeeded();
            getCompensationContext().snapshotEntity(oldIface);
            vmNicDao.update(getInterface());
            saveNetworkFilterParameters();
            getCompensationContext().stateChanged();
            return null;
        });
        succeeded = updateHost();
    } finally {
        setSucceeded(succeeded);
        macPoolCleanupAfterExecution(macAddedToPool);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    oldVmDevice = vmDeviceDao.get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> vmNics = vmNicDao.getAllForVm(getVmId());
    oldIface = vmNics.stream().filter(i -> i.getId().equals(getInterface().getId())).findFirst().orElse(null);
    if (oldIface == null || oldVmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!updateVnicForBackwardCompatibility(oldIface)) {
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(vmNics)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(vmNics);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    if (duplicateMacExists(allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getClusterCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(getVm().getClusterId())) || !validate(nicValidator.canVnicWithExternalNetworkBePlugged()) || !validate(nicValidator.typeMatchesProfile()) || !validate(nicValidator.passthroughIsLinked()) || !validate(nicValidator.validateProfileNotEmptyForHostedEngineVm(getVm()))) {
        return false;
    }
    Network network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network)) || !validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    initVmData();
    if (oldIface == null || oldVmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!updateVnicForBackwardCompatibility(oldIface)) {
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(vmInterfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(vmInterfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    String macAddressOfInterface = getMacAddress();
    boolean macAddressIsNotEmpty = macAddressOfInterface != null && !macAddressOfInterface.isEmpty();
    if (macAddressIsNotEmpty && duplicateMacExists(allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getClusterCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(getVm().getClusterId())) || !validate(nicValidator.canVnicWithExternalNetworkBePlugged()) || !validate(nicValidator.typeMatchesProfile()) || !validate(nicValidator.passthroughIsLinked()) || !validate(nicValidator.validateProfileNotEmptyForHostedEngineVm(getVm()))) {
        return false;
    }
    Network network = networkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = networkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network)) || !validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    initMacPoolData();
    if (macShouldBeChanged && macShouldBeAddedIntoPool() && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        if (oldIface.isLinked() != getInterface().isLinked()) {
            AuditLogType customValue = getInterface().isLinked() ? AuditLogType.NETWORK_UPDATE_VM_INTERFACE_LINK_UP : AuditLogType.NETWORK_UPDATE_VM_INTERFACE_LINK_DOWN;
            addCustomValue("LinkState", auditLogDirector.getMessage(customValue));
        } else {
            addCustomValue("LinkState", " ");
        }
        return AuditLogType.NETWORK_UPDATE_VM_INTERFACE;
    }
    return AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        if (oldIface.isLinked() != getInterface().isLinked()) {
            AuditLogType customValue = getInterface().isLinked() ? AuditLogType.NETWORK_UPDATE_VM_INTERFACE_LINK_UP : AuditLogType.NETWORK_UPDATE_VM_INTERFACE_LINK_DOWN;
            addCustomValue("LinkState", MessageBundler.getMessage(customValue));
        } else {
            addCustomValue("LinkState", " ");
        }
        return AuditLogType.NETWORK_UPDATE_VM_INTERFACE;
    }
    return AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", VmInterfaceType.forValue(getInterface().getType()).getDescription().toString());
    this.setVmName(vmStaticDao.get(getParameters().getVmId()).getName());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (StringUtils.isEmpty(getMacAddress())) {
            getInterface().setMacAddress(macPool.allocateNewMac());
            macAddedToPool = true;
        } else {
            macAddedToPool = addMacToPool(getMacAddress());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        getInterface().setId(Guid.newGuid());
        getInterface().setVmId(getParameters().getVmId());
        TransactionSupport.executeInNewTransaction(() -> {
            bumpVmVersion();
            addInterfaceToDb(getInterface());
            addInterfaceDeviceToDb();
            getCompensationContext().stateChanged();
            return null;
        });
        if (getInterface().isPlugged()) {
            succeeded = activateNewNic(getInterface());
        } else {
            succeeded = true;
        }
    } finally {
        setSucceeded(succeeded);
        if (macAddedToPool && !succeeded) {
            macPool.freeMac(getMacAddress());
        }
    }
}
#method_after
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", VmInterfaceType.forValue(getInterface().getType()).getDescription().toString());
    this.setVmName(vmStaticDao.get(getParameters().getVmId()).getName());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (StringUtils.isEmpty(getMacAddress())) {
            getInterface().setMacAddress(macPool.allocateNewMac());
            macAddedToPool = true;
        } else {
            macAddedToPool = addMacToPool(getMacAddress());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        getInterface().setId(Guid.newGuid());
        getInterface().setVmId(getParameters().getVmId());
        TransactionSupport.executeInNewTransaction(() -> {
            bumpVmVersion();
            addInterfaceToDb(getInterface());
            addInterfaceDeviceToDb();
            saveNetworkFilterParameters();
            getCompensationContext().stateChanged();
            return null;
        });
        if (getInterface().isPlugged()) {
            succeeded = activateNewNic(getInterface());
        } else {
            succeeded = true;
        }
    } finally {
        setSucceeded(succeeded);
        if (macAddedToPool && !succeeded) {
            macPool.freeMac(getMacAddress());
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    macPool = getMacPool();
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (!validate(vmStatusLegal(vmDynamicDao.get(getParameters().getVmId()).getStatus()))) {
        return false;
    }
    List<VmNic> preexistingVmNics = vmNicDao.getAllForVm(getParameters().getVmId());
    if (!uniqueInterfaceName(preexistingVmNics)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(preexistingVmNics);
    allInterfaces.add(getInterface());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    if (duplicateMacExists(allInterfaces)) {
        return false;
    }
    Version compatibilityVersion = getVm().getClusterCompatibilityVersion();
    VmNicValidator nicValidator = new VmNicValidator(getInterface(), compatibilityVersion, getVm().getOs());
    if (!validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.profileValid(getVm().getClusterId())) || !validate(nicValidator.typeMatchesProfile()) || !validate(nicValidator.passthroughIsLinked()) || !validate(nicValidator.validateProfileNotEmptyForHostedEngineVm(getVm()))) {
        return false;
    }
    if (StringUtils.isNotEmpty(getMacAddress())) {
        if (!validate(macAvailable())) {
            return false;
        }
    } else if (macPool.getAvailableMacsCount() <= 0) {
        addValidationMessage(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    macPool = getMacPool();
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (!validate(vmStatusLegal(vmDynamicDao.get(getParameters().getVmId()).getStatus()))) {
        return false;
    }
    List<VmNic> preexistingVmNics = vmNicDao.getAllForVm(getParameters().getVmId());
    if (!uniqueInterfaceName(preexistingVmNics)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    List<VmNic> allInterfaces = new ArrayList<>(preexistingVmNics);
    allInterfaces.add(getInterface());
    // check that not exceeded PCI and IDE limit
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    String macAddressOfInterface = getMacAddress();
    boolean macAddressIsNotEmpty = macAddressOfInterface != null && !macAddressOfInterface.isEmpty();
    if (macAddressIsNotEmpty && duplicateMacExists(allInterfaces)) {
        return false;
    }
    Version compatibilityVersion = getVm().getClusterCompatibilityVersion();
    VmNicValidator nicValidator = new VmNicValidator(getInterface(), compatibilityVersion, getVm().getOs());
    if (!validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.profileValid(getVm().getClusterId())) || !validate(nicValidator.typeMatchesProfile()) || !validate(nicValidator.passthroughIsLinked()) || !validate(nicValidator.validateProfileNotEmptyForHostedEngineVm(getVm()))) {
        return false;
    }
    if (StringUtils.isNotEmpty(macAddressOfInterface)) {
        if (!validate(macAvailable())) {
            return false;
        }
    } else if (macPool.getAvailableMacsCount() <= 0) {
        addValidationMessage(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean activateOrDeactivateNic(VmNic nic, PlugAction plugAction, boolean newNic) {
    ActivateDeactivateVmNicParameters parameters = new ActivateDeactivateVmNicParameters(nic, plugAction, newNic);
    parameters.setVmId(getParameters().getVmId());
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameters, cloneContextAndDetachFromParent());
    if (!returnValue.getSucceeded()) {
        propagateFailure(returnValue);
    }
    return returnValue.getSucceeded();
}
#method_after
protected boolean activateOrDeactivateNic(VmNic nic, PlugAction plugAction, boolean newNic) {
    ActivateDeactivateVmNicParameters parameters = new ActivateDeactivateVmNicParameters(nic, plugAction, newNic);
    parameters.setVmId(getParameters().getVmId());
    ActionReturnValue returnValue = runInternalAction(ActionType.ActivateDeactivateVmNic, parameters, cloneContextAndDetachFromParent());
    if (!returnValue.getSucceeded()) {
        propagateFailure(returnValue);
    }
    return returnValue.getSucceeded();
}
#end_block

#method_before
protected boolean uniqueInterfaceName(List<VmNic> interfaces) {
    return VmHandler.isNotDuplicateInterfaceName(interfaces, getInterfaceName(), getReturnValue().getValidationMessages());
}
#method_after
protected boolean uniqueInterfaceName(List<VmNic> interfaces) {
    return validate(vmHandler.isNotDuplicateInterfaceName(interfaces, getInterfaceName()));
}
#end_block

#method_before
protected boolean updateVnicForBackwardCompatibility(VmNic oldNic) {
    if (!validate(VnicProfileHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), oldNic, getParameters().getNetworkName(), getParameters().isPortMirroring(), getVm().getStaticData(), getCurrentUser()))) {
        return false;
    }
    return true;
}
#method_after
protected boolean updateVnicForBackwardCompatibility(VmNic oldNic) {
    if (!validate(backwardCompatibilityVnicHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), oldNic, getParameters().getNetworkName(), getParameters().isPortMirroring(), getVm().getStaticData(), getCurrentUser()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(QueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), new AsyncQuery<QueryReturnValue>(returnValue -> {
        allBonds = returnValue.getReturnValue();
        initNetworkModels();
        initNicModels();
        stopProgress();
    }));
}
#method_after
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(QueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), new AsyncQuery<QueryReturnValue>(returnValue -> {
        allBonds = returnValue.getReturnValue();
        queryTLVInformation();
        initNetworkModels();
        initNicModels();
        stopProgress();
    }));
}
#end_block

#method_before
private void showNetwork(LogicalNetworkModel networkModel) {
    boolean descriptionSectionHasValues = false;
    contents.removeAllRows();
    Network entity = networkModel.getNetwork();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName(), BACKGROUND_COLOR));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageWithText(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
        descriptionSectionHasValues = true;
    } else {
        if (networkModel.getErrorMessage() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, templates.maxWidthNteworkItemPopup(networkModel.getErrorMessage())));
            descriptionSectionHasValues = true;
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
            descriptionSectionHasValues = true;
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addSyncDiff(networkModel);
            descriptionSectionHasValues = true;
        }
    }
    if (descriptionSectionHasValues) {
        insertHorizontalLine();
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    boolean isGluster = false;
    boolean isDefaultRoute = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
        isGluster = entity.getCluster().isGluster();
        isDefaultRoute = entity.getCluster().isDefaultRoute();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration || isGluster || isDefaultRoute) {
        // $NON-NLS-1$
        addRow(templates.strongTextWithColor(constants.usageItemInfo() + ":", WHITE_TEXT_COLOR));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo(), TEXT_COLOR));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo(), TEXT_COLOR));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo(), TEXT_COLOR));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo(), TEXT_COLOR));
        }
        if (isGluster) {
            addRow(templates.imageTextSetupNetworkUsage(glusterNwImage, constants.glusterNwItemInfo(), TEXT_COLOR));
        }
        if (isDefaultRoute) {
            addRow(templates.imageTextSetupNetworkUsage(defaultRouteImage, constants.defaultRouteItemInfo(), TEXT_COLOR));
        }
        insertHorizontalLine();
    }
    // Mtu
    if (!entity.isExternal()) {
        final String mtuValue = entity.getMtu() == 0 ? messages.defaultMtu(defaultMtu) : String.valueOf(entity.getMtu());
        // $NON-NLS-1$
        final String mtu = templates.strongTextWithColor(constants.mtuItemInfo(), WHITE_TEXT_COLOR).asString() + ": " + templates.coloredText(mtuValue, TEXT_COLOR).asString();
        addRow(SafeHtmlUtils.fromTrustedString(mtu));
    }
    // Boot protocol and IP info
    if (networkModel.isAttached()) {
        if (networkModel.hasVlan() && networkModel.getVlanDevice() != null) {
            addBootProtoAndIpInfo(networkModel.getVlanDevice(), networkModel.getNetworkAttachment());
        } else if (!networkModel.hasVlan()) {
            addBootProtoAndIpInfo(networkModel.getAttachedToNic().getOriginalIface(), networkModel.getNetworkAttachment());
        } else {
            IpConfiguration ipConfiguration = networkModel.getNetworkAttachment().getIpConfiguration();
            if (ipConfiguration != null && ipConfiguration.hasIpv4PrimaryAddressSet() && ipConfiguration.hasIpv6PrimaryAddressSet()) {
                addBootProtoAndIpInfo(ipConfiguration.getIpv4PrimaryAddress(), ipConfiguration.getIpv6PrimaryAddress());
            }
        }
    }
}
#method_after
private void showNetwork(LogicalNetworkModel networkModel) {
    boolean descriptionSectionHasValues = false;
    contents.removeAllRows();
    Network entity = networkModel.getNetwork();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName(), BACKGROUND_COLOR));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageWithText(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
        descriptionSectionHasValues = true;
    } else {
        if (networkModel.getErrorMessage() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, templates.maxWidthNteworkItemPopup(networkModel.getErrorMessage())));
            descriptionSectionHasValues = true;
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
            descriptionSectionHasValues = true;
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addSyncDiff(networkModel);
            descriptionSectionHasValues = true;
        }
    }
    if (descriptionSectionHasValues) {
        insertHorizontalLine();
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    boolean isGluster = false;
    boolean isDefaultRoute = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
        isGluster = entity.getCluster().isGluster();
        isDefaultRoute = entity.getCluster().isDefaultRoute();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration || isGluster || isDefaultRoute) {
        // $NON-NLS-1$
        addRow(templates.strongTextWithColor(constants.usageItemInfo() + ":", WHITE_TEXT_COLOR));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo(), TEXT_COLOR));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo(), TEXT_COLOR));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo(), TEXT_COLOR));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo(), TEXT_COLOR));
        }
        if (isGluster) {
            addRow(templates.imageTextSetupNetworkUsage(glusterNwImage, constants.glusterNwItemInfo(), TEXT_COLOR));
        }
        if (isDefaultRoute) {
            addRow(templates.imageTextSetupNetworkUsage(defaultRouteImage, constants.defaultRouteItemInfo(), TEXT_COLOR));
        }
        insertHorizontalLine();
    }
    // Mtu
    if (!entity.isExternal()) {
        final String mtuValue = entity.getMtu() == 0 ? messages.defaultMtu(defaultMtu) : String.valueOf(entity.getMtu());
        // $NON-NLS-1$
        final String mtu = templates.strongTextWithColor(constants.mtuItemInfo(), WHITE_TEXT_COLOR).asString() + ": " + templates.coloredText(mtuValue, TEXT_COLOR).asString();
        addRow(SafeHtmlUtils.fromTrustedString(mtu));
    }
    // Boot protocol and IP info
    if (networkModel.isAttached()) {
        IpConfiguration ipConfiguration = networkModel.getNetworkAttachment().getIpConfiguration();
        addBootProtoAndIpInfo(ipConfiguration != null && ipConfiguration.hasIpv4PrimaryAddressSet() ? ipConfiguration.getIpv4PrimaryAddress() : null, ipConfiguration != null && ipConfiguration.hasIpv6PrimaryAddressSet() ? ipConfiguration.getIpv6PrimaryAddress() : null);
    }
}
#end_block

#method_before
private void showNic(NetworkInterfaceModel nic) {
    contents.removeAllRows();
    VdsNetworkInterface entity = nic.getOriginalIface();
    addRow(templates.titleSetupNetworkTooltip(nic.getName(), BACKGROUND_COLOR));
    if (nic.getItems().isEmpty() && !nic.isBonded()) {
        addBootProtoAndIpInfo(entity);
    }
    if (nic instanceof BondNetworkInterfaceModel) {
        addRow(constants.bondOptionsItemInfo(), entity.getBondOptions());
    }
    if (nic.isVf()) {
        addRow(constants.physicalFunction(), nic.getPhysicalFunction());
    }
}
#method_after
private void showNic(NetworkInterfaceModel nic) {
    contents.removeAllRows();
    VdsNetworkInterface entity = nic.getOriginalIface();
    addRow(templates.titleSetupNetworkTooltip(nic.getName(), BACKGROUND_COLOR));
    if (nic.getItems().isEmpty() && !nic.isBonded()) {
        addBootProtoAndIpInfo(entity);
    }
    if (nic instanceof BondNetworkInterfaceModel) {
        addRow(constants.bondOptionsItemInfo(), entity.getBondOptions().replace(BOND_OPTIONS_IP_SEPARATOR, // $NON-NLS-1$
        BOND_OPTIONS_IP_SEPARATOR + " "));
    } else {
        addLldpInfo(nic);
    }
    if (nic.isVf()) {
        addRow(constants.physicalFunction(), nic.getPhysicalFunction());
    }
}
#end_block

#method_before
private void addBootProtoAndIpInfo(IPv4Address ipv4, IpV6Address ipv6) {
    insertHorizontalLine();
    // IPv4
    // $NON-NLS-1$
    addRow(templates.strongTextWithColor(constants.ipv4ItemInfo() + ":", WHITE_TEXT_COLOR));
    Ipv4BootProtocol ipv4BootProtocol = ipv4.getBootProtocol();
    addRow(constants.bootProtocolItemInfo(), IPV4_RENDERER.render(ipv4BootProtocol));
    addNonNullOrEmptyValueRow(constants.addressItemInfo(), ipv4.getAddress());
    addNonNullOrEmptyValueRow(constants.subnetItemInfo(), ipv4.getNetmask());
    addNonNullOrEmptyValueRow(constants.gatewayItemInfo(), ipv4.getGateway());
    // IPv6
    // $NON-NLS-1$
    addRow(templates.strongTextWithColor(constants.ipv6ItemInfo() + ":", WHITE_TEXT_COLOR));
    Ipv6BootProtocol ipv6BootProtocol = ipv6.getBootProtocol();
    addRow(constants.bootProtocolItemInfo(), IPV6_RENDERER.render(ipv6BootProtocol));
    addNonNullOrEmptyValueRow(constants.addressItemInfo(), ipv6.getAddress());
    addNonNullOrEmptyValueRow(constants.prefixItemInfo(), ipv6.getPrefix() != null ? ipv6.getPrefix().toString() : null);
    addNonNullOrEmptyValueRow(constants.gatewayItemInfo(), ipv6.getGateway());
}
#method_after
private void addBootProtoAndIpInfo(IPv4Address ipv4, IpV6Address ipv6) {
    insertHorizontalLine();
    // IPv4
    // $NON-NLS-1$
    addRow(templates.strongTextWithColor(constants.ipv4ItemInfo() + ":", WHITE_TEXT_COLOR));
    if (ipv4 != null) {
        Ipv4BootProtocol ipv4BootProtocol = ipv4.getBootProtocol();
        addRow(constants.bootProtocolItemInfo(), IPV4_RENDERER.render(ipv4BootProtocol));
        addNonNullOrEmptyValueRow(constants.addressItemInfo(), ipv4.getAddress());
        addNonNullOrEmptyValueRow(constants.subnetItemInfo(), ipv4.getNetmask());
        addNonNullOrEmptyValueRow(constants.gatewayItemInfo(), ipv4.getGateway());
    } else {
        addRow(SafeHtmlUtils.fromSafeConstant(constants.notAvailableLabel()));
    }
    // IPv6
    // $NON-NLS-1$
    addRow(templates.strongTextWithColor(constants.ipv6ItemInfo() + ":", WHITE_TEXT_COLOR));
    if (ipv6 != null) {
        Ipv6BootProtocol ipv6BootProtocol = ipv6.getBootProtocol();
        addRow(constants.bootProtocolItemInfo(), IPV6_RENDERER.render(ipv6BootProtocol));
        addNonNullOrEmptyValueRow(constants.addressItemInfo(), ipv6.getAddress());
        addNonNullOrEmptyValueRow(constants.prefixItemInfo(), ipv6.getPrefix() != null ? ipv6.getPrefix().toString() : null);
        addNonNullOrEmptyValueRow(constants.gatewayItemInfo(), ipv6.getGateway());
    } else {
        addRow(SafeHtmlUtils.fromSafeConstant(constants.notAvailableLabel()));
    }
}
#end_block

#method_before
private void writeCpuTune() {
    writer.writeStartElement("cputune");
    @SuppressWarnings("unchecked")
    Map<String, Object> cpuPinning = (Map<String, Object>) createInfo.get(VdsProperties.cpuPinning);
    if (cpuPinning != null) {
        cpuPinning.forEach((vcpu, cpuset) -> {
            writer.writeStartElement("vcpupin");
            writer.writeAttributeString("vcpu", vcpu);
            writer.writeAttributeString("cpuset", (String) cpuset);
            writer.writeEndElement();
        });
    }
    if (vm.getCpuShares() > 0) {
        writer.writeElement("shares", String.valueOf(vm.getCpuShares()));
    }
    String ioCpus = (String) createInfo.get(VdsProperties.ioThreadsPinnning);
    if (ioCpus != null) {
        for (int i = 0; i < vm.getNumOfIoThreads(); i++) {
            writer.writeStartElement("iothreadpin");
            writer.writeAttributeString("iothread", String.valueOf(i + 1));
            writer.writeAttributeString("cpuset", ioCpus);
            writer.writeEndElement();
        }
    }
    String emulatorCpus = (String) createInfo.get(VdsProperties.emulatorThreadsPinnning);
    if (emulatorCpus != null) {
        writer.writeStartElement("emulatorpin");
        writer.writeAttributeString("cpuset", emulatorCpus);
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
private void writeCpuTune() {
    writer.writeStartElement("cputune");
    @SuppressWarnings("unchecked")
    Map<String, Object> cpuPinning = (Map<String, Object>) createInfo.get(VdsProperties.cpuPinning);
    if (cpuPinning != null) {
        cpuPinning.forEach((vcpu, cpuset) -> {
            writer.writeStartElement("vcpupin");
            writer.writeAttributeString("vcpu", vcpu);
            writer.writeAttributeString("cpuset", (String) cpuset);
            writer.writeEndElement();
        });
    }
    if (vm.getCpuShares() > 0) {
        writer.writeElement("shares", String.valueOf(vm.getCpuShares()));
    }
    // iothreadpin + emulatorpin
    String ioEmulatorCpus = vmInfoBuildUtils.getIoThreadsAndEmulatorPinningCpus(vm, hostNumaNodesSupplier, vdsCpuThreads);
    if (ioEmulatorCpus != null) {
        for (int i = 0; i < vm.getNumOfIoThreads(); i++) {
            writer.writeStartElement("iothreadpin");
            writer.writeAttributeString("iothread", String.valueOf(i + 1));
            writer.writeAttributeString("cpuset", ioEmulatorCpus);
            writer.writeEndElement();
        }
        writer.writeStartElement("emulatorpin");
        writer.writeAttributeString("cpuset", ioEmulatorCpus);
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeVmMetadata() {
    writer.writeStartElement(OVIRT_VM_URI, "vm");
    writeMinGuaranteedMemoryMetadata();
    writeClusterVersionMetadata();
    writeVmCustomMetadata();
    writeNetworkInterfaceMetadata();
    writeDiskMetadata();
    writeRunAndPauseMetadata();
    writer.writeEndElement();
}
#method_after
private void writeVmMetadata() {
    writer.writeStartElement(OVIRT_VM_URI, "vm");
    writeMinGuaranteedMemoryMetadata();
    writeClusterVersionMetadata();
    writeVmCustomMetadata();
    writeNetworkInterfaceMetadata();
    writeDiskMetadata();
    writeRunAndPauseMetadata();
    writePayloadMetadata();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    writer.writeStartElement("devices");
    writeInput();
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if (device.getSpecParams() != null && "serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmDevicesMonitoring.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    writer.writeStartElement("devices");
    writeInput();
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if (device.getSpecParams() != null && "serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmDevicesMonitoring.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#end_block

#method_before
private List<VmDevice> overrideDevicesForRunOnce(List<VmDevice> devices) {
    if (!vm.isRunOnce()) {
        return devices;
    }
    // video device handling
    DisplayType displayType = vm.getDefaultDisplayType();
    if (displayType != null) {
        // remove existing video device
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.VIDEO).collect(Collectors.toList());
        // add new video device
        if (displayType != DisplayType.none) {
            devices.add(vmInfoBuildUtils.createVideoDeviceByDisplayType(displayType, vm.getId()));
        }
    }
    // graphics device handling
    if (displayType == DisplayType.none || (vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty())) {
        // remove existing graphics devices
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.GRAPHICS).collect(Collectors.toList());
        if (displayType != DisplayType.none) {
            // add new graphics devices
            Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
            Map<String, Object> specParamsFromVm = new HashMap<>();
            vmInfoBuildUtils.addVmGraphicsOptions(infos, specParamsFromVm, vm);
            devices.addAll(vmInfoBuildUtils.createGraphicsDevices(infos, specParamsFromVm, vm.getId()));
        }
    }
    if (runOncePayload != null) {
        devices = devices.stream().filter(dev -> !VmPayload.isPayload(dev.getSpecParams())).collect(Collectors.toList());
        devices.add(runOncePayload);
    }
    // the user may specify floppy path while there is no device in the database
    if (!StringUtils.isEmpty(vm.getFloppyPath()) && !devices.stream().anyMatch(dev -> !dev.getDevice().equals(VmDeviceType.FLOPPY.getName()))) {
        devices.add(vmInfoBuildUtils.createFloppyDevice(vm));
    }
    return devices;
}
#method_after
private List<VmDevice> overrideDevicesForRunOnce(List<VmDevice> devices) {
    if (!vm.isRunOnce()) {
        return devices;
    }
    // video device handling
    DisplayType displayType = vm.getDefaultDisplayType();
    if (displayType != null) {
        // remove existing video device
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.VIDEO).collect(Collectors.toList());
        // add new video device
        if (displayType != DisplayType.none) {
            devices.add(vmInfoBuildUtils.createVideoDeviceByDisplayType(displayType, vm.getId()));
        }
    }
    // graphics device handling
    if (displayType == DisplayType.none || (vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty())) {
        // remove existing graphics devices
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.GRAPHICS).collect(Collectors.toList());
        if (displayType != DisplayType.none) {
            // add new graphics devices
            Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
            Map<String, Object> specParamsFromVm = new HashMap<>();
            vmInfoBuildUtils.addVmGraphicsOptions(infos, specParamsFromVm, vm);
            devices.addAll(vmInfoBuildUtils.createGraphicsDevices(infos, specParamsFromVm, vm.getId()));
        }
    }
    // the user may specify floppy path while there is no device in the database
    if (!StringUtils.isEmpty(vm.getFloppyPath()) && !devices.stream().anyMatch(dev -> !dev.getDevice().equals(VmDeviceType.FLOPPY.getName()))) {
        devices.add(vmInfoBuildUtils.createFloppyDevice(vm));
    }
    return devices;
}
#end_block

#method_before
private void writeFloppy(VmDevice device) {
    if (device == null) {
        return;
    }
    // <disk device="floppy" snapshot="no" type="file">
    // <source file="/var/run/vdsm/payload/8b5fa6b8-9c57-4d7c-80cb-64537eea560f.6e38a5ccb3c6b2b674086e9d07126a03.img" startupPolicy="optional" />
    // <target bus="fdc" dev="fda" />
    // <readonly />
    // </disk>
    writer.writeStartElement("disk");
    writer.writeAttributeString("type", "file");
    writer.writeAttributeString("device", "floppy");
    writer.writeAttributeString("snapshot", "no");
    writer.writeStartElement("source");
    writer.writeAttributeString("file", VmPayload.isPayload(device.getSpecParams()) ? "PAYLOAD:" : vm.getFloppyPath());
    writer.writeAttributeString("startupPolicy", "optional");
    writer.writeEndElement();
    writer.writeStartElement("target");
    // IDE slot 2 is reserved by VDSM to CDROM
    writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(VdsProperties.Fdc, 0));
    writer.writeAttributeString("bus", VdsProperties.Fdc);
    writer.writeEndElement();
    writer.writeElement("readonly");
    writeAddress(device);
    writer.writeEndElement();
}
#method_after
private void writeFloppy(VmDevice device) {
    if (device == null) {
        return;
    }
    // <disk device="floppy" snapshot="no" type="file">
    // <source file="/var/run/vdsm/payload/8b5fa6b8-9c57-4d7c-80cb-64537eea560f.6e38a5ccb3c6b2b674086e9d07126a03.img" startupPolicy="optional" />
    // <target bus="fdc" dev="fda" />
    // <readonly />
    // </disk>
    writer.writeStartElement("disk");
    writer.writeAttributeString("type", "file");
    writer.writeAttributeString("device", "floppy");
    writer.writeAttributeString("snapshot", "no");
    writer.writeStartElement("source");
    writer.writeAttributeString("file", VmPayload.isPayload(device.getSpecParams()) ? "PAYLOAD:" : vm.getFloppyPath());
    writer.writeAttributeString("startupPolicy", "optional");
    writer.writeEndElement();
    writer.writeStartElement("target");
    // IDE slot 2 is reserved by VDSM to CDROM
    String name = vmInfoBuildUtils.makeDiskName(VdsProperties.Fdc, 0);
    writer.writeAttributeString("dev", name);
    writer.writeAttributeString("bus", VdsProperties.Fdc);
    writer.writeEndElement();
    writer.writeElement("readonly");
    writeAddress(device);
    payloadMetadata = new Pair<>(name, new VmPayload(device));
    writer.writeEndElement();
}
#end_block

#method_before
private void writeCdRom(List<VmDevice> devices) {
    // <disk type='file' device='cdrom' snapshot='no'>
    // <driver name='qemu' type='raw' error_policy='report' />
    // <source file='<path>' startupPolicy='optional'/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    devices.stream().filter(d -> VmPayload.isPayload(d.getSpecParams())).forEach(device -> {
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", "PAYLOAD:");
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        payloadIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, payloadIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if ("scsi".equals(cdInterface)) {
            int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
            writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
        writer.writeEndElement();
    });
    VmDevice nonPayload = devices.stream().filter(d -> !VmPayload.isPayload(d.getSpecParams())).findAny().orElse(null);
    if (nonPayload != null || (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath()))) {
        // add a device that points to vm.getCdPath()
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", vm.getCdPath());
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if (nonPayload != null) {
            writeAddress(nonPayload);
            writeBootOrder(nonPayload.getBootOrder());
        }
        writer.writeEndElement();
    }
}
#method_after
private void writeCdRom(List<VmDevice> devices) {
    // <disk type='file' device='cdrom' snapshot='no'>
    // <driver name='qemu' type='raw' error_policy='report' />
    // <source file='<path>' startupPolicy='optional'/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    devices.stream().filter(d -> VmPayload.isPayload(d.getSpecParams())).forEach(device -> {
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", "PAYLOAD:");
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        payloadIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        String name = vmInfoBuildUtils.makeDiskName(cdInterface, payloadIndex);
        writer.writeAttributeString("dev", name);
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if ("scsi".equals(cdInterface)) {
            int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
            writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
        payloadMetadata = new Pair<>(name, new VmPayload(device));
        writer.writeEndElement();
    });
    VmDevice nonPayload = devices.stream().filter(d -> !VmPayload.isPayload(d.getSpecParams())).findAny().orElse(null);
    if (nonPayload != null || (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath()))) {
        // add a device that points to vm.getCdPath()
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", vm.getCdPath());
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if (nonPayload != null) {
            writeAddress(nonPayload);
            writeBootOrder(nonPayload.getBootOrder());
        }
        writer.writeEndElement();
    }
}
#end_block

#method_before
private void removeDiskImages() {
    List<DiskImage> images = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    for (DiskImage image : images) {
        image.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
        image.setStoragePoolId(getParameters().getStoragePoolId());
    }
    Set<String> allMemoryVolumes = MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots());
    for (String memoryVolumes : allMemoryVolumes) {
        if (!StringUtils.isEmpty(memoryVolumes)) {
            List<Guid> guids = Guid.createGuidListFromString(memoryVolumes);
            DiskImage memoryDisk = createMemoryDisk(guids.get(2), guids.get(3));
            images.add(memoryDisk);
            DiskImage metadataDisk = createMemoryDisk(guids.get(4), guids.get(5));
            images.add(metadataDisk);
        }
    }
    removeVmImages(images);
}
#method_after
private void removeDiskImages() {
    List<DiskImage> images = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    boolean shouldWipe = false;
    for (DiskImage image : images) {
        image.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
        image.setStoragePoolId(getParameters().getStoragePoolId());
        shouldWipe |= image.isWipeAfterDelete();
    }
    Set<String> allMemoryVolumes = MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots());
    for (String memoryVolumes : allMemoryVolumes) {
        if (!StringUtils.isEmpty(memoryVolumes)) {
            List<Guid> guids = Guid.createGuidListFromString(memoryVolumes);
            DiskImage memoryDisk = createMemoryDisk(guids.get(2), guids.get(3), shouldWipe);
            images.add(memoryDisk);
            DiskImage metadataDisk = createMemoryDisk(guids.get(4), guids.get(5), shouldWipe);
            images.add(metadataDisk);
        }
    }
    removeVmImages(images);
}
#end_block

#method_before
private DiskImage createMemoryDisk(Guid diskId, Guid imageId) {
    DiskImage disk = new DiskImage();
    disk.setId(diskId);
    disk.setImageId(imageId);
    disk.setStoragePoolId(getParameters().getStoragePoolId());
    disk.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
    disk.setWipeAfterDelete(false);
    disk.setActive(true);
    return disk;
}
#method_after
private DiskImage createMemoryDisk(Guid diskId, Guid imageId, boolean shouldWipe) {
    DiskImage disk = new DiskImage();
    disk.setId(diskId);
    disk.setImageId(imageId);
    disk.setStoragePoolId(getParameters().getStoragePoolId());
    disk.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
    disk.setWipeAfterDelete(shouldWipe);
    disk.setActive(true);
    return disk;
}
#end_block

#method_before
private void showNic(NetworkInterfaceModel nic) {
    contents.removeAllRows();
    VdsNetworkInterface entity = nic.getOriginalIface();
    addRow(templates.titleSetupNetworkTooltip(nic.getName(), BACKGROUND_COLOR));
    if (nic.getItems().isEmpty() && !nic.isBonded()) {
        addBootProtoAndIpInfo(entity);
    }
    if (nic instanceof BondNetworkInterfaceModel) {
        addRow(constants.bondOptionsItemInfo(), entity.getBondOptions());
    }
    if (nic.isVf()) {
        addRow(constants.physicalFunction(), nic.getPhysicalFunction());
    }
    if (nic instanceof NetworkInterfaceModelWithTlv) {
        addLldpInfo((NetworkInterfaceModelWithTlv) nic);
    }
}
#method_after
private void showNic(NetworkInterfaceModel nic) {
    contents.removeAllRows();
    VdsNetworkInterface entity = nic.getOriginalIface();
    addRow(templates.titleSetupNetworkTooltip(nic.getName(), BACKGROUND_COLOR));
    if (nic.getItems().isEmpty() && !nic.isBonded()) {
        addBootProtoAndIpInfo(entity);
    }
    if (nic instanceof BondNetworkInterfaceModel) {
        addRow(constants.bondOptionsItemInfo(), entity.getBondOptions());
    } else {
        addLldpInfo(nic);
    }
    if (nic.isVf()) {
        addRow(constants.physicalFunction(), nic.getPhysicalFunction());
    }
}
#end_block

#method_before
private void addLldpInfo(NetworkInterfaceModelWithTlv iface) {
    insertHorizontalLine();
    addRow(templates.strongTextWithColor(constants.lldpTlvs(), WHITE_TEXT_COLOR));
    if (iface.getTlvs() != null) {
        iface.getTlvs().stream().filter(tlv -> tlv.getType() == 4 || tlv.getType() == 5 || (tlv.getType() == 127 && isTlvImportant(tlv))).forEach(tlv -> tlv.getProperties().entrySet().stream().forEach(entry -> addRow(entry.getKey(), entry.getValue())));
    }
}
#method_after
private void addLldpInfo(NetworkInterfaceModel nic) {
    HostSetupNetworksModel model = nic.getSetupModel();
    Guid id = nic.getOriginalIface().getId();
    List<Tlv> tlvs = model.getNetworkTlvsByGuid(id);
    insertHorizontalLine();
    addRow(templates.strongTextWithColor(constants.linkLayerInfo(), WHITE_TEXT_COLOR));
    if (tlvs != null && !tlvs.isEmpty()) {
        List<Tlv> filteredTlvs = tlvs.stream().filter(this::isTlvImportant).collect(Collectors.toList());
        if (!filteredTlvs.isEmpty()) {
            filteredTlvs.stream().forEach(tlv -> tlv.getProperties().entrySet().stream().forEach(entry -> addRow(entry.getKey(), entry.getValue())));
        } else {
            addRow(SafeHtmlUtils.fromSafeConstant(constants.noImportantLLDP()));
        }
    } else {
        if (model.isNetworkTlvsPresent(id)) {
            addRow(SafeHtmlUtils.fromSafeConstant(constants.noLldpInfoAvailable()));
        } else {
            addRow(SafeHtmlUtils.fromSafeConstant(constants.fetchingLldpInfo()));
        }
    }
}
#end_block

#method_before
private boolean isTlvImportant(Tlv tlv) {
    return TlvSpecificType.VlanName.isSameAsTlv(tlv) || TlvSpecificType.PortVlanID.isSameAsTlv(tlv) || TlvSpecificType.PortAndProtocolVlanID.isSameAsTlv(tlv) || TlvSpecificType.MaximumFrameSize.isSameAsTlv(tlv) || TlvSpecificType.LinkAggregation802_1.isSameAsTlv(tlv) || TlvSpecificType.LinkAggregation802_3.isSameAsTlv(tlv);
}
#method_after
private boolean isTlvImportant(Tlv tlv) {
    return TlvSpecificType.PortDescription.isSameAsTlv(tlv) || TlvSpecificType.SystemName.isSameAsTlv(tlv) || TlvSpecificType.VlanName.isSameAsTlv(tlv) || TlvSpecificType.PortVlanID.isSameAsTlv(tlv) || TlvSpecificType.PortAndProtocolVlanID.isSameAsTlv(tlv) || TlvSpecificType.MaximumFrameSize.isSameAsTlv(tlv) || TlvSpecificType.LinkAggregation802_1.isSameAsTlv(tlv) || TlvSpecificType.LinkAggregation802_3.isSameAsTlv(tlv);
}
#end_block

#method_before
private Map<String, NetworkInterfaceModel> createRegularNicModels(Map<String, Set<LogicalNetworkModel>> nicNameToNetworkModels, Map<String, List<VdsNetworkInterface>> bondNameToSlaves, Map<String, List<NetworkLabelModel>> nicNameToLabelModels, final Map<Guid, VdsNetworkInterface> nicsById) {
    Map<String, NetworkInterfaceModel> regularNicModels = new HashMap<>();
    for (VdsNetworkInterface nic : allExistingNics) {
        if (!isPhysicalNic(nic, bondNameToSlaves.keySet(), getAllSlaveNames())) {
            continue;
        }
        final VdsNetworkInterface physicalFunction = findPhysicalFunction(nicsById, nic.getId());
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicNameToNetworkModels.get(nicName);
        NetworkInterfaceModel nicModel = new NetworkInterfaceModelWithTlv(nic, nicNetworks, nicNameToLabelModels.get(nicName), nicToVfsConfig.containsKey(nic.getId()), physicalFunction == null ? null : physicalFunction.getName(), this, networkTlvsByGuid.get(nic.getId()));
        regularNicModels.put(nicName, nicModel);
    }
    return regularNicModels;
}
#method_after
private Map<String, NetworkInterfaceModel> createRegularNicModels(Map<String, Set<LogicalNetworkModel>> nicNameToNetworkModels, Map<String, List<VdsNetworkInterface>> bondNameToSlaves, Map<String, List<NetworkLabelModel>> nicNameToLabelModels, final Map<Guid, VdsNetworkInterface> nicsById) {
    Map<String, NetworkInterfaceModel> regularNicModels = new HashMap<>();
    for (VdsNetworkInterface nic : allExistingNics) {
        if (!isPhysicalNic(nic, bondNameToSlaves.keySet(), getAllSlaveNames())) {
            continue;
        }
        final VdsNetworkInterface physicalFunction = findPhysicalFunction(nicsById, nic.getId());
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicNameToNetworkModels.get(nicName);
        NetworkInterfaceModel nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicNameToLabelModels.get(nicName), nicToVfsConfig.containsKey(nic.getId()), physicalFunction == null ? null : physicalFunction.getName(), this);
        regularNicModels.put(nicName, nicModel);
    }
    return regularNicModels;
}
#end_block

#method_before
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(QueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), new AsyncQuery<QueryReturnValue>(returnValue -> {
        allBonds = returnValue.getReturnValue();
        initNetworkModels();
        initNicModels();
        stopProgress();
    }));
}
#method_after
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(QueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), new AsyncQuery<QueryReturnValue>(returnValue -> {
        allBonds = returnValue.getReturnValue();
        queryTLVInformation();
        initNetworkModels();
        initNicModels();
        stopProgress();
    }));
}
#end_block

#method_before
private void queryInterfaces() {
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    // query for interfaces
    Frontend.getInstance().runQuery(QueryType.GetVdsInterfacesByVdsId, params, new AsyncQuery<>((QueryReturnValue returnValue) -> {
        allExistingNics = returnValue.getReturnValue();
        existingVlanDevicesByVlanId = mapVlanDevicesByVlanId();
        initCreateOrUpdateBondParameters();
        initNicLabelsParameters();
        // chain the LLDP query
        queryTLVInformations();
    }));
}
#method_after
private void queryInterfaces() {
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    // query for interfaces
    Frontend.getInstance().runQuery(QueryType.GetVdsInterfacesByVdsId, params, new AsyncQuery<>((QueryReturnValue returnValue) -> {
        allExistingNics = returnValue.getReturnValue();
        existingVlanDevicesByVlanId = mapVlanDevicesByVlanId();
        initCreateOrUpdateBondParameters();
        initNicLabelsParameters();
        // chain the network attachments query
        queryNetworkAttachments();
    }));
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    mandatory(disk().provisionedSize());
    optional(disk().diskProfile().id());
    optional(disk().name());
    optional(disk().openstackVolumeType().name());
// optional(disk().size());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(disk().provisionedSize());
    or(optional(disk().storageDomains()[COLLECTION].id()), optional(disk().storageDomains()[COLLECTION].name()));
    optional(disk().diskProfile().id());
    optional(disk().name());
    optional(disk().openstackVolumeType().name());
// optional(disk().size());
}
#end_block

#method_before
public List<Statistic> getStatistics(VDS entity) {
    VdsStatistics s = entity.getStatisticsData();
    // if user queries host statistics before host installation completed, null values are possible (therefore added checks).
    long memTotal = entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * Mb;
    long memUsed = (s == null || s.getUsageMemPercent() == null) ? 0 : memTotal * s.getUsageMemPercent() / 100;
    List<Statistic> statistics = asList(setDatum(clone(MEM_TOTAL), memTotal), setDatum(clone(MEM_USED), memUsed), setDatum(clone(MEM_FREE), memTotal - memUsed), setDatum(clone(MEM_SHARED), (s == null || s.getMemShared() == null) ? 0 : s.getMemShared() * Mb), setDatum(clone(MEM_BUFFERS), 0), setDatum(clone(MEM_CACHED), 0), setDatum(clone(SWAP_TOTAL), (s == null || s.getSwapTotal() == null) ? 0 : s.getSwapTotal() * Mb), setDatum(clone(SWAP_FREE), (s == null || s.getSwapFree() == null) ? 0 : s.getSwapFree() * Mb), setDatum(clone(SWAP_USED), getSwapUsed(s) * Mb), setDatum(clone(SWAP_CACHED), 0), setDatum(clone(CPU_KSM), (s == null || s.getKsmCpuPercent() == null) ? 0 : s.getKsmCpuPercent()), setDatum(clone(CPU_USER), (s == null || s.getCpuUser() == null) ? 0 : s.getCpuUser()), setDatum(clone(CPU_SYS), (s == null || s.getCpuSys() == null) ? 0 : s.getCpuSys()), setDatum(clone(CPU_IDLE), (s == null || s.getCpuIdle() == null) ? 0 : s.getCpuIdle()), setDatum(clone(CPU_LOAD), (s == null || s.getCpuLoad() == null) ? 0 : s.getCpuLoad() / 100), setDatum(clone(BOOT_TIME), (s == null || s.getBootTime() == null) ? 0 : s.getBootTime()));
    if (s != null) {
        s.getHugePages().stream().filter(page -> page.getAmount() != null).map(page -> setDatum(create("hugepages." + page.getSizeKB() + ".free", "Amount of free huge pages of the given size", GAUGE, NONE, INTEGER), page.getAmount())).forEach(page -> statistics.add(page));
    }
    return statistics;
}
#method_after
public List<Statistic> getStatistics(VDS entity) {
    VdsStatistics s = entity.getStatisticsData();
    // if user queries host statistics before host installation completed, null values are possible (therefore added checks).
    long memTotal = entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * Mb;
    long memUsed = (s == null || s.getUsageMemPercent() == null) ? 0 : memTotal * s.getUsageMemPercent() / 100;
    List<Statistic> statistics = asList(setDatum(clone(MEM_TOTAL), memTotal), setDatum(clone(MEM_USED), memUsed), setDatum(clone(MEM_FREE), memTotal - memUsed), setDatum(clone(MEM_SHARED), (s == null || s.getMemShared() == null) ? 0 : s.getMemShared() * Mb), setDatum(clone(MEM_BUFFERS), 0), setDatum(clone(MEM_CACHED), 0), setDatum(clone(SWAP_TOTAL), (s == null || s.getSwapTotal() == null) ? 0 : s.getSwapTotal() * Mb), setDatum(clone(SWAP_FREE), (s == null || s.getSwapFree() == null) ? 0 : s.getSwapFree() * Mb), setDatum(clone(SWAP_USED), getSwapUsed(s) * Mb), setDatum(clone(SWAP_CACHED), 0), setDatum(clone(CPU_KSM), (s == null || s.getKsmCpuPercent() == null) ? 0 : s.getKsmCpuPercent()), setDatum(clone(CPU_USER), (s == null || s.getCpuUser() == null) ? 0 : s.getCpuUser()), setDatum(clone(CPU_SYS), (s == null || s.getCpuSys() == null) ? 0 : s.getCpuSys()), setDatum(clone(CPU_IDLE), (s == null || s.getCpuIdle() == null) ? 0 : s.getCpuIdle()), setDatum(clone(CPU_LOAD), (s == null || s.getCpuLoad() == null) ? 0 : s.getCpuLoad() / 100), setDatum(clone(BOOT_TIME), (s == null || s.getBootTime() == null) ? 0 : s.getBootTime()));
    if (s != null) {
        s.getHugePages().stream().filter(page -> page.getAmount() != null).map(this::createHugePagesFree).forEach(statistics::add);
    }
    return statistics;
}
#end_block

#method_before
private Container createSlavesContainer() {
    Row content = new Row();
    Column gridColumn = new Column(ColumnSize.SM_12);
    content.add(gridColumn);
    Container container = createItemContainerPanel(content);
    CellTable<HostInterface> slavesTable = new CellTable<>(MAX_SLAVES, (Resources) GWT.create(CellTablePopupTableResources.class));
    slavesTable.getElement().addClassName(Styles.TABLE);
    slavesTable.getElement().addClassName(PatternflyConstants.PF_TABLE_STRIPED);
    slavesTable.getElement().addClassName(PatternflyConstants.PF_TABLE_BORDERED);
    ListDataProvider<HostInterface> logicalNetworkDataProvider = new ListDataProvider<>();
    logicalNetworkDataProvider.addDataDisplay(slavesTable);
    logicalNetworkDataProvider.setList(getEntity().getInterfaces());
    // Setup columns
    TextColumn<HostInterface> name = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return hostInterface.getName();
        }
    };
    slavesTable.addColumn(name, constants.macInterface());
    TextColumn<HostInterface> macAddress = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return hostInterface.getInterface().getMacAddress() != null ? hostInterface.getInterface().getMacAddress() : constants.unAvailablePropertyLabel();
        }
    };
    slavesTable.addColumn(macAddress, constants.macInterface());
    TextColumn<HostInterface> speed = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return hostInterface.getInterface().hasSpeed() ? String.valueOf(hostInterface.getInterface().getSpeed()) : constants.unAvailablePropertyLabel();
        }
    };
    slavesTable.addColumn(speed, constants.speedInterface());
    TextColumn<HostInterface> rxRate = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return rateRenderer.render(new Double[] { hostInterface.getRxRate(), hostInterface.getSpeed().doubleValue() });
        }
    };
    slavesTable.addColumn(rxRate, templates.sub(constants.rxRate(), constants.mbps()));
    TextColumn<HostInterface> txRate = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return rateRenderer.render(new Double[] { hostInterface.getTxRate(), hostInterface.getSpeed().doubleValue() });
        }
    };
    slavesTable.addColumn(txRate, templates.sub(constants.txRate(), constants.mbps()));
    TextColumn<HostInterface> rxTotal = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return hostInterface.getRxTotal() != null ? totalRenderer.render(hostInterface.getRxTotal()) : constants.notAvailableLabel();
        }
    };
    slavesTable.addColumn(rxTotal, templates.sub(constants.rxTotal(), constants.mbps()));
    TextColumn<HostInterface> txTotal = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return hostInterface.getTxTotal() != null ? totalRenderer.render(hostInterface.getTxTotal()) : constants.notAvailableLabel();
        }
    };
    slavesTable.addColumn(txTotal, templates.sub(constants.txTotal(), constants.mbps()));
    TextColumn<HostInterface> dropRate = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return String.valueOf(hostInterface.getRxDrop() + hostInterface.getTxDrop());
        }
    };
    slavesTable.addColumn(dropRate, templates.sub(constants.dropsInterface(), constants.pkts()));
    gridColumn.add(slavesTable);
    return container;
}
#method_after
private Container createSlavesContainer() {
    Row content = new Row();
    Column gridColumn = new Column(ColumnSize.SM_12);
    content.add(gridColumn);
    Container container = createItemContainerPanel(content);
    CellTable<HostInterface> slavesTable = new CellTable<>(MAX_SLAVES, (Resources) GWT.create(CellTablePopupTableResources.class));
    slavesTable.getElement().addClassName(Styles.TABLE);
    slavesTable.getElement().addClassName(PatternflyConstants.PF_TABLE_STRIPED);
    slavesTable.getElement().addClassName(PatternflyConstants.PF_TABLE_BORDERED);
    ListDataProvider<HostInterface> logicalNetworkDataProvider = new ListDataProvider<>();
    logicalNetworkDataProvider.addDataDisplay(slavesTable);
    logicalNetworkDataProvider.setList(getEntity().getInterfaces());
    // Setup columns
    TextColumn<HostInterface> name = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return hostInterface.getName();
        }
    };
    slavesTable.addColumn(name, constants.macInterface());
    TextColumn<HostInterface> macAddress = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return hostInterface.getInterface().getMacAddress() != null ? hostInterface.getInterface().getMacAddress() : constants.unAvailablePropertyLabel();
        }
    };
    slavesTable.addColumn(macAddress, constants.macInterface());
    TextColumn<HostInterface> speed = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return hostInterface.getInterface().hasSpeed() ? String.valueOf(hostInterface.getInterface().getSpeed()) : constants.unAvailablePropertyLabel();
        }
    };
    slavesTable.addColumn(speed, constants.speedInterface());
    TextColumn<HostInterface> rxRate = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return rateRenderer.render(new Double[] { hostInterface.getRxRate(), hostInterface.getSpeed().doubleValue() });
        }
    };
    slavesTable.addColumn(rxRate, templates.sub(constants.rxRate(), constants.mbps()));
    TextColumn<HostInterface> txRate = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return rateRenderer.render(new Double[] { hostInterface.getTxRate(), hostInterface.getSpeed().doubleValue() });
        }
    };
    slavesTable.addColumn(txRate, templates.sub(constants.txRate(), constants.mbps()));
    TextColumn<HostInterface> rxTotal = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return totalRenderer.render(hostInterface.getRxTotal());
        }
    };
    slavesTable.addColumn(rxTotal, templates.sub(constants.rxTotal(), constants.mbps()));
    TextColumn<HostInterface> txTotal = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return totalRenderer.render(hostInterface.getTxTotal());
        }
    };
    slavesTable.addColumn(txTotal, templates.sub(constants.txTotal(), constants.mbps()));
    TextColumn<HostInterface> dropRate = new TextColumn<HostInterface>() {

        @Override
        public String getValue(HostInterface hostInterface) {
            return String.valueOf(hostInterface.getRxDrop() + hostInterface.getTxDrop());
        }
    };
    slavesTable.addColumn(dropRate, templates.sub(constants.dropsInterface(), constants.pkts()));
    gridColumn.add(slavesTable);
    return container;
}
#end_block

#method_before
private Container createStatisticsItemContainerPanel(VmNetworkInterface networkInterface) {
    Row content = new Row();
    Column column = new Column(ColumnSize.MD_12);
    content.add(column);
    RxTxRateRenderer rateRenderer = new RxTxRateRenderer();
    RxTxTotalRenderer totalRenderer = new RxTxTotalRenderer();
    DListElement dl = Document.get().createDLElement();
    dl.addClassName(DL_HORIZONTAL);
    addDetailItem(templates.sub(constants.rxRate(), constants.mbps()), rateRenderer.render(new Double[] { networkInterface.getStatistics().getReceiveRate(), networkInterface.hasSpeed() ? networkInterface.getSpeed().doubleValue() : 0 }), dl);
    addDetailItem(templates.sub(constants.txRate(), constants.mbps()), rateRenderer.render(new Double[] { networkInterface.getStatistics().getTransmitRate(), networkInterface.getSpeed().doubleValue() }), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.rxTotal()), networkInterface.getStatistics().getReceivedBytes() != null ? totalRenderer.render(networkInterface.getStatistics().getReceivedBytes()) : constants.notAvailableLabel(), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.txTotal()), networkInterface.getStatistics().getTransmittedBytes() != null ? totalRenderer.render(networkInterface.getStatistics().getTransmittedBytes()) : constants.notAvailableLabel(), dl);
    addDetailItem(templates.sub(constants.dropsInterface(), constants.pkts()), String.valueOf(networkInterface.getStatistics().getReceiveDropRate() + networkInterface.getStatistics().getTransmitDropRate()), dl);
    column.getElement().appendChild(dl);
    return createItemContainerPanel(content);
}
#method_after
private Container createStatisticsItemContainerPanel(VmNetworkInterface networkInterface) {
    Row content = new Row();
    Column column = new Column(ColumnSize.MD_12);
    content.add(column);
    RxTxRateRenderer rateRenderer = new RxTxRateRenderer();
    RxTxTotalRenderer totalRenderer = new RxTxTotalRenderer();
    DListElement dl = Document.get().createDLElement();
    dl.addClassName(DL_HORIZONTAL);
    addDetailItem(templates.sub(constants.rxRate(), constants.mbps()), rateRenderer.render(new Double[] { networkInterface.getStatistics().getReceiveRate(), networkInterface.hasSpeed() ? networkInterface.getSpeed().doubleValue() : 0 }), dl);
    addDetailItem(templates.sub(constants.txRate(), constants.mbps()), rateRenderer.render(new Double[] { networkInterface.getStatistics().getTransmitRate(), networkInterface.getSpeed().doubleValue() }), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.rxTotal()), totalRenderer.render(networkInterface.getStatistics().getReceivedBytes()), dl);
    addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.txTotal()), totalRenderer.render(networkInterface.getStatistics().getTransmittedBytes()), dl);
    addDetailItem(templates.sub(constants.dropsInterface(), constants.pkts()), String.valueOf(networkInterface.getStatistics().getReceiveDropRate() + networkInterface.getStatistics().getTransmitDropRate()), dl);
    column.getElement().appendChild(dl);
    return createItemContainerPanel(content);
}
#end_block

#method_before
private IsWidget createRxColumn(HostInterface hostInterface) {
    Column rxCol = new Column(ColumnSize.SM_3);
    DListElement dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.rxRate(), constants.mbps()), rateRenderer.render(new Double[] { hostInterface.getRxRate(), hostInterface.getSpeed().doubleValue() }), dl);
    dl.addClassName(Styles.PULL_LEFT);
    rxCol.getElement().appendChild(dl);
    FlowPanel divider = new FlowPanel();
    divider.addStyleName(RATE_DIVIDER);
    rxCol.add(divider);
    dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.rxTotal(), constants.bytes()), hostInterface.getRxTotal() != null ? totalRenderer.render(hostInterface.getRxTotal()) : constants.notAvailableLabel(), dl);
    dl.addClassName(Styles.PULL_LEFT);
    rxCol.getElement().appendChild(dl);
    return rxCol;
}
#method_after
private IsWidget createRxColumn(HostInterface hostInterface) {
    Column rxCol = new Column(ColumnSize.SM_3);
    DListElement dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.rxRate(), constants.mbps()), rateRenderer.render(new Double[] { hostInterface.getRxRate(), hostInterface.getSpeed().doubleValue() }), dl);
    dl.addClassName(Styles.PULL_LEFT);
    rxCol.getElement().appendChild(dl);
    FlowPanel divider = new FlowPanel();
    divider.addStyleName(RATE_DIVIDER);
    rxCol.add(divider);
    dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.rxTotal(), constants.bytes()), totalRenderer.render(hostInterface.getRxTotal()), dl);
    dl.addClassName(Styles.PULL_LEFT);
    rxCol.getElement().appendChild(dl);
    return rxCol;
}
#end_block

#method_before
private IsWidget createTxColumn(HostInterface hostInterface) {
    Column txCol = new Column(ColumnSize.SM_3);
    DListElement dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.txRate(), constants.mbps()), rateRenderer.render(new Double[] { hostInterface.getTxRate(), hostInterface.getSpeed().doubleValue() }), dl);
    dl.addClassName(Styles.PULL_LEFT);
    txCol.getElement().appendChild(dl);
    FlowPanel divider = new FlowPanel();
    divider.addStyleName(RATE_DIVIDER);
    txCol.add(divider);
    dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.txTotal(), constants.bytes()), hostInterface.getTxTotal() != null ? totalRenderer.render(hostInterface.getTxTotal()) : constants.notAvailableLabel(), dl);
    dl.addClassName(Styles.PULL_LEFT);
    txCol.getElement().appendChild(dl);
    return txCol;
}
#method_after
private IsWidget createTxColumn(HostInterface hostInterface) {
    Column txCol = new Column(ColumnSize.SM_3);
    DListElement dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.txRate(), constants.mbps()), rateRenderer.render(new Double[] { hostInterface.getTxRate(), hostInterface.getSpeed().doubleValue() }), dl);
    dl.addClassName(Styles.PULL_LEFT);
    txCol.getElement().appendChild(dl);
    FlowPanel divider = new FlowPanel();
    divider.addStyleName(RATE_DIVIDER);
    txCol.add(divider);
    dl = Document.get().createDLElement();
    addReverseDetailItem(templates.sub(constants.txTotal(), constants.bytes()), totalRenderer.render(hostInterface.getTxTotal()), dl);
    dl.addClassName(Styles.PULL_LEFT);
    txCol.getElement().appendChild(dl);
    return txCol;
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    or(mandatory(cluster().id()), mandatory(cluster().name()));
    optional(clone());
    optional(exclusive());
    optional(template().name());
    optional(configuration());
}
#method_after
@InputDetail
default void inputDetail() {
    or(mandatory(cluster().id()), mandatory(cluster().name()));
    optional(clone());
    optional(exclusive());
    optional(template().name());
    optional(registrationConfiguration());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    or(mandatory(cluster().id()), mandatory(cluster().name()));
    optional(configuration());
}
#method_after
@InputDetail
default void inputDetail() {
    or(mandatory(cluster().id()), mandatory(cluster().name()));
    optional(registrationConfiguration());
}
#end_block

#method_before
private void onUpgrade() {
    if (getProgress() != null) {
        return;
    }
    UpgradeHostParameters params = new UpgradeHostParameters(host.getId(), getLatch().getEntity().booleanValue());
    invokeHostUpgrade(params);
}
#method_after
private void onUpgrade() {
    if (getProgress() != null) {
        return;
    }
    UpgradeHostParameters params = new UpgradeHostParameters(host.getId(), getReboot().getEntity().booleanValue());
    invokeHostUpgrade(params);
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    mandatory(template().name());
    or(mandatory(template().vm().id()), mandatory(template().vm().name()));
    optional(template().bios().bootMenu().enabled());
    optional(template().cluster().id());
    optional(template().cluster().name());
    optional(template().comment());
    optional(template().console().enabled());
    optional(template().cpu().architecture());
    optional(template().cpu().topology().cores());
    optional(template().cpu().topology().sockets());
    optional(template().cpu().topology().threads());
    optional(template().cpuProfile().id());
    optional(template().cpuShares());
    optional(template().customCpuModel());
    optional(template().customEmulatedMachine());
    optional(template().deleteProtected());
    optional(template().description());
    optional(template().display().allowOverride());
    optional(template().display().copyPasteEnabled());
    optional(template().display().disconnectAction());
    optional(template().display().fileTransferEnabled());
    optional(template().display().keyboardLayout());
    optional(template().display().monitors());
    optional(template().display().smartcardEnabled());
    optional(template().display().type());
    optional(template().domain().name());
    optional(template().highAvailability().enabled());
    optional(template().highAvailability().priority());
    optional(template().initialization().configuration().data());
    optional(template().initialization().configuration().type());
    optional(template().io().threads());
    optional(template().largeIcon().data());
    optional(template().largeIcon().id());
    optional(template().largeIcon().mediaType());
    optional(template().memory());
    optional(template().memoryPolicy().ballooning());
    optional(template().memoryPolicy().guaranteed());
    optional(template().migration().autoConverge());
    optional(template().migration().compressed());
    optional(template().migrationDowntime());
    optional(template().origin());
    optional(template().os().cmdline());
    optional(template().os().initrd());
    optional(template().os().kernel());
    optional(template().os().type());
    // TODO: check
    optional(template().vm().placementPolicy().affinity());
    optional(template().serialNumber().policy());
    optional(template().serialNumber().value());
    optional(template().smallIcon().id());
    optional(template().soundcardEnabled());
    optional(template().startPaused());
    optional(template().stateless());
    optional(template().storageDomain().id());
    optional(template().timeZone().name());
    optional(template().tunnelMigration());
    optional(template().type());
    optional(template().usb().enabled());
    optional(template().usb().type());
    optional(template().version().baseTemplate().id());
    optional(template().version().versionName());
    optional(template().virtioScsi().enabled());
    optional(template().display().singleQxlPci());
    optional(template().rngDevice().rate().bytes());
    optional(template().rngDevice().rate().period());
    optional(template().rngDevice().source());
    optional(template().vm().diskAttachments()[COLLECTION].name());
    optional(template().vm().diskAttachments()[COLLECTION].description());
    optional(template().vm().diskAttachments()[COLLECTION].id());
    // optional(template().vm().diskAttachments()[COLLECTION].storageDomain--collection()); //TODO: check
    optional(template().customProperties()[COLLECTION].name());
    optional(template().customProperties()[COLLECTION].value());
    optional(template().os().boot().devices()[COLLECTION]);
    optional(template().cpu().cpuTune().vcpuPins()[COLLECTION].cpuSet());
    optional(template().cpu().cpuTune().vcpuPins()[COLLECTION].vcpu());
    optional(template().sso().methods()[COLLECTION].id());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(template().name());
    or(mandatory(template().vm().id()), mandatory(template().vm().name()));
    optional(template().bios().bootMenu().enabled());
    optional(template().cluster().id());
    optional(template().cluster().name());
    optional(template().comment());
    optional(template().console().enabled());
    optional(template().cpu().architecture());
    optional(template().cpu().topology().cores());
    optional(template().cpu().topology().sockets());
    optional(template().cpu().topology().threads());
    optional(template().cpuProfile().id());
    optional(template().cpuShares());
    optional(template().customCpuModel());
    optional(template().customEmulatedMachine());
    optional(template().deleteProtected());
    optional(template().description());
    optional(template().display().allowOverride());
    optional(template().display().copyPasteEnabled());
    optional(template().display().disconnectAction());
    optional(template().display().fileTransferEnabled());
    optional(template().display().keyboardLayout());
    optional(template().display().monitors());
    optional(template().display().smartcardEnabled());
    optional(template().display().type());
    optional(template().domain().name());
    optional(template().highAvailability().enabled());
    optional(template().highAvailability().priority());
    optional(template().initialization().configuration().data());
    optional(template().initialization().configuration().type());
    optional(template().io().threads());
    optional(template().largeIcon().data());
    optional(template().largeIcon().id());
    optional(template().largeIcon().mediaType());
    optional(template().memory());
    optional(template().memoryPolicy().ballooning());
    optional(template().memoryPolicy().guaranteed());
    optional(template().migration().autoConverge());
    optional(template().migration().compressed());
    optional(template().migrationDowntime());
    optional(template().origin());
    optional(template().os().cmdline());
    optional(template().os().initrd());
    optional(template().os().kernel());
    optional(template().os().type());
    // TODO: check
    optional(template().vm().placementPolicy().affinity());
    optional(template().serialNumber().policy());
    optional(template().serialNumber().value());
    optional(template().smallIcon().id());
    optional(template().soundcardEnabled());
    optional(template().startPaused());
    optional(template().stateless());
    optional(template().storageDomain().id());
    optional(template().timeZone().name());
    optional(template().tunnelMigration());
    optional(template().type());
    optional(template().usb().enabled());
    optional(template().usb().type());
    optional(template().version().baseTemplate().id());
    optional(template().version().versionName());
    optional(template().virtioScsi().enabled());
    optional(template().display().singleQxlPci());
    optional(template().rngDevice().rate().bytes());
    optional(template().rngDevice().rate().period());
    optional(template().rngDevice().source());
    optional(template().vm().diskAttachments()[COLLECTION].name());
    optional(template().vm().diskAttachments()[COLLECTION].description());
    optional(template().vm().diskAttachments()[COLLECTION].id());
    // optional(template().vm().diskAttachments()[COLLECTION].storageDomain--collection()); //TODO: check
    optional(template().customProperties()[COLLECTION].name());
    optional(template().customProperties()[COLLECTION].value());
    optional(template().os().boot().devices()[COLLECTION]);
    optional(template().cpu().cpuTune().vcpuPins()[COLLECTION].cpuSet());
    optional(template().cpu().cpuTune().vcpuPins()[COLLECTION].vcpu());
    optional(template().sso().methods()[COLLECTION].id());
    optional(template().storageErrorResumeBehaviour());
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    setVmId(getParameters().getContainerId());
    setStoragePoolId(getParameters().getStoragePoolId());
    imageToDestinationDomainMap = getParameters().getImageToDestinationDomainMap();
    if (getParameters().getVm() != null && getVm().getDiskMap() != null) {
        imageList = new ArrayList<>();
        for (Disk disk : getVm().getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                imageList.add((DiskImage) disk);
            }
        }
    }
    ensureDomainMap(imageList, getParameters().getDestDomainId());
}
#method_after
@Override
protected void init() {
    super.init();
    setVmId(getParameters().getContainerId());
    setStoragePoolId(getParameters().getStoragePoolId());
    imageToDestinationDomainMap = getParameters().getImageToDestinationDomainMap();
    if (getParameters().getVm() != null && getVm().getDiskMap() != null) {
        imageList = getVm().getDiskMap().values().stream().filter(DisksFilter.ONLY_IMAGES).map(DiskImage.class::cast).collect(Collectors.toList());
    }
    ensureDomainMap(imageList, getParameters().getDestDomainId());
}
#end_block

#method_before
private void initImportClonedVm() {
    Guid guid = getParameters().getVm().getId();
    getVm().setId(guid);
    setVmId(guid);
    getVm().setName(getParameters().getVm().getName());
    getVm().setStoragePoolId(getParameters().getStoragePoolId());
    getParameters().setVm(getVm());
    for (VmNic iface : getVm().getInterfaces()) {
        iface.setId(Guid.newGuid());
    }
}
#method_after
private void initImportClonedVm() {
    Guid guid = getParameters().getVm().getId();
    getVm().setId(guid);
    setVmId(guid);
    getVm().setName(getParameters().getVm().getName());
    getVm().setStoragePoolId(getParameters().getStoragePoolId());
    getParameters().setVm(getVm());
    getVm().getInterfaces().forEach(iface -> iface.setId(Guid.newGuid()));
}
#end_block

#method_before
protected boolean validateImages(Map<Guid, StorageDomain> domainsMap) {
    List<String> validationMessages = getReturnValue().getValidationMessages();
    // Iterate over all the VM images (active image and snapshots)
    for (DiskImage image : getImages()) {
        if (Guid.Empty.equals(image.getVmSnapshotId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
        }
        if (getParameters().getCopyCollapse()) {
            // a match with the image from the VM.
            for (DiskImage p : imageList) {
                // only if requested by the user
                if (p.getImageId().equals(image.getImageId())) {
                    if (p.getVolumeFormat() != null) {
                        image.setVolumeFormat(p.getVolumeFormat());
                    }
                    if (p.getVolumeType() != null) {
                        image.setVolumeType(p.getVolumeType());
                    }
                    // Validate the configuration of the image got from the parameters.
                    if (!validateImageConfig(validationMessages, domainsMap, image)) {
                        return false;
                    }
                    break;
                }
            }
        }
        image.setStoragePoolId(getParameters().getStoragePoolId());
        // we put the source domain id in order that copy will
        // work properly.
        // we fix it to DestDomainId in
        // MoveOrCopyAllImageGroups();
        image.setStorageIds(new ArrayList<>(Arrays.asList(getSourceDomainId(image))));
    }
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
    for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
        Guid id = entry.getKey();
        List<DiskImage> diskList = entry.getValue();
        getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
    }
    return true;
}
#method_after
protected boolean validateImages(Map<Guid, StorageDomain> domainsMap) {
    List<String> validationMessages = getReturnValue().getValidationMessages();
    // Iterate over all the VM images (active image and snapshots)
    for (DiskImage image : getImages()) {
        if (Guid.Empty.equals(image.getVmSnapshotId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
        }
        if (getParameters().getCopyCollapse()) {
            // a match with the image from the VM.
            for (DiskImage p : imageList) {
                // only if requested by the user
                if (p.getImageId().equals(image.getImageId())) {
                    if (p.getVolumeFormat() != null) {
                        image.setVolumeFormat(p.getVolumeFormat());
                    }
                    if (p.getVolumeType() != null) {
                        image.setVolumeType(p.getVolumeType());
                    }
                    // Validate the configuration of the image got from the parameters.
                    if (!validateImageConfig(validationMessages, domainsMap, image)) {
                        return false;
                    }
                    break;
                }
            }
        }
        image.setStoragePoolId(getParameters().getStoragePoolId());
        // we put the source domain id in order that copy will
        // work properly.
        // we fix it to DestDomainId in
        // MoveOrCopyAllImageGroups();
        image.setStorageIds(new ArrayList<>(Arrays.asList(getSourceDomainId(image))));
    }
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
    images.entrySet().stream().forEach(e -> getVm().getDiskMap().put(e.getKey(), getActiveVolumeDisk(e.getValue())));
    return true;
}
#end_block

#method_before
protected VM getVmFromExportDomain(Guid vmId) {
    for (VM vm : getVmsFromExportDomain()) {
        if (vmId.equals(vm.getId())) {
            return vm;
        }
    }
    return null;
}
#method_after
protected VM getVmFromExportDomain(Guid vmId) {
    return getVmsFromExportDomain().stream().filter(v -> vmId.equals(v.getId())).findFirst().orElse(null);
}
#end_block

#method_before
private boolean validateLunDisksForVm(VM vmFromParams) {
    if (vmFromParams.getDiskMap() != null) {
        List<LunDisk> lunDisks = DisksFilter.filterLunDisks(vmFromParams.getDiskMap().values());
        for (LunDisk lunDisk : lunDisks) {
            List<EngineMessage> lunValidationMessages = validateLunDisk(lunDisk);
            if (lunValidationMessages.isEmpty()) {
                getVm().getDiskMap().put(lunDisk.getId(), lunDisk);
            } else if (!getParameters().isAllowPartialImport()) {
                addValidationMessages(lunValidationMessages);
                return false;
            } else {
                log.warn("Skipping validation for external LUN disk '{}' since partialImport flag is true." + " Invalid external LUN disk might reflect on the run VM process", lunDisk.getId());
                vmFromParams.getDiskMap().remove(lunDisk.getId());
                failedDisksToImportForAuditLog.putIfAbsent(lunDisk.getId(), lunDisk.getDiskAlias());
            }
        }
    }
    return true;
}
#method_after
private boolean validateLunDisksForVm(VM vmFromParams) {
    if (vmFromParams.getDiskMap() != null) {
        List<LunDisk> lunDisks = DisksFilter.filterLunDisks(vmFromParams.getDiskMap().values());
        for (LunDisk lunDisk : lunDisks) {
            List<EngineMessage> lunValidationMessages = validateLunDisk(lunDisk);
            if (lunValidationMessages.isEmpty()) {
                getVm().getDiskMap().put(lunDisk.getId(), lunDisk);
            } else if (!getParameters().isAllowPartialImport()) {
                return failValidation(lunValidationMessages);
            } else {
                log.warn("Skipping validation for external LUN disk '{}' since partialImport flag is true." + " Invalid external LUN disk might reflect on the run VM process", lunDisk.getId());
                vmFromParams.getDiskMap().remove(lunDisk.getId());
                failedDisksToImportForAuditLog.putIfAbsent(lunDisk.getId(), lunDisk.getDiskAlias());
            }
        }
    }
    return true;
}
#end_block

#method_before
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    QueryReturnValue qRetVal = runInternalQuery(QueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    if (qRetVal.getSucceeded()) {
        Map<VmTemplate, ?> templates = qRetVal.getReturnValue();
        for (VmTemplate template : templates.keySet()) {
            if (getParameters().getVm().getVmtGuid().equals(template.getId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    QueryReturnValue qRetVal = runInternalQuery(QueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    if (!qRetVal.getSucceeded()) {
        return false;
    }
    Map<VmTemplate, ?> templates = qRetVal.getReturnValue();
    return templates.keySet().stream().anyMatch(t -> getParameters().getVm().getVmtGuid().equals(t.getId()));
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (getParameters().getVm().getDiskMap() != null) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (Disk disk : getDisksForDiskProfileValidation()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                map.put(diskImage, imageToDestinationDomainMap.get(diskImage.getId()));
            }
        }
        return validate(diskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (getParameters().getVm().getDiskMap() != null) {
        Map<DiskImage, Guid> map = getDisksForDiskProfileValidation().stream().filter(DisksFilter.ONLY_IMAGES).collect(Collectors.toMap(DiskImage.class::cast, d -> imageToDestinationDomainMap.get(d.getId())));
        return validate(diskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
private Collection<Snapshot> getSnapshotsToBeExportedWithMemory() {
    if (getParameters().getCopyCollapse()) {
        Snapshot activeSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
        return !activeSnapshot.getMemoryVolume().isEmpty() ? Collections.singleton(activeSnapshot) : Collections.emptyList();
    } else {
        return snapshotDao.getAll(getVmId()).stream().filter(s -> !StringUtils.EMPTY.equals(s.getMemoryVolume())).map(Function.identity()).collect(Collectors.toList());
    }
}
#method_after
private Collection<Snapshot> getSnapshotsToBeExportedWithMemory() {
    if (getParameters().getCopyCollapse()) {
        Snapshot activeSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
        return !activeSnapshot.getMemoryVolume().isEmpty() ? Collections.singleton(activeSnapshot) : Collections.emptyList();
    } else {
        return snapshotDao.getAll(getVmId()).stream().filter(s -> !StringUtils.EMPTY.equals(s.getMemoryVolume())).collect(Collectors.toList());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
    freeLock();
    // update vm init
    vmHandler.updateVmInitFromDB(getVm().getStaticData(), true);
    // immediately after the execution of the previous steps
    if (!hasSnappableDisks() && snapshotsWithMemory.isEmpty()) {
        endSuccessfully();
    } else {
        TransactionSupport.executeInNewTransaction(() -> {
            moveOrCopyAllImageGroups();
            return null;
        });
        if (!getReturnValue().getVdsmTaskIdList().isEmpty()) {
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
    freeLock();
    // update vm init
    vmHandler.updateVmInitFromDB(getVm().getStaticData(), true);
    // immediately after the execution of the previous steps
    if (!hasSnappableDisks() && snapshotsWithMemory.isEmpty()) {
        endSuccessfully();
    } else {
        TransactionSupport.executeInNewTransaction(() -> {
            moveOrCopyAllImageGroups();
            return null;
        });
        setSucceeded(true);
    }
}
#end_block

#method_before
private boolean updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<>();
    ArrayList<DiskImage> AllVmImages = new ArrayList<>();
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(vmNetworkInterfaceDao.getAllForVm(vm.getId()));
    }
    List<Guid> imageGroupIds = new ArrayList<>();
    for (Disk disk : getDisksBasedOnImage()) {
        DiskImage diskImage = (DiskImage) disk;
        diskImage.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomainId)));
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
        diskImage.setVolumeFormat(diskForVolumeInfo.getVolumeFormat());
        diskImage.setVolumeType(diskForVolumeInfo.getVolumeType());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
            diskImage.setActualSizeInBytes(fromVdsm.getActualSizeInBytes());
        }
        AllVmImages.add(diskImage);
        imageGroupIds.add(disk.getId());
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = vmTemplateDao.get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    String vmMeta = ovfManager.exportVm(vm, AllVmImages, clusterUtils.getCompatibilityVersion(vm));
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return runVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#method_after
private boolean updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<>();
    List<DiskImage> vmImages = new ArrayList<>();
    List<LunDisk> lunDisks = new ArrayList<>();
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(vmNetworkInterfaceDao.getAllForVm(vm.getId()));
    }
    List<Guid> imageGroupIds = new ArrayList<>();
    for (Disk disk : getDisksBasedOnImage()) {
        DiskImage diskImage = (DiskImage) disk;
        diskImage.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomainId)));
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
        diskImage.setVolumeFormat(diskForVolumeInfo.getVolumeFormat());
        diskImage.setVolumeType(diskForVolumeInfo.getVolumeType());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
            diskImage.setActualSizeInBytes(fromVdsm.getActualSizeInBytes());
        }
        vmImages.add(diskImage);
        imageGroupIds.add(disk.getId());
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = vmTemplateDao.get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    // TODO: Validate export
    lunDisks.addAll(DisksFilter.filterLunDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE));
    for (LunDisk lun : lunDisks) {
        lun.getLun().setLunConnections(new ArrayList<>(storageServerConnectionDao.getAllForLun(lun.getLun().getId())));
    }
    getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    String vmMeta = ovfManager.exportVm(vm, vmImages, lunDisks, clusterUtils.getCompatibilityVersion(vm));
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return runVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#end_block

#method_before
private void copyAllMemoryImages(Guid containerID) {
    for (Snapshot snapshot : snapshotsWithMemory) {
        List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
        // copy the memory dump image
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerID, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerID, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
private void copyAllMemoryImages(Guid containerID) {
    for (Snapshot snapshot : snapshotsWithMemory) {
        List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
        // copy the memory dump image
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerID, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
        getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerID, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
        getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
    }
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(containerID, disk));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(containerID, disk));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
        getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
    }
}
#end_block

#method_before
protected boolean updateVmInSpm() {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<>();
    ovfUpdateProcessHelper.loadVmData(getVm());
    ovfUpdateProcessHelper.buildMetadataDictionaryForVm(getVm(), metaDictionary, ovfUpdateProcessHelper.getVmImagesFromDb(getVm()));
    return ovfUpdateProcessHelper.executeUpdateVmInSpmCommand(getVm().getStoragePoolId(), metaDictionary, getParameters().getStorageDomainId());
}
#method_after
protected boolean updateVmInSpm() {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<>();
    ovfUpdateProcessHelper.loadVmData(getVm());
    ovfUpdateProcessHelper.buildMetadataDictionaryForVm(getVm(), metaDictionary, ovfUpdateProcessHelper.getVmImagesFromDb(getVm()), new ArrayList<>());
    return ovfUpdateProcessHelper.executeUpdateVmInSpmCommand(getVm().getStoragePoolId(), metaDictionary, getParameters().getStorageDomainId());
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(HostDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("parent_device_name", entity.getParentDeviceName()).addValue("capability", entity.getCapability()).addValue("iommu_group", entity.getIommuGroup()).addValue("mdev_types", StringUtils.join(entity.getMdevTypes(), ",")).addValue("product_name", entity.getProductName()).addValue("product_id", entity.getProductId()).addValue("vendor_name", entity.getVendorName()).addValue("vendor_id", entity.getVendorId()).addValue("physfn", entity.getParentPhysicalFunction()).addValue("total_vfs", entity.getTotalVirtualFunctions()).addValue("net_iface_name", entity.getNetworkInterfaceName()).addValue("driver", entity.getDriver()).addValue("is_assignable", entity.isAssignable()).addValue("address", SerializationFactory.getSerializer().serialize(entity.getAddress()));
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(HostDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("parent_device_name", entity.getParentDeviceName()).addValue("capability", entity.getCapability()).addValue("iommu_group", entity.getIommuGroup()).addValue("mdev_types", String.join(",", entity.getMdevTypes())).addValue("product_name", entity.getProductName()).addValue("product_id", entity.getProductId()).addValue("vendor_name", entity.getVendorName()).addValue("vendor_id", entity.getVendorId()).addValue("physfn", entity.getParentPhysicalFunction()).addValue("total_vfs", entity.getTotalVirtualFunctions()).addValue("net_iface_name", entity.getNetworkInterfaceName()).addValue("driver", entity.getDriver()).addValue("is_assignable", entity.isAssignable()).addValue("address", SerializationFactory.getSerializer().serialize(entity.getAddress()));
}
#end_block

#method_before
@Test
public void testGetVolumesSupportedAsStorageDomain() {
    List<GlusterVolumeEntity> vols = dao.getVolumesSupportedAsStorageDomain();
    assertEquals(3, vols.size());
}
#method_after
@Test
public void testGetVolumesSupportedAsStorageDomain() {
    List<GlusterVolumeEntity> vols = dao.getVolumesSupportedAsStorageDomain();
    assertEquals(2, vols.size());
}
#end_block

#method_before
private ValidationResult validateVolumeIdAndUpdatePath(StorageServerConnections connection) {
    if (connection.getGlusterVolumeId() != null) {
        GlusterVolumeEntity glusterVolume = glusterVolumeDao.getById(connection.getGlusterVolumeId());
        if (glusterVolume == null || glusterVolume.getBricks().isEmpty()) {
            return new ValidationResult(EngineMessage.VALIDATION_STORAGE_CONNECTION_INVALID_GLUSTER_VOLUME);
        }
        Set<String> addressSet = new LinkedHashSet<>();
        glusterVolume.getBricks().forEach(brick -> addressSet.add(brick.getNetworkId() != null && !brick.getNetworkAddress().isEmpty() ? brick.getNetworkAddress() : brick.getServerName()));
        String firstHost = (String) addressSet.toArray()[0];
        // we don't want the firstHost repeated in backup-volfile-servers
        addressSet.remove(firstHost);
        connection.setConnection(firstHost + StorageConstants.GLUSTER_VOL_SEPARATOR + glusterVolume.getName());
        String mountOptions = "";
        if (!addressSet.isEmpty()) {
            mountOptions += StorageConstants.GLUSTER_BACKUP_SERVERS_MNT_OPTION + KEY_VALUE_SEPARATOR + StringUtils.join(addressSet.toArray(), ':');
        }
        if (StringUtils.isBlank(connection.getMountOptions())) {
            connection.setMountOptions(mountOptions);
        } else if (!connection.getMountOptions().contains(StorageConstants.GLUSTER_BACKUP_SERVERS_MNT_OPTION)) {
            mountOptions = connection.getMountOptions().concat("," + mountOptions);
            connection.setMountOptions(mountOptions);
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateVolumeIdAndUpdatePath(StorageServerConnections connection) {
    if (connection.getGlusterVolumeId() != null) {
        GlusterVolumeEntity glusterVolume = glusterVolumeDao.getById(connection.getGlusterVolumeId());
        if (glusterVolume == null || glusterVolume.getBricks().isEmpty()) {
            return new ValidationResult(EngineMessage.VALIDATION_STORAGE_CONNECTION_INVALID_GLUSTER_VOLUME);
        }
        Set<String> addressSet = new LinkedHashSet<>();
        glusterVolume.getBricks().forEach(brick -> addressSet.add(brick.getNetworkId() != null && !brick.getNetworkAddress().isEmpty() ? brick.getNetworkAddress() : brick.getServerName()));
        String firstHost = (String) addressSet.toArray()[0];
        // we don't want the firstHost repeated in backup-volfile-servers
        addressSet.remove(firstHost);
        connection.setConnection(firstHost + StorageConstants.GLUSTER_VOL_SEPARATOR + glusterVolume.getName());
        String mountOptions = addressSet.stream().collect(Collectors.joining(":", StorageConstants.GLUSTER_BACKUP_SERVERS_MNT_OPTION + KEY_VALUE_SEPARATOR, ""));
        if (StringUtils.isBlank(connection.getMountOptions())) {
            connection.setMountOptions(mountOptions);
        } else if (!connection.getMountOptions().contains(StorageConstants.GLUSTER_BACKUP_SERVERS_MNT_OPTION)) {
            mountOptions = connection.getMountOptions().concat("," + mountOptions);
            connection.setMountOptions(mountOptions);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    // DEPRECATED
    mandatory(host().rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(host().ssh().authenticationMethod());
    mandatory(host().ssh().user().password());
    mandatory(host().ssh().user().userName());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(ssh().authenticationMethod());
    optional(ssh().fingerprint());
    optional(ssh().port());
    optional(ssh().user().password());
    optional(ssh().user().userName());
}
#end_block

#method_before
@Override
public Host update(Host incoming) {
    QueryIdResolver<Guid> hostResolver = new QueryIdResolver<>(QueryType.GetVdsByVdsId, IdQueryParameters.class);
    VDS entity = getEntity(hostResolver, true);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.equals(entity.getClusterId())) {
            performAction(ActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(clusterId, guid));
            // After changing the cluster with the specialized command we need to reload the entity, so that it
            // contains the new cluster id. If we don't do this the next command will think that we are trying
            // to change the cluster, and it will explicitly refuse to perform the update.
            entity = getEntity(hostResolver, true);
        }
    }
    Host host = performUpdate(incoming, entity, map(entity), hostResolver, ActionType.UpdateVds, new UpdateParametersProvider());
    return host;
}
#method_after
@Override
public Host update(Host incoming) {
    QueryIdResolver<Guid> hostResolver = new QueryIdResolver<>(QueryType.GetVdsByVdsId, IdQueryParameters.class);
    VDS entity = getEntity(hostResolver, true);
    // if fence agents list is null set it to null in entity
    if (incoming.getAgents() == null) {
        entity.setFenceAgents(null);
    }
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.equals(entity.getClusterId())) {
            performAction(ActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(clusterId, guid));
            // After changing the cluster with the specialized command we need to reload the entity, so that it
            // contains the new cluster id. If we don't do this the next command will think that we are trying
            // to change the cluster, and it will explicitly refuse to perform the update.
            entity = getEntity(hostResolver, true);
        }
    }
    Host host = performUpdate(incoming, entity, map(entity), hostResolver, ActionType.UpdateVds, new UpdateParametersProvider());
    return host;
}
#end_block

#method_before
@Override
public ExternalNetworkProviderConfigurationsResource getExternalNetworkProviderConfigurationsResource() {
    return inject(new BackendExternalNetworkProviderConfigurationsResource(guid));
}
#method_after
@Override
public ExternalNetworkProviderConfigurationsResource getExternalNetworkProviderConfigurationsResource() {
    return inject(new BackendHostExternalNetworkProviderConfigurationsResource(guid));
}
#end_block

#method_before
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setClusterId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.setHostName(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setPort(model.getPort());
    } else {
        entity.setPort(DEFAULT_VDSM_PORT);
    }
    if (model.isSetSsh()) {
        map(model.getSsh(), entity);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetSpm()) {
        if (model.getSpm().getPriority() != null) {
            entity.setVdsSpmPriority(model.getSpm().getPriority());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplay().getAddress()) ? null : model.getDisplay().getAddress());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetExternalHostProvider()) {
        String providerId = model.getExternalHostProvider().getId();
        entity.setHostProviderId(providerId == null ? null : GuidUtils.asGuid(providerId));
    }
    if (model.isSetOs()) {
        mapOperatingSystem(model.getOs(), entity);
    }
    if (model.isSetExternalNetworkProviderConfigurations() && model.getExternalNetworkProviderConfigurations().isSetExternalNetworkProviderConfigurations()) {
        List<ExternalNetworkProviderConfiguration> externalProviders = model.getExternalNetworkProviderConfigurations().getExternalNetworkProviderConfigurations();
        if (externalProviders.size() > 0) {
            String providerId = externalProviders.get(0).getExternalNetworkProvider().getId();
            entity.setOpenstackNetworkProviderId(providerId == null ? null : GuidUtils.asGuid(providerId));
        }
    }
    return entity;
}
#method_after
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setClusterId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.setHostName(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setPort(model.getPort());
    } else {
        entity.setPort(DEFAULT_VDSM_PORT);
    }
    if (model.isSetSsh()) {
        map(model.getSsh(), entity);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetSpm()) {
        if (model.getSpm().getPriority() != null) {
            entity.setVdsSpmPriority(model.getSpm().getPriority());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplay().getAddress()) ? null : model.getDisplay().getAddress());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetExternalHostProvider()) {
        String providerId = model.getExternalHostProvider().getId();
        entity.setHostProviderId(providerId == null ? null : GuidUtils.asGuid(providerId));
    }
    if (model.isSetOs()) {
        mapOperatingSystem(model.getOs(), entity);
    }
    if (model.isSetExternalNetworkProviderConfigurations() && model.getExternalNetworkProviderConfigurations().isSetExternalNetworkProviderConfigurations()) {
        List<ExternalNetworkProviderConfiguration> externalProviders = model.getExternalNetworkProviderConfigurations().getExternalNetworkProviderConfigurations();
        if (externalProviders.size() > 0) {
            // Ignore everything but the first external provider, because engine's VdsStatic currently supports
            // only a single external network provider
            String providerId = externalProviders.get(0).getExternalNetworkProvider().getId();
            entity.setOpenstackNetworkProviderId(providerId == null ? null : GuidUtils.asGuid(providerId));
        }
    }
    return entity;
}
#end_block

#method_before
private String readCmdline(String pid) throws IOException {
    String cmdlineFile = String.format("%s/%s/%s", PROC, pid, CMDLINE);
    return new String(Files.readAllBytes(Paths.get(cmdlineFile)));
}
#method_after
private String readCmdline(String pid) throws IOException {
    String cmdlineFile = String.format("%s/%s/%s", PROC, pid, CMDLINE);
    return readLine(cmdlineFile);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Boolean result = false;
    try {
        String pid = readPid();
        log.debug("ovirt-cockpit-sso  pid read: " + pid);
        String cmdline = readCmdline(pid);
        log.debug("ovirt-cockpit-sso cmdline: " + cmdline);
        result = cmdline.contains(OVIRT_COCKPIT_SSO);
        if (!result) {
            log.info("ovirt-cockpit-sso is not running. PID: " + pid + ", cmdline: " + cmdline);
        }
    } catch (IOException ioex) {
        log.info("The ovirt-cockpit-sso service is not running, pid file: " + PID_FILE + ". Exception: " + ioex.getMessage());
    }
    getQueryReturnValue().setReturnValue(result);
}
#method_after
@Override
protected void executeQueryCommand() {
    Boolean result = false;
    try {
        String pid = readLine(PID_FILE);
        if (pid != null) {
            String cmdline = readCmdline(pid.trim());
            result = cmdline.contains(OVIRT_COCKPIT_SSO);
            if (!result) {
                log.info("ovirt-cockpit-sso is not running. Found '{}' PID with command line: '{}'", pid, cmdline);
            }
        } else {
            log.info("The PID of ovirt-cockpit-sso service can not be read from: '{}'.", PID_FILE);
        }
    } catch (IOException ioex) {
        log.info("The ovirt-cockpit-sso service is not running, pid file: '{}'.", PID_FILE);
        log.debug("Exception: ", ioex.getMessage());
    }
    getQueryReturnValue().setReturnValue(result);
}
#end_block

#method_before
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    VDS host = getSelectedItem();
    EditHostModel hostModel = new EditHostModel();
    AsyncDataProvider.getInstance().getAllFenceAgentsByHostId(new AsyncQuery<>(retValue -> {
        ArrayList<FenceAgent> fenceAgents = new ArrayList<>();
        for (FenceAgent fenceAgent : retValue) {
            fenceAgents.add(fenceAgent);
        }
        host.setFenceAgents(fenceAgents);
        hostModel.getFenceAgentListModel().setItems(hostModel.getFenceAgentModelList(host));
    }), getSelectedItem().getId());
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(dataCenters -> {
        hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis);
        hostModel.setSelectedCluster(host);
        hostModel.onDataInitialized();
        hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
        hostModel.setHelpTag(HelpTag.edit_host);
        // $NON-NLS-1$
        hostModel.setHashName("edit_host");
        hostModel.setIsHeSystem(isHeSystem());
        hostModel.setHostsWithHeDeployed(getHostsWithHeDeployed());
        hostModel.setHostedEngineHostModel(new HostedEngineHostModel());
        setWindow(hostModel);
        if (host.getFenceProxySources() != null && !host.getFenceProxySources().isEmpty()) {
            hostModel.setPmProxyPreferences(FenceProxySourceTypeHelper.saveAsString(host.getFenceProxySources()));
        } else {
            AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery<>(returnValue -> hostModel.setPmProxyPreferences(returnValue)));
        }
        // $NON-NLS-1$
        UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", HostListModel.this);
        hostModel.getCommands().add(onSaveFalseCommand);
        // $NON-NLS-1$
        UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", HostListModel.this);
        hostModel.getCommands().add(cancelCommand);
    }));
}
#method_after
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    VDS host = getSelectedItem();
    EditHostModel hostModel = new EditHostModel();
    hostModel.setSelectedCluster(host);
    AsyncDataProvider.getInstance().getAllFenceAgentsByHostId(new AsyncQuery<>(retValue -> {
        ArrayList<FenceAgent> fenceAgents = new ArrayList<>();
        for (FenceAgent fenceAgent : retValue) {
            fenceAgents.add(fenceAgent);
        }
        host.setFenceAgents(fenceAgents);
        hostModel.getFenceAgentListModel().setItems(hostModel.getFenceAgentModelList(host));
    }), getSelectedItem().getId());
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(dataCenters -> {
        hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis);
        hostModel.onDataInitialized();
        hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
        hostModel.setHelpTag(HelpTag.edit_host);
        // $NON-NLS-1$
        hostModel.setHashName("edit_host");
        hostModel.setIsHeSystem(isHeSystem());
        hostModel.setHostsWithHeDeployed(getHostsWithHeDeployed());
        hostModel.setHostedEngineHostModel(new HostedEngineHostModel());
        setWindow(hostModel);
        if (host.getFenceProxySources() != null && !host.getFenceProxySources().isEmpty()) {
            hostModel.setPmProxyPreferences(FenceProxySourceTypeHelper.saveAsString(host.getFenceProxySources()));
        } else {
            AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery<>(returnValue -> hostModel.setPmProxyPreferences(returnValue)));
        }
        // $NON-NLS-1$
        UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", HostListModel.this);
        hostModel.getCommands().add(onSaveFalseCommand);
        // $NON-NLS-1$
        UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", HostListModel.this);
        hostModel.getCommands().add(cancelCommand);
    }));
}
#end_block

#method_before
public void onHostConsole() {
    AsyncDataProvider.getInstance().isOvirtCockpitSSOStarted(new // TODO: Query implementation
    AsyncQuery<>(isStarted -> {
        if (isStarted) {
            openCockpitWithSSO();
        } else {
            openCockpitWithoutSSO();
        }
    }));
}
#method_after
public void onHostConsole() {
    AsyncDataProvider.getInstance().isOvirtCockpitSSOStarted(new AsyncQuery<>(isStarted -> {
        if (isStarted) {
            openCockpitWithSSO();
        } else {
            openCockpitWithoutSSO();
        }
    }));
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    mandatory(host().address());
    mandatory(host().name());
    or(mandatory(host().cluster().id()), mandatory(host().cluster().name()));
    optional(host().comment());
    optional(host().display().address());
    optional(host().overrideIptables());
    optional(host().port());
    optional(host().powerManagement().automaticPmEnabled());
    optional(host().powerManagement().enabled());
    optional(host().powerManagement().kdumpDetection());
    optional(host().protocol());
    optional(host().spm().priority());
    optional(host().powerManagement().pmProxies()[COLLECTION].type());
    optional(host().externalNetworkProviders()[COLLECTION].externalNetworkProvider().id());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(host().address());
    mandatory(host().name());
    or(mandatory(host().cluster().id()), mandatory(host().cluster().name()));
    optional(host().comment());
    optional(host().display().address());
    optional(host().overrideIptables());
    optional(host().port());
    optional(host().powerManagement().automaticPmEnabled());
    optional(host().powerManagement().enabled());
    optional(host().powerManagement().kdumpDetection());
    optional(host().protocol());
    optional(host().spm().priority());
    optional(host().powerManagement().pmProxies()[COLLECTION].type());
    optional(host().externalNetworkProviderConfigurations()[COLLECTION].externalNetworkProvider().id());
}
#end_block

#method_before
public static Map<String, Object> createHotplugMemoryParamsMap(VmDevice vmDevice, boolean copyAlias, int minAllocatedMem) {
    Map<String, Object> data = new HashMap<>();
    data.put("vmId", vmDevice.getVmId().toString());
    data.put("memGuaranteedSize", minAllocatedMem);
    data.put("memory", createVmMemoryDeviceMap(vmDevice, copyAlias));
    return data;
}
#method_after
public static Map<String, Object> createHotplugMemoryParamsMap(VmDevice vmDevice, boolean copyAlias, int minAllocatedMem) {
    Map<String, Object> data = createHotplugMemoryParamsMap(vmDevice, copyAlias);
    data.put("memGuaranteedSize", minAllocatedMem);
    return data;
}
#end_block

#method_before
public static Map<String, Object> createHotplugMemoryParamsMap(VmDevice vmDevice, boolean copyAlias, int minAllocatedMem) {
    Map<String, Object> data = new HashMap<>();
    data.put("vmId", vmDevice.getVmId().toString());
    data.put("memGuaranteedSize", minAllocatedMem);
    data.put("memory", createVmMemoryDeviceMap(vmDevice, copyAlias));
    return data;
}
#method_after
public static Map<String, Object> createHotplugMemoryParamsMap(VmDevice vmDevice, boolean copyAlias) {
    Map<String, Object> data = new HashMap<>();
    data.put("vmId", vmDevice.getVmId().toString());
    data.put("memory", createVmMemoryDeviceMap(vmDevice, copyAlias));
    return data;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.SetAmountOfMemory, new SetAmountOfMemoryVDSCommand.Params(getVm().getRunOnVds(), getVm().getId(), createMemoryDevice(), getVm().getMinAllocatedMem()));
    if (vdsReturnValue.getSucceeded()) {
        setSucceeded(true);
    } else {
        EngineFault fault = new EngineFault();
        fault.setError(vdsReturnValue.getVdsError().getCode());
        fault.setMessage(vdsReturnValue.getVdsError().getMessage());
        getReturnValue().setFault(fault);
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.SetAmountOfMemory, new SetAmountOfMemoryVDSCommand.Params(getVm().getRunOnVds(), getVm().getId(), createMemoryDevice(), getParameters().getVmStaticData().getMinAllocatedMem()));
    if (vdsReturnValue.getSucceeded()) {
        setSucceeded(true);
    } else {
        EngineFault fault = new EngineFault();
        fault.setError(vdsReturnValue.getVdsError().getCode());
        fault.setMessage(vdsReturnValue.getVdsError().getMessage());
        getReturnValue().setFault(fault);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid newMacPoolId = getNewMacPoolId();
    moveMacs.migrateMacsToAnotherMacPool(oldCluster, newMacPoolId, getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    setDefaultFirewallTypeIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    clusterDao.update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
        // update gluster parameters on all hosts
        updateGlusterHosts();
    }
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        final NetworkCluster managementNetworkCluster = createManagementNetworkCluster();
        networkClusterDao.save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    updateVms();
    updateTemplates();
    if (getCluster().getFirewallType() != getPrevCluster().getFirewallType()) {
        updateHosts();
    }
    if (!failedUpgradeEntities.isEmpty()) {
        logFailedUpgrades();
        failValidation(Arrays.asList(EngineMessage.CLUSTER_CANNOT_UPDATE_CLUSTER_FAILED_TO_UPDATE_VMS), "$VmList " + StringUtils.join(failedUpgradeEntities.keySet(), ", "));
        getReturnValue().setValid(false);
        setSucceeded(false);
        return;
    }
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid newMacPoolId = getNewMacPoolId();
    moveMacs.migrateMacsToAnotherMacPool(oldCluster, newMacPoolId, getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    setDefaultFirewallTypeIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    clusterDao.update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
        // update gluster parameters on all hosts
        updateGlusterHosts();
    }
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        final NetworkCluster managementNetworkCluster = createManagementNetworkCluster();
        networkClusterDao.save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    updateVms();
    updateTemplates();
    if (getCluster().getFirewallType() != getPrevCluster().getFirewallType()) {
        markHostsForReinstall();
    }
    if (!failedUpgradeEntities.isEmpty()) {
        logFailedUpgrades();
        failValidation(Arrays.asList(EngineMessage.CLUSTER_CANNOT_UPDATE_CLUSTER_FAILED_TO_UPDATE_VMS), "$VmList " + StringUtils.join(failedUpgradeEntities.keySet(), ", "));
        getReturnValue().setValid(false);
        setSucceeded(false);
        return;
    }
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    oldHost = vdsDao.get(getVdsId());
    UpdateHostValidator validator = getUpdateHostValidator(oldHost, getParameters().getvds(), getParameters().isInstallHost());
    return validate(validator.hostExists()) && validate(validator.hostStatusValid()) && validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.updateHostAddressAllowed()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.statusSupportedForHostInstallation()) && validate(validator.passwordProvidedForHostInstallation(getParameters().getAuthMethod(), getParameters().getPassword())) && validate(validator.updatePortAllowed()) && validate(validator.clusterNotChanged()) && validate(validator.hostProviderExists()) && validate(validator.hostProviderTypeMatches()) && validateNetworkProviderConfiguration() && isPowerManagementLegal(getParameters().getVdsStaticData().isPmEnabled(), getParameters().getFenceAgents(), oldHost.getClusterCompatibilityVersion().toString()) && validate(validator.supportsDeployingHostedEngine(getParameters().getHostedEngineDeployConfiguration()));
}
#method_after
@Override
protected boolean validate() {
    oldHost = vdsDao.get(getVdsId());
    // if fence agents list is null, try to fill it from database
    // so we can enable changing other host attributes from API
    // without failing validation or removing the persisted fence agents
    boolean validateAgents = true;
    if (getParameters().getFenceAgents() == null) {
        getParameters().setFenceAgents(fenceAgentDao.getFenceAgentsForHost(getVdsId()));
        validateAgents = false;
    }
    UpdateHostValidator validator = getUpdateHostValidator(oldHost, getParameters().getvds(), getParameters().isInstallHost());
    return validate(validator.hostExists()) && validate(validator.hostStatusValid()) && validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.updateHostAddressAllowed()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.statusSupportedForHostInstallation()) && validate(validator.passwordProvidedForHostInstallation(getParameters().getAuthMethod(), getParameters().getPassword())) && validate(validator.updatePortAllowed()) && validate(validator.clusterNotChanged()) && validate(validator.hostProviderExists()) && validate(validator.hostProviderTypeMatches()) && validateNetworkProviderConfiguration() && isPowerManagementLegal(getParameters().getVdsStaticData().isPmEnabled(), getParameters().getFenceAgents(), oldHost.getClusterCompatibilityVersion().toString(), validateAgents) && validate(validator.supportsDeployingHostedEngine(getParameters().getHostedEngineDeployConfiguration()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().getVdsStaticData().setVdsNeedsReinstall(needToReinstallVds());
    updateVdsData();
    if (needToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().isInstallHost()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().isReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        if (vdsDynamicDao.get(getVdsId()).getStatus() == VDSStatus.InstallingOS) {
            // TODO: remove hack when reinstall api will provider override-firewall parameter.
            // https://bugzilla.redhat.com/show_bug.cgi?id=1177126 - for now we override firewall
            // configurations on each deploy for provisioned host to avoid wrong deployment.
            tempVar.setOverrideFirewall(true);
        } else {
            tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        }
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setActivateHost(getParameters().getActivateHost());
        tempVar.setNetworkProviderId(getParameters().getVdsStaticData().getOpenstackNetworkProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        if (getParameters().getHostedEngineDeployConfiguration() != null) {
            tempVar.setHostedEngineConfiguration(hostedEngineHelper.createVdsDeployParams(getVdsId(), getParameters().getHostedEngineDeployConfiguration().getDeployAction()));
        }
        List<ActionReturnValue> resultList = runInternalMultipleActions(actionType, new ArrayList<>(Arrays.asList(tempVar)), ExecutionHandler.createInternalJobContext().getExecutionContext());
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            ActionReturnValue actionReturnValue = resultList.get(0);
            if (actionReturnValue != null && !actionReturnValue.isValid()) {
                List<String> validationMessages = actionReturnValue.getValidationMessages();
                if (!validationMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getValidationMessages().addAll(validationMessages);
                    log.error("Installation/upgrade of Host '{}', '{}' failed: {}", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().translateErrorText(validationMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setValid(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(oldHost.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    // set clusters network to be operational (if needed)
    if (oldHost.getStatus() == VDSStatus.Up) {
        List<Network> networks = networkDao.getAllForCluster(oldHost.getClusterId());
        networkClusterHelper.setStatus(oldHost.getClusterId(), networks);
    }
    alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    testVdsPowerManagementStatus(getParameters().getVdsStaticData());
    checkKdumpIntegrationStatus();
    updateAffinityLabels();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getParameters().getVdsStaticData().setReinstallRequired(shouldVdsBeReinstalled());
    updateVdsData();
    if (needToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().isInstallHost()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().isReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        if (vdsDynamicDao.get(getVdsId()).getStatus() == VDSStatus.InstallingOS) {
            // TODO: remove hack when reinstall api will provider override-firewall parameter.
            // https://bugzilla.redhat.com/show_bug.cgi?id=1177126 - for now we override firewall
            // configurations on each deploy for provisioned host to avoid wrong deployment.
            tempVar.setOverrideFirewall(true);
        } else {
            tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        }
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setActivateHost(getParameters().getActivateHost());
        tempVar.setNetworkProviderId(getParameters().getVdsStaticData().getOpenstackNetworkProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        if (getParameters().getHostedEngineDeployConfiguration() != null) {
            tempVar.setHostedEngineConfiguration(hostedEngineHelper.createVdsDeployParams(getVdsId(), getParameters().getHostedEngineDeployConfiguration().getDeployAction()));
        }
        List<ActionReturnValue> resultList = runInternalMultipleActions(actionType, new ArrayList<>(Arrays.asList(tempVar)), ExecutionHandler.createInternalJobContext().getExecutionContext());
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            ActionReturnValue actionReturnValue = resultList.get(0);
            if (actionReturnValue != null && !actionReturnValue.isValid()) {
                List<String> validationMessages = actionReturnValue.getValidationMessages();
                if (!validationMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getValidationMessages().addAll(validationMessages);
                    log.error("Installation/upgrade of Host '{}', '{}' failed: {}", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().translateErrorText(validationMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setValid(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(oldHost.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    // set clusters network to be operational (if needed)
    if (oldHost.getStatus() == VDSStatus.Up) {
        List<Network> networks = networkDao.getAllForCluster(oldHost.getClusterId());
        networkClusterHelper.setStatus(oldHost.getClusterId(), networks);
    }
    alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    testVdsPowerManagementStatus(getParameters().getVdsStaticData());
    checkKdumpIntegrationStatus();
    updateAffinityLabels();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean isPowerManagementLegal(boolean pmEnabled, List<FenceAgent> fenceAgents, String clusterCompatibilityVersion) {
    return super.isPowerManagementLegal(pmEnabled, fenceAgents, clusterCompatibilityVersion);
}
#method_after
@Override
protected boolean isPowerManagementLegal(boolean pmEnabled, List<FenceAgent> fenceAgents, String clusterCompatibilityVersion, boolean validateAgents) {
    return super.isPowerManagementLegal(pmEnabled, fenceAgents, clusterCompatibilityVersion, validateAgents);
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParams(final VdsStatic vds) {
    return getCustomMapSqlParameterSource().addValue("host_name", vds.getHostName()).addValue("free_text_comment", vds.getComment()).addValue("vds_unique_id", vds.getUniqueID()).addValue("port", vds.getPort()).addValue("cluster_id", vds.getClusterId()).addValue("vds_id", vds.getId()).addValue("vds_name", vds.getName()).addValue("server_SSL_enabled", vds.isServerSslEnabled()).addValue("vds_type", vds.getVdsType()).addValue("vds_strength", vds.getVdsStrength()).addValue("pm_enabled", vds.isPmEnabled()).addValue("pm_proxy_preferences", FenceProxySourceTypeHelper.saveAsString(vds.getFenceProxySources())).addValue("pm_detect_kdump", vds.isPmKdumpDetection()).addValue("otp_validity", vds.getOtpValidity()).addValue("vds_spm_priority", vds.getVdsSpmPriority()).addValue("console_address", vds.getConsoleAddress()).addValue("sshKeyFingerprint", vds.getSshKeyFingerprint()).addValue("ssh_port", vds.getSshPort()).addValue("ssh_username", vds.getSshUsername()).addValue("disable_auto_pm", vds.isDisablePowerManagementPolicy()).addValue("host_provider_id", vds.getHostProviderId()).addValue("openstack_network_provider_id", vds.getOpenstackNetworkProviderId()).addValue("kernel_cmdline", KernelCmdlineColumn.fromVdsStatic(vds).toJson()).addValue("last_stored_kernel_cmdline", vds.getLastStoredKernelCmdline()).addValue("vds_needs_reinstall", vds.isVdsNeedsReinstall());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParams(final VdsStatic vds) {
    return getCustomMapSqlParameterSource().addValue("host_name", vds.getHostName()).addValue("free_text_comment", vds.getComment()).addValue("vds_unique_id", vds.getUniqueID()).addValue("port", vds.getPort()).addValue("cluster_id", vds.getClusterId()).addValue("vds_id", vds.getId()).addValue("vds_name", vds.getName()).addValue("server_SSL_enabled", vds.isServerSslEnabled()).addValue("vds_type", vds.getVdsType()).addValue("vds_strength", vds.getVdsStrength()).addValue("pm_enabled", vds.isPmEnabled()).addValue("pm_proxy_preferences", FenceProxySourceTypeHelper.saveAsString(vds.getFenceProxySources())).addValue("pm_detect_kdump", vds.isPmKdumpDetection()).addValue("otp_validity", vds.getOtpValidity()).addValue("vds_spm_priority", vds.getVdsSpmPriority()).addValue("console_address", vds.getConsoleAddress()).addValue("sshKeyFingerprint", vds.getSshKeyFingerprint()).addValue("ssh_port", vds.getSshPort()).addValue("ssh_username", vds.getSshUsername()).addValue("disable_auto_pm", vds.isDisablePowerManagementPolicy()).addValue("host_provider_id", vds.getHostProviderId()).addValue("openstack_network_provider_id", vds.getOpenstackNetworkProviderId()).addValue("kernel_cmdline", KernelCmdlineColumn.fromVdsStatic(vds).toJson()).addValue("last_stored_kernel_cmdline", vds.getLastStoredKernelCmdline()).addValue("reinstall_required", vds.isReinstallRequired());
}
#end_block

#method_before
@Override
public void render(Context context, VDS vds, SafeHtmlBuilder sb, String id) {
    // Nothing to render if no host is provided:
    if (vds == null) {
        return;
    }
    // Find the image corresponding to the status of the host:
    VDSStatus status = vds.getStatus();
    ImageResource statusImage = null;
    switch(status) {
        case Unassigned:
        case NonResponsive:
        case InstallFailed:
        case Connecting:
        case Down:
            statusImage = resources.downImage();
            break;
        case PreparingForMaintenance:
            statusImage = resources.prepareImage();
            break;
        case Maintenance:
            statusImage = resources.maintenanceImage();
            break;
        case Up:
            statusImage = resources.upImage();
            break;
        case Error:
            statusImage = resources.errorImage();
            break;
        case Installing:
            statusImage = resources.hostInstallingImage();
            break;
        case Reboot:
            statusImage = resources.waitImage();
            break;
        case NonOperational:
            statusImage = resources.nonOperationalImage();
            break;
        case PendingApproval:
        case InstallingOS:
            statusImage = resources.unconfiguredImage();
            break;
        case Initializing:
            statusImage = resources.waitImage();
            break;
        case Kdumping:
            statusImage = resources.waitImage();
            break;
        default:
            statusImage = resources.downImage();
    }
    // Find the image corresponding to the alert:
    ImageResource alertImage = resources.alertImage();
    // Generate the HTML for the images:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    SafeHtml alertImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(alertImage).getHTML());
    // Generate the HTML for the cell including the exclamation mark only if
    // power management is not enabled or there are network configuration
    // changes that haven't been saved yet:
    // $NON-NLS-1$ //$NON-NLS-2$
    sb.appendHtmlConstant("<div id=\"" + id + "\" style=\"text-align: center;\">");
    sb.append(statusImageHtml);
    boolean getnet_config_dirty = vds.getNetConfigDirty() == null ? false : vds.getNetConfigDirty().booleanValue();
    boolean showPMAlert = vds.getClusterSupportsVirtService() && !vds.isPmEnabled() && vds.isFencingEnabled();
    boolean showGlusterAlert = vds.getClusterSupportsGlusterService() && vds.getGlusterPeerStatus() != PeerStatus.CONNECTED;
    if (showPMAlert || getnet_config_dirty || showGlusterAlert || vds.getStaticData().isVdsNeedsReinstall()) {
        sb.append(alertImageHtml);
    }
    // $NON-NLS-1$
    sb.appendHtmlConstant("</div>");
}
#method_after
@Override
public void render(Context context, VDS vds, SafeHtmlBuilder sb, String id) {
    // Nothing to render if no host is provided:
    if (vds == null) {
        return;
    }
    // Find the image corresponding to the status of the host:
    VDSStatus status = vds.getStatus();
    ImageResource statusImage = null;
    switch(status) {
        case Unassigned:
        case NonResponsive:
        case InstallFailed:
        case Connecting:
        case Down:
            statusImage = resources.downImage();
            break;
        case PreparingForMaintenance:
            statusImage = resources.prepareImage();
            break;
        case Maintenance:
            statusImage = resources.maintenanceImage();
            break;
        case Up:
            statusImage = resources.upImage();
            break;
        case Error:
            statusImage = resources.errorImage();
            break;
        case Installing:
            statusImage = resources.hostInstallingImage();
            break;
        case Reboot:
            statusImage = resources.waitImage();
            break;
        case NonOperational:
            statusImage = resources.nonOperationalImage();
            break;
        case PendingApproval:
        case InstallingOS:
            statusImage = resources.unconfiguredImage();
            break;
        case Initializing:
            statusImage = resources.waitImage();
            break;
        case Kdumping:
            statusImage = resources.waitImage();
            break;
        default:
            statusImage = resources.downImage();
    }
    // Find the image corresponding to the alert:
    ImageResource alertImage = resources.alertImage();
    // Generate the HTML for the images:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    SafeHtml alertImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(alertImage).getHTML());
    // Generate the HTML for the cell including the exclamation mark only if
    // power management is not enabled or there are network configuration
    // changes that haven't been saved yet:
    // $NON-NLS-1$ //$NON-NLS-2$
    sb.appendHtmlConstant("<div id=\"" + id + "\" style=\"text-align: center;\">");
    sb.append(statusImageHtml);
    boolean getnet_config_dirty = vds.getNetConfigDirty() == null ? false : vds.getNetConfigDirty().booleanValue();
    boolean showPMAlert = vds.getClusterSupportsVirtService() && !vds.isPmEnabled() && vds.isFencingEnabled();
    boolean showGlusterAlert = vds.getClusterSupportsGlusterService() && vds.getGlusterPeerStatus() != PeerStatus.CONNECTED;
    if (showPMAlert || getnet_config_dirty || showGlusterAlert || vds.getStaticData().isReinstallRequired()) {
        sb.append(alertImageHtml);
    }
    // $NON-NLS-1$
    sb.appendHtmlConstant("</div>");
}
#end_block

#method_before
protected boolean isPowerManagementLegal(boolean pmEnabled, List<FenceAgent> fenceAgents, String clusterCompatibilityVersion) {
    if (pmEnabled && fenceAgents != null) {
        if (fenceAgents.isEmpty()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_PM_ENABLED_WITHOUT_AGENT);
            return false;
        }
        FenceValidator fenceValidator = new FenceValidator();
        for (FenceAgent agent : fenceAgents) {
            if (!fenceValidator.isFenceAgentVersionCompatible(agent, clusterCompatibilityVersion, getReturnValue().getValidationMessages()) || !isFenceAgentValid(agent)) {
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean isPowerManagementLegal(boolean pmEnabled, List<FenceAgent> fenceAgents, String clusterCompatibilityVersion, boolean validateAgents) {
    if (pmEnabled && fenceAgents != null) {
        if (fenceAgents.isEmpty()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_PM_ENABLED_WITHOUT_AGENT);
            return false;
        }
        if (validateAgents) {
            FenceValidator fenceValidator = new FenceValidator();
            for (FenceAgent agent : fenceAgents) {
                if (!fenceValidator.isFenceAgentVersionCompatible(agent, clusterCompatibilityVersion, getReturnValue().getValidationMessages()) || !isFenceAgentValid(agent)) {
                    return false;
                }
            }
        } else {
            return true;
        }
    }
    return true;
}
#end_block

#method_before
protected void markVdsReinstalled() {
    vdsStaticDao.updateVdsNeedsReinstall(getVds().getStaticData().getId(), false);
}
#method_after
protected void markVdsReinstalled() {
    vdsStaticDao.updateReinstallRequired(getVds().getStaticData().getId(), false);
}
#end_block

#method_before
private void runAnsibleHostDeployPlaybook(FirewallType firewallType) throws IOException, InterruptedException {
    AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(getVds().getHostName()).variables(new Pair<>("host_deploy_cluster_version", getVds().getClusterCompatibilityVersion()), new Pair<>("host_deploy_gluster_enabled", getVds().getClusterSupportsGlusterService()), new Pair<>("host_deploy_virt_enabled", getVds().getClusterSupportsVirtService()), new Pair<>("host_deploy_vdsm_port", getVds().getPort()), new Pair<>("host_deploy_override_firewall", getParameters().getOverrideFirewall()), new Pair<>("host_deploy_firewall_type", firewallType.name()), new Pair<>("ansible_port", getVds().getSshPort()), new Pair<>("host_deploy_post_tasks", AnsibleConstants.HOST_DEPLOY_POST_TASKS_FILE_PATH), new Pair<>("host_deploy_ovn_tunneling_network", managementNetworkUtil.getManagementNetwork(getVds().getClusterId()).getVdsmName()), new Pair<>("host_deploy_ovn_central", getOvnCentral())).logFileDirectory(VdsDeployBase.HOST_DEPLOY_LOG_DIRECTORY).logFilePrefix("ovirt-host-deploy-ansible").logFileName(getVds().getHostName()).logFileSuffix(getCorrelationId()).playbook(AnsibleConstants.HOST_DEPLOY_PLAYBOOK);
    AuditLogable logable = new AuditLogableImpl();
    logable.setVdsName(getVds().getName());
    logable.setVdsId(getVds().getId());
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_STARTED);
    if (ansibleExecutor.runCommand(command) != AnsibleReturnCode.OK) {
        throw new VdsInstallException(VDSStatus.InstallFailed, String.format("Failed to execute Ansible host-deploy role. Please check logs for more details: %1$s", command.logFile()));
    }
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_FINISHED);
}
#method_after
private void runAnsibleHostDeployPlaybook(FirewallType firewallType) throws IOException, InterruptedException {
    AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(getVds().getHostName()).variables(new Pair<>("host_deploy_cluster_version", getVds().getClusterCompatibilityVersion()), new Pair<>("host_deploy_gluster_enabled", getVds().getClusterSupportsGlusterService()), new Pair<>("host_deploy_virt_enabled", getVds().getClusterSupportsVirtService()), new Pair<>("host_deploy_vdsm_port", getVds().getPort()), new Pair<>("host_deploy_override_firewall", getParameters().getOverrideFirewall()), new Pair<>("host_deploy_firewall_type", firewallType.name()), new Pair<>("ansible_port", getVds().getSshPort()), new Pair<>("host_deploy_post_tasks", AnsibleConstants.HOST_DEPLOY_POST_TASKS_FILE_PATH), new Pair<>("host_deploy_ovn_tunneling_network", NetworkUtils.getHostIp(getVds())), new Pair<>("host_deploy_ovn_central", getOvnCentral())).logFileDirectory(VdsDeployBase.HOST_DEPLOY_LOG_DIRECTORY).logFilePrefix("ovirt-host-deploy-ansible").logFileName(getVds().getHostName()).logFileSuffix(getCorrelationId()).playbook(AnsibleConstants.HOST_DEPLOY_PLAYBOOK);
    AuditLogable logable = new AuditLogableImpl();
    logable.setVdsName(getVds().getName());
    logable.setVdsId(getVds().getId());
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_STARTED);
    if (ansibleExecutor.runCommand(command) != AnsibleReturnCode.OK) {
        throw new VdsInstallException(VDSStatus.InstallFailed, String.format("Failed to execute Ansible host-deploy role. Please check logs for more details: %1$s", command.logFile()));
    }
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_FINISHED);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, hostName, consoleAddress, name, otpValidity, pmEnabled, pmKdumpDetection, port, sshPort, sshUsername, serverSslEnabled, uniqueId, clusterId, vdsStrength, vdsType, disablePowerManagementPolicy, hostProviderId, openstackNetworkProviderId, currentKernelCmdline, kernelCmdlineParsable, lastStoredKernelCmdline, kernelCmdlineIommu, kernelCmdlineKvmNested, kernelCmdlinePciRealloc, kernelCmdlineUnsafeInterrupts);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, hostName, consoleAddress, name, otpValidity, pmEnabled, pmKdumpDetection, port, sshPort, sshUsername, serverSslEnabled, uniqueId, clusterId, vdsStrength, vdsType, disablePowerManagementPolicy, hostProviderId, openstackNetworkProviderId, currentKernelCmdline, kernelCmdlineParsable, lastStoredKernelCmdline, kernelCmdlineIommu, kernelCmdlineKvmNested, kernelCmdlinePciRealloc, kernelCmdlineUnsafeInterrupts, reinstallRequired);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VdsStatic)) {
        return false;
    }
    VdsStatic other = (VdsStatic) obj;
    return Objects.equals(id, other.id) && Objects.equals(hostName, other.hostName) && Objects.equals(consoleAddress, other.consoleAddress) && Objects.equals(name, other.name) && otpValidity == other.otpValidity && pmEnabled == other.pmEnabled && pmKdumpDetection == other.isPmKdumpDetection() && port == other.port && sshPort == other.sshPort && Objects.equals(sshUsername, other.sshUsername) && Objects.equals(serverSslEnabled, other.serverSslEnabled) && Objects.equals(uniqueId, other.uniqueId) && Objects.equals(clusterId, other.clusterId) && Objects.equals(vdsStrength, other.vdsStrength) && vdsType == other.vdsType && Objects.equals(sshKeyFingerprint, other.sshKeyFingerprint) && disablePowerManagementPolicy == other.disablePowerManagementPolicy && Objects.equals(hostProviderId, other.hostProviderId) && Objects.equals(openstackNetworkProviderId, other.openstackNetworkProviderId) && Objects.equals(currentKernelCmdline, other.currentKernelCmdline) && Objects.equals(kernelCmdlineParsable, other.kernelCmdlineParsable) && Objects.equals(lastStoredKernelCmdline, other.lastStoredKernelCmdline) && Objects.equals(kernelCmdlineIommu, other.kernelCmdlineIommu) && Objects.equals(kernelCmdlineKvmNested, other.kernelCmdlineKvmNested) && Objects.equals(kernelCmdlinePciRealloc, other.kernelCmdlinePciRealloc) && Objects.equals(kernelCmdlineUnsafeInterrupts, other.kernelCmdlineUnsafeInterrupts);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VdsStatic)) {
        return false;
    }
    VdsStatic other = (VdsStatic) obj;
    return Objects.equals(id, other.id) && Objects.equals(hostName, other.hostName) && Objects.equals(consoleAddress, other.consoleAddress) && Objects.equals(name, other.name) && otpValidity == other.otpValidity && pmEnabled == other.pmEnabled && pmKdumpDetection == other.isPmKdumpDetection() && port == other.port && sshPort == other.sshPort && Objects.equals(sshUsername, other.sshUsername) && Objects.equals(serverSslEnabled, other.serverSslEnabled) && Objects.equals(uniqueId, other.uniqueId) && Objects.equals(clusterId, other.clusterId) && Objects.equals(vdsStrength, other.vdsStrength) && vdsType == other.vdsType && Objects.equals(sshKeyFingerprint, other.sshKeyFingerprint) && disablePowerManagementPolicy == other.disablePowerManagementPolicy && Objects.equals(hostProviderId, other.hostProviderId) && Objects.equals(openstackNetworkProviderId, other.openstackNetworkProviderId) && Objects.equals(currentKernelCmdline, other.currentKernelCmdline) && Objects.equals(kernelCmdlineParsable, other.kernelCmdlineParsable) && Objects.equals(lastStoredKernelCmdline, other.lastStoredKernelCmdline) && Objects.equals(kernelCmdlineIommu, other.kernelCmdlineIommu) && Objects.equals(kernelCmdlineKvmNested, other.kernelCmdlineKvmNested) && Objects.equals(kernelCmdlinePciRealloc, other.kernelCmdlinePciRealloc) && Objects.equals(kernelCmdlineUnsafeInterrupts, other.kernelCmdlineUnsafeInterrupts) && reinstallRequired == other.reinstallRequired;
}
#end_block

#method_before
@Override
protected void readHeader(XmlNode header) {
    super.readHeader(header);
    version = header != null ? header.attributes.get("ovf:version").getValue() : "";
}
#method_after
@Override
protected void readHeader(XmlNode header) {
    super.readHeader(header);
    setVersion(header != null ? header.attributes.get("ovf:version").getValue() : "");
}
#end_block

#method_before
public AnsibleReturnCode runCommand(AnsibleCommandBuilder command, int timeout) throws IOException, InterruptedException {
    log.trace("Enter AnsibleExecutor::runCommand");
    if (Files.notExists(Paths.get(command.playbook()))) {
        log.warn("Playbook '{}' does not exists. Ensure ovirt-ansible-roles is installed.", command.playbook());
        return AnsibleReturnCode.ERROR;
    }
    Path inventoryFile = null;
    AnsibleReturnCode returnCode = AnsibleReturnCode.UNEXPECTED_ERROR;
    try {
        // Create a temporary inventory file if user didn't specified it:
        inventoryFile = createInventoryFile(command);
        // Build the command:
        log.info("Executing Ansible command: {}", command);
        List<String> ansibleCommand = command.build();
        File logFile = command.logFile();
        ProcessBuilder ansibleProcessBuilder = new ProcessBuilder().redirectErrorStream(true).redirectOutput(logFile).command(ansibleCommand).directory(command.playbookDir().toFile());
        // Set environment variables:
        ansibleProcessBuilder.environment().put("ANSIBLE_CONFIG", Paths.get(command.playbookDir().toString(), "ansible.cfg").toString());
        // Execute the command:
        Process ansibleProcess = ansibleProcessBuilder.start();
        ansibleProcess.waitFor(timeout, TimeUnit.MINUTES);
        returnCode = AnsibleReturnCode.values()[ansibleProcess.exitValue()];
        ansibleProcess.destroy();
    } finally {
        log.info("Ansible playbook command has exited with value: {}", returnCode);
        removeFile(inventoryFile);
    }
    log.trace("Exit AnsibleExecutor::runCommand");
    return returnCode;
}
#method_after
public AnsibleReturnCode runCommand(AnsibleCommandBuilder command, int timeout) throws IOException, InterruptedException {
    log.trace("Enter AnsibleExecutor::runCommand");
    if (Files.notExists(Paths.get(command.playbook()))) {
        log.warn("Playbook '{}' does not exist, please ensure that ovirt-ansible-roles package is properly installed.", command.playbook());
        return AnsibleReturnCode.ERROR;
    }
    Path inventoryFile = null;
    AnsibleReturnCode returnCode = AnsibleReturnCode.UNEXPECTED_ERROR;
    try {
        // Create a temporary inventory file if user didn't specified it:
        inventoryFile = createInventoryFile(command);
        // Build the command:
        log.info("Executing Ansible command: {}", command);
        List<String> ansibleCommand = command.build();
        File logFile = command.logFile();
        ProcessBuilder ansibleProcessBuilder = new ProcessBuilder().redirectErrorStream(true).redirectOutput(logFile).command(ansibleCommand).directory(command.playbookDir().toFile());
        // Set environment variables:
        ansibleProcessBuilder.environment().put("ANSIBLE_CONFIG", Paths.get(command.playbookDir().toString(), "ansible.cfg").toString());
        // Execute the command:
        Process ansibleProcess = ansibleProcessBuilder.start();
        ansibleProcess.waitFor(timeout, TimeUnit.MINUTES);
        returnCode = AnsibleReturnCode.values()[ansibleProcess.exitValue()];
        ansibleProcess.destroy();
    } finally {
        log.info("Ansible playbook command has exited with value: {}", returnCode);
        removeFile(inventoryFile);
    }
    log.trace("Exit AnsibleExecutor::runCommand");
    return returnCode;
}
#end_block

#method_before
@Override
public SystemOption get() {
    try {
        ConfigValues config = ConfigValues.valueOf(id);
        GetSystemOptionParameters parameters = new GetSystemOptionParameters(config);
        String version = ParametersHelper.getParameter(httpHeaders, uriInfo, "version");
        if (version != null && !version.isEmpty()) {
            parameters.setOptionVersion(version);
        }
        QueryReturnValue result = runQuery(QueryType.GetSystemOption, parameters);
        if (result.getReturnValue() == null) {
            return handleError(new EntityNotFoundException(id), true);
        }
        return LinkHelper.addLinks(SystemOptionsMapper.map(result.getReturnValue(), id));
    } catch (IllegalArgumentException ex) {
        return handleError(new EntityNotFoundException(id), true);
    }
}
#method_after
@Override
public SystemOption get() {
    ConfigValues config;
    try {
        config = ConfigValues.valueOf(id);
    } catch (IllegalArgumentException ex) {
        throw new WebApplicationException(Response.Status.NOT_FOUND);
    }
    GetSystemOptionParameters parameters = new GetSystemOptionParameters(config);
    String version = ParametersHelper.getParameter(httpHeaders, uriInfo, VERSION);
    if (version != null && !version.isEmpty()) {
        parameters.setOptionVersion(version);
    }
    QueryReturnValue result = runQuery(QueryType.GetSystemOption, parameters);
    if (result.getReturnValue() == null) {
        throw new WebApplicationException(Response.Status.NOT_FOUND);
    }
    return LinkHelper.addLinks(SystemOptionsMapper.map(result.getReturnValue(), id));
}
#end_block

#method_before
@Override
public SystemOptionResource getOptionResource(String id) {
    return inject(new BackendSystemOptionResource(id));
}
#method_after
/*
     * This class is purposely left almost empty. We don't want to provide a mechanism to list options.
     */
@Override
public SystemOptionResource getOptionResource(String id) {
    return inject(new BackendSystemOptionResource(id));
}
#end_block

#method_before
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // Load the thread pools
    serviceLoader.load(EngineThreadPools.class);
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    serviceLoader.load(AsyncTaskManager.class);
    serviceLoader.load(CommandCoordinatorUtil.class);
    serviceLoader.load(CommandCallbacksPoller.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    serviceLoader.load(VmMigrationProgressMonitoring.class);
    // Load the thread monitoring service
    serviceLoader.load(ThreadPoolMonitoringService.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // Load the thread pools
    serviceLoader.load(EngineThreadPools.class);
    // Load the thread monitoring service
    serviceLoader.load(ThreadPoolMonitoringService.class);
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    serviceLoader.load(AsyncTaskManager.class);
    serviceLoader.load(CommandCoordinatorUtil.class);
    serviceLoader.load(CommandCallbacksPoller.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    serviceLoader.load(VmMigrationProgressMonitoring.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
@Override
public ActionReturnValue runAction(ActionType actionType, ActionParametersBase parameters) {
    ActionReturnValue returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        return returnValue;
    }
    return runActionImpl(actionType, parameters, false, null);
}
#method_after
@Override
@InvocationLogger
public ActionReturnValue runAction(ActionType actionType, ActionParametersBase parameters) {
    ActionReturnValue returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        return returnValue;
    }
    return runActionImpl(actionType, parameters, false, null);
}
#end_block

#method_before
@Override
public QueryReturnValue runQuery(QueryType actionType, QueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true, null);
}
#method_after
@InvocationLogger
@Override
public QueryReturnValue runQuery(QueryType actionType, QueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true, null);
}
#end_block

#method_before
@Override
public String toString() {
    StringJoiner info = new StringJoiner(", ", String.format("Thread pool: %s has ", poolName), "");
    threadStateMap.entrySet().stream().forEach(entry -> info.add(String.format("%s threads in state %s", entry.getValue(), entry.getKey().name())));
    return info.toString();
}
#method_after
@Override
public String toString() {
    int usedThreads = threadStateMap.getOrDefault(Thread.State.NEW, ZERO).get() + threadStateMap.getOrDefault(Thread.State.RUNNABLE, ZERO).get() + threadStateMap.getOrDefault(Thread.State.BLOCKED, ZERO).get();
    int waitingThreads = threadStateMap.getOrDefault(Thread.State.TIMED_WAITING, ZERO).get() + threadStateMap.getOrDefault(Thread.State.WAITING, ZERO).get();
    return String.format(msg, poolName, usedThreads, maxThreads, waitingThreads);
}
#end_block

#method_before
@PostConstruct
public void init() {
    try {
        threadMXBean = ManagementFactory.getThreadMXBean();
    } catch (Exception e) {
        throw new IllegalStateException("Problem getting ThreadMXBean:" + e);
    }
    log.info("Initializing Thread Monitoring Service");
    executor.scheduleWithFixedDelay(this::monitorEngineThreadPools, 0, Config.<Integer>getValue(ConfigValues.ThreadPoolMonitoringIntervalInMinutes), TimeUnit.MINUTES);
    log.info("Thread Monitoring Service initialized");
}
#method_after
@PostConstruct
public void init() {
    try {
        threadMXBean = ManagementFactory.getThreadMXBean();
    } catch (Exception e) {
        throw new IllegalStateException("Problem getting ThreadMXBean:" + e);
    }
    log.info("Initializing Thread Monitoring Service");
    int threadPoolMonitoringIntervalInSeconds = EngineLocalConfig.getInstance().getInteger("THREAD_POOL_MONITORING_INTERVAL_IN_SECONDS");
    if (threadPoolMonitoringIntervalInSeconds <= 0) {
        log.info("Thread Monitoring Service is disabled.");
    } else {
        executor.scheduleWithFixedDelay(this::monitorEngineThreadPools, 0, threadPoolMonitoringIntervalInSeconds, TimeUnit.SECONDS);
        log.info("Thread Monitoring Service initialized");
    }
}
#end_block

#method_before
private void monitorEngineThreadPools() {
    try {
        threadPoolInfoMap.clear();
        Arrays.asList(threadMXBean.getAllThreadIds()).stream().forEach(threadId -> processThread(threadMXBean.getThreadInfo(threadId)));
        StringJoiner info = new StringJoiner("\n", "ThreadPools Info\n", "");
        threadPoolInfoMap.entrySet().stream().forEach(entry -> info.add(entry.getValue().toString()));
        log.info(info.toString());
    } catch (Exception ex) {
        log.info("Exception", ex);
    }
}
#method_after
private void monitorEngineThreadPools() {
    try {
        threadPoolInfoMap.clear();
        Arrays.asList(threadMXBean.getAllThreadIds()).stream().forEach(threadId -> processThread(threadMXBean.getThreadInfo(threadId)));
        threadPoolInfoMap.entrySet().stream().forEach(entry -> log.info(entry.getValue().toString()));
    } catch (Exception ex) {
        log.info("Error fetching thread pools data: {}", ex.getMessage());
        log.debug("Exception", ex);
    }
}
#end_block

#method_before
private void processThread(ThreadInfo[] threadInfo) {
    Arrays.asList(threadInfo).stream().filter(tInfo -> tInfo.getThreadName().startsWith("EE")).filter(tInfo -> tInfo.getThreadName().split("-").length > 2).forEach(tInfo -> processThread(tInfo));
}
#method_after
private void processThread(ThreadInfo[] threadInfo) {
    Arrays.asList(threadInfo).stream().filter(// In Wildfly 11 the managed threads start with EE
    tInfo -> tInfo.getThreadName().startsWith("EE")).filter(tInfo -> tInfo.getThreadName().split("-").length > 2).forEach(tInfo -> processThread(tInfo));
}
#end_block

#method_before
public SPMAsyncTask createTask(AsyncTaskType taskType, AsyncTaskParameters taskParameters) {
    return asyncTaskFactory.construct(taskType, taskParameters, false);
}
#method_after
public Guid createTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, ActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Step taskStep = ExecutionHandler.getInstance().addTaskStep(command.getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description, command.getCommandStepSubjectEntities());
    command.getExecutionContext().setStep(taskStep);
    if (taskStep != null) {
        asyncTaskCreationInfo.setStepId(taskStep.getId());
    }
    SPMAsyncTask task = concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
    task.setEntitiesMap(entitiesMap);
    AsyncTaskUtils.addOrUpdateTaskInDB(coco.get(), task);
    asyncTaskManager.get().lockAndAddTaskToManager(task);
    Guid vdsmTaskId = task.getVdsmTaskId();
    ExecutionHandler.getInstance().updateStepExternalId(taskStep, vdsmTaskId, ExternalSystemType.VDSM);
    return vdsmTaskId;
}
#end_block

#method_before
public SPMAsyncTask concreteCreateTask(CommandCoordinator coco, Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, ActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, getAsyncTask(coco, taskId, command, asyncTaskCreationInfo, parentCommand));
    p.setEntityInfo(command.getParameters().getEntityInfo());
    return createTask(internalGetTaskType(command), p);
}
#method_after
public SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, ActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand));
    p.setEntityInfo(command.getParameters().getEntityInfo());
    return createTask(internalGetTaskType(command), p);
}
#end_block

#method_before
public void revertTasks(CommandBase<?> command) {
    if (command.getParameters().getVdsmTaskIds() != null) {
        // list to send to the pollTasks method
        ArrayList<Guid> taskIdAsList = new ArrayList<>();
        for (Guid taskId : command.getParameters().getVdsmTaskIds()) {
            taskIdAsList.add(taskId);
            ArrayList<AsyncTaskStatus> tasksStatuses = getAsyncTaskManager().pollTasks(taskIdAsList);
            // call revert task only if ended successfully
            if (tasksStatuses.get(0).getTaskEndedSuccessfully()) {
                getBackend().getResourceManager().runVdsCommand(VDSCommandType.SPMRevertTask, new SPMTaskGuidBaseVDSCommandParameters(command.getStoragePool().getId(), taskId));
            }
            taskIdAsList.clear();
        }
    }
}
#method_after
public void revertTasks(CommandBase<?> command) {
    if (command.getParameters().getVdsmTaskIds() != null) {
        // list to send to the pollTasks method
        ArrayList<Guid> taskIdAsList = new ArrayList<>();
        for (Guid taskId : command.getParameters().getVdsmTaskIds()) {
            taskIdAsList.add(taskId);
            ArrayList<AsyncTaskStatus> tasksStatuses = asyncTaskManager.get().pollTasks(taskIdAsList);
            // call revert task only if ended successfully
            if (tasksStatuses.get(0).getTaskEndedSuccessfully()) {
                getBackend().getResourceManager().runVdsCommand(VDSCommandType.SPMRevertTask, new SPMTaskGuidBaseVDSCommandParameters(command.getStoragePool().getId(), taskId));
            }
            taskIdAsList.clear();
        }
    }
}
#end_block

#method_before
public void cancelTasks(final CommandBase<?> command, final Logger log) {
    if (command.hasTasks()) {
        ThreadPoolUtil.execute(() -> {
            log.info("Rollback for command '{}'", command.getClass().getName());
            try {
                getAsyncTaskManager().cancelTasks(command.getReturnValue().getVdsmTaskIdList());
            } catch (Exception e) {
                log.error("Failed to cancel tasks for command '{}'", command.getClass().getName());
            }
        });
    }
}
#method_after
public void cancelTasks(final CommandBase<?> command, final Logger log) {
    if (command.hasTasks()) {
        ThreadPoolUtil.execute(() -> {
            log.info("Rollback for command '{}'", command.getClass().getName());
            try {
                asyncTaskManager.get().cancelTasks(command.getReturnValue().getVdsmTaskIdList());
            } catch (Exception e) {
                log.error("Failed to cancel tasks for command '{}'", command.getClass().getName());
            }
        });
    }
}
#end_block

#method_before
private CommandEntity getCommandEntity(Guid cmdId) {
    CommandEntity cmdEntity = getCommandsRepository().getCommandEntity(cmdId);
    if (cmdEntity == null) {
        cmdEntity = createCommandEntity(cmdId, ActionType.Unknown, new ActionParametersBase());
    }
    return cmdEntity;
}
#method_after
private CommandEntity getCommandEntity(Guid cmdId) {
    CommandEntity cmdEntity = commandsRepositoryInstance.get().getCommandEntity(cmdId);
    if (cmdEntity == null) {
        cmdEntity = createCommandEntity(cmdId, ActionType.Unknown, new ActionParametersBase());
    }
    return cmdEntity;
}
#end_block

#method_before
public void saveAsyncTaskToDb(final CommandCoordinator coco, final AsyncTask asyncTask) {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
        DbFacade.getInstance().getAsyncTaskDao().save(asyncTask);
        coco.persistCommand(asyncTask.getRootCmdEntity());
        coco.persistCommand(asyncTask.getChildCmdEntity());
        return null;
    });
}
#method_after
public void saveAsyncTaskToDb(final AsyncTask asyncTask) {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
        DbFacade.getInstance().getAsyncTaskDao().save(asyncTask);
        coco.get().persistCommand(asyncTask.getRootCmdEntity());
        coco.get().persistCommand(asyncTask.getChildCmdEntity());
        return null;
    });
}
#end_block

#method_before
public int removeTaskFromDbByTaskId(final CommandCoordinator coco, final Guid taskId) throws RuntimeException {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
        AsyncTask asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(taskId);
        int retVal = DbFacade.getInstance().getAsyncTaskDao().remove(taskId);
        if (shouldRemoveCommand(coco, asyncTask)) {
            coco.removeCommand(asyncTask.getCommandId());
            if (!coco.hasCommandEntitiesWithRootCommandId(asyncTask.getRootCommandId())) {
                coco.removeCommand(asyncTask.getRootCommandId());
            }
        }
        return retVal;
    });
}
#method_after
public int removeTaskFromDbByTaskId(final Guid taskId) throws RuntimeException {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
        AsyncTask asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(taskId);
        int retVal = DbFacade.getInstance().getAsyncTaskDao().remove(taskId);
        if (shouldRemoveCommand(asyncTask)) {
            coco.get().removeCommand(asyncTask.getCommandId());
            if (!coco.get().hasCommandEntitiesWithRootCommandId(asyncTask.getRootCommandId())) {
                coco.get().removeCommand(asyncTask.getRootCommandId());
            }
        }
        return retVal;
    });
}
#end_block

#method_before
private boolean shouldRemoveCommand(CommandCoordinator coco, AsyncTask asyncTask) {
    if (asyncTask == null || Guid.isNullOrEmpty(asyncTask.getCommandId())) {
        return false;
    }
    CommandEntity cmdEntity = coco.getCommandEntity(asyncTask.getCommandId());
    CommandEntity parentEntity = null;
    if (cmdEntity != null) {
        parentEntity = coco.getCommandEntity(cmdEntity.getParentCommandId());
    }
    return cmdEntity != null && !cmdEntity.isCallbackEnabled() && (parentEntity == null || !parentEntity.isCallbackEnabled());
}
#method_after
private boolean shouldRemoveCommand(AsyncTask asyncTask) {
    if (asyncTask == null || Guid.isNullOrEmpty(asyncTask.getCommandId())) {
        return false;
    }
    CommandEntity cmdEntity = coco.get().getCommandEntity(asyncTask.getCommandId());
    CommandEntity parentEntity = null;
    if (cmdEntity != null) {
        parentEntity = coco.get().getCommandEntity(cmdEntity.getParentCommandId());
    }
    return cmdEntity != null && !cmdEntity.isCallbackEnabled() && (parentEntity == null || !parentEntity.isCallbackEnabled());
}
#end_block

#method_before
public int removeByVdsmTaskId(final CommandCoordinator coco, final Guid vdsmTaskId) {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
        AsyncTask asyncTask = DbFacade.getInstance().getAsyncTaskDao().getByVdsmTaskId(vdsmTaskId);
        int retVal = DbFacade.getInstance().getAsyncTaskDao().removeByVdsmTaskId(vdsmTaskId);
        if (shouldRemoveCommand(coco, asyncTask)) {
            coco.removeCommand(asyncTask.getCommandId());
            if (!coco.hasCommandEntitiesWithRootCommandId(asyncTask.getRootCommandId())) {
                coco.removeCommand(asyncTask.getRootCommandId());
            }
        }
        return retVal;
    });
}
#method_after
public int removeByVdsmTaskId(final Guid vdsmTaskId) {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
        AsyncTask asyncTask = DbFacade.getInstance().getAsyncTaskDao().getByVdsmTaskId(vdsmTaskId);
        int retVal = DbFacade.getInstance().getAsyncTaskDao().removeByVdsmTaskId(vdsmTaskId);
        if (shouldRemoveCommand(asyncTask)) {
            coco.get().removeCommand(asyncTask.getCommandId());
            if (!coco.get().hasCommandEntitiesWithRootCommandId(asyncTask.getRootCommandId())) {
                coco.get().removeCommand(asyncTask.getRootCommandId());
            }
        }
        return retVal;
    });
}
#end_block

#method_before
public void addOrUpdateTaskInDB(final CommandCoordinator coco, final AsyncTask asyncTask) {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
        if (asyncTask.getChildCmdEntity().getRootCommandId() != null && !asyncTask.getChildCmdEntity().getRootCommandId().equals(asyncTask.getChildCmdEntity().getId())) {
            coco.persistCommand(asyncTask.getRootCmdEntity());
        }
        coco.persistCommand(asyncTask.getChildCmdEntity());
        DbFacade.getInstance().getAsyncTaskDao().saveOrUpdate(asyncTask);
        return null;
    });
}
#method_after
public void addOrUpdateTaskInDB(final AsyncTask asyncTask) {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
        if (asyncTask.getChildCmdEntity().getRootCommandId() != null && !asyncTask.getChildCmdEntity().getRootCommandId().equals(asyncTask.getChildCmdEntity().getId())) {
            coco.get().persistCommand(asyncTask.getRootCmdEntity());
        }
        coco.get().persistCommand(asyncTask.getChildCmdEntity());
        DbFacade.getInstance().getAsyncTaskDao().saveOrUpdate(asyncTask);
        return null;
    });
}
#end_block

#method_before
public AsyncTask getAsyncTask(CommandCoordinator coco, Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, ActionType parentCommand) {
    AsyncTask asyncTask = null;
    if (!taskId.equals(Guid.Empty)) {
        asyncTask = getAsyncTaskFromDb(taskId);
    }
    if (asyncTask != null) {
        ActionParametersBase parentParameters = command.getParentParameters() == null ? command.getParentParameters(parentCommand) : command.getParentParameters();
        Guid parentCommandId = parentParameters == null ? Guid.Empty : parentParameters.getCommandId();
        if (ActionType.Unknown.equals(command.getParameters().getCommandType())) {
            command.getParameters().setCommandType(command.getActionType());
        }
        asyncTask.setActionType(parentCommand);
        asyncTask.setVdsmTaskId(asyncTaskCreationInfo.getVdsmTaskId());
        asyncTask.setActionParameters(parentParameters);
        asyncTask.setTaskParameters(command.getParameters());
        asyncTask.setStepId(asyncTaskCreationInfo.getStepId());
        asyncTask.setCommandId(command.getCommandId());
        asyncTask.setRootCmdEntity(getParentCommandEntity(coco, parentCommandId, parentCommand, parentParameters));
        asyncTask.setChildCmdEntity(getChildCommandEntity(coco, command, parentCommand));
        asyncTask.setStoragePoolId(asyncTaskCreationInfo.getStoragePoolID());
        asyncTask.setTaskType(asyncTaskCreationInfo.getTaskType());
        asyncTask.setCommandStatus(command.getCommandStatus());
        asyncTask.setCommandType(command.getParameters().getCommandType());
    } else {
        asyncTask = createAsyncTask(coco, command, asyncTaskCreationInfo, parentCommand);
    }
    return asyncTask;
}
#method_after
public AsyncTask getAsyncTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, ActionType parentCommand) {
    AsyncTask asyncTask = null;
    if (!taskId.equals(Guid.Empty)) {
        asyncTask = getAsyncTaskFromDb(taskId);
    }
    if (asyncTask != null) {
        ActionParametersBase parentParameters = command.getParentParameters() == null ? command.getParentParameters(parentCommand) : command.getParentParameters();
        Guid parentCommandId = parentParameters == null ? Guid.Empty : parentParameters.getCommandId();
        if (ActionType.Unknown.equals(command.getParameters().getCommandType())) {
            command.getParameters().setCommandType(command.getActionType());
        }
        asyncTask.setActionType(parentCommand);
        asyncTask.setVdsmTaskId(asyncTaskCreationInfo.getVdsmTaskId());
        asyncTask.setActionParameters(parentParameters);
        asyncTask.setTaskParameters(command.getParameters());
        asyncTask.setStepId(asyncTaskCreationInfo.getStepId());
        asyncTask.setCommandId(command.getCommandId());
        asyncTask.setRootCmdEntity(getParentCommandEntity(parentCommandId, parentCommand, parentParameters));
        asyncTask.setChildCmdEntity(getChildCommandEntity(command, parentCommand));
        asyncTask.setStoragePoolId(asyncTaskCreationInfo.getStoragePoolID());
        asyncTask.setTaskType(asyncTaskCreationInfo.getTaskType());
        asyncTask.setCommandStatus(command.getCommandStatus());
        asyncTask.setCommandType(command.getParameters().getCommandType());
    } else {
        asyncTask = createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
    }
    return asyncTask;
}
#end_block

#method_before
public AsyncTask createAsyncTask(CommandCoordinator coco, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, ActionType parentCommand) {
    ActionParametersBase parentParameters = command.getParentParameters() == null ? command.getParentParameters(parentCommand) : command.getParentParameters();
    Guid parentCommandId = parentParameters == null ? Guid.Empty : parentParameters.getCommandId();
    if (ActionType.Unknown.equals(command.getParameters().getCommandType())) {
        command.getParameters().setCommandType(command.getActionType());
    }
    AsyncTask asyncTask = new AsyncTask(AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, command.getUserId(), asyncTaskCreationInfo.getVdsmTaskId(), asyncTaskCreationInfo.getStepId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType(), getParentCommandEntity(coco, parentCommandId, parentCommand, parentParameters), getChildCommandEntity(coco, command, parentCommand));
    return asyncTask;
}
#method_after
public AsyncTask createAsyncTask(CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, ActionType parentCommand) {
    ActionParametersBase parentParameters = command.getParentParameters() == null ? command.getParentParameters(parentCommand) : command.getParentParameters();
    Guid parentCommandId = parentParameters == null ? Guid.Empty : parentParameters.getCommandId();
    if (ActionType.Unknown.equals(command.getParameters().getCommandType())) {
        command.getParameters().setCommandType(command.getActionType());
    }
    AsyncTask asyncTask = new AsyncTask(AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, command.getUserId(), asyncTaskCreationInfo.getVdsmTaskId(), asyncTaskCreationInfo.getStepId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType(), getParentCommandEntity(parentCommandId, parentCommand, parentParameters), getChildCommandEntity(command, parentCommand));
    return asyncTask;
}
#end_block

#method_before
private CommandEntity getChildCommandEntity(CommandCoordinator coco, CommandBase<?> command, ActionType parentCommand) {
    CommandEntity cmdEntity = coco.getCommandEntity(command.getCommandId());
    if (cmdEntity == null) {
        command.persistCommand(parentCommand, command.getCallback() != null);
    }
    return coco.getCommandEntity(command.getCommandId());
}
#method_after
private CommandEntity getChildCommandEntity(CommandBase<?> command, ActionType parentCommand) {
    CommandEntity cmdEntity = coco.get().getCommandEntity(command.getCommandId());
    if (cmdEntity == null) {
        command.persistCommand(parentCommand, command.getCallback() != null);
    }
    return coco.get().getCommandEntity(command.getCommandId());
}
#end_block

#method_before
private CommandEntity getParentCommandEntity(CommandCoordinator coco, Guid cmdId, ActionType actionType, ActionParametersBase parameters) {
    CommandEntity cmdEntity = coco.getCommandEntity(cmdId);
    if (cmdEntity == null) {
        cmdEntity = createCommandEntity(cmdId, actionType, parameters);
        if (!Guid.isNullOrEmpty(cmdId)) {
            cmdEntity.setCommandStatus(CommandStatus.ACTIVE);
            coco.persistCommand(cmdEntity);
        }
    }
    return cmdEntity;
}
#method_after
private CommandEntity getParentCommandEntity(Guid cmdId, ActionType actionType, ActionParametersBase parameters) {
    CommandEntity cmdEntity = coco.get().getCommandEntity(cmdId);
    if (cmdEntity == null) {
        cmdEntity = createCommandEntity(cmdId, actionType, parameters);
        if (!Guid.isNullOrEmpty(cmdId)) {
            cmdEntity.setCommandStatus(CommandStatus.ACTIVE);
            coco.get().persistCommand(cmdEntity);
        }
    }
    return cmdEntity;
}
#end_block

#method_before
public ActionReturnValue endAction(CommandCoordinator coco, SPMTask task) {
    AsyncTask dbAsyncTask = task.getParameters().getDbAsyncTask();
    ActionType actionType = getEndActionType(dbAsyncTask);
    ActionParametersBase parameters = dbAsyncTask.getActionParameters();
    CommandBase<?> command = CommandHelper.buildCommand(actionType, parameters, coco.retrieveCommandContext(dbAsyncTask.getRootCommandId()).getExecutionContext(), coco.getCommandStatus(dbAsyncTask.getCommandId()));
    return new DecoratedCommand<>(command).endAction();
}
#method_after
public ActionReturnValue endAction(SPMTask task) {
    AsyncTask dbAsyncTask = task.getParameters().getDbAsyncTask();
    ActionType actionType = getEndActionType(dbAsyncTask);
    ActionParametersBase parameters = dbAsyncTask.getActionParameters();
    CommandBase<?> command = CommandHelper.buildCommand(actionType, parameters, coco.get().retrieveCommandContext(dbAsyncTask.getRootCommandId()).getExecutionContext(), coco.get().getCommandStatus(dbAsyncTask.getCommandId()));
    return new DecoratedCommand<>(command).endAction();
}
#end_block

#method_before
@Override
protected boolean validate() {
    // check for removal of last fence agent while PM is enabled in the host
    if (getVds().isPmEnabled()) {
        List<FenceAgent> fenceAgents = fenceAgentDao.getFenceAgentsForHost(getVdsId());
        if (fenceAgents.size() == 1) {
            return failValidation(EngineMessage.VDS_REMOVE_LAST_FENCE_AGENT_PM_ENABLED);
        }
    }
    if (getParameters() == null || getParameters().getAgent() == null || getParameters().getAgent().getId() == null) {
        return failValidation(EngineMessage.VDS_REMOVE_FENCE_AGENT_ID_REQUIRED);
    }
    return super.validate();
}
#method_after
@Override
protected boolean validate() {
    if (getParameters() == null || getParameters().getAgent() == null || getParameters().getAgent().getId() == null) {
        return failValidation(EngineMessage.VDS_REMOVE_FENCE_AGENT_ID_REQUIRED);
    }
    // check for removal of last fence agent while PM is enabled in the host
    VDS host = getVds();
    if (host != null && host.isPmEnabled()) {
        List<FenceAgent> fenceAgents = fenceAgentDao.getFenceAgentsForHost(getVdsId());
        if (fenceAgents.size() == 1) {
            return failValidation(EngineMessage.VDS_REMOVE_LAST_FENCE_AGENT_PM_ENABLED);
        }
    }
    return super.validate();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new EngineException(EngineError.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVdsStaticToDb();
        addVdsDynamicToDb();
        addVdsStatisticsToDb();
        addAffinityLabels();
        getCompensationContext().stateChanged();
        return null;
    });
    if (getParameters().isProvisioned()) {
        HostProviderProxy proxy = providerProxyFactory.create(getHostProvider());
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        auditLogDirector.log(this, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getCluster().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        initializeVds(true);
        alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
        testVdsPowerManagementStatus(getParameters().getVdsStaticData());
        setSucceeded(true);
        setActionReturnValue(getVdsIdRef());
        // If the installation failed, we don't want to compensate for the failure since it will remove the
        // host, but instead the host should be left in an "install failed" status.
        getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
        return null;
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().isPending() && !getParameters().isProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setNetworkProviderId(getParameters().getVdsStaticData().getOpenstackNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        installVdsParameters.setEnableSerialConsole(getParameters().getEnableSerialConsole());
        if (getParameters().getHostedEngineDeployConfiguration() != null) {
            Map<String, String> vdsDeployParams = hostedEngineHelper.createVdsDeployParams(getVdsId(), getParameters().getHostedEngineDeployConfiguration().getDeployAction());
            installVdsParameters.setHostedEngineConfiguration(vdsDeployParams);
        }
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = executionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(() -> runInternalAction(ActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx)));
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new EngineException(EngineError.HOST_ALREADY_EXISTS);
        }
    }
    completeOpenstackNetworkProviderId();
    TransactionSupport.executeInNewTransaction(() -> {
        addVdsStaticToDb();
        addVdsDynamicToDb();
        addVdsStatisticsToDb();
        addAffinityLabels();
        getCompensationContext().stateChanged();
        return null;
    });
    if (getParameters().isProvisioned()) {
        HostProviderProxy proxy = providerProxyFactory.create(getHostProvider());
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        auditLogDirector.log(this, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getCluster().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        initializeVds(true);
        alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
        testVdsPowerManagementStatus(getParameters().getVdsStaticData());
        setSucceeded(true);
        setActionReturnValue(getVdsIdRef());
        // If the installation failed, we don't want to compensate for the failure since it will remove the
        // host, but instead the host should be left in an "install failed" status.
        getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
        return null;
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().isPending() && !getParameters().isProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setNetworkProviderId(getParameters().getVdsStaticData().getOpenstackNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        installVdsParameters.setEnableSerialConsole(getParameters().getEnableSerialConsole());
        if (getParameters().getHostedEngineDeployConfiguration() != null) {
            Map<String, String> vdsDeployParams = hostedEngineHelper.createVdsDeployParams(getVdsId(), getParameters().getHostedEngineDeployConfiguration().getDeployAction());
            installVdsParameters.setHostedEngineConfiguration(vdsDeployParams);
        }
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = executionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(() -> runInternalAction(ActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx)));
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    T params = getParameters();
    setClusterId(params.getVdsStaticData().getClusterId());
    params.setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateCluster();
    if (returnValue) {
        HostValidator validator = getHostValidator();
        returnValue = validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.hostNameIsValid()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.portIsValid()) && validate(validator.sshUserNameNotEmpty()) && validate(validator.validateSingleHostAttachedToLocalStorage()) && validate(validator.securityKeysExists()) && validate(validator.provisioningComputeResourceValid(params.isProvisioned(), params.getComputeResource())) && validate(validator.provisioningHostGroupValid(params.isProvisioned(), params.getHostGroup())) && validate(validator.passwordNotEmpty(params.isPending(), params.getAuthMethod(), params.getPassword())) && validate(validator.supportsDeployingHostedEngine(params.getHostedEngineDeployConfiguration()));
    }
    if (!(returnValue && isPowerManagementLegal(params.getVdsStaticData().isPmEnabled(), params.getFenceAgents(), getCluster().getCompatibilityVersion().toString(), true) && canConnect(params.getvds()))) {
        return false;
    }
    if (params.getVdsStaticData().getOpenstackNetworkProviderId() != null && !validateOpenstackNetworkProviderProperties(params.getVdsStaticData().getOpenstackNetworkProviderId(), params.getNetworkMappings())) {
        return false;
    }
    if (isGlusterSupportEnabled() && clusterHasNonInitializingServers()) {
        // allow simultaneous installation of hosts, but if a host has completed install, only
        // allow addition of another host if it can be peer probed to cluster.
        VDS upServer = glusterUtil.getUpServer(getClusterId());
        if (upServer == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    T params = getParameters();
    setClusterId(params.getVdsStaticData().getClusterId());
    params.setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateCluster();
    if (returnValue) {
        HostValidator validator = getHostValidator();
        returnValue = validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.hostNameIsValid()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.portIsValid()) && validate(validator.sshUserNameNotEmpty()) && validate(validator.validateSingleHostAttachedToLocalStorage()) && validate(validator.securityKeysExists()) && validate(validator.provisioningComputeResourceValid(params.isProvisioned(), params.getComputeResource())) && validate(validator.provisioningHostGroupValid(params.isProvisioned(), params.getHostGroup())) && validate(validator.passwordNotEmpty(params.isPending(), params.getAuthMethod(), params.getPassword())) && validate(validator.supportsDeployingHostedEngine(params.getHostedEngineDeployConfiguration()));
    }
    if (!(returnValue && isPowerManagementLegal(params.getVdsStaticData().isPmEnabled(), params.getFenceAgents(), getCluster().getCompatibilityVersion().toString(), true) && canConnect(params.getvds()))) {
        return false;
    }
    if (params.getVdsStaticData().getOpenstackNetworkProviderId() != null) {
        Provider<?> provider = providerDao.get(params.getVdsStaticData().getOpenstackNetworkProviderId());
        if (provider == null) {
            return false;
        }
        if (!(provider.getType() == ProviderType.OPENSTACK_NETWORK || provider.getType() == ProviderType.EXTERNAL_NETWORK)) {
            return false;
        }
        if ((provider.getType() == ProviderType.OPENSTACK_NETWORK) && !validateOpenstackNetworkProviderProperties(params.getVdsStaticData().getOpenstackNetworkProviderId(), params.getNetworkMappings())) {
            return false;
        }
    }
    if (isGlusterSupportEnabled() && clusterHasNonInitializingServers()) {
        // allow simultaneous installation of hosts, but if a host has completed install, only
        // allow addition of another host if it can be peer probed to cluster.
        VDS upServer = glusterUtil.getUpServer(getClusterId());
        if (upServer == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    oldHost = vdsDao.get(getVdsId());
    // if fenece agents list is null, try to fill it from database
    // so we can enable changing other host attributes from API
    // without failing validation or removing the persisted fence agents
    boolean validateAgents = true;
    if (getParameters().getFenceAgents() == null || getParameters().getFenceAgents().isEmpty()) {
        getParameters().setFenceAgents(fenceAgentDao.getFenceAgentsForHost(getVdsId()));
        validateAgents = false;
    }
    UpdateHostValidator validator = getUpdateHostValidator(oldHost, getParameters().getvds(), getParameters().isInstallHost());
    return validate(validator.hostExists()) && validate(validator.hostStatusValid()) && validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.updateHostAddressAllowed()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.statusSupportedForHostInstallation()) && validate(validator.passwordProvidedForHostInstallation(getParameters().getAuthMethod(), getParameters().getPassword())) && validate(validator.updatePortAllowed()) && validate(validator.clusterNotChanged()) && validate(validator.hostProviderExists()) && validate(validator.hostProviderTypeMatches()) && validateNetworkProviderConfiguration() && isPowerManagementLegal(getParameters().getVdsStaticData().isPmEnabled(), getParameters().getFenceAgents(), oldHost.getClusterCompatibilityVersion().toString(), validateAgents) && validate(validator.supportsDeployingHostedEngine(getParameters().getHostedEngineDeployConfiguration()));
}
#method_after
@Override
protected boolean validate() {
    oldHost = vdsDao.get(getVdsId());
    // if fence agents list is null, try to fill it from database
    // so we can enable changing other host attributes from API
    // without failing validation or removing the persisted fence agents
    boolean validateAgents = true;
    if (getParameters().getFenceAgents() == null) {
        getParameters().setFenceAgents(fenceAgentDao.getFenceAgentsForHost(getVdsId()));
        validateAgents = false;
    }
    UpdateHostValidator validator = getUpdateHostValidator(oldHost, getParameters().getvds(), getParameters().isInstallHost());
    return validate(validator.hostExists()) && validate(validator.hostStatusValid()) && validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.updateHostAddressAllowed()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.statusSupportedForHostInstallation()) && validate(validator.passwordProvidedForHostInstallation(getParameters().getAuthMethod(), getParameters().getPassword())) && validate(validator.updatePortAllowed()) && validate(validator.clusterNotChanged()) && validate(validator.hostProviderExists()) && validate(validator.hostProviderTypeMatches()) && validateNetworkProviderConfiguration() && isPowerManagementLegal(getParameters().getVdsStaticData().isPmEnabled(), getParameters().getFenceAgents(), oldHost.getClusterCompatibilityVersion().toString(), validateAgents) && validate(validator.supportsDeployingHostedEngine(getParameters().getHostedEngineDeployConfiguration()));
}
#end_block

#method_before
private void sleepOnReboot(final VDSStatus status) {
    int sleepTimeInSec = Config.<Integer>getValue(ConfigValues.ServerRebootTimeout);
    log.info("Waiting {} seconds, for server to finish reboot process.", sleepTimeInSec);
    ThreadUtils.sleep(TimeUnit.SECONDS.toMillis(sleepTimeInSec));
    setVdsStatus(status);
}
#method_after
private void sleepOnReboot(final VDSStatus status) {
    int sleepTimeInSec = Config.<Integer>getValue(ConfigValues.ServerRebootTimeout);
    log.info("Waiting {} seconds, for server to finish reboot process.", sleepTimeInSec);
    resourceManager.getVdsManager(getVdsId()).setInServerRebootTimeout(true);
    ThreadUtils.sleep(TimeUnit.SECONDS.toMillis(sleepTimeInSec));
    resourceManager.getVdsManager(getVdsId()).setInServerRebootTimeout(false);
    setVdsStatus(status);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    UnregisteredDisk that = (UnregisteredDisk) o;
    if (!diskImage.equals(that.diskImage)) {
        return false;
    }
    return vms.equals(that.vms);
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    UnregisteredDisk that = (UnregisteredDisk) o;
    return Objects.equals(diskImage, that.diskImage) && Objects.equals(vms, that.vms) && Objects.equals(id, that.id);
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = diskImage.hashCode();
    result = 31 * result + vms.hashCode();
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(diskImage, vms, id);
}
#end_block

#method_before
@Override
public List<UnregisteredDisk> getByDiskIdAndStorageDomainId(Guid diskId, Guid storageDomainId) {
    List<UnregisteredDisk> unregisteredDisks = getCallsHandler().executeReadList("GetDiskByDiskIdAndStorageDomainId", unregisteredDiskRowMapper, getCustomMapSqlParameterSource().addValue("disk_id", diskId).addValue("storage_domain_id", storageDomainId));
    for (UnregisteredDisk unregDisk : unregisteredDisks) {
        List<VmBase> vms = getCallsHandler().executeReadList("GetEntitiesByDiskId", vmsForUnregisteredDiskRowMapper, getCustomMapSqlParameterSource().addValue("disk_id", unregDisk.getId().getDiskId()));
        unregDisk.getVms().addAll(vms);
    }
    return unregisteredDisks;
}
#method_after
@Override
public List<UnregisteredDisk> getByDiskIdAndStorageDomainId(Guid diskId, Guid storageDomainId) {
    List<UnregisteredDisk> unregisteredDisks = getCallsHandler().executeReadList("GetDiskByDiskIdAndStorageDomainId", unregisteredDiskRowMapper, getCustomMapSqlParameterSource().addValue("disk_id", diskId).addValue("storage_domain_id", storageDomainId));
    for (UnregisteredDisk unregDisk : unregisteredDisks) {
        List<VmBase> vms = getCallsHandler().executeReadList("GetEntitiesByDiskId", vmsForUnregisteredDiskRowMapper, getCustomMapSqlParameterSource().addValue("disk_id", unregDisk.getDiskId()));
        unregDisk.getVms().addAll(vms);
    }
    return unregisteredDisks;
}
#end_block

#method_before
protected List<VDS> getAllRunningVdssInPool() {
    return vdsDao.getAllForStoragePoolAndStatus(getStoragePool().getId(), VDSStatus.Up);
}
#method_after
protected List<VDS> getAllRunningVdssInPool() {
    return vdsDao.getAllForStoragePoolAndStatus(getStoragePoolId(), VDSStatus.Up);
}
#end_block

#method_before
protected VDS checkForActiveVds() {
    List<VDS> hosts = vdsDao.getAllForStoragePoolAndStatus(getStoragePool().getId(), VDSStatus.Up);
    if (!hosts.isEmpty()) {
        return hosts.get(new Random().nextInt(hosts.size()));
    }
    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    return null;
}
#method_after
protected VDS checkForActiveVds() {
    List<VDS> hosts = getAllRunningVdssInPool();
    if (!hosts.isEmpty()) {
        return hosts.get(new Random().nextInt(hosts.size()));
    }
    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    return null;
}
#end_block

#method_before
protected void calcStoragePoolStatusByDomainsStatus() {
    StorageDomain masterDomain = storageDomainDao.getStorageDomains(getStoragePool().getId(), StorageDomainType.Master).stream().findFirst().orElse(null);
    // if no master then Uninitialized
    // if master not active maintenance
    StoragePoolStatus newStatus = (masterDomain == null) ? StoragePoolStatus.Uninitialized : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Maintenance) ? StoragePoolStatus.Maintenance : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Active) ? StoragePoolStatus.Up : StoragePoolStatus.NonResponsive;
    if (newStatus != getStoragePool().getStatus()) {
        getCompensationContext().snapshotEntity(getStoragePool());
        getStoragePool().setStatus(newStatus);
        StoragePool poolFromDb = storagePoolDao.get(getStoragePool().getId());
        if ((getStoragePool().getSpmVdsId() == null && poolFromDb.getSpmVdsId() != null) || (getStoragePool().getSpmVdsId() != null && !getStoragePool().getSpmVdsId().equals(poolFromDb.getSpmVdsId()))) {
            getStoragePool().setSpmVdsId(poolFromDb.getSpmVdsId());
        }
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            getStoragePool().setSpmVdsId(null);
        }
        executeInScope(TransactionScopeOption.Required, () -> {
            storagePoolDao.update(getStoragePool());
            return null;
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    }
}
#method_after
protected void calcStoragePoolStatusByDomainsStatus() {
    StorageDomain masterDomain = storageDomainDao.getStorageDomains(getStoragePool().getId(), StorageDomainType.Master).stream().findFirst().orElse(null);
    // if no master then Uninitialized
    // if master not active maintenance
    StoragePoolStatus newStatus = (masterDomain == null) ? StoragePoolStatus.Uninitialized : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Maintenance) ? StoragePoolStatus.Maintenance : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Active) ? StoragePoolStatus.Up : StoragePoolStatus.NonResponsive;
    if (newStatus != getStoragePool().getStatus()) {
        log.info("Update storage pool '{}' status from '{} to '{}'", getStoragePool().getId(), getStoragePool().getStatus(), newStatus);
        getCompensationContext().snapshotEntity(getStoragePool());
        getStoragePool().setStatus(newStatus);
        StoragePool poolFromDb = storagePoolDao.get(getStoragePool().getId());
        if ((getStoragePool().getSpmVdsId() == null && poolFromDb.getSpmVdsId() != null) || (getStoragePool().getSpmVdsId() != null && !getStoragePool().getSpmVdsId().equals(poolFromDb.getSpmVdsId()))) {
            log.info("Set storage pool '{}' vds Id to '{}'", getStoragePool().getId(), poolFromDb.getSpmVdsId());
            getStoragePool().setSpmVdsId(poolFromDb.getSpmVdsId());
        }
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            log.info("Set storage pool '{}' vds Id to null", getStoragePool().getId(), poolFromDb.getSpmVdsId());
            getStoragePool().setSpmVdsId(null);
        }
        executeInScope(TransactionScopeOption.Required, () -> {
            storagePoolDao.update(getStoragePool());
            return null;
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    }
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk(Guid storageDomainId, Guid storagePoolId) {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList<>(getAllOVFDisks(storageDomainId, storagePoolId));
    if (!ovfStoreDiskImages.isEmpty()) {
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    ActionReturnValue actionReturnValueReturnValue = runInternalAction(ActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), storageDomainId, ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(actionReturnValueReturnValue.getInternalVdsmTaskIdList());
                    if (actionReturnValueReturnValue.getSucceeded()) {
                        List<OvfEntityData> returnedMap = OvfUtils.getOvfEntities(actionReturnValueReturnValue.getActionReturnValue(), unregisteredDisks, storageDomainId);
                        return returnedMap;
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), storageDomainId);
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), storageDomainId, e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            } else {
                log.error("Couldn't find additional ovf store to retrieve the ovf data from in storage domain '{}'", storageDomainId);
                break;
            }
        }
        AuditLogable logable = new AuditLogableImpl();
        logable.setStorageDomainId(storageDomainId);
        logable.setStorageDomainName(storageDomainStaticDao.get(storageDomainId).getName());
        auditLogDirector.log(logable, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", storageDomainId);
    }
    return new ArrayList<>();
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk(Guid storageDomainId, Guid storagePoolId) {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList<>(getAllOVFDisks(storageDomainId, storagePoolId));
    if (!ovfStoreDiskImages.isEmpty()) {
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    ActionReturnValue actionReturnValueReturnValue = runInternalAction(ActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), storageDomainId, ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(actionReturnValueReturnValue.getInternalVdsmTaskIdList());
                    if (actionReturnValueReturnValue.getSucceeded()) {
                        List<OvfEntityData> returnedMap = ovfUtils.getOvfEntities(actionReturnValueReturnValue.getActionReturnValue(), unregisteredDisks, storageDomainId);
                        return returnedMap;
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), storageDomainId);
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), storageDomainId, e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            } else {
                log.error("Couldn't find additional ovf store to retrieve the ovf data from in storage domain '{}'", storageDomainId);
                break;
            }
        }
        AuditLogable logable = new AuditLogableImpl();
        logable.setStorageDomainId(storageDomainId);
        logable.setStorageDomainName(storageDomainStaticDao.get(storageDomainId).getName());
        auditLogDirector.log(logable, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", storageDomainId);
    }
    return new ArrayList<>();
}
#end_block

#method_before
protected void initUnregisteredDisksToDB(Guid storageDomainId) {
    List<DiskImage> existingDisks = diskImageDao.getAllForStorageDomain(storageDomainId);
    for (Object unregisteredDiskObj : unregisteredDisks) {
        UnregisteredDisk unregisteredDisk = (UnregisteredDisk) unregisteredDiskObj;
        if (existingDisks.stream().anyMatch(diskImage -> diskImage.getId().equals(unregisteredDisk.getDiskImage().getId()))) {
            log.info("Disk {} with id '{}' already exists in the engine, therefore will not be " + "part of the unregistered disks.", unregisteredDisk.getDiskAlias(), unregisteredDisk.getDiskImage().getId());
            continue;
        }
        unregisteredDisksDao.removeUnregisteredDisk(unregisteredDisk.getId().getDiskId(), storageDomainId);
        unregisteredDisksDao.saveUnregisteredDisk(unregisteredDisk);
        log.info("Adding unregistered disk of disk id '{}' and disk alias '{}'", unregisteredDisk.getDiskImage().getId(), unregisteredDisk.getDiskAlias());
    }
}
#method_after
protected void initUnregisteredDisksToDB(Guid storageDomainId) {
    List<DiskImage> existingDisks = diskImageDao.getAllForStorageDomain(storageDomainId);
    for (UnregisteredDisk unregisteredDisk : unregisteredDisks) {
        if (existingDisks.stream().anyMatch(diskImage -> diskImage.getId().equals(unregisteredDisk.getId()))) {
            log.info("Disk {} with id '{}' already exists in the engine, therefore will not be " + "part of the unregistered disks.", unregisteredDisk.getDiskAlias(), unregisteredDisk.getDiskId());
            continue;
        }
        unregisteredDisksDao.removeUnregisteredDisk(unregisteredDisk.getDiskId(), storageDomainId);
        unregisteredDisksDao.saveUnregisteredDisk(unregisteredDisk);
        log.info("Adding unregistered disk of disk id '{}' and disk alias '{}'", unregisteredDisk.getDiskId(), unregisteredDisk.getDiskAlias());
    }
}
#end_block

#method_before
protected String getJsonDiskDescription(Disk disk) {
    try {
        return MetadataDiskDescriptionHandler.getInstance().generateJsonDiskDescription(disk);
    } catch (IOException e) {
        log.error("Exception while generating json for disk. ERROR: '{}'", e);
        return StringUtils.EMPTY;
    }
}
#method_after
protected String getJsonDiskDescription(Disk disk) {
    try {
        return metadataDiskDescriptionHandler.generateJsonDiskDescription(disk);
    } catch (IOException e) {
        log.error("Exception while generating json for disk. ERROR: '{}'", e);
        return StringUtils.EMPTY;
    }
}
#end_block

#method_before
@Override
public int compareTo(UnregisteredDiskId o) {
    int idComparison = diskId.compareTo(o.diskId);
    if (idComparison == 0) {
        return storageDomainId.compareTo(o.storageDomainId);
    } else {
        return idComparison;
    }
}
#method_after
@Override
public int compareTo(UnregisteredDiskId o) {
    int idComparison = diskId.compareTo(o.diskId);
    if (idComparison == 0) {
        return storageDomainId.compareTo(o.storageDomainId);
    }
    return idComparison;
}
#end_block

#method_before
@Test
public void testSaveDiskWithAliasAndDescription() {
    ArrayList<VmBase> vms = new ArrayList<>();
    UnregisteredDisk unregisteredDisk = initUnregisteredDisks(vms);
    dao.saveUnregisteredDisk(unregisteredDisk);
    List<UnregisteredDisk> fetchedUnregisteredDisk = dao.getByDiskIdAndStorageDomainId(unregisteredDisk.getId().getDiskId(), FixturesTool.STORAGE_DOMAIN_NFS2_1);
    assertTrue("Disk should exists in the UnregisteredDisks table", !fetchedUnregisteredDisk.isEmpty());
    assertTrue("Disk should not have multiple vms attached", fetchedUnregisteredDisk.get(0).getVms().isEmpty());
    assertEquals("Disk alias should be the same as initialized", "Disk Alias", fetchedUnregisteredDisk.get(0).getDiskAlias());
    assertEquals("Disk description should be the same as initialized", "Disk Description", fetchedUnregisteredDisk.get(0).getDiskDescription());
    assertEquals("Storage Domain id should be the same as initialized", 0, fetchedUnregisteredDisk.get(0).getStorageDomainId().compareTo(FixturesTool.STORAGE_DOMAIN_NFS2_1));
}
#method_after
@Test
public void testSaveDiskWithAliasAndDescription() {
    ArrayList<VmBase> vms = new ArrayList<>();
    UnregisteredDisk unregisteredDisk = initUnregisteredDisks(vms);
    dao.saveUnregisteredDisk(unregisteredDisk);
    List<UnregisteredDisk> fetchedUnregisteredDisk = dao.getByDiskIdAndStorageDomainId(unregisteredDisk.getDiskId(), FixturesTool.STORAGE_DOMAIN_NFS2_1);
    assertTrue("Disk should exists in the UnregisteredDisks table", !fetchedUnregisteredDisk.isEmpty());
    assertTrue("Disk should not have multiple vms attached", fetchedUnregisteredDisk.get(0).getVms().isEmpty());
    assertEquals("Disk alias should be the same as initialized", "Disk Alias", fetchedUnregisteredDisk.get(0).getDiskAlias());
    assertEquals("Disk description should be the same as initialized", "Disk Description", fetchedUnregisteredDisk.get(0).getDiskDescription());
    assertEquals("Storage Domain id should be the same as initialized", 0, fetchedUnregisteredDisk.get(0).getStorageDomainId().compareTo(FixturesTool.STORAGE_DOMAIN_NFS2_1));
}
#end_block

#method_before
@Test
public void testSaveAttachedDiskWithoutAliasAndDescription() {
    VmBase vm1 = new VmBase();
    vm1.setId(Guid.newGuid());
    vm1.setName("First VM");
    ArrayList<VmBase> vms = new ArrayList<>();
    vms.add(vm1);
    // Set new disk image.
    DiskImage diskImage = new DiskImage();
    diskImage.setId(Guid.newGuid());
    diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(FixturesTool.STORAGE_DOMAIN_NFS2_1)));
    UnregisteredDiskId id = new UnregisteredDiskId(diskImage.getId(), diskImage.getStorageIds().get(0));
    UnregisteredDisk unregDisk = new UnregisteredDisk(id, diskImage, vms);
    dao.saveUnregisteredDisk(unregDisk);
    List<UnregisteredDisk> fetchedUnregisteredDisk = dao.getByDiskIdAndStorageDomainId(unregDisk.getId().getDiskId(), FixturesTool.STORAGE_DOMAIN_NFS2_1);
    assertTrue("Disk should exists in the UnregisteredDisks table", !fetchedUnregisteredDisk.isEmpty());
    assertEquals("Disk should have vm attached", 1, fetchedUnregisteredDisk.get(0).getVms().size());
    assertTrue("Disk alias should not be initialized", fetchedUnregisteredDisk.get(0).getDiskAlias().isEmpty());
    assertTrue("Disk description should not be initialized", StringUtils.isEmpty(fetchedUnregisteredDisk.get(0).getDiskDescription()));
    assertEquals("Storage Domain id should be the same as initialized", 0, fetchedUnregisteredDisk.get(0).getStorageDomainId().compareTo(FixturesTool.STORAGE_DOMAIN_NFS2_1));
}
#method_after
@Test
public void testSaveAttachedDiskWithoutAliasAndDescription() {
    VmBase vm1 = new VmBase();
    vm1.setId(Guid.newGuid());
    vm1.setName("First VM");
    ArrayList<VmBase> vms = new ArrayList<>();
    vms.add(vm1);
    // Set new disk image.
    DiskImage diskImage = new DiskImage();
    diskImage.setId(Guid.newGuid());
    diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(FixturesTool.STORAGE_DOMAIN_NFS2_1)));
    UnregisteredDiskId id = new UnregisteredDiskId(diskImage.getId(), diskImage.getStorageIds().get(0));
    UnregisteredDisk unregDisk = new UnregisteredDisk(id, diskImage, vms);
    dao.saveUnregisteredDisk(unregDisk);
    List<UnregisteredDisk> fetchedUnregisteredDisk = dao.getByDiskIdAndStorageDomainId(unregDisk.getDiskId(), FixturesTool.STORAGE_DOMAIN_NFS2_1);
    assertTrue("Disk should exists in the UnregisteredDisks table", !fetchedUnregisteredDisk.isEmpty());
    assertEquals("Disk should have vm attached", 1, fetchedUnregisteredDisk.get(0).getVms().size());
    assertTrue("Disk alias should not be initialized", fetchedUnregisteredDisk.get(0).getDiskAlias().isEmpty());
    assertTrue("Disk description should not be initialized", StringUtils.isEmpty(fetchedUnregisteredDisk.get(0).getDiskDescription()));
    assertEquals("Storage Domain id should be the same as initialized", 0, fetchedUnregisteredDisk.get(0).getStorageDomainId().compareTo(FixturesTool.STORAGE_DOMAIN_NFS2_1));
}
#end_block

#method_before
protected void setVmsForUnregisteredDisks(List<OvfEntityData> allEntities) {
    for (OvfEntityData ovfEntity : allEntities) {
        try {
            XmlDocument xmlDocument = new XmlDocument(ovfEntity.getOvfData());
            OvfUtils.updateUnregisteredDisksWithVMs(unregisteredDisks, ovfEntity.getEntityId(), ovfEntity.getEntityName(), xmlDocument);
        } catch (Exception e) {
            log.warn("Could not parse OVF data of VM");
            continue;
        }
    }
}
#method_after
protected void setVmsForUnregisteredDisks(List<OvfEntityData> allEntities) {
    for (OvfEntityData ovfEntity : allEntities) {
        try {
            XmlDocument xmlDocument = new XmlDocument(ovfEntity.getOvfData());
            ovfUtils.updateUnregisteredDisksWithVMs(unregisteredDisks, ovfEntity.getEntityId(), ovfEntity.getEntityName(), xmlDocument);
        } catch (Exception e) {
            log.warn("Could not parse OVF data of VM");
            continue;
        }
    }
}
#end_block

#method_before
public static Set<Guid> fetchVmDisks(XmlDocument xmlDocument) {
    Set<Guid> disksIds = new HashSet<>();
    XmlNode references = xmlDocument.selectSingleNode("//*/References");
    // we assume that all files in OVFs that are generated by oVirt are disks
    for (XmlNode file : references.selectNodes("File")) {
        disksIds.add(Guid.createGuidFromString(file.attributes.get("ovf:href").getValue().substring(0, GUID_LENGTH)));
    }
    return disksIds;
}
#method_after
public Set<Guid> fetchVmDisks(XmlDocument xmlDocument) {
    Set<Guid> disksIds = new HashSet<>();
    XmlNode references = xmlDocument.selectSingleNode("//*/References");
    // we assume that all files in OVFs that are generated by oVirt are disks
    for (XmlNode file : references.selectNodes("File")) {
        disksIds.add(Guid.createGuidFromString(file.attributes.get("ovf:href").getValue().substring(0, GUID_LENGTH)));
    }
    disksIds.addAll(fetchMemoryDisks(xmlDocument));
    return disksIds;
}
#end_block

#method_before
public static List<OvfEntityData> getOvfEntities(byte[] tar, List<UnregisteredDisk> unregisteredDisks, Guid storageDomainId) {
    List<OvfEntityData> ovfEntityDataFromTar = new ArrayList<>();
    InputStream is = new ByteArrayInputStream(tar);
    log.info("Start fetching OVF files from tar file");
    Map<String, ByteBuffer> filesFromTar;
    try (TarInMemoryExport memoryTar = new TarInMemoryExport(is)) {
        filesFromTar = memoryTar.unTar();
    } catch (IOException e) {
        throw new RuntimeException(String.format("Exception while getting OVFs files from tar file for domain %s", storageDomainId), e);
    }
    for (Entry<String, ByteBuffer> fileEntry : filesFromTar.entrySet()) {
        if (fileEntry.getKey().endsWith(OVF_FILE_EXT)) {
            String ovfData = new String(fileEntry.getValue().array());
            VmEntityType vmType = getVmEntityType(ovfData);
            ArchitectureType archType = null;
            Guid entityId = getEntityId(fileEntry.getKey());
            String vmName = getEntityName(ovfData);
            try {
                XmlDocument xmlDocument = new XmlDocument(ovfData);
                archType = getOsSection(xmlDocument);
                if (isExternalVM(xmlDocument)) {
                    log.warn("Retrieve an external OVF Entity from storage domain ID '{}' for entity ID '{}'," + " entity name '{}' and VM Type of '{}'." + " This OVF will be ignored since external VMs should not be restored.", storageDomainId, getEntityId(fileEntry.getKey()), getEntityName(ovfData), vmType.name());
                    continue;
                }
                updateUnregisteredDisksWithVMs(unregisteredDisks, entityId, vmName, xmlDocument);
            } catch (Exception e) {
                log.error("Could not parse VM's disks or architecture, file name: {}, content size: {}, error: {}", fileEntry.getKey(), ovfData.length(), e.getMessage());
                log.debug("Exception", e);
                continue;
            }
            // Creates an OVF entity data.
            OvfEntityData ovfEntityData = createOvfEntityData(storageDomainId, ovfData, vmType, vmName, archType, entityId);
            log.info("Retrieve OVF Entity from storage domain ID '{}' for entity ID '{}', entity name '{}' and VM Type of '{}'", storageDomainId, getEntityId(fileEntry.getKey()), getEntityName(ovfData), vmType.name());
            ovfEntityDataFromTar.add(ovfEntityData);
        } else {
            log.info("File '{}' is not an OVF file, will be ignored.", fileEntry.getKey());
        }
    }
    log.info("Finish to fetch OVF files from tar file. The number of OVF entities are {}", ovfEntityDataFromTar.size());
    return ovfEntityDataFromTar;
}
#method_after
public List<OvfEntityData> getOvfEntities(byte[] tar, List<UnregisteredDisk> unregisteredDisks, Guid storageDomainId) {
    List<OvfEntityData> ovfEntityDataFromTar = new ArrayList<>();
    InputStream is = new ByteArrayInputStream(tar);
    log.info("Start fetching OVF files from tar file");
    Map<String, ByteBuffer> filesFromTar;
    try (TarInMemoryExport memoryTar = new TarInMemoryExport(is)) {
        filesFromTar = memoryTar.unTar();
    } catch (IOException e) {
        throw new RuntimeException(String.format("Exception while getting OVFs files from tar file for domain %s", storageDomainId), e);
    }
    for (Entry<String, ByteBuffer> fileEntry : filesFromTar.entrySet()) {
        if (fileEntry.getKey().endsWith(OVF_FILE_EXT)) {
            String ovfData = new String(fileEntry.getValue().array());
            VmEntityType vmType = getVmEntityType(ovfData);
            ArchitectureType archType = null;
            Guid entityId = getEntityId(fileEntry.getKey());
            String vmName = getEntityName(ovfData);
            try {
                XmlDocument xmlDocument = new XmlDocument(ovfData);
                archType = getOsSection(xmlDocument);
                if (isExternalVM(xmlDocument)) {
                    log.warn("Retrieve an external OVF Entity from storage domain ID '{}' for entity ID '{}'," + " entity name '{}' and VM Type of '{}'." + " This OVF will be ignored since external VMs should not be restored.", storageDomainId, getEntityId(fileEntry.getKey()), getEntityName(ovfData), vmType.name());
                    continue;
                }
                updateUnregisteredDisksWithVMs(unregisteredDisks, entityId, vmName, xmlDocument);
            } catch (Exception e) {
                log.error("Could not parse VM's disks or architecture, file name: {}, content size: {}, error: {}", fileEntry.getKey(), ovfData.length(), e.getMessage());
                log.debug("Exception", e);
                continue;
            }
            // Creates an OVF entity data.
            OvfEntityData ovfEntityData = createOvfEntityData(storageDomainId, ovfData, vmType, vmName, archType, entityId);
            log.info("Retrieve OVF Entity from storage domain ID '{}' for entity ID '{}', entity name '{}' and VM Type of '{}'", storageDomainId, getEntityId(fileEntry.getKey()), getEntityName(ovfData), vmType.name());
            ovfEntityDataFromTar.add(ovfEntityData);
        } else {
            log.info("File '{}' is not an OVF file, will be ignored.", fileEntry.getKey());
        }
    }
    log.info("Finish to fetch OVF files from tar file. The number of OVF entities are {}", ovfEntityDataFromTar.size());
    return ovfEntityDataFromTar;
}
#end_block

#method_before
public static boolean isExternalVM(XmlDocument xmlDocument) {
    XmlNode content = xmlDocument.selectSingleNode("//*/Content");
    NodeList nodeList = content.getChildNodes();
    for (int i = 0; i < nodeList.getLength(); i++) {
        Node node = nodeList.item(i);
        if (node.getNodeName().equals(VM_ORIGIN) && node.getChildNodes().item(0) != null) {
            Integer originType = Integer.valueOf(node.getChildNodes().item(0).getNodeValue());
            return OriginType.EXTERNAL == OriginType.forValue(originType);
        }
    }
    return false;
}
#method_after
public boolean isExternalVM(XmlDocument xmlDocument) {
    XmlNode content = xmlDocument.selectSingleNode("//*/Content");
    NodeList nodeList = content.getChildNodes();
    for (int i = 0; i < nodeList.getLength(); i++) {
        Node node = nodeList.item(i);
        if (node.getNodeName().equals(VM_ORIGIN) && node.getChildNodes().item(0) != null) {
            Integer originType = Integer.valueOf(node.getChildNodes().item(0).getNodeValue());
            return OriginType.EXTERNAL == OriginType.forValue(originType);
        }
    }
    return false;
}
#end_block

#method_before
public static void updateUnregisteredDisksWithVMs(List<UnregisteredDisk> unregisteredDisks, Guid entityId, String vmName, XmlDocument xmlDocument) {
    for (Guid diskId : fetchVmDisks(xmlDocument)) {
        UnregisteredDisk unregisterDisk = unregisteredDisks.stream().filter(unregrDisk -> diskId.equals(unregrDisk.getId().getDiskId())).findAny().orElse(null);
        VmBase vm = new VmBase();
        vm.setId(entityId);
        vm.setName(vmName);
        if (unregisterDisk != null) {
            unregisterDisk.getVms().add(vm);
        }
    }
}
#method_after
public void updateUnregisteredDisksWithVMs(List<UnregisteredDisk> unregisteredDisks, Guid entityId, String vmName, XmlDocument xmlDocument) {
    for (Guid diskId : fetchVmDisks(xmlDocument)) {
        UnregisteredDisk unregisterDisk = unregisteredDisks.stream().filter(unregrDisk -> diskId.equals(unregrDisk.getDiskId())).findAny().orElse(null);
        VmBase vm = new VmBase();
        vm.setId(entityId);
        vm.setName(vmName);
        if (unregisterDisk != null) {
            unregisterDisk.getVms().add(vm);
        }
    }
}
#end_block

#method_before
private static ArchitectureType getOsSection(XmlDocument xmlDocument) {
    ArchitectureType archType = null;
    XmlNode content = xmlDocument.selectSingleNode("//*/Content");
    XmlNodeList nodeList = content.selectNodes("Section");
    XmlNode selectedSection = null;
    OsRepository osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    if (nodeList != null) {
        for (XmlNode section : nodeList) {
            String value = section.attributes.get("xsi:type").getValue();
            if (value.equals("ovf:OperatingSystemSection_Type")) {
                selectedSection = section;
                break;
            }
        }
        if (selectedSection != null) {
            int osId = osRepository.getOsIdByUniqueName(selectedSection.innerText);
            archType = osRepository.getArchitectureFromOS(osId);
        }
    }
    return archType;
}
#method_after
private ArchitectureType getOsSection(XmlDocument xmlDocument) {
    ArchitectureType archType = null;
    XmlNode content = xmlDocument.selectSingleNode("//*/Content");
    XmlNodeList nodeList = content.selectNodes("Section");
    XmlNode selectedSection = null;
    if (nodeList != null) {
        for (XmlNode section : nodeList) {
            String value = section.attributes.get("xsi:type").getValue();
            if (value.equals("ovf:OperatingSystemSection_Type")) {
                selectedSection = section;
                break;
            }
        }
        if (selectedSection != null) {
            int osId = osRepository.getOsIdByUniqueName(selectedSection.innerText);
            archType = osRepository.getArchitectureFromOS(osId);
        }
    }
    return archType;
}
#end_block

#method_before
@Test
public void testFetchVmDisks() throws Exception {
    XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
    Set<Guid> disks = OvfUtils.fetchVmDisks(xmlDocument);
    assertNotNull("The list of disks should not be null", disks);
    assertTrue("The list of disks should not be empty", !disks.isEmpty());
}
#method_after
@Test
public void testFetchVmDisks() throws Exception {
    XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
    Set<Guid> disks = ovfUtils.fetchVmDisks(xmlDocument);
    assertNotNull("The list of disks should not be null", disks);
    assertTrue("The list of disks should not be empty", !disks.isEmpty());
}
#end_block

#method_before
@Test
public void testIsExternalVM() throws Exception {
    XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
    assertFalse("VM should not be external VM", OvfUtils.isExternalVM(xmlDocument));
}
#method_after
@Test
public void testIsExternalVM() throws Exception {
    XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
    assertFalse("VM should not be external VM", ovfUtils.isExternalVM(xmlDocument));
}
#end_block

#method_before
@Test
public void testUpdateUnregisteredDisksWithVMsWithEmptyUnregDisks() throws Exception {
    XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
    List<UnregisteredDisk> unregDisks = new ArrayList<>();
    OvfUtils.updateUnregisteredDisksWithVMs(unregDisks, Guid.newGuid(), "TestVM", xmlDocument);
    assertTrue("The list of disks should not be empty", unregDisks.isEmpty());
}
#method_after
@Test
public void testUpdateUnregisteredDisksWithVMsWithEmptyUnregDisks() throws Exception {
    XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
    List<UnregisteredDisk> unregDisks = new ArrayList<>();
    ovfUtils.updateUnregisteredDisksWithVMs(unregDisks, Guid.newGuid(), "TestVM", xmlDocument);
    assertTrue("The list of disks should not be empty", unregDisks.isEmpty());
}
#end_block

#method_before
@Test
public void testUpdateUnregisteredDisksWithVMsWithInitializedUnregDisks() throws Exception {
    XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
    List<UnregisteredDisk> unregDisks = new ArrayList<>();
    DiskImage diskImage = new DiskImage();
    diskImage.setId(Guid.createGuidFromString("8c634412-1e8b-4ef3-bc40-b67a456e9d2f"));
    diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(Guid.createGuidFromString("7e2a7eac-3b76-4d45-a7dd-caae8fe0f588"))));
    UnregisteredDisk unregDisk = new UnregisteredDisk(diskImage);
    unregDisks.add(unregDisk);
    OvfUtils.updateUnregisteredDisksWithVMs(unregDisks, Guid.newGuid(), "TestVM", xmlDocument);
    assertTrue("The list of disks should not be empty", !unregDisks.isEmpty());
    assertTrue("The VMs id is set in the unregisteterd disks", !unregDisks.get(0).getVms().isEmpty());
}
#method_after
@Test
public void testUpdateUnregisteredDisksWithVMsWithInitializedUnregDisks() throws Exception {
    XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
    List<UnregisteredDisk> unregDisks = new ArrayList<>();
    DiskImage diskImage = new DiskImage();
    diskImage.setId(Guid.createGuidFromString("8c634412-1e8b-4ef3-bc40-b67a456e9d2f"));
    diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(Guid.createGuidFromString("7e2a7eac-3b76-4d45-a7dd-caae8fe0f588"))));
    UnregisteredDisk unregDisk = new UnregisteredDisk(diskImage);
    unregDisks.add(unregDisk);
    ovfUtils.updateUnregisteredDisksWithVMs(unregDisks, Guid.newGuid(), "TestVM", xmlDocument);
    assertTrue("The list of disks should not be empty", !unregDisks.isEmpty());
    assertTrue("The VMs id is set in the unregisteterd disks", !unregDisks.get(0).getVms().isEmpty());
}
#end_block

#method_before
protected List<VDS> getAllRunningVdssInPool() {
    return vdsDao.getAllForStoragePoolAndStatus(getStoragePool().getId(), VDSStatus.Up);
}
#method_after
protected List<VDS> getAllRunningVdssInPool() {
    return vdsDao.getAllForStoragePoolAndStatus(getStoragePoolId(), VDSStatus.Up);
}
#end_block

#method_before
protected VDS checkForActiveVds() {
    List<VDS> hosts = vdsDao.getAllForStoragePoolAndStatus(getStoragePool().getId(), VDSStatus.Up);
    if (!hosts.isEmpty()) {
        return hosts.get(new Random().nextInt(hosts.size()));
    }
    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    return null;
}
#method_after
protected VDS checkForActiveVds() {
    List<VDS> hosts = getAllRunningVdssInPool();
    if (!hosts.isEmpty()) {
        return hosts.get(new Random().nextInt(hosts.size()));
    }
    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    return null;
}
#end_block

#method_before
protected void calcStoragePoolStatusByDomainsStatus() {
    StorageDomain masterDomain = storageDomainDao.getStorageDomains(getStoragePool().getId(), StorageDomainType.Master).stream().findFirst().orElse(null);
    // if no master then Uninitialized
    // if master not active maintenance
    StoragePoolStatus newStatus = (masterDomain == null) ? StoragePoolStatus.Uninitialized : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Maintenance) ? StoragePoolStatus.Maintenance : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Active) ? StoragePoolStatus.Up : StoragePoolStatus.NonResponsive;
    if (newStatus != getStoragePool().getStatus()) {
        getCompensationContext().snapshotEntity(getStoragePool());
        getStoragePool().setStatus(newStatus);
        StoragePool poolFromDb = storagePoolDao.get(getStoragePool().getId());
        if ((getStoragePool().getSpmVdsId() == null && poolFromDb.getSpmVdsId() != null) || (getStoragePool().getSpmVdsId() != null && !getStoragePool().getSpmVdsId().equals(poolFromDb.getSpmVdsId()))) {
            getStoragePool().setSpmVdsId(poolFromDb.getSpmVdsId());
        }
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            getStoragePool().setSpmVdsId(null);
        }
        executeInScope(TransactionScopeOption.Required, () -> {
            storagePoolDao.update(getStoragePool());
            return null;
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    }
}
#method_after
protected void calcStoragePoolStatusByDomainsStatus() {
    StorageDomain masterDomain = storageDomainDao.getStorageDomains(getStoragePool().getId(), StorageDomainType.Master).stream().findFirst().orElse(null);
    // if no master then Uninitialized
    // if master not active maintenance
    StoragePoolStatus newStatus = (masterDomain == null) ? StoragePoolStatus.Uninitialized : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Maintenance) ? StoragePoolStatus.Maintenance : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Active) ? StoragePoolStatus.Up : StoragePoolStatus.NonResponsive;
    if (newStatus != getStoragePool().getStatus()) {
        log.info("Update storage pool '{}' status from '{} to '{}'", getStoragePool().getId(), getStoragePool().getStatus(), newStatus);
        getCompensationContext().snapshotEntity(getStoragePool());
        getStoragePool().setStatus(newStatus);
        StoragePool poolFromDb = storagePoolDao.get(getStoragePool().getId());
        if ((getStoragePool().getSpmVdsId() == null && poolFromDb.getSpmVdsId() != null) || (getStoragePool().getSpmVdsId() != null && !getStoragePool().getSpmVdsId().equals(poolFromDb.getSpmVdsId()))) {
            log.info("Set storage pool '{}' vds Id to '{}'", getStoragePool().getId(), poolFromDb.getSpmVdsId());
            getStoragePool().setSpmVdsId(poolFromDb.getSpmVdsId());
        }
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            log.info("Set storage pool '{}' vds Id to null", getStoragePool().getId(), poolFromDb.getSpmVdsId());
            getStoragePool().setSpmVdsId(null);
        }
        executeInScope(TransactionScopeOption.Required, () -> {
            storagePoolDao.update(getStoragePool());
            return null;
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    }
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk(Guid storageDomainId, Guid storagePoolId) {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList<>(getAllOVFDisks(storageDomainId, storagePoolId));
    if (!ovfStoreDiskImages.isEmpty()) {
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    ActionReturnValue actionReturnValueReturnValue = runInternalAction(ActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), storageDomainId, ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(actionReturnValueReturnValue.getInternalVdsmTaskIdList());
                    if (actionReturnValueReturnValue.getSucceeded()) {
                        List<OvfEntityData> returnedMap = OvfUtils.getOvfEntities(actionReturnValueReturnValue.getActionReturnValue(), unregisteredDisks, storageDomainId);
                        return returnedMap;
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), storageDomainId);
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), storageDomainId, e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            } else {
                log.error("Couldn't find additional ovf store to retrieve the ovf data from in storage domain '{}'", storageDomainId);
                break;
            }
        }
        AuditLogable logable = new AuditLogableImpl();
        logable.setStorageDomainId(storageDomainId);
        logable.setStorageDomainName(storageDomainStaticDao.get(storageDomainId).getName());
        auditLogDirector.log(logable, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", storageDomainId);
    }
    return new ArrayList<>();
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk(Guid storageDomainId, Guid storagePoolId) {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList<>(getAllOVFDisks(storageDomainId, storagePoolId));
    if (!ovfStoreDiskImages.isEmpty()) {
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    ActionReturnValue actionReturnValueReturnValue = runInternalAction(ActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), storageDomainId, ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(actionReturnValueReturnValue.getInternalVdsmTaskIdList());
                    if (actionReturnValueReturnValue.getSucceeded()) {
                        List<OvfEntityData> returnedMap = ovfUtils.getOvfEntities(actionReturnValueReturnValue.getActionReturnValue(), unregisteredDisks, storageDomainId);
                        return returnedMap;
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), storageDomainId);
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), storageDomainId, e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            } else {
                log.error("Couldn't find additional ovf store to retrieve the ovf data from in storage domain '{}'", storageDomainId);
                break;
            }
        }
        AuditLogable logable = new AuditLogableImpl();
        logable.setStorageDomainId(storageDomainId);
        logable.setStorageDomainName(storageDomainStaticDao.get(storageDomainId).getName());
        auditLogDirector.log(logable, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", storageDomainId);
    }
    return new ArrayList<>();
}
#end_block

#method_before
protected void initUnregisteredDisksToDB(Guid storageDomainId) {
    // Using a Set to later use a an O(1) HashSet#contains
    Set<DiskImage> existingDisks = new HashSet<>(diskImageDao.getAllForStorageDomain(storageDomainId));
    List<UnregisteredDisk> unregisteredDisksToSave = new LinkedList<>();
    for (Object unregisteredDiskObj : unregisteredDisks) {
        UnregisteredDisk unregisteredDisk = (UnregisteredDisk) unregisteredDiskObj;
        if (existingDisks.contains(unregisteredDisk.getDiskImage())) {
            log.info("Disk {} with id '{}' already exists in the engine, therefore will not be " + "part of the unregistered disks.", unregisteredDisk.getDiskAlias(), unregisteredDisk.getDiskImage().getId());
            continue;
        }
        unregisteredDisksToSave.add(unregisteredDisk);
        log.info("Adding unregistered disk of disk id '{}' and disk alias '{}'", unregisteredDisk.getDiskImage().getId(), unregisteredDisk.getDiskAlias());
    }
    unregisteredDisksDao.saveAllInBatch(unregisteredDisksToSave);
}
#method_after
protected void initUnregisteredDisksToDB(Guid storageDomainId) {
    // Using a Set to later use an O(1) HashSet#contains
    Set<Guid> existingDiskIds = diskImageDao.getAllForStorageDomain(storageDomainId).stream().map(DiskImage::getId).collect(Collectors.toSet());
    for (UnregisteredDisk unregisteredDisk : unregisteredDisks) {
        if (existingDiskIds.contains(unregisteredDisk.getDiskId())) {
            log.info("Disk {} with id '{}' already exists in the engine, therefore will not be " + "part of the unregistered disks.", unregisteredDisk.getDiskAlias(), unregisteredDisk.getDiskId());
            continue;
        }
        unregisteredDisksDao.removeUnregisteredDisk(unregisteredDisk.getDiskId(), storageDomainId);
        unregisteredDisksDao.saveUnregisteredDisk(unregisteredDisk);
        log.info("Adding unregistered disk of disk id '{}' and disk alias '{}'", unregisteredDisk.getDiskId(), unregisteredDisk.getDiskAlias());
    }
}
#end_block

#method_before
protected String getJsonDiskDescription(Disk disk) {
    try {
        return MetadataDiskDescriptionHandler.getInstance().generateJsonDiskDescription(disk);
    } catch (IOException e) {
        log.error("Exception while generating json for disk. ERROR: '{}'", e);
        return StringUtils.EMPTY;
    }
}
#method_after
protected String getJsonDiskDescription(Disk disk) {
    try {
        return metadataDiskDescriptionHandler.generateJsonDiskDescription(disk);
    } catch (IOException e) {
        log.error("Exception while generating json for disk. ERROR: '{}'", e);
        return StringUtils.EMPTY;
    }
}
#end_block

#method_before
private void showNetwork(LogicalNetworkModel networkModel) {
    boolean descriptionSectionHasValues = false;
    contents.removeAllRows();
    Network entity = networkModel.getNetwork();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName(), BACKGROUND_COLOR));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageWithText(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
        descriptionSectionHasValues = true;
    } else {
        if (networkModel.getErrorMessage() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, templates.maxWidthNteworkItemPopup(networkModel.getErrorMessage())));
            descriptionSectionHasValues = true;
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
            descriptionSectionHasValues = true;
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addSyncDiff(networkModel);
            descriptionSectionHasValues = true;
        }
    }
    if (descriptionSectionHasValues) {
        insertHorizontalLine();
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    boolean isGluster = false;
    boolean isDefaultRoute = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
        isGluster = entity.getCluster().isGluster();
        isDefaultRoute = entity.getCluster().isDefaultRoute();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration || isGluster || isDefaultRoute) {
        // $NON-NLS-1$
        addRow(templates.strongTextWithColor(constants.usageItemInfo() + ":", WHITE_TEXT_COLOR));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo(), TEXT_COLOR));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo(), TEXT_COLOR));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo(), TEXT_COLOR));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo(), TEXT_COLOR));
        }
        if (isGluster) {
            addRow(templates.imageTextSetupNetworkUsage(glusterNwImage, constants.glusterNwItemInfo(), TEXT_COLOR));
        }
        if (isDefaultRoute) {
            addRow(templates.imageTextSetupNetworkUsage(defaultRouteImage, constants.defaultRouteItemInfo(), TEXT_COLOR));
        }
        insertHorizontalLine();
    }
    // Mtu
    if (!entity.isExternal()) {
        final String mtuValue = entity.getMtu() == 0 ? messages.defaultMtu(defaultMtu) : String.valueOf(entity.getMtu());
        // $NON-NLS-1$
        final String mtu = templates.strongTextWithColor(constants.mtuItemInfo(), WHITE_TEXT_COLOR).asString() + ": " + templates.coloredText(mtuValue, TEXT_COLOR).asString();
        addRow(SafeHtmlUtils.fromTrustedString(mtu));
    }
    // Boot protocol and IP info
    if (networkModel.isAttached()) {
        insertHorizontalLine();
        addBootProtoAndIpInfo(networkModel.hasVlan() && networkModel.getVlanDevice() != null ? networkModel.getVlanDevice() : networkModel.getAttachedToNic().getOriginalIface());
    }
}
#method_after
private void showNetwork(LogicalNetworkModel networkModel) {
    boolean descriptionSectionHasValues = false;
    contents.removeAllRows();
    Network entity = networkModel.getNetwork();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName(), BACKGROUND_COLOR));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageWithText(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
        descriptionSectionHasValues = true;
    } else {
        if (networkModel.getErrorMessage() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, templates.maxWidthNteworkItemPopup(networkModel.getErrorMessage())));
            descriptionSectionHasValues = true;
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
            descriptionSectionHasValues = true;
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addSyncDiff(networkModel);
            descriptionSectionHasValues = true;
        }
    }
    if (descriptionSectionHasValues) {
        insertHorizontalLine();
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    boolean isGluster = false;
    boolean isDefaultRoute = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
        isGluster = entity.getCluster().isGluster();
        isDefaultRoute = entity.getCluster().isDefaultRoute();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration || isGluster || isDefaultRoute) {
        // $NON-NLS-1$
        addRow(templates.strongTextWithColor(constants.usageItemInfo() + ":", WHITE_TEXT_COLOR));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo(), TEXT_COLOR));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo(), TEXT_COLOR));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo(), TEXT_COLOR));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo(), TEXT_COLOR));
        }
        if (isGluster) {
            addRow(templates.imageTextSetupNetworkUsage(glusterNwImage, constants.glusterNwItemInfo(), TEXT_COLOR));
        }
        if (isDefaultRoute) {
            addRow(templates.imageTextSetupNetworkUsage(defaultRouteImage, constants.defaultRouteItemInfo(), TEXT_COLOR));
        }
        insertHorizontalLine();
    }
    // Mtu
    if (!entity.isExternal()) {
        final String mtuValue = entity.getMtu() == 0 ? messages.defaultMtu(defaultMtu) : String.valueOf(entity.getMtu());
        // $NON-NLS-1$
        final String mtu = templates.strongTextWithColor(constants.mtuItemInfo(), WHITE_TEXT_COLOR).asString() + ": " + templates.coloredText(mtuValue, TEXT_COLOR).asString();
        addRow(SafeHtmlUtils.fromTrustedString(mtu));
    }
    // Boot protocol and IP info
    if (networkModel.isAttached()) {
        if (networkModel.hasVlan() && networkModel.getVlanDevice() != null) {
            addBootProtoAndIpInfo(networkModel.getVlanDevice());
        } else if (!networkModel.hasVlan()) {
            addBootProtoAndIpInfo(networkModel.getAttachedToNic().getOriginalIface());
        }
    }
}
#end_block

#method_before
private void addBootProtoAndIpInfo(VdsNetworkInterface iface) {
    // IPv4
    // $NON-NLS-1$
    addRow(templates.strongTextWithColor(constants.ipv4ItemInfo() + ":", WHITE_TEXT_COLOR));
    Ipv4BootProtocol ipv4BootProtocol = iface.getIpv4BootProtocol();
    addRow(constants.bootProtocolItemInfo(), IPV4_RENDERER.render(ipv4BootProtocol));
    addNonNullOrEmptyValueRow(constants.addressItemInfo(), iface.getIpv4Address());
    addNonNullOrEmptyValueRow(constants.subnetItemInfo(), iface.getIpv4Subnet());
    addNonNullOrEmptyValueRow(constants.gatewayItemInfo(), iface.getIpv4Gateway());
    // IPv6
    // $NON-NLS-1$
    addRow(templates.strongTextWithColor(constants.ipv6ItemInfo() + ":", WHITE_TEXT_COLOR));
    Ipv6BootProtocol ipv6BootProtocol = iface.getIpv6BootProtocol();
    addRow(constants.bootProtocolItemInfo(), IPV6_RENDERER.render(ipv6BootProtocol));
    addNonNullOrEmptyValueRow(constants.addressItemInfo(), iface.getIpv6Address());
    addNonNullOrEmptyValueRow(constants.prefixItemInfo(), iface.getIpv6Prefix() != null ? iface.getIpv6Prefix().toString() : null);
    addNonNullOrEmptyValueRow(constants.gatewayItemInfo(), iface.getIpv6Gateway());
}
#method_after
private void addBootProtoAndIpInfo(VdsNetworkInterface iface) {
    insertHorizontalLine();
    // IPv4
    // $NON-NLS-1$
    addRow(templates.strongTextWithColor(constants.ipv4ItemInfo() + ":", WHITE_TEXT_COLOR));
    Ipv4BootProtocol ipv4BootProtocol = iface.getIpv4BootProtocol();
    addRow(constants.bootProtocolItemInfo(), IPV4_RENDERER.render(ipv4BootProtocol));
    addNonNullOrEmptyValueRow(constants.addressItemInfo(), iface.getIpv4Address());
    addNonNullOrEmptyValueRow(constants.subnetItemInfo(), iface.getIpv4Subnet());
    addNonNullOrEmptyValueRow(constants.gatewayItemInfo(), iface.getIpv4Gateway());
    // IPv6
    // $NON-NLS-1$
    addRow(templates.strongTextWithColor(constants.ipv6ItemInfo() + ":", WHITE_TEXT_COLOR));
    Ipv6BootProtocol ipv6BootProtocol = iface.getIpv6BootProtocol();
    addRow(constants.bootProtocolItemInfo(), IPV6_RENDERER.render(ipv6BootProtocol));
    addNonNullOrEmptyValueRow(constants.addressItemInfo(), iface.getIpv6Address());
    addNonNullOrEmptyValueRow(constants.prefixItemInfo(), iface.getIpv6Prefix() != null ? iface.getIpv6Prefix().toString() : null);
    addNonNullOrEmptyValueRow(constants.gatewayItemInfo(), iface.getIpv6Gateway());
}
#end_block

#method_before
protected boolean connectLunDisks(Guid hostId) {
    if (getVm().getDiskMap().isEmpty()) {
        vmHandler.updateDisksFromDb(getVm());
    }
    List<LunDisk> lunDisks = DisksFilter.filterLunDisks(getVm().getDiskMap().values());
    Set<String> connections = new HashSet<>();
    for (LunDisk lunDisk : lunDisks) {
        LUNs lun = lunDisk.getLun();
        lun.setLunConnections(new ArrayList<>(storageServerConnectionDao.getAllForLun(lun.getLUNId())));
        // optimization - don't connect the target if was connected already (check all its connections)
        if (connections.containsAll(lun.getLunConnections().stream().map(c -> c.getConnection()).collect(Collectors.toList()))) {
            continue;
        }
        if (lun.getLunConnections().isEmpty()) {
            return false;
        }
        if (!connect(hostId, lun)) {
            log.info("Failed to connect a lun disk to vdsm '{}' skipping it", hostId);
            return false;
        }
        connections.addAll(lun.getLunConnections().stream().map(c -> c.getConnection()).collect(Collectors.toList()));
    }
    return true;
}
#method_after
protected boolean connectLunDisks(Guid hostId) {
    if (getVm().getDiskMap().isEmpty()) {
        vmHandler.updateDisksFromDb(getVm());
    }
    List<LunDisk> lunDisks = DisksFilter.filterLunDisks(getVm().getDiskMap().values());
    Map<StorageType, List<StorageServerConnections>> connectionsByType = lunDisks.stream().flatMap(d -> storageServerConnectionDao.getAllForLun(d.getLun().getLUNId()).stream()).distinct().collect(groupingBy(StorageServerConnections::getStorageType, toList()));
    return connectionsByType.entrySet().stream().map(entry -> runVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(hostId, getStoragePoolId(), entry.getKey(), entry.getValue()))).noneMatch(vdsReturnValue -> !vdsReturnValue.getSucceeded());
}
#end_block

#method_before
@Override
public void delay(Guid vdsId) {
    log.debug("Try to wait for te engine update the host memory and cpu stats");
    try {
        // time out waiting for an update is the highest between the refresh rate and the last update elapsed time
        // but still no higher than a configurable max to prevent very long updates to stall command.
        long t = Math.max(resourceManager.getVdsManager(vdsId).getLastUpdateElapsed(), TimeUnit.SECONDS.toMillis(Config.<Integer>getValue(VdsRefreshRate)));
        t = Math.min(Config.<Integer>getValue(ConfigValues.ThrottlerMaxWaitForVdsUpdateInMillis), t);
        // wait for the run-time refresh to decrease any current powering-up VMs
        getBlockingQueue(vdsId).poll(t, TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
    // ignore
    }
}
#method_after
@Override
public void delay(Guid vdsId) {
    log.debug("Try to wait for te engine update the host memory and cpu stats");
    try {
        // time out waiting for an update is the highest between the refresh rate and the last update elapsed time
        // but still no higher than a configurable max to prevent very long updates to stall command.
        long t = Math.max(resourceManager.getVdsManager(vdsId).getLastUpdateElapsed(), TimeUnit.SECONDS.toMillis(Config.<Long>getValue(VdsRefreshRate)));
        t = Math.min(Config.<Integer>getValue(ConfigValues.ThrottlerMaxWaitForVdsUpdateInMillis), t);
        // wait for the run-time refresh to decrease any current powering-up VMs
        getBlockingQueue(vdsId).poll(t, TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
    // ignore
    }
}
#end_block

#method_before
private void setCreateVmVDSMethod() {
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setReturnValue(VMStatus.Up);
    when(vdsBrokerFrontend.runAsyncVdsCommand(eq(VDSCommandType.Create), any(), any())).thenReturn(returnValue);
}
#method_after
private void setCreateVmVDSMethod() {
    VDSReturnValue returnValue = succesfull();
    returnValue.setReturnValue(VMStatus.Up);
    when(vdsBrokerFrontend.runAsyncVdsCommand(eq(VDSCommandType.Create), any(), any())).thenReturn(returnValue);
}
#end_block

#method_before
@Before
public void setUp() {
    mockCpuFlagsManagerHandler();
    when(osRepository.isWindows(anyInt())).thenReturn(false);
    when(osRepository.isCpuSupported(anyInt(), any(), any())).thenReturn(true);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    vmHandler.init();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    doReturn(Collections.emptyMap()).when(command).flushPassthroughVnicToVfMap();
    mockBackend();
}
#method_after
@Before
public void setUp() {
    mockCpuFlagsManagerHandler();
    when(osRepository.isWindows(anyInt())).thenReturn(false);
    when(osRepository.isCpuSupported(anyInt(), any(), any())).thenReturn(true);
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    vmHandler.init();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    doReturn(Collections.emptyMap()).when(command).flushPassthroughVnicToVfMap();
    mockBackend();
}
#end_block

#method_before
@Override
public void addModelListeners() {
    super.addModelListeners();
    getTable().getSelectionModel().addSelectionChangeHandler(event -> {
        getModelProvider().setSelectedItems(getTable().getSelectedItems());
    });
}
#method_after
@Override
public void addModelListeners() {
    super.addModelListeners();
    getTable().getSelectionModel().addSelectionChangeHandler(event -> getModelProvider().setSelectedItems(getTable().getSelectedItems()));
}
#end_block

#method_before
@Override
public void addModelListeners() {
    super.addModelListeners();
    getTable().getSelectionModel().addSelectionChangeHandler(event -> {
        getModelProvider().setSelectedItems(getTable().getSelectedItems());
    });
}
#method_after
@Override
public void addModelListeners() {
    super.addModelListeners();
    getTable().getSelectionModel().addSelectionChangeHandler(event -> getModelProvider().setSelectedItems(getTable().getSelectedItems()));
}
#end_block

#method_before
@Override
public void addModelListeners() {
    super.addModelListeners();
    getTable().getSelectionModel().addSelectionChangeHandler(event -> {
        getModelProvider().setSelectedItems(getTable().getSelectedItems());
    });
}
#method_after
@Override
public void addModelListeners() {
    super.addModelListeners();
    getTable().getSelectionModel().addSelectionChangeHandler(event -> getModelProvider().setSelectedItems(getTable().getSelectedItems()));
}
#end_block

#method_before
@Override
public void setItems(Collection<Snapshot> value) {
    List<Snapshot> snapshots = value != null ? new ArrayList<>(value) : new ArrayList<>();
    snapshots.forEach(snapshot -> {
        SnapshotModel snapshotModel = snapshotsMap.computeIfAbsent(snapshot.getId(), id -> new SnapshotModel());
        snapshotModel.setEntity(snapshot);
    });
    // Filter active snapshot when in preview mode
    boolean hasNoPreviewSnapshot = snapshots.stream().noneMatch(s -> s.getType() == SnapshotType.PREVIEW);
    snapshots = snapshots.stream().filter(snapshot -> snapshot.getType() != SnapshotType.ACTIVE || hasNoPreviewSnapshot).collect(Collectors.toList());
    snapshots.sort(comparator);
    if (snapshots.stream().anyMatch(s -> s.getStatus() == SnapshotStatus.IN_PREVIEW)) {
        updatePreviewedDiskSnapshots(snapshots);
    } else {
        updateItems(snapshots);
    }
}
#method_after
@Override
public void setItems(Collection<Snapshot> value) {
    List<Snapshot> snapshots = value != null ? new ArrayList<>(value) : new ArrayList<>();
    snapshots.forEach(snapshot -> {
        SnapshotModel snapshotModel = snapshotsMap.computeIfAbsent(snapshot.getId(), id -> new SnapshotModel());
        snapshotModel.setEntity(snapshot);
    });
    // Filter active snapshot when in preview mode
    boolean hasNoPreviewSnapshot = snapshots.stream().noneMatch(s -> s.getType() == SnapshotType.PREVIEW);
    snapshots = snapshots.stream().filter(snapshot -> snapshot.getType() != SnapshotType.ACTIVE || hasNoPreviewSnapshot).sorted(comparator).collect(Collectors.toList());
    if (snapshots.stream().anyMatch(s -> s.getStatus() == SnapshotStatus.IN_PREVIEW)) {
        updatePreviewedDiskSnapshots(snapshots);
    } else {
        updateItems(snapshots);
    }
}
#end_block

#method_before
private void addDevicesToParams(AddVmParameters params, Vm vm, VmTemplate template, InstanceType instanceType, VmStatic vmStatic, Cluster cluster) {
    Guid templateId = template != null ? template.getId() : null;
    Guid instanceTypeId = instanceType != null ? instanceType.getId() : null;
    if (vm.isSetVirtioScsi()) {
        params.setVirtioScsiEnabled(vm.getVirtioScsi().isEnabled());
    } else {
        // it is not defined on the template
        params.setVirtioScsiEnabled(instanceTypeId != null ? !VmHelper.getVirtioScsiControllersForEntity(this, instanceTypeId).isEmpty() : null);
    }
    if (vm.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(vm.isSoundcardEnabled());
    } else if (instanceTypeId != null || templateId != null) {
        params.setSoundDeviceEnabled(!VmHelper.getSoundDevicesForEntity(this, instanceTypeId != null ? instanceTypeId : templateId).isEmpty());
    }
    if (vm.isSetMemoryPolicy()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    } else if (shouldCopyDevice(SimpleDependencyInjector.getInstance().get(OsRepository.class).isBalloonEnabled(vmStatic.getOsId(), cluster.getCompatibilityVersion()), templateId, instanceTypeId) && (instanceTypeId != null || templateId != null)) {
        params.setBalloonEnabled(VmHelper.isMemoryBalloonEnabledForEntity(this, instanceTypeId != null ? instanceTypeId : templateId));
    }
    if (vm.isSetConsole()) {
        params.setConsoleEnabled(vm.getConsole().isEnabled());
    } else if (templateId != null || instanceType != null) {
        params.setConsoleEnabled(!getConsoleDevicesForEntity(instanceTypeId != null ? instanceTypeId : templateId).isEmpty());
    }
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    } else if (instanceTypeId != null || templateId != null) {
        copyRngDeviceFromTemplateOrInstanceType(params, vmStatic, cluster, templateId, instanceTypeId);
    }
}
#method_after
private void addDevicesToParams(AddVmParameters params, Vm vm, VmTemplate template, InstanceType instanceType, VmStatic vmStatic, Cluster cluster) {
    Guid templateId = template != null ? template.getId() : null;
    Guid instanceTypeId = instanceType != null ? instanceType.getId() : null;
    if (vm.isSetVirtioScsi()) {
        params.setVirtioScsiEnabled(vm.getVirtioScsi().isEnabled());
    } else {
        // it is not defined on the template
        params.setVirtioScsiEnabled(instanceTypeId != null ? !VmHelper.getVirtioScsiControllersForEntity(this, instanceTypeId).isEmpty() : null);
    }
    if (vm.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(vm.isSoundcardEnabled());
    } else if (instanceTypeId != null || templateId != null) {
        params.setSoundDeviceEnabled(!VmHelper.getSoundDevicesForEntity(this, instanceTypeId != null ? instanceTypeId : templateId).isEmpty());
    }
    if (vm.isSetMemoryPolicy()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    } else if (shouldCopyDevice(SimpleDependencyInjector.getInstance().get(OsRepository.class).isBalloonEnabled(vmStatic.getOsId(), cluster.getCompatibilityVersion()), templateId, instanceTypeId) && (instanceTypeId != null || templateId != null)) {
        params.setBalloonEnabled(VmHelper.isMemoryBalloonEnabledForEntity(this, instanceTypeId != null ? instanceTypeId : templateId));
    }
    if (vm.isSetConsole()) {
        params.setConsoleEnabled(vm.getConsole().isEnabled());
    } else if (templateId != null || instanceTypeId != null) {
        params.setConsoleEnabled(!getConsoleDevicesForEntity(instanceTypeId != null ? instanceTypeId : templateId).isEmpty());
    }
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    } else if (instanceTypeId != null || templateId != null) {
        copyRngDeviceFromTemplateOrInstanceType(params, vmStatic, cluster, templateId, instanceTypeId);
    }
}
#end_block

#method_before
@Override
public void setItems(Collection value) {
    ArrayList<Snapshot> snapshots = value != null ? Linq.<Snapshot>cast(value) : new ArrayList<Snapshot>();
    Collections.sort(snapshots, comparator);
    ArrayList<Snapshot> sortedSnapshots = new ArrayList<>();
    for (Snapshot snapshot : snapshots) {
        SnapshotModel snapshotModel = snapshotsMap.get(snapshot.getId());
        if (snapshotModel == null) {
            snapshotModel = new SnapshotModel();
            snapshotsMap.put(snapshot.getId(), snapshotModel);
        }
        snapshotModel.setEntity(snapshot);
        // Remove active snapshot when in preview mode
        if (snapshot.getType() != SnapshotType.ACTIVE || getInType(SnapshotType.PREVIEW, snapshots) == null) {
            sortedSnapshots.add(snapshot);
        }
    }
    if (getInPreview(sortedSnapshots) != null) {
        updatePreviewedDiskSnapshots(sortedSnapshots);
    } else {
        updateItems(sortedSnapshots);
    }
}
#method_after
@Override
public void setItems(Collection value) {
    ArrayList<Snapshot> snapshots = value != null ? Linq.<Snapshot>cast(value) : new ArrayList<Snapshot>();
    ArrayList<Snapshot> sortedSnapshots = new ArrayList<>();
    for (Snapshot snapshot : snapshots) {
        SnapshotModel snapshotModel = snapshotsMap.get(snapshot.getId());
        if (snapshotModel == null) {
            snapshotModel = new SnapshotModel();
            snapshotsMap.put(snapshot.getId(), snapshotModel);
        }
        snapshotModel.setEntity(snapshot);
        // Remove active snapshot when in preview mode
        if (snapshot.getType() != SnapshotType.ACTIVE || getInType(SnapshotType.PREVIEW, snapshots) == null) {
            sortedSnapshots.add(snapshot);
        }
    }
    Collections.sort(sortedSnapshots, comparator);
    if (getInPreview(sortedSnapshots) != null) {
        updatePreviewedDiskSnapshots(sortedSnapshots);
    } else {
        updateItems(sortedSnapshots);
    }
}
#end_block

#method_before
@Override
public void executeCommand() {
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupId()));
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    VDSReturnValue vdsReturnValue = null;
    try {
        vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, createVDSParameters());
    } catch (EngineException e) {
        log.error("Failed to delete image {}/{}. Retrying ...", getParameters().getImageGroupId(), getParameters().getImageList().stream().findFirst(), e);
        setSucceeded(true);
        setCommandStatus(CommandStatus.ACTIVE);
        return;
    }
    if (vdsReturnValue != null && vdsReturnValue.getCreationInfo() != null) {
        getParameters().setVdsmTaskIds(new ArrayList<>());
        Guid result = createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId());
        getReturnValue().getInternalVdsmTaskIdList().add(result);
        getReturnValue().getVdsmTaskIdList().add(result);
        getParameters().getVdsmTaskIds().add(result);
        setSucceeded(vdsReturnValue.getSucceeded());
        setCommandStatus(CommandStatus.SUCCEEDED);
        log.info("Successfully started task to remove orphaned volumes resulting from live merge");
    }
}
#method_after
@Override
public void executeCommand() {
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupId()));
    VDSReturnValue vdsReturnValue = null;
    try {
        vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, createVDSParameters());
    } catch (EngineException e) {
        log.error("Failed to delete image {}/{}", getParameters().getImageGroupId(), getParameters().getImageList().stream().findFirst().get(), e);
    }
    if (vdsReturnValue != null && vdsReturnValue.getCreationInfo() != null) {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        getParameters().setVdsmTaskIds(new ArrayList<>());
        Guid result = createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId());
        getReturnValue().getInternalVdsmTaskIdList().add(result);
        getReturnValue().getVdsmTaskIdList().add(result);
        getParameters().getVdsmTaskIds().add(result);
        setSucceeded(vdsReturnValue.getSucceeded());
        setCommandStatus(CommandStatus.SUCCEEDED);
        log.info("Successfully started task to remove orphaned volumes resulting from live merge");
    } else {
        log.info("Retrying deleting image {}/{}", getParameters().getImageGroupId(), getParameters().getImageList().stream().findFirst().get());
        setSucceeded(true);
        setCommandStatus(CommandStatus.ACTIVE);
    }
}
#end_block

#method_before
private Set<Guid> getVolumeChain() {
    Map[] vms = null;
    try {
        vms = (Map[]) runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(getParameters().getVdsId(), Collections.singletonList(getParameters().getVmId()))).getReturnValue();
    } catch (EngineException e) {
    // Do nothing, just don't fail the whole live merge operation
    }
    if (vms == null || vms.length == 0) {
        log.error("Failed to retrieve VM information");
        return null;
    }
    Map vm = vms[0];
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received incomplete VM information");
        return null;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    if (!vmId.equals(getParameters().getVmId())) {
        log.error("Invalid VM returned when querying status: expected '{}', got '{}'", getParameters().getVmId(), vmId);
        return null;
    }
    Set<Guid> images = new HashSet<>();
    DiskImage activeDiskImage = getParameters().getActiveImage();
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (VdsProperties.Disk.equals(device.get(VdsProperties.Type)) && activeDiskImage.getId().equals(Guid.createGuidFromString((String) device.get(VdsProperties.ImageId)))) {
            Object[] volumeChain = (Object[]) device.get("volumeChain");
            for (Object v : volumeChain) {
                Map<String, Object> volume = (Map<String, Object>) v;
                images.add(Guid.createGuidFromString((String) volume.get(VdsProperties.VolumeId)));
            }
            break;
        }
    }
    return images;
}
#method_after
private Set<Guid> getVolumeChain() {
    Map[] vms = null;
    try {
        vms = (Map[]) runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(getParameters().getVdsId(), Collections.singletonList(getParameters().getVmId()))).getReturnValue();
    } catch (EngineException e) {
        log.error("Failed to retrieve images list of VM {}. Retrying ...", getParameters().getVmId(), e);
    }
    if (vms == null || vms.length == 0) {
        log.error("Failed to retrieve VM information");
        return null;
    }
    Map vm = vms[0];
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received incomplete VM information");
        return null;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    if (!vmId.equals(getParameters().getVmId())) {
        log.error("Invalid VM returned when querying status: expected '{}', got '{}'", getParameters().getVmId(), vmId);
        return null;
    }
    Set<Guid> images = new HashSet<>();
    DiskImage activeDiskImage = getParameters().getActiveImage();
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (VdsProperties.Disk.equals(device.get(VdsProperties.Type)) && activeDiskImage.getId().equals(Guid.createGuidFromString((String) device.get(VdsProperties.ImageId)))) {
            Object[] volumeChain = (Object[]) device.get("volumeChain");
            for (Object v : volumeChain) {
                Map<String, Object> volume = (Map<String, Object>) v;
                images.add(Guid.createGuidFromString((String) volume.get(VdsProperties.VolumeId)));
            }
            break;
        }
    }
    return images;
}
#end_block

#method_before
public int getMaxMaxMemorySize(Integer osId, Version compatVersion) {
    if (osId == null) {
        return getMaxMaxMemoryForAllOss();
    }
    final ConfigValues maxMaxMemoryConfigValue = getMaxMaxMemoryConfigValue(osId);
    return (Integer) getConfigValuePreConvertedOptionalVersion(maxMaxMemoryConfigValue, compatVersion);
}
#method_after
public int getMaxMaxMemorySize(Integer osId, Version compatVersion) {
    String usedVersion = compatVersion != null ? compatVersion.getValue() : Version.getLast().getValue();
    if (osId == null) {
        return getMaxMaxMemoryForAllOss(usedVersion);
    }
    final ConfigValues maxMaxMemoryConfigValue = getMaxMaxMemoryConfigValue(osId);
    return (Integer) getConfigValuePreConverted(maxMaxMemoryConfigValue, usedVersion);
}
#end_block

#method_before
private int getMaxMaxMemoryForAllOss() {
    final int x86_32MaxMaxMemory = (Integer) getConfigValuePreConverted(ConfigValues.VM32BitMaxMemorySizeInMB);
    final int x86_64MaxMaxMemory = (Integer) getConfigValuePreConverted(ConfigValues.VM64BitMaxMemorySizeInMB);
    final int ppc64MaxMaxMemory = (Integer) getConfigValuePreConverted(ConfigValues.VMPpc64BitMaxMemorySizeInMB);
    return Math.max(Math.max(x86_32MaxMaxMemory, x86_64MaxMaxMemory), ppc64MaxMaxMemory);
}
#method_after
private int getMaxMaxMemoryForAllOss(String version) {
    final int x86_32MaxMaxMemory = (Integer) getConfigValuePreConverted(ConfigValues.VM32BitMaxMemorySizeInMB, version);
    final int x86_64MaxMaxMemory = (Integer) getConfigValuePreConverted(ConfigValues.VM64BitMaxMemorySizeInMB, version);
    final int ppc64MaxMaxMemory = (Integer) getConfigValuePreConverted(ConfigValues.VMPpc64BitMaxMemorySizeInMB, version);
    return Math.max(Math.max(x86_32MaxMaxMemory, x86_64MaxMaxMemory), ppc64MaxMaxMemory);
}
#end_block

#method_before
public void getAllProvidersByType(AsyncQuery<List<Provider<?>>> aQuery, ProviderType providerType) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(QueryType.GetAllProviders, new GetAllProvidersParameters(providerType), aQuery);
}
#method_after
public void getAllProvidersByType(AsyncQuery<List<Provider<?>>> aQuery, ProviderType... providerTypes) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(QueryType.GetAllProviders, new GetAllProvidersParameters(providerTypes), aQuery);
}
#end_block

#method_before
private List<String> getSupportedVersions(ConfigValues option) {
    List<String> versions = new ArrayList<>();
    for (Entry<KeyValuePairCompat<ConfigValues, String>, Object> entry : cachedConfigValuesPreConvert.entrySet()) {
        if (entry.getKey().getKey() == option && (Boolean) entry.getValue()) {
            versions.add(entry.getKey().getValue());
        }
    }
    /* because if there is no special value for 'general' version in db then a record for 'general' is added with
         * value based on ConfigValues > @DefaultValueAttribute
         */
    if (versions.size() > 1 && versions.contains(GENERAL)) {
        versions.remove(GENERAL);
    }
    return versions;
}
#method_after
private List<String> getSupportedVersions(ConfigValues option) {
    List<String> versions = new ArrayList<>();
    for (Entry<KeyValuePairCompat<ConfigValues, String>, Object> entry : cachedConfigValuesPreConvert.entrySet()) {
        if (entry.getKey().getKey() == option && (Boolean) entry.getValue()) {
            versions.add(entry.getKey().getValue());
        }
    }
    return versions;
}
#end_block

#method_before
private void initNetworkProvidersList() {
    startProgress();
    AsyncDataProvider.getInstance().getAllProvidersByTypes(new AsyncQuery<>(result -> {
        stopProgress();
        List<Provider<OpenstackNetworkProviderProperties>> providers = (List) result;
        providers.add(0, null);
        getNetworkProviders().setItems(providers);
        getNetworkProviders().setSelectedItem(null);
    }), ProviderType.OPENSTACK_NETWORK, ProviderType.EXTERNAL_NETWORK);
}
#method_after
private void initNetworkProvidersList() {
    startProgress();
    AsyncDataProvider.getInstance().getAllProvidersByType(new AsyncQuery<>(result -> {
        stopProgress();
        List<Provider<OpenstackNetworkProviderProperties>> providers = (List) result;
        providers.add(0, null);
        getNetworkProviders().setItems(providers);
        getNetworkProviders().setSelectedItem(null);
    }), ProviderType.OPENSTACK_NETWORK, ProviderType.EXTERNAL_NETWORK);
}
#end_block

#method_before
List<DiskImage> mapDisks(Disks disks) {
    List<DiskImage> diskImages = null;
    if (disks.isSetDisks()) {
        diskImages = disks.getDisks().stream().filter(Objects::nonNull).map(d -> (DiskImage) DiskMapper.map(d, null)).collect(Collectors.toList());
    }
    return diskImages;
}
#method_after
List<DiskImage> mapDisks(Disks disks) {
    List<DiskImage> diskImages = null;
    if (disks != null && disks.isSetDisks()) {
        diskImages = disks.getDisks().stream().filter(Objects::nonNull).map(disk -> (DiskImage) DiskMapper.map(disk, null)).collect(Collectors.toList());
    }
    return diskImages;
}
#end_block

#method_before
private List<Map<String, Object>> parseControllers(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.CONTROLLER);
    // devices with spec params to appear first
    dbDevices.sort((d1, d2) -> d1.getSpecParams().isEmpty() && !d2.getSpecParams().isEmpty() ? 1 : 0);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.CONTROLLER)) {
        String address = parseAddress(node);
        String index = parseAttribute(node, INDEX);
        String model = parseAttribute(node, MODEL);
        String devType = "virtio-scsi".equals(model) ? model : parseAttribute(node, TYPE);
        boolean isUsbWithNoneModel = devType.equalsIgnoreCase(VmDeviceType.USB.toString().toLowerCase()) && model.equals(UsbControllerModel.NONE.libvirtName);
        // which is a special case of a device without adress that is still marked as plugged
        if (address.isEmpty() && !isUsbWithNoneModel) {
            continue;
        }
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        dev.put(VdsProperties.Device, devType);
        dev.put(VdsProperties.Address, address);
        dev.put(VdsProperties.Alias, parseAlias(node));
        VmDevice dbDev = dbDevices.stream().filter(d -> d.getDevice().equals(dev.get(VdsProperties.Device))).filter(d -> d.getSpecParams().isEmpty() || Objects.equals(d.getSpecParams().get(INDEX), index)).filter(d -> d.getSpecParams().isEmpty() || Objects.equals(d.getSpecParams().get(MODEL), model)).findFirst().orElse(null);
        if (dbDev != null) {
            dbDevices.remove(dbDev);
            dev.put(VdsProperties.DeviceId, dbDev.getId().getDeviceId().toString());
            dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        } else {
            dev.put(VdsProperties.DeviceId, Guid.newGuid().toString());
            Map<String, Object> specParams = new HashMap<>();
            if (index != null) {
                specParams.put(INDEX, index);
            }
            if (model != null) {
                specParams.put(MODEL, model);
            }
            dev.put(VdsProperties.SpecParams, specParams);
        }
        result.add(dev);
    }
    return result;
}
#method_after
private List<Map<String, Object>> parseControllers(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.CONTROLLER);
    // devices with spec params to appear first
    dbDevices.sort((d1, d2) -> d1.getSpecParams().isEmpty() && !d2.getSpecParams().isEmpty() ? 1 : 0);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.CONTROLLER)) {
        String address = parseAddress(node);
        String index = parseAttribute(node, INDEX);
        String model = parseAttribute(node, MODEL);
        String devType = "virtio-scsi".equals(model) ? model : parseAttribute(node, TYPE);
        boolean devWithModelNone = model != null ? model.equals(UsbControllerModel.NONE.libvirtName) : false;
        // which is a special case of a device without address that is still marked as plugged
        if (address.isEmpty() && !devWithModelNone) {
            continue;
        }
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        dev.put(VdsProperties.Device, devType);
        dev.put(VdsProperties.Address, address);
        dev.put(VdsProperties.Alias, parseAlias(node));
        VmDevice dbDev = dbDevices.stream().filter(d -> d.getDevice().equals(dev.get(VdsProperties.Device))).filter(d -> d.getSpecParams().isEmpty() || Objects.equals(d.getSpecParams().get(INDEX), index)).filter(d -> d.getSpecParams().isEmpty() || Objects.equals(d.getSpecParams().get(MODEL), model)).findFirst().orElse(null);
        if (dbDev != null) {
            dbDevices.remove(dbDev);
            dev.put(VdsProperties.DeviceId, dbDev.getId().getDeviceId().toString());
            dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        } else {
            dev.put(VdsProperties.DeviceId, Guid.newGuid().toString());
            Map<String, Object> specParams = new HashMap<>();
            if (index != null) {
                specParams.put(INDEX, index);
            }
            if (model != null) {
                specParams.put(MODEL, model);
            }
            dev.put(VdsProperties.SpecParams, specParams);
        }
        result.add(dev);
    }
    return result;
}
#end_block

#method_before
@Override
public void setRowData(int start, final List<? extends T> values) {
    if (values.size() == 1) {
        addStyleName(HIDE_ONE_ROW_SCROLL);
    } else {
        removeStyleName(HIDE_ONE_ROW_SCROLL);
    }
    super.setRowData(start, values);
}
#method_after
@Override
public void setRowData(int start, final List<? extends T> values) {
    if (values.size() == 1) {
        addStyleName(HIDE_ONE_ROW_SCROLL);
    } else {
        removeStyleName(HIDE_ONE_ROW_SCROLL);
    }
    super.setRowData(start, values);
    int rowCount = values.size();
    int height = ROW_HEIGHT;
    if (rowCount > 0) {
        height = rowCount * ROW_HEIGHT;
    }
    updateGridSize(height);
}
#end_block

#method_before
private void resizeGridToContentHeight(int height) {
    int top = getAbsoluteTop();
    int maxGridHeight = Window.getClientHeight() - top - GRID_SUBTRACT;
    int contentHeight = determineBrowserHeightAdjustment(height);
    if (isHorizontalScrollbarVisible()) {
        contentHeight += scrollbarThickness;
    }
    if (contentHeight > maxGridHeight) {
        contentHeight = maxGridHeight;
    }
    if (contentHeight > 0) {
        super.setHeight(contentHeight + Unit.PX.getType());
    }
    redraw();
}
#method_after
protected void resizeGridToContentHeight(int height) {
    int top = getAbsoluteTop();
    int maxGridHeight = Window.getClientHeight() - top - GRID_SUBTRACT;
    int contentHeight = determineBrowserHeightAdjustment(height);
    if (isHorizontalScrollbarVisible()) {
        contentHeight += scrollbarThickness;
    }
    if (contentHeight > maxGridHeight) {
        contentHeight = maxGridHeight;
    }
    if (contentHeight > 0) {
        super.setHeight(contentHeight + Unit.PX.getType());
    }
    redraw();
}
#end_block

#method_before
public void updateGridSize() {
    int rowCount = getRowCount();
    int height = getLoadingIndicator() != null ? LOADING_HEIGHT : NO_ITEMS_HEIGHT;
    if (rowCount > 0) {
        height = rowCount * ROW_HEIGHT;
    }
    updateGridSize(height);
}
#method_after
public void updateGridSize() {
    int rowCount = getRowCount();
    int height = getLoadingIndicator() != null ? LOADING_HEIGHT : ROW_HEIGHT;
    if (rowCount > 0) {
        height = rowCount * ROW_HEIGHT;
    }
    updateGridSize(height);
}
#end_block

#method_before
@Override
public void onLoad() {
    super.onLoad();
    int rowCount = getRowCount();
    int height = getLoadingIndicator() != null ? LOADING_HEIGHT : NO_ITEMS_HEIGHT;
    if (rowCount > 0) {
        height = rowCount * ROW_HEIGHT;
    }
    updateGridSize(height);
}
#method_after
@Override
public void onLoad() {
    super.onLoad();
    int rowCount = getRowCount();
    int height = getLoadingIndicator() != null ? LOADING_HEIGHT : ROW_HEIGHT;
    if (rowCount > 0) {
        height = rowCount * ROW_HEIGHT;
    }
    updateGridSize(height);
}
#end_block

#method_before
@Override
public void onLoad() {
    super.onLoad();
    int rowCount = getRowCount();
    int height = getLoadingIndicator() != null ? LOADING_HEIGHT : NO_ITEMS_HEIGHT;
    if (rowCount > 0) {
        height = rowCount * ROW_HEIGHT;
    }
    updateGridSize(height);
}
#method_after
@Override
public void onLoad() {
    super.onLoad();
    int rowCount = getRowCount();
    int height = getLoadingIndicator() != null ? LOADING_HEIGHT : ROW_HEIGHT;
    if (rowCount > 0) {
        height = rowCount * ROW_HEIGHT;
    }
    updateGridSize(height);
}
#end_block

#method_before
public boolean verifyAddVm(List<String> reasons, int nicsCount, int vmPriority, MacPool macPool) {
    if (!verifyMacPool(reasons, nicsCount, macPool)) {
        return false;
    } else if (!isVmPriorityValueLegal(vmPriority, reasons)) {
        return false;
    }
    return true;
}
#method_after
public boolean verifyAddVm(List<String> reasons, int nicsCount, int vmPriority, MacPool macPool) {
    return verifyMacPool(reasons, nicsCount, macPool) && isVmPriorityValueLegal(vmPriority, reasons);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
    freeLock();
    // update vm init
    vmHandler.updateVmInitFromDB(getVm().getStaticData(), true);
    // immediately after the execution of the previous steps
    if (!hasSnappableDisks() && snapshotsWithMemory.isEmpty()) {
        auditLogDirector.log(this, AuditLogType.IMPORTEXPORT_STARTING_EXPORT_VM);
        endSuccessfully();
    } else {
        TransactionSupport.executeInNewTransaction(() -> {
            moveOrCopyAllImageGroups();
            return null;
        });
        if (!getReturnValue().getVdsmTaskIdList().isEmpty()) {
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
    freeLock();
    // update vm init
    vmHandler.updateVmInitFromDB(getVm().getStaticData(), true);
    // immediately after the execution of the previous steps
    if (!hasSnappableDisks() && snapshotsWithMemory.isEmpty()) {
        endSuccessfully();
    } else {
        TransactionSupport.executeInNewTransaction(() -> {
            moveOrCopyAllImageGroups();
            return null;
        });
        setSucceeded(true);
    }
}
#end_block

#method_before
private void copyAllMemoryImages(Guid containerID) {
    for (Snapshot snapshot : snapshotsWithMemory) {
        List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
        // copy the memory dump image
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerID, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerID, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
private void copyAllMemoryImages(Guid containerID) {
    for (Snapshot snapshot : snapshotsWithMemory) {
        List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
        // copy the memory dump image
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerID, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
        getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerID, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
        getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
    }
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(containerID, disk));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(containerID, disk));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
        getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (!getSucceeded()) {
                return AuditLogType.IMPORTEXPORT_EXPORT_VM_FAILED;
            }
            if (getCommandStatus() == CommandStatus.ENDED_SUCCESSFULLY) {
                return AuditLogType.IMPORTEXPORT_EXPORT_VM;
            }
            return AuditLogType.IMPORTEXPORT_STARTING_EXPORT_VM;
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.IMPORTEXPORT_EXPORT_VM : AuditLogType.IMPORTEXPORT_EXPORT_VM_FAILED;
        default:
            return AuditLogType.IMPORTEXPORT_EXPORT_VM_FAILED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? AuditLogType.IMPORTEXPORT_STARTING_EXPORT_VM : AuditLogType.IMPORTEXPORT_EXPORT_VM_FAILED;
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.IMPORTEXPORT_EXPORT_VM : AuditLogType.IMPORTEXPORT_EXPORT_VM_FAILED;
        default:
            return AuditLogType.IMPORTEXPORT_EXPORT_VM_FAILED;
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    macPool = getMacPool();
    Map<Guid, StorageDomain> domainsMap = new HashMap<>();
    if (!validateBeforeCloneVm(domainsMap)) {
        return false;
    }
    // Since methods #validateBeforeCloneVm > #validateAndSetVmFromExportDomain > #setVmFromExportDomain may
    // change this.vm instance, following code can't be in #init() method and has to follow call of
    // #validateBeforeCloneVm.
    VmHandler.updateMaxMemorySize(getVm().getStaticData(), getEffectiveCompatibilityVersion());
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > macPool.getAvailableMacsCount()) {
            return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        }
    }
    if (!validateBallonDevice()) {
        return false;
    }
    if (!validateSoundDevice()) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getVm().getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return validateAfterCloneVm(domainsMap);
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    Map<Guid, StorageDomain> domainsMap = new HashMap<>();
    if (!validateBeforeCloneVm(domainsMap)) {
        return false;
    }
    // Since methods #validateBeforeCloneVm > #validateAndSetVmFromExportDomain > #setVmFromExportDomain may
    // change this.vm instance, following code can't be in #init() method and has to follow call of
    // #validateBeforeCloneVm.
    VmHandler.updateMaxMemorySize(getVm().getStaticData(), getEffectiveCompatibilityVersion());
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > getMacPool().getAvailableMacsCount()) {
            return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        }
    }
    if (!validateBallonDevice()) {
        return false;
    }
    if (!validateSoundDevice()) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getVm().getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return validateAfterCloneVm(domainsMap);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (getVm().isAutoStartup() && shouldAddLease(getVm().getStaticData())) {
        if (FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            if (validateLeaseStorageDomain(getVm().getLeaseStorageDomainId())) {
                if (!addVmLease(getVm().getLeaseStorageDomainId(), getVm().getId())) {
                    getVm().setLeaseStorageDomainId(null);
                }
            } else {
                getVm().setLeaseStorageDomainId(null);
                auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_STORAGE_DOMAIN);
            }
        } else {
            getVm().setLeaseStorageDomainId(null);
            auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_COMPAT_VERSION);
        }
    } else {
        getVm().setLeaseStorageDomainId(null);
    }
    super.executeVmCommand();
    if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
        auditLogDirector.log(this, AuditLogType.IMPORTEXPORT_STARTING_IMPORT_VM);
    }
}
#method_after
@Override
protected void executeVmCommand() {
    if (getVm().isAutoStartup() && shouldAddLease(getVm().getStaticData())) {
        if (FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            if (validateLeaseStorageDomain(getVm().getLeaseStorageDomainId())) {
                if (!addVmLease(getVm().getLeaseStorageDomainId(), getVm().getId())) {
                    getVm().setLeaseStorageDomainId(null);
                }
            } else {
                getVm().setLeaseStorageDomainId(null);
                auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_STORAGE_DOMAIN);
            }
        } else {
            getVm().setLeaseStorageDomainId(null);
            auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_COMPAT_VERSION);
        }
    } else {
        getVm().setLeaseStorageDomainId(null);
    }
    super.executeVmCommand();
}
#end_block

#method_before
private Predicate<VmNetworkInterface> getVnicRequiresNewMacPredicate() {
    return ((Predicate<VmNetworkInterface>) this::nicWithoutMacAddress).or(this::shouldMacBeReassigned);
}
#method_after
private Predicate<VmNetworkInterface> getVnicRequiresNewMacPredicate() {
    return ((Predicate<VmNetworkInterface>) this::nicWithoutMacAddress).or(iface -> getParameters().isReassignBadMacs() && vNicHasBadMac(iface));
}
#end_block

#method_before
private void copyAllMemoryImages(Guid containerId) {
    for (String memoryVolumes : MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots())) {
        List<Guid> guids = GuidUtils.getGuidListFromString(memoryVolumes);
        // copy the memory dump image
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy memory image");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy metadata image");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
private void copyAllMemoryImages(Guid containerId) {
    for (String memoryVolumes : MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots())) {
        List<Guid> guids = Guid.createGuidListFromString(memoryVolumes);
        // copy the memory dump image
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy memory image");
        }
        // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
        getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy metadata image");
        }
        // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
        getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
    }
}
#end_block

#method_before
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy disk!");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy disk!");
        }
        // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
        getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
    }
}
#end_block

#method_before
private void updateMemoryDisks(Snapshot snapshot) {
    List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
    snapshot.setMemoryDiskId(guids.get(2));
    snapshot.setMetadataDiskId(guids.get(4));
}
#method_after
private void updateMemoryDisks(Snapshot snapshot) {
    List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
    snapshot.setMemoryDiskId(guids.get(2));
    snapshot.setMetadataDiskId(guids.get(4));
}
#end_block

#method_before
private void addMemoryImages() {
    getVm().getSnapshots().stream().filter(snapshot -> !StringUtils.isEmpty(snapshot.getMemoryVolume())).forEach(snapshot -> {
        addDisk(createMemoryDisk(snapshot));
        addDisk(createMetadaaDisk(snapshot));
    });
}
#method_after
private void addMemoryImages() {
    getVm().getSnapshots().stream().filter(snapshot -> !StringUtils.isEmpty(snapshot.getMemoryVolume())).forEach(snapshot -> {
        addDisk(createMemoryDisk(snapshot));
        addDisk(createMetadataDisk(getVm(), snapshot));
    });
}
#end_block

#method_before
private DiskImage createMemoryDisk(Snapshot snapshot) {
    List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
    VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
    DiskImage memoryDisk = MemoryUtils.createMemoryDisk(vm, storageDomainStaticDao.get(guids.get(0)).getStorageType(), vmOverheadCalculator);
    memoryDisk.setId(guids.get(2));
    memoryDisk.setImageId(guids.get(3));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    return memoryDisk;
}
#method_after
private DiskImage createMemoryDisk(Snapshot snapshot) {
    List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
    StorageDomainStatic sd = validateStorageDomainExistsInDb(snapshot, guids.get(0), guids.get(2), guids.get(3));
    if (sd == null) {
        return null;
    }
    VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
    DiskImage memoryDisk = MemoryUtils.createMemoryDisk(vm, sd.getStorageType(), vmOverheadCalculator, MemoryUtils.generateMemoryDiskDescription(vm, snapshot.getDescription()));
    memoryDisk.setId(guids.get(2));
    memoryDisk.setImageId(guids.get(3));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    return memoryDisk;
}
#end_block

#method_before
private void addDisk(DiskImage disk) {
    saveImage(disk);
    saveBaseDisk(disk);
    saveDiskImageDynamic(disk);
}
#method_after
private void addDisk(DiskImage disk) {
    if (disk != null) {
        saveImage(disk);
        saveBaseDisk(disk);
        saveDiskImageDynamic(disk);
    } else {
        log.error("Memory metadata/dump disk could not be added");
    }
}
#end_block

#method_before
protected void removeVmNetworkInterfaces() {
    new VmInterfaceManager(macPool).removeAll(getVmId());
}
#method_after
protected void removeVmNetworkInterfaces() {
    new VmInterfaceManager(getMacPool()).removeAllAndReleaseMacAddresses(getVmId());
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (!getSucceeded()) {
                return AuditLogType.IMPORTEXPORT_IMPORT_VM_FAILED;
            }
            return getReturnValue().getVdsmTaskIdList().isEmpty() ? AuditLogType.IMPORTEXPORT_IMPORT_VM : AuditLogType.IMPORTEXPORT_STARTING_IMPORT_VM;
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.IMPORTEXPORT_IMPORT_VM : AuditLogType.IMPORTEXPORT_IMPORT_VM_FAILED;
        case END_FAILURE:
            return AuditLogType.IMPORTEXPORT_IMPORT_VM_FAILED;
    }
    return super.getAuditLogTypeValue();
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? AuditLogType.IMPORTEXPORT_STARTING_IMPORT_VM : AuditLogType.IMPORTEXPORT_IMPORT_VM_FAILED;
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.IMPORTEXPORT_IMPORT_VM : AuditLogType.IMPORTEXPORT_IMPORT_VM_FAILED;
        case END_FAILURE:
            return AuditLogType.IMPORTEXPORT_IMPORT_VM_FAILED;
    }
    return super.getAuditLogTypeValue();
}
#end_block

#method_before
private void resizeGridToContentHeight(int height) {
    int top = getAbsoluteTop();
    int maxGridHeight = Window.getClientHeight() - top - GRID_SUBTRACT;
    int contentHeight = determineBrowserHeighAdjustment(height);
    if (contentHeight > maxGridHeight) {
        contentHeight = maxGridHeight;
    }
    if (contentHeight > 0) {
        super.setHeight(contentHeight + Unit.PX.getType());
    }
    redraw();
}
#method_after
private void resizeGridToContentHeight(int height) {
    int top = getAbsoluteTop();
    int maxGridHeight = Window.getClientHeight() - top - GRID_SUBTRACT;
    int contentHeight = determineBrowserHeightAdjustment(height);
    if (contentHeight > maxGridHeight) {
        contentHeight = maxGridHeight;
    }
    if (contentHeight > 0) {
        super.setHeight(contentHeight + Unit.PX.getType());
    }
    redraw();
}
#end_block

#method_before
private void runAnsibleHostDeployPlaybook(FirewallType firewallType) throws IOException, InterruptedException {
    AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(getVds().getHostName()).variables(new Pair<>("host_deploy_cluster_version", getVds().getClusterCompatibilityVersion()), new Pair<>("host_deploy_gluster_enabled", getVds().getClusterSupportsGlusterService()), new Pair<>("host_deploy_virt_enabled", getVds().getClusterSupportsVirtService()), new Pair<>("host_deploy_vdsm_port", getVds().getPort()), new Pair<>("host_deploy_override_firewall", getParameters().getOverrideFirewall()), new Pair<>("host_deploy_firewall_type", firewallType.name()), new Pair<>("ansible_port", getVds().getSshPort()), new Pair<>("host_deploy_post_tasks", AnsibleConstants.HOST_DEPLOY_POST_TASKS_FILE_PATH), new Pair<>("host_deploy_ovn_tunneling_network", managementNetworkUtil.getManagementNetwork(getVds().getClusterId()).getVdsmName()), new Pair<>("host_deploy_ovn_central", externalNetworkInformation.getOvnCentralByHost(getVds()))).logFileDirectory(VdsDeployBase.HOST_DEPLOY_LOG_DIRECTORY).logFilePrefix("ovirt-host-deploy-ansible").logFileName(getVds().getHostName()).logFileSuffix(getCorrelationId()).playbook(AnsibleConstants.HOST_DEPLOY_PLAYBOOK);
    AuditLogable logable = new AuditLogableImpl();
    logable.setVdsName(getVds().getName());
    logable.setVdsId(getVds().getId());
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_STARTED);
    if (ansibleExecutor.runCommand(command) != AnsibleReturnCode.OK) {
        throw new VdsInstallException(VDSStatus.InstallFailed, String.format("Failed to execute Ansible host-deploy role. Please check logs for more details: %1$s", command.logFile()));
    }
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_FINISHED);
}
#method_after
private void runAnsibleHostDeployPlaybook(FirewallType firewallType) throws IOException, InterruptedException {
    AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(getVds().getHostName()).variables(new Pair<>("host_deploy_cluster_version", getVds().getClusterCompatibilityVersion()), new Pair<>("host_deploy_gluster_enabled", getVds().getClusterSupportsGlusterService()), new Pair<>("host_deploy_virt_enabled", getVds().getClusterSupportsVirtService()), new Pair<>("host_deploy_vdsm_port", getVds().getPort()), new Pair<>("host_deploy_override_firewall", getParameters().getOverrideFirewall()), new Pair<>("host_deploy_firewall_type", firewallType.name()), new Pair<>("ansible_port", getVds().getSshPort()), new Pair<>("host_deploy_post_tasks", AnsibleConstants.HOST_DEPLOY_POST_TASKS_FILE_PATH), new Pair<>("host_deploy_ovn_tunneling_network", managementNetworkUtil.getManagementNetwork(getVds().getClusterId()).getVdsmName()), new Pair<>("host_deploy_ovn_central", getOvnCentral())).logFileDirectory(VdsDeployBase.HOST_DEPLOY_LOG_DIRECTORY).logFilePrefix("ovirt-host-deploy-ansible").logFileName(getVds().getHostName()).logFileSuffix(getCorrelationId()).playbook(AnsibleConstants.HOST_DEPLOY_PLAYBOOK);
    AuditLogable logable = new AuditLogableImpl();
    logable.setVdsName(getVds().getName());
    logable.setVdsId(getVds().getId());
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_STARTED);
    if (ansibleExecutor.runCommand(command) != AnsibleReturnCode.OK) {
        throw new VdsInstallException(VDSStatus.InstallFailed, String.format("Failed to execute Ansible host-deploy role. Please check logs for more details: %1$s", command.logFile()));
    }
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_FINISHED);
}
#end_block

#method_before
public static boolean interfaceHasVlan(VdsNetworkInterface iface, List<VdsNetworkInterface> allIfaces) {
    for (VdsNetworkInterface i : allIfaces) {
        if (NetworkCommonUtils.isVlan(i) && interfaceBasedOn(i, iface.getName())) {
            return true;
        }
    }
    return false;
}
#method_after
public static boolean interfaceHasVlan(VdsNetworkInterface iface, List<VdsNetworkInterface> allIfaces) {
    return allIfaces.stream().anyMatch(i -> NetworkCommonUtils.isVlan(i) && interfaceBasedOn(i, iface.getName()));
}
#end_block

#method_before
public static Map<String, Network> networksByName(List<Network> networks) {
    if (!networks.isEmpty()) {
        Map<String, Network> byName = new HashMap<>();
        for (Network net : networks) {
            byName.put(net.getName(), net);
        }
        return byName;
    } else {
        return Collections.emptyMap();
    }
}
#method_after
public static Map<String, Network> networksByName(List<Network> networks) {
    return networks.stream().collect(Collectors.toMap(Network::getName, Function.identity()));
}
#end_block

#method_before
public static List<String> filterNonVmNetworkNames(List<Network> networks, Set<String> networkNames) {
    List<String> list = new ArrayList<>();
    for (Network net : networks) {
        if (!net.isVmNetwork() && networkNames.contains(net.getName())) {
            list.add(net.getName());
        }
    }
    return list;
}
#method_after
public static List<String> filterNonVmNetworkNames(List<Network> networks, Set<String> networkNames) {
    return networks.stream().filter(net -> !net.isVmNetwork() && networkNames.contains(net.getName())).map(Network::getName).collect(Collectors.toList());
}
#end_block

#method_before
public static Network getDisplayNetwork(Collection<Network> clusterNetworks) {
    Network displayNetwork = null;
    for (Network network : clusterNetworks) {
        if (network.getCluster().isDisplay()) {
            displayNetwork = network;
            break;
        }
    }
    return displayNetwork;
}
#method_after
public static Network getDisplayNetwork(Collection<Network> clusterNetworks) {
    return clusterNetworks.stream().filter(n -> n.getCluster().isDisplay()).findFirst().orElse(null);
}
#end_block

#method_before
public static <E extends VdsNetworkInterface> Map<String, E> hostInterfacesByNetworkName(Collection<E> hostNics) {
    return hostNics == null ? Collections.emptyMap() : hostNics.stream().filter(hostNic -> hostNic.getNetworkName() != null).collect(Collectors.toMap(VdsNetworkInterface::getNetworkName, Function.<E>identity()));
}
#method_after
public static <E extends VdsNetworkInterface> Map<String, E> hostInterfacesByNetworkName(Collection<E> hostNics) {
    return hostNics == null ? Collections.emptyMap() : hostNics.stream().filter(hostNic -> hostNic.getNetworkName() != null).collect(Collectors.toMap(VdsNetworkInterface::getNetworkName, Function.identity()));
}
#end_block

#method_before
private VdsNetworkInterface createVlan(String baseIfaceName) {
    VdsNetworkInterface iface = new Vlan(RandomUtils.instance().nextInt(100), baseIfaceName);
    return iface;
}
#method_after
private VdsNetworkInterface createVlan(String baseIfaceName) {
    VdsNetworkInterface iface = new Vlan();
    iface.setVlanId(RandomUtils.instance().nextInt(100));
    iface.setBaseInterface(baseIfaceName);
    return iface;
}
#end_block

#method_before
public void setExecutorService(ExecutorService executorService) {
    this.executorService = executorService;
}
#method_after
public void setExecutorService(ScheduledExecutorService executorService) {
    this.executorService = executorService;
    this.tracker.setExecutorService(executorService);
}
#end_block

#method_before
public Future<JsonRpcResponse> call(JsonRpcRequest req, BrokerCommandCallback callback) throws ClientConnectionException {
    final Call call = new Call(req, executorService, callback);
    this.tracker.registerCall(req, call);
    retryCall(req, call);
    try {
        this.getClient().sendMessage(jsonToByteArray(req.toJson()));
    } finally {
        retryCall(req, call);
    }
    return call;
}
#method_after
public Future<JsonRpcResponse> call(JsonRpcRequest req, BrokerCommandCallback callback) throws ClientConnectionException {
    final Call call = new Call(req, callback);
    this.tracker.registerCall(req, call);
    retryCall(req, call);
    try {
        this.getClient().sendMessage(jsonToByteArray(req.toJson()));
    } finally {
        retryCall(req, call);
    }
    return call;
}
#end_block

#method_before
public void processResponse(JsonRpcResponse response) {
    JsonNode id = response.getId();
    if (NullNode.class.isInstance(id) || id == null) {
        this.tracker.processIssue(response);
        return;
    }
    JsonRpcCall call = this.tracker.removeCall(response.getId());
    if (call == null) {
        this.log.error("Not able to update response for {}", response.getId());
        return;
    }
    call.addResponse(response);
    if (call.getCallback() != null && call.getExecutor() != null) {
        if (response.getError() != null) {
            Map<String, Object> map = mapValues(response.getError());
            String message = (String) map.get("message");
            call.getExecutor().submit(() -> call.getCallback().onFailure(new Exception(message)));
        } else {
            call.getExecutor().submit(() -> call.getCallback().onResponse(new JsonResponseUtil().populate(response)));
        }
    }
}
#method_after
public void processResponse(JsonRpcResponse response) {
    JsonNode id = response.getId();
    if (NullNode.class.isInstance(id) || id == null) {
        this.tracker.processIssue(response);
        return;
    }
    JsonRpcCall call = this.tracker.removeCall(response.getId());
    if (call == null) {
        this.log.error("Not able to update response for {}", response.getId());
        return;
    }
    call.addResponse(response);
    if (call.getCallback() != null && executorService != null) {
        if (response.getError() != null) {
            executorService.schedule(() -> call.getCallback().onFailure(mapValues(response.getError())), 0, TimeUnit.SECONDS);
        } else {
            executorService.schedule(() -> call.getCallback().onResponse(new JsonResponseUtil().populate(response)), 0, TimeUnit.SECONDS);
        }
    }
}
#end_block

#method_before
private void writeMemoryBacking() {
    if (!HugePageUtils.isBackedByHugepages(vm.getStaticData())) {
        return;
    }
    writer.writeStartElement("memoryBacking");
    writer.writeStartElement("hugepages");
    writer.writeStartElement("page");
    int hugepageSize = Integer.parseInt(HugePageUtils.getHugePageSize(vm.getStaticData()));
    List<Integer> hugepageSizes = hostStatisticsSupplier.get().getHugePages().stream().map(HugePage::getSizeKB).collect(Collectors.toList());
    if (!hugepageSizes.contains(hugepageSizes)) {
        switch(vm.getClusterArch().getFamily()) {
            case x86:
                hugepageSize = 2048;
                break;
            case ppc:
                hugepageSize = 16384;
                break;
        }
    }
    writer.writeAttributeString("size", String.valueOf(hugepageSize));
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeMemoryBacking() {
    if (!HugePageUtils.isBackedByHugepages(vm.getStaticData())) {
        return;
    }
    writer.writeStartElement("memoryBacking");
    writer.writeStartElement("hugepages");
    writer.writeStartElement("page");
    int hugepageSize = Integer.parseInt(HugePageUtils.getHugePageSize(vm.getStaticData()));
    List<Integer> hugepageSizes = hostStatisticsSupplier.get().getHugePages().stream().map(HugePage::getSizeKB).collect(Collectors.toList());
    if (!hugepageSizes.contains(hugepageSizes)) {
        switch(vm.getClusterArch().getFamily()) {
            case x86:
                hugepageSize = DEFAULT_HUGEPAGESIZE_X86_64;
                break;
            case ppc:
                hugepageSize = DEFAULT_HUGEPAGESIZE_PPC64LE;
                break;
        }
    }
    writer.writeAttributeString("size", String.valueOf(hugepageSize));
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeNetworkInterfaceMetadata() {
    vnicMetadata.forEach((mac, data) -> {
        writer.writeStartElement(OVIRT_VM_URI, "device");
        writer.writeAttributeString("mac_address", mac);
        List<String> portMirroring = (List<String>) data.remove("portMirroring");
        if (portMirroring != null) {
            writer.writeStartElement(OVIRT_VM_URI, "portMirroring");
            portMirroring.forEach(network -> writer.writeElement(OVIRT_VM_URI, "network", network));
            writer.writeEndElement();
        }
        writer.writeStartElement(OVIRT_VM_URI, "custom");
        Map<String, String> runtimeCustomProperties = (Map<String, String>) data.remove("runtimeCustomProperties");
        if (runtimeCustomProperties != null) {
            runtimeCustomProperties.forEach((key, value) -> writer.writeElement(OVIRT_VM_URI, key, value));
        }
        // write the other custom properties
        data.forEach((key, value) -> writer.writeElement(OVIRT_VM_URI, key, value.toString()));
        writer.writeEndElement();
        writer.writeEndElement();
    });
}
#method_after
private void writeNetworkInterfaceMetadata() {
    vnicMetadata.forEach((mac, data) -> {
        writer.writeStartElement(OVIRT_VM_URI, "device");
        writer.writeAttributeString("mac_address", mac);
        List<String> portMirroring = (List<String>) data.get("portMirroring");
        if (portMirroring != null) {
            writer.writeStartElement(OVIRT_VM_URI, "portMirroring");
            portMirroring.forEach(network -> writer.writeElement(OVIRT_VM_URI, "network", network));
            writer.writeEndElement();
        }
        writer.writeStartElement(OVIRT_VM_URI, "custom");
        Map<String, String> runtimeCustomProperties = (Map<String, String>) data.get("runtimeCustomProperties");
        if (runtimeCustomProperties != null) {
            runtimeCustomProperties.forEach((key, value) -> writer.writeElement(OVIRT_VM_URI, key, value));
        }
        writer.writeEndElement();
        writer.writeEndElement();
    });
}
#end_block

#method_before
private void writeInterface(VmDevice device, VmNetworkInterface nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    Map<String, String> properties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    VnicProfile vnicProfile = vnicProfileDao.get(nic.getVnicProfileId());
    Network network = vnicProfile != null ? networkDao.get(vnicProfile.getNetworkId()) : null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            writer.writeAttributeString("type", ifaceType == VmInterfaceType.pv ? "virtio" : ifaceType.getInternalName());
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", network != null ? network.getVdsmName() : "");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().remove("queues") : null;
            String driverName = getDriverNameForNetwork(nic.getNetworkName(), properties);
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (network != null && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach((key, value) -> writer.writeAttributeString(key, value));
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmNicFilterParameterDao.getAllForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    if (properties.containsKey("sndbuf")) {
        writer.writeStartElement("tune");
        writer.writeStartElement("sndbuf");
        writer.writeRaw(properties.get("sndbuf"));
        writer.writeEndElement();
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNetworkInterface nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    Map<String, String> properties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    VnicProfile vnicProfile = vnicProfileDao.get(nic.getVnicProfileId());
    Network network = vnicProfile != null ? networkDao.get(vnicProfile.getNetworkId()) : null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            writer.writeAttributeString("type", ifaceType == VmInterfaceType.pv ? "virtio" : ifaceType.getInternalName());
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", network != null ? network.getVdsmName() : "");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().get("queues") : null;
            String driverName = getDriverNameForNetwork(nic.getNetworkName(), properties);
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (network != null && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach((key, value) -> writer.writeAttributeString(key, value));
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmNicFilterParameterDao.getAllForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    if (properties.containsKey("sndbuf")) {
        writer.writeStartElement("tune");
        writer.writeStartElement("sndbuf");
        writer.writeRaw(properties.get("sndbuf"));
        writer.writeEndElement();
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
@Override
public OneUuidReturn reduceVolume(String spUUID, String sdUUID, String imageUUID, String volumeUUID, boolean force) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.reduceVolume").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imageUUID).withParameter("volumeID", volumeUUID).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#method_after
@Override
public OneUuidReturn reduceVolume(String spUUID, String sdUUID, String imageUUID, String volumeUUID, boolean allowActive) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.reduceVolume").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imageUUID).withParameter("volumeID", volumeUUID).withParameter("allowActive", allowActive).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters());
    Guid currentChildId = getCurrentChildId(getParameters());
    ActionReturnValue actionReturnValue = null;
    if (currentChildId != null) {
        actionReturnValue = CommandCoordinatorUtil.getCommandReturnValue(currentChildId);
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<ActionType, ? extends ActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(ActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(ActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(ActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (actionReturnValue != null) {
                getParameters().setMergeStatusReturnValue(actionReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = buildDestroyCommand(ActionType.DestroyImage, getActionType(), new ArrayList<>(getParameters().getMergeStatusReturnValue().getImagesToRemove()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE_CHECK);
            break;
        case DESTROY_IMAGE_CHECK:
            nextCommand = buildDestroyCommand(ActionType.DestroyImageCheck, getActionType(), new ArrayList<>(getParameters().getMergeStatusReturnValue().getImagesToRemove()));
            if (isInternalMerge() && isReduceVolumeSupported()) {
                getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.REDUCE_IMAGE);
            } else {
                getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.COMPLETE);
            }
            break;
        case REDUCE_IMAGE:
            nextCommand = buildReduceImageCommand();
            if (isVmRunningOnSPM()) {
                getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.COMPLETE);
            } else {
                getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.REFRESH_IMAGE);
            }
            break;
        case REFRESH_IMAGE:
            nextCommand = buildRefreshImageCommand();
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters());
    Guid currentChildId = getCurrentChildId(getParameters());
    ActionReturnValue actionReturnValue = null;
    if (currentChildId != null) {
        actionReturnValue = commandCoordinatorUtil.getCommandReturnValue(currentChildId);
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<ActionType, ? extends ActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(ActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(ActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(ActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (actionReturnValue != null) {
                getParameters().setMergeStatusReturnValue(actionReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = buildDestroyCommand(ActionType.DestroyImage, getActionType(), new ArrayList<>(getParameters().getMergeStatusReturnValue().getImagesToRemove()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE_CHECK);
            break;
        case DESTROY_IMAGE_CHECK:
            nextCommand = buildDestroyCommand(ActionType.DestroyImageCheck, getActionType(), new ArrayList<>(getParameters().getMergeStatusReturnValue().getImagesToRemove()));
            if (isInternalMerge() && isReduceVolumeSupported()) {
                getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.REDUCE_IMAGE);
            } else {
                getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.COMPLETE);
            }
            break;
        case REDUCE_IMAGE:
            nextCommand = buildReduceImageCommand();
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        commandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
private boolean completedMerge() {
    return getParameters().getCommandStep() == RemoveSnapshotSingleDiskStep.DESTROY_IMAGE || getParameters().getCommandStep() == RemoveSnapshotSingleDiskStep.DESTROY_IMAGE_CHECK || getParameters().getCommandStep() == RemoveSnapshotSingleDiskStep.REDUCE_IMAGE || getParameters().getCommandStep() == RemoveSnapshotSingleDiskStep.COMPLETE;
}
#method_after
private boolean completedMerge() {
    return getParameters().getCommandStep() == RemoveSnapshotSingleDiskStep.DESTROY_IMAGE || getParameters().getCommandStep() == RemoveSnapshotSingleDiskStep.DESTROY_IMAGE_CHECK || getParameters().getCommandStep() == RemoveSnapshotSingleDiskStep.COMPLETE;
}
#end_block

#method_before
private Pair<ActionType, ReduceImageParameters> buildReduceImageCommand() {
    ReduceImageParameters parameters = new ReduceImageParameters(getStoragePool().getSpmVdsId(), getDiskImage().getStoragePoolId(), getDiskImage().getStorageIds().get(0), getActiveDiskImage().getId(), getDiskImage().getImageId(), isVmRunningOnSPM(), true);
    parameters.setParentCommand(ActionType.RemoveSnapshotSingleDiskLive);
    parameters.setParentParameters(getParameters());
    return new Pair<>(ActionType.ReduceImage, parameters);
}
#method_after
private Pair<ActionType, ReduceImageCommandParameters> buildReduceImageCommand() {
    ReduceImageCommandParameters parameters = new ReduceImageCommandParameters(getStoragePool().getSpmVdsId(), getVdsId(), getDiskImage().getStoragePoolId(), getDiskImage().getStorageIds().get(0), getActiveDiskImage().getId(), getDiskImage().getImageId(), true);
    parameters.setParentCommand(ActionType.RemoveSnapshotSingleDiskLive);
    parameters.setParentParameters(getParameters());
    return new Pair<>(ActionType.ReduceImage, parameters);
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    return new RemoveSnapshotSingleDiskLiveCommandCallback();
}
#method_after
@Override
public CommandCallback getCallback() {
    return callbackProvider.get();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupId()));
    if (!getParameters().isVmRunningOnSpm()) {
        // Prepare the image on the SPM
        imagesHandler.prepareImage(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getImageGroupId(), getParameters().getImageId(), getParameters().getSpmId());
    }
    ReduceImageVDSCommandParameters parameters = new ReduceImageVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getImageGroupId(), getParameters().getImageId(), getParameters().isForce());
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ReduceImage, parameters);
    if (vdsReturnValue.getSucceeded()) {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        getTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupId()));
    boolean prepareImageSucceeded = false;
    boolean reduceImageSucceeded = false;
    if (!getParameters().isVmRunningOnSpm()) {
        // The VM isn't running on the SPM but the reduce command is performed on the SPM, hence
        // we have to prepare the image on the SPM
        log.debug("Preparing image {}/{} on the SPM", getParameters().getImageGroupId(), getParameters().getImageId());
        try {
            prepareImage();
            prepareImageSucceeded = true;
        } catch (EngineException e) {
            log.error("Failed to prepare image {}/{} on the SPM", getParameters().getImageGroupId(), getParameters().getImageId());
        }
    }
    if (!getParameters().isVmRunningOnSpm() && !prepareImageSucceeded) {
        // As we don't want to fail the live merge because of a failure to reduce the image, we still mark the
        // command as succeeded.
        setSucceeded(true);
        return;
    }
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ReduceImage, creaeteReduceImageVDSCommandParameters());
        if (vdsReturnValue.getSucceeded()) {
            Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
            getTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
            reduceImageSucceeded = true;
        }
    } catch (EngineException e) {
        log.error("Reducing image {}/{} failed", getParameters().getImageGroupId(), getParameters().getImageId());
    }
    if (prepareImageSucceeded && !reduceImageSucceeded) {
        try {
            teardownImage();
        } catch (EngineException e) {
            log.error("Failed to teardown image {}/{} on the SPM", getParameters().getImageGroupId(), getParameters().getImageId());
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public ActionReturnValue endAction() {
    ActionReturnValue returnValue = super.endAction();
    // Teardown the image on the SPM
    if (!getParameters().isVmRunningOnSpm()) {
        imagesHandler.teardownImage(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getImageGroupId(), getParameters().getImageId(), getParameters().getSpmId());
    }
    return returnValue;
}
#method_after
@Override
public ActionReturnValue endAction() {
    if (!getParameters().isVmRunningOnSpm()) {
        // Teardown the image on the SPM
        log.debug("Tearing down image {}/{} on the SPM", getParameters().getImageGroupId(), getParameters().getImageId());
        try {
            teardownImage();
        } catch (EngineException e) {
            log.error("Failed to teardown image {}/{} on the SPM", getParameters().getImageGroupId(), getParameters().getImageId());
        }
        // Refresh image on the host running the VM
        log.debug("Refreshing image {}/{} on its running host {}", getParameters().getImageGroupId(), getParameters().getImageId(), getParameters().getRunningVdsId());
        try {
            runInternalAction(ActionType.RefreshVolume, createRefreshVolumeParameters());
        } catch (EngineException e) {
            log.error("Failed to refresh image {}/{} on its running host {}", getParameters().getImageGroupId(), getParameters().getImageId(), getParameters().getRunningVdsId());
        }
    }
    // We mark the action as succeeded, even if it failed, in order not to fail the live merge operation.
    setSucceeded(true);
    setCommandStatus(CommandStatus.SUCCEEDED);
    return getReturnValue();
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(getParameters().getStorageDomainId(), VdcObjectType.Storage, getActionType().getActionGroup()));
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.emptyList();
}
#end_block

#method_before
@Override
protected void executeIrsBrokerCommand() {
    log.info("Executing ReduceImageVDSCommand");
    uuidReturn = getIrsProxy().reduceVolume(getParameters().getStoragePoolId().toString(), getParameters().getStorageDomainId().toString(), getParameters().getImageGroupId().toString(), getParameters().getImageId().toString(), getParameters().isForce());
    proceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.uuid);
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.reduceImage, getParameters().getStoragePoolId()));
}
#method_after
@Override
protected void executeIrsBrokerCommand() {
    log.info("Executing ReduceImageVDSCommand");
    uuidReturn = getIrsProxy().reduceVolume(getParameters().getStoragePoolId().toString(), getParameters().getStorageDomainId().toString(), getParameters().getImageGroupId().toString(), getParameters().getImageId().toString(), getParameters().isAllowActive());
    proceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.uuid);
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.reduceImage, getParameters().getStoragePoolId()));
}
#end_block

#method_before
@Override
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return super.appendAttributes(tsb).append("imageId", getImageId()).append("force", isForce());
}
#method_after
@Override
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return super.appendAttributes(tsb).append("imageId", getImageId()).append("allowActive", isAllowActive());
}
#end_block

#method_before
private void addAlert(VDS host, AuditLogType auditMessage) {
    AuditLogableBase logableBase = new AuditLogableBase();
    logableBase.addCustomValue("VdsName", host.getName());
    AlertDirector.addVdsAlert(host.getId(), auditMessage, auditLogDirector, logableBase);
}
#method_after
private void addAlert(VDS host, AuditLogType auditMessage) {
    AuditLogableBase logableBase = Injector.injectMembers(new AuditLogableBase());
    logableBase.setVds(host);
    AlertDirector.addVdsAlert(host.getId(), auditMessage, auditLogDirector, logableBase);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    List<VmNetworkInterface> nicList = new ArrayList<>(1);
    nicList.add(getSelectedItem());
    RemoveVmInterfaceModel model = new RemoveVmInterfaceModel(this, nicList, false);
    setWindow(model);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveVmInterfaceModel model = new RemoveVmInterfaceModel(this, Arrays.asList(getSelectedItem()), false);
    setWindow(model);
}
#end_block

#method_before
private void nfsStorageModel_PathChanged(Object sender) {
    NfsStorageModel senderModel = (NfsStorageModel) sender;
    for (Object item : getStorageModels()) {
        if (item instanceof NfsStorageModel && item != sender) {
            NfsStorageModel model = (NfsStorageModel) item;
            model.getPath().setEntity(senderModel.getPath().getEntity());
        }
    }
}
#method_after
private void nfsStorageModel_PathChanged(Object sender) {
    NfsStorageModel senderModel = (NfsStorageModel) sender;
    getStorageModels().stream().filter(item -> item instanceof NfsStorageModel && item != sender).map(item -> (NfsStorageModel) item).forEach(model -> model.getPath().setEntity(senderModel.getPath().getEntity()));
}
#end_block

#method_before
protected void storageItemsChanged() {
    if (getStorageModels() != null) {
        for (Object item : getStorageModels()) {
            IStorageModel model = (IStorageModel) item;
            model.setContainer(this);
            if (item instanceof NfsStorageModel) {
                NfsStorageModel nfsModel = (NfsStorageModel) item;
                nfsModel.getPathChangedEvent().addListener(this);
            }
        }
    }
}
#method_after
protected void storageItemsChanged() {
    if (getStorageModels() != null) {
        getStorageModels().forEach(item -> {
            item.setContainer(this);
            if (item instanceof NfsStorageModel) {
                NfsStorageModel nfsModel = (NfsStorageModel) item;
                nfsModel.getPathChangedEvent().addListener(this);
            }
        });
    }
}
#end_block

#method_before
private void host_SelectedItemChanged() {
    VDS host = getHost().getSelectedItem();
    if (getCurrentStorageItem() != null) {
        // When changing host clear items for san storage model.
        if (getCurrentStorageItem() instanceof SanStorageModelBase) {
            SanStorageModelBase sanStorageModel = (SanStorageModelBase) getCurrentStorageItem();
            if (getStorage() == null) {
                sanStorageModel.setItems(null);
            }
        }
        if (host != null) {
            getCurrentStorageItem().getUpdateCommand().execute();
            // $NON-NLS-1$
            String prefix = host.isOvirtVintageNode() ? localFSPath : "";
            if (!StringHelper.isNullOrEmpty(prefix)) {
                for (Object item : getStorageModels()) {
                    if (item instanceof LocalStorageModel) {
                        LocalStorageModel model = (LocalStorageModel) item;
                        model.getPath().setEntity(prefix);
                        model.getPath().setIsChangeable(false);
                    }
                }
            }
        }
    }
}
#method_after
private void host_SelectedItemChanged() {
    VDS host = getHost().getSelectedItem();
    if (getCurrentStorageItem() != null) {
        // When changing host clear items for san storage model.
        if (getCurrentStorageItem() instanceof SanStorageModelBase) {
            SanStorageModelBase sanStorageModel = (SanStorageModelBase) getCurrentStorageItem();
            if (getStorage() == null) {
                sanStorageModel.setItems(null);
            }
        }
        if (host != null) {
            getCurrentStorageItem().getUpdateCommand().execute();
            // $NON-NLS-1$
            String prefix = host.isOvirtVintageNode() ? localFSPath : "";
            if (!StringHelper.isNullOrEmpty(prefix)) {
                getStorageModels().stream().filter(item -> item instanceof LocalStorageModel).map(item -> (LocalStorageModel) item).forEach(model -> {
                    model.getPath().setEntity(prefix);
                    model.getPath().setIsChangeable(false);
                });
            }
        }
    }
}
#end_block

#method_before
private void initDataCenter() {
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        SystemTreeItemModel dataCenterItem;
        StoragePool dc;
        switch(getSystemTreeSelectedItem().getType()) {
            case DataCenter:
            case Cluster:
            case Storages:
            case Storage:
                dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                dc = (StoragePool) dataCenterItem.getEntity();
                getDataCenter().setItems(new ArrayList<>(Arrays.asList(new StoragePool[] { dc })));
                getDataCenter().setSelectedItem(dc);
                getDataCenter().setIsChangeable(false);
                getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                break;
            case Host:
                VDS host = (VDS) getSystemTreeSelectedItem().getEntity();
                getHost().setIsChangeable(false);
                getHost().setChangeProhibitionReason(constants.cannotChangeHostInTreeContext());
                getHost().setSelectedItem(host);
                dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                dc = (StoragePool) dataCenterItem.getEntity();
                getDataCenter().setItems(new ArrayList<>(Arrays.asList(new StoragePool[] { dc })));
                getDataCenter().setSelectedItem(dc);
                getDataCenter().setIsChangeable(false);
                getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                break;
        }
    } else {
        if (getStorage() == null || getStorage().getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) {
            // We are either adding a new storage or editing an unattached storage
            // -> fill DataCenters drop-down with all possible Data-Centers, choose the empty one:
            // [TODO: In case of an Unattached SD, choose only DCs of the same type]
            AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(dataCenters -> {
                StorageModelBehavior storageModelBehavior = behavior;
                dataCenters = storageModelBehavior.filterDataCenter(dataCenters);
                StorageModel.addEmptyDataCenterToList(dataCenters);
                StoragePool oldSelectedItem = getDataCenter().getSelectedItem();
                getDataCenter().setItems(dataCenters);
                if (oldSelectedItem != null) {
                    getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters, new Linq.IdPredicate<>(oldSelectedItem.getId())));
                } else {
                    getDataCenter().setSelectedItem(getStorage() == null ? Linq.firstOrNull(dataCenters) : Linq.firstOrNull(dataCenters, new Linq.IdPredicate<>(UnassignedDataCenterId)));
                }
            }));
        } else {
            // "Edit Storage" mode:
            AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery<>(dataCentersWithStorage -> {
                List<StoragePool> dataCenters = new ArrayList<>();
                if (dataCentersWithStorage.size() < 1 || dataCentersWithStorage.get(0) == null) {
                    StorageModel.addEmptyDataCenterToList(dataCenters);
                } else {
                    dataCenters = new ArrayList<>(Arrays.asList(new StoragePool[] { dataCentersWithStorage.get(0) }));
                }
                getDataCenter().setItems(dataCenters);
                getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
            }), getStorage().getId());
        }
    }
}
#method_after
private void initDataCenter() {
    if (getStorage() == null || getStorage().getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) {
        // We are either adding a new storage or editing an unattached storage
        // -> fill DataCenters drop-down with all possible Data-Centers, choose the empty one:
        // [TODO: In case of an Unattached SD, choose only DCs of the same type]
        AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(dataCenters -> {
            StorageModelBehavior storageModelBehavior = behavior;
            dataCenters = storageModelBehavior.filterDataCenter(dataCenters);
            addEmptyDataCenterToList(dataCenters);
            StoragePool oldSelectedItem = getDataCenter().getSelectedItem();
            getDataCenter().setItems(dataCenters);
            if (oldSelectedItem != null) {
                getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters, new Linq.IdPredicate<>(oldSelectedItem.getId())));
            } else {
                getDataCenter().setSelectedItem(getStorage() == null ? Linq.firstOrNull(dataCenters) : Linq.firstOrNull(dataCenters, new Linq.IdPredicate<>(UnassignedDataCenterId)));
            }
        }));
    } else {
        // "Edit Storage" mode:
        AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery<>(dataCentersWithStorage -> {
            List<StoragePool> dataCenters = new ArrayList<>();
            if (dataCentersWithStorage.size() < 1 || dataCentersWithStorage.get(0) == null) {
                addEmptyDataCenterToList(dataCenters);
            } else {
                dataCenters = new ArrayList<>(Collections.singletonList(dataCentersWithStorage.get(0)));
            }
            getDataCenter().setItems(dataCenters);
            getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
        }), getStorage().getId());
    }
}
#end_block

#method_before
void updateHost() {
    if (getDataCenter().getItems() == null) {
        return;
    }
    if (getCurrentStorageItem() == null) {
        return;
    }
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    boolean localFsOnly = getCurrentStorageItem() instanceof LocalStorageModel;
    Guid dataCenterId = dataCenter == null ? null : dataCenter.getId();
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery<>(hosts -> postUpdateHost(hosts)), dataCenterId, localFsOnly);
}
#method_after
void updateHost() {
    if (getDataCenter().getItems() == null) {
        return;
    }
    if (getCurrentStorageItem() == null) {
        return;
    }
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    boolean localFsOnly = getCurrentStorageItem() instanceof LocalStorageModel;
    Guid dataCenterId = dataCenter == null ? null : dataCenter.getId();
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery<>(this::postUpdateHost), dataCenterId, localFsOnly);
}
#end_block

#method_before
public void postUpdateHost(Collection<VDS> hosts) {
    // Filter hosts
    hosts = Linq.where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    VDS oldSelectedItem = getHost().getSelectedItem();
    VDS selectedItem = null;
    // any host can perform the operation, thus no need to filter to use just the SPM
    if (getStorage() != null && getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        VDS spm = getSPM(hosts);
        hosts = spm != null ? Collections.singletonList(spm) : Collections.<VDS>emptyList();
    }
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        selectedItem = Linq.firstOrNull(hosts, new Linq.IdPredicate<>(oldSelectedItem.getId()));
    }
    // Select a default - if there's a SPM choose it, otherwise choose the first host in the list.
    if (selectedItem == null) {
        VDS spm = getSPM(hosts);
        selectedItem = spm == null ? Linq.firstOrNull(hosts) : spm;
    }
    getHost().setItems(hosts, selectedItem);
}
#method_after
public void postUpdateHost(Collection<VDS> hosts) {
    // Filter hosts
    hosts = Linq.where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    VDS oldSelectedItem = getHost().getSelectedItem();
    VDS selectedItem = null;
    // any host can perform the operation, thus no need to filter to use just the SPM
    if (getStorage() != null && getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        VDS spm = getSPM(hosts);
        hosts = spm != null ? Collections.singletonList(spm) : Collections.emptyList();
    }
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        selectedItem = Linq.firstOrNull(hosts, new Linq.IdPredicate<>(oldSelectedItem.getId()));
    }
    // Select a default - if there's a SPM choose it, otherwise choose the first host in the list.
    if (selectedItem == null) {
        VDS spm = getSPM(hosts);
        selectedItem = spm == null ? Linq.firstOrNull(hosts) : spm;
    }
    getHost().setItems(hosts, selectedItem);
}
#end_block

#method_before
private VDS getSPM(Iterable<VDS> hosts) {
    for (VDS host : hosts) {
        if (host.getSpmStatus() == VdsSpmStatus.SPM) {
            return host;
        }
    }
    return null;
}
#method_after
private VDS getSPM(Collection<VDS> hosts) {
    return hosts.stream().filter(host -> host.getSpmStatus() == VdsSpmStatus.SPM).findFirst().orElse(null);
}
#end_block

#method_before
private void updateDiscardAfterDelete() {
    if (getDataCenter().getSelectedItem() != null && getAvailableStorageTypeItems().getSelectedItem() != null) {
        boolean isBlockDomain = getAvailableStorageTypeItems().getSelectedItem().isBlockDomain();
        boolean isStorageDomainUnattached = getDataCenter().getSelectedItem().getId().equals(Guid.Empty);
        if (!isBlockDomain || isStorageDomainUnattached) {
            getDiscardAfterDelete().setIsAvailable(false);
            getDiscardAfterDelete().setEntity(false);
            return;
        }
        boolean discardAfterDeleteSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.DiscardAfterDeleteSupported, getDataCenter().getSelectedItem().getCompatibilityVersion().toString());
        getDiscardAfterDelete().setIsAvailable(discardAfterDeleteSupported);
        if (getDiscardAfterDelete().getIsAvailable()) {
            if (isNewStorage()) {
                getDiscardAfterDelete().setEntity(true);
            } else {
                getDiscardAfterDelete().setEntity(getStorage().getDiscardAfterDelete());
            }
        } else {
            getDiscardAfterDelete().setEntity(false);
        }
    }
}
#method_after
private void updateDiscardAfterDelete() {
    if (getDataCenter().getSelectedItem() != null && getAvailableStorageTypeItems().getSelectedItem() != null) {
        boolean isBlockDomain = getAvailableStorageTypeItems().getSelectedItem().isBlockDomain();
        boolean isStorageDomainUnattached = getDataCenter().getSelectedItem().getId().equals(Guid.Empty);
        if (!isBlockDomain || isStorageDomainUnattached) {
            getDiscardAfterDelete().setIsAvailable(false);
            getDiscardAfterDelete().setEntity(false);
            return;
        }
        boolean discardAfterDeleteSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.DiscardAfterDeleteSupported, getDataCenter().getSelectedItem().getCompatibilityVersion().toString());
        getDiscardAfterDelete().setIsAvailable(discardAfterDeleteSupported);
        if (getDiscardAfterDelete().getIsAvailable()) {
            if (isNewStorage()) {
                getDiscardAfterDelete().setEntity(true);
            } else {
                getDiscardAfterDelete().setEntity(getStorage().getDiscardAfterDelete());
            }
        } else {
            getDiscardAfterDelete().setEntity(false);
        }
    }
}
#end_block

#method_before
private void updateBackup() {
    if (getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport) {
        isBackup().setIsAvailable(false);
        isBackup().setEntity(false);
        return;
    }
    boolean backupSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.BackupSupported, getDataCenter().getSelectedItem().getCompatibilityVersion().toString());
    isBackup().setIsAvailable(backupSupported);
    if (isBackup().getIsAvailable()) {
        if (isNewStorage()) {
            isBackup().setEntity(false);
        } else {
            isBackup().setEntity(getStorage().isBackup());
        }
    }
}
#method_after
private void updateBackup() {
    if (getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport) {
        getBackup().setIsAvailable(false);
        getBackup().setEntity(false);
        return;
    }
    boolean backupSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.BackupSupported, getDataCenter().getSelectedItem().getCompatibilityVersion().toString());
    getBackup().setIsAvailable(backupSupported);
    getBackup().setEntity(isNewStorage() ? false : getStorage().isBackup());
}
#end_block

#method_before
public boolean validate() {
    validateListItems(getHost());
    validateListItems(getAvailableStorageDomainTypeItems());
    validateListItems(getAvailableStorageTypeItems());
    getDescription().validateEntity(new IValidation[] { new LengthValidation(BusinessEntitiesDefinitions.GENERAL_MAX_SIZE), new SpecialAsciiI18NOrNoneValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getWarningLowSpaceIndicator().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, StorageConstants.LOW_SPACE_THRESHOLD) });
    getCriticalSpaceActionBlocker().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, Integer.MAX_VALUE) });
    validateDiscardAfterDelete();
    return getName().getIsValid() && getHost().getIsValid() && getIsValid() && getCurrentStorageItem().validate() && getDescription().getIsValid() && getComment().getIsValid() && getWarningLowSpaceIndicator().getIsValid() && getCriticalSpaceActionBlocker().getIsValid() && getDiscardAfterDelete().getIsValid();
}
#method_after
public boolean validate() {
    validateListItems(getHost());
    validateListItems(getAvailableStorageDomainTypeItems());
    validateListItems(getAvailableStorageTypeItems());
    getDescription().validateEntity(new IValidation[] { new LengthValidation(BusinessEntitiesDefinitions.GENERAL_MAX_SIZE), new SpecialAsciiI18NOrNoneValidation() });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getWarningLowSpaceIndicator().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, StorageConstants.LOW_SPACE_THRESHOLD) });
    getCriticalSpaceActionBlocker().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, Integer.MAX_VALUE) });
    validateDiscardAfterDelete();
    return getName().getIsValid() && getHost().getIsValid() && getIsValid() && getCurrentStorageItem().validate() && getDescription().getIsValid() && getComment().getIsValid() && getWarningLowSpaceIndicator().getIsValid() && getCriticalSpaceActionBlocker().getIsValid() && getDiscardAfterDelete().getIsValid() && getBackup().getIsValid();
}
#end_block

#method_before
private boolean storageDomainSupportsDiscard(Collection<LunModel> luns) {
    for (LunModel lun : luns) {
        if (!lun.getEntity().supportsDiscard()) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean storageDomainSupportsDiscard(Collection<LunModel> luns) {
    return luns.stream().allMatch(lun -> lun.getEntity().supportsDiscard());
}
#end_block

#method_before
private int getWarningLowSpaceIndicatorValue() {
    if (isNewStorage()) {
        return (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.WarningLowSpaceIndicator);
    }
    return getStorage().getWarningLowSpaceIndicator();
}
#method_after
private int getWarningLowSpaceIndicatorValue() {
    if (isNewStorage()) {
        return (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.WarningLowSpaceIndicator);
    }
    return getStorage().getWarningLowSpaceIndicator();
}
#end_block

#method_before
private int getCriticalSpaceThresholdValue() {
    if (isNewStorage()) {
        return (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.CriticalSpaceActionBlocker);
    }
    return getStorage().getCriticalSpaceActionBlocker();
}
#method_after
private int getCriticalSpaceThresholdValue() {
    if (isNewStorage()) {
        return (Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.CriticalSpaceActionBlocker);
    }
    return getStorage().getCriticalSpaceActionBlocker();
}
#end_block

#method_before
public void updateCurrentStorageItem() {
    StorageDomainType storageDomainType = getAvailableStorageDomainTypeItems().getSelectedItem();
    StorageType storageType = getAvailableStorageTypeItems().getSelectedItem();
    for (IStorageModel model : getStorageModels()) {
        if (model.getType() == storageType && model.getRole() == storageDomainType) {
            setCurrentStorageItem(model);
            break;
        }
    }
}
#method_after
public void updateCurrentStorageItem() {
    StorageDomainType storageDomainType = getAvailableStorageDomainTypeItems().getSelectedItem();
    StorageType storageType = getAvailableStorageTypeItems().getSelectedItem();
    getStorageModels().stream().filter(model -> model.getType() == storageType && model.getRole() == storageDomainType).findFirst().ifPresent(this::setCurrentStorageItem);
}
#end_block

#method_before
public List<IStorageModel> getStorageModelsByRole(StorageDomainType role) {
    List<IStorageModel> filteredModels = new LinkedList<>();
    for (IStorageModel model : getStorageModels()) {
        if (model.getRole() == role) {
            filteredModels.add(model);
        }
    }
    return filteredModels;
}
#method_after
public List<IStorageModel> getStorageModelsByRole(StorageDomainType role) {
    return getStorageModels().stream().filter(model -> model.getRole() == role).collect(Collectors.toList());
}
#end_block

#method_before
private void setDetailList(final StorageEventListModel storageEventListModel, final PermissionListModel<StorageDomain> permissionListModel) {
    generalModel.setIsAvailable(false);
    dcListModel.setIsAvailable(false);
    this.vmBackupModel.setIsAvailable(false);
    this.templateBackupModel.setIsAvailable(false);
    vmRegisterListModel.setIsAvailable(false);
    templateRegisterListModel.setIsAvailable(false);
    diskImageRegisterListModel.setIsAvailable(false);
    vmListModel.setIsAvailable(false);
    templateListModel.setIsAvailable(false);
    isoListModel.setIsAvailable(false);
    diskListModel.setIsAvailable(false);
    registerDiskListModel.setIsAvailable(false);
    snapshotListModel.setIsAvailable(false);
    this.diskProfileListModel.setIsAvailable(false);
    this.storageDRListModel.setIsAvailable(false);
    this.storageLeaseListModel.setIsAvailable(false);
    List<HasEntity<StorageDomain>> list = new ArrayList<>();
    list.add(generalModel);
    list.add(dcListModel);
    list.add(vmBackupModel);
    list.add(templateBackupModel);
    list.add(vmRegisterListModel);
    list.add(templateRegisterListModel);
    list.add(diskImageRegisterListModel);
    list.add(vmListModel);
    list.add(templateListModel);
    list.add(storageLeaseListModel);
    list.add(isoListModel);
    list.add(diskListModel);
    list.add(registerDiskListModel);
    list.add(snapshotListModel);
    list.add(this.diskProfileListModel);
    list.add(this.storageDRListModel);
    list.add(storageEventListModel);
    list.add(permissionListModel);
    setDetailModels(list);
}
#method_after
private void setDetailList() {
    generalModel.setIsAvailable(false);
    dcListModel.setIsAvailable(false);
    vmBackupModel.setIsAvailable(false);
    templateBackupModel.setIsAvailable(false);
    vmRegisterListModel.setIsAvailable(false);
    templateRegisterListModel.setIsAvailable(false);
    diskImageRegisterListModel.setIsAvailable(false);
    vmListModel.setIsAvailable(false);
    templateListModel.setIsAvailable(false);
    isoListModel.setIsAvailable(false);
    diskListModel.setIsAvailable(false);
    registerDiskListModel.setIsAvailable(false);
    snapshotListModel.setIsAvailable(false);
    diskProfileListModel.setIsAvailable(false);
    drListModel.setIsAvailable(false);
    leaseListModel.setIsAvailable(false);
    List<HasEntity<StorageDomain>> list = new ArrayList<>();
    list.add(generalModel);
    list.add(dcListModel);
    list.add(vmBackupModel);
    list.add(templateBackupModel);
    list.add(vmRegisterListModel);
    list.add(templateRegisterListModel);
    list.add(diskImageRegisterListModel);
    list.add(vmListModel);
    list.add(templateListModel);
    list.add(leaseListModel);
    list.add(isoListModel);
    list.add(diskListModel);
    list.add(registerDiskListModel);
    list.add(snapshotListModel);
    list.add(diskProfileListModel);
    list.add(drListModel);
    list.add(eventListModel);
    list.add(permissionListModel);
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(applySortOptions(getSearchString()), SearchType.StorageDomain, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#method_after
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(applySortOptions(getSearchString()), SearchType.StorageDomain, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(QueryType.Search, tempVar);
}
#end_block

#method_before
private void newDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDomainTitle());
    model.setHelpTag(HelpTag.new_domain);
    // $NON-NLS-1$
    model.setHashName("new_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    // putting all Data domains at the beginning on purpose (so when choosing the
    // first selectable storage type/function, it will be a Data one, if relevant).
    List<IStorageModel> items = AsyncDataProvider.getInstance().getDataStorageModels();
    items.addAll(AsyncDataProvider.getInstance().getIsoStorageModels());
    items.addAll(AsyncDataProvider.getInstance().getExportStorageModels());
    model.setStorageModels(items);
    model.initialize();
    // $NON-NLS-1$
    UICommand command = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#method_after
private void newDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDomainTitle());
    model.setHelpTag(HelpTag.new_domain);
    // $NON-NLS-1$
    model.setHashName("new_domain");
    // putting all Data domains at the beginning on purpose (so when choosing the
    // first selectable storage type/function, it will be a Data one, if relevant).
    List<IStorageModel> items = AsyncDataProvider.getInstance().getDataStorageModels();
    items.addAll(AsyncDataProvider.getInstance().getIsoStorageModels());
    items.addAll(AsyncDataProvider.getInstance().getExportStorageModels());
    model.setStorageModels(items);
    model.initialize();
    // $NON-NLS-1$
    UICommand command = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#end_block

#method_before
private void edit() {
    StorageDomain storage = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    model.setHelpTag(HelpTag.edit_domain);
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangeable(false);
    model.getFormat().setIsChangeable(false);
    boolean isStorageNameEditable = model.isStorageActive() || model.isNewStorage();
    boolean isStorageInMaintenance = !model.isNewStorage() && model.getStorage().getStatus() == StorageDomainStatus.Maintenance;
    model.getHost().setIsChangeable(false);
    model.getName().setIsChangeable(isStorageNameEditable);
    // set the field domain type to non editable
    model.getAvailableStorageTypeItems().setIsChangeable(false);
    model.getAvailableStorageDomainTypeItems().setIsChangeable(false);
    model.setIsChangeable(isStorageNameEditable && !isStorageInMaintenance);
    model.getWarningLowSpaceIndicator().setEntity(storage.getWarningLowSpaceIndicator());
    model.getWarningLowSpaceSize().setEntity(ConstantsManager.getInstance().getMessages().bracketsWithGB(storage.getWarningLowSpaceSize()));
    model.getWarningLowSpaceSize().setIsAvailable(true);
    model.getCriticalSpaceActionBlocker().setEntity(storage.getCriticalSpaceActionBlocker());
    IStorageModel item = prepareStorageForEdit(storage, model);
    model.setStorageModels(new ArrayList<>(Arrays.asList(new IStorageModel[] { item })));
    model.setCurrentStorageItem(item);
    model.initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        model.getName().setIsChangeable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    UICommand command;
    // $NON-NLS-1$
    command = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#method_after
private void edit() {
    StorageDomain storage = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    model.setHelpTag(HelpTag.edit_domain);
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangeable(false);
    model.getFormat().setIsChangeable(false);
    boolean isStorageNameEditable = model.isStorageActive() || model.isNewStorage();
    boolean isStorageInMaintenance = !model.isNewStorage() && model.getStorage().getStatus() == StorageDomainStatus.Maintenance;
    model.getHost().setIsChangeable(false);
    model.getName().setIsChangeable(isStorageNameEditable);
    // set the field domain type to non editable
    model.getAvailableStorageTypeItems().setIsChangeable(false);
    model.getAvailableStorageDomainTypeItems().setIsChangeable(false);
    model.setIsChangeable(isStorageNameEditable && !isStorageInMaintenance);
    model.getWarningLowSpaceIndicator().setEntity(storage.getWarningLowSpaceIndicator());
    model.getWarningLowSpaceSize().setEntity(ConstantsManager.getInstance().getMessages().bracketsWithGB(storage.getWarningLowSpaceSize()));
    model.getWarningLowSpaceSize().setIsAvailable(true);
    model.getCriticalSpaceActionBlocker().setEntity(storage.getCriticalSpaceActionBlocker());
    IStorageModel item = prepareStorageForEdit(storage, model);
    model.setStorageModels(new ArrayList<>(Arrays.asList(new IStorageModel[] { item })));
    model.setCurrentStorageItem(item);
    model.initialize();
    UICommand command;
    // $NON-NLS-1$
    command = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#end_block

#method_before
private void importDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new ImportStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().importPreConfiguredDomainTitle());
    model.setHelpTag(HelpTag.import_pre_configured_domain);
    // $NON-NLS-1$
    model.setHashName("import_pre-configured_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.getFormat().setIsAvailable(false);
    model.initialize();
    UICommand command;
    // $NON-NLS-1$
    command = UICommand.createDefaultOkUiCommand("OnImport", this);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#method_after
private void importDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new ImportStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().importPreConfiguredDomainTitle());
    model.setHelpTag(HelpTag.import_pre_configured_domain);
    // $NON-NLS-1$
    model.setHashName("import_pre-configured_domain");
    model.getFormat().setIsAvailable(false);
    model.initialize();
    UICommand command;
    // $NON-NLS-1$
    command = UICommand.createDefaultOkUiCommand("OnImport", this);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#end_block

#method_before
private void cleanConnection(StorageServerConnections connection, Guid hostId) {
    // then the id of connection will be empty, and there's nothing to delete.
    if (connection.getId() != null && !connection.getId().equals("")) {
        // $NON-NLS-1$
        Frontend.getInstance().runAction(VdcActionType.RemoveStorageServerConnection, new StorageServerConnectionParametersBase(connection, hostId, false), null, this);
    }
}
#method_after
private void cleanConnection(StorageServerConnections connection, Guid hostId) {
    // then the id of connection will be empty, and there's nothing to delete.
    if (connection.getId() != null && !connection.getId().equals("")) {
        // $NON-NLS-1$
        Frontend.getInstance().runAction(ActionType.RemoveStorageServerConnection, new StorageServerConnectionParametersBase(connection, hostId, false), null, this);
    }
}
#end_block

#method_before
private void updateOvfs() {
    StorageDomain storage = getSelectedItem();
    if (storage != null) {
        ProcessOvfUpdateForStorageDomainCommandParameters params = new ProcessOvfUpdateForStorageDomainCommandParameters();
        params.setStorageDomainId(storage.getId());
        params.setStoragePoolId(storage.getStoragePoolId());
        Frontend.getInstance().runAction(VdcActionType.ProcessOvfUpdateForStorageDomain, params, null, this);
    }
    cancel();
}
#method_after
private void updateOvfs() {
    StorageDomain storage = getSelectedItem();
    if (storage != null) {
        StorageDomainParametersBase params = new StorageDomainParametersBase(storage.getId());
        Frontend.getInstance().runAction(ActionType.UpdateOvfStoreForStorageDomain, params, null, this);
    }
    cancel();
}
#end_block

#method_before
private void onRemove() {
    if (getSelectedItem() != null) {
        StorageDomain storage = getSelectedItem();
        RemoveStorageModel model = (RemoveStorageModel) getWindow();
        if (!model.validate()) {
            return;
        }
        VDS host = model.getHostList().getSelectedItem();
        RemoveStorageDomainParameters tempVar = new RemoveStorageDomainParameters(storage.getId());
        tempVar.setVdsId(host.getId());
        tempVar.setDoFormat(model.getFormat().getEntity());
        Frontend.getInstance().runAction(VdcActionType.RemoveStorageDomain, tempVar, null, this);
    }
    cancel();
}
#method_after
private void onRemove() {
    if (getSelectedItem() != null) {
        StorageDomain storage = getSelectedItem();
        RemoveStorageModel model = (RemoveStorageModel) getWindow();
        if (!model.validate()) {
            return;
        }
        VDS host = model.getHostList().getSelectedItem();
        RemoveStorageDomainParameters tempVar = new RemoveStorageDomainParameters(storage.getId());
        tempVar.setVdsId(host.getId());
        tempVar.setDoFormat(model.getFormat().getEntity());
        selectNextItem();
        Frontend.getInstance().runAction(ActionType.RemoveStorageDomain, tempVar, null, this);
    }
    cancel();
}
#end_block

#method_before
private void onDestroy() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    StorageDomain storageDomain = getSelectedItem();
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.ForceRemoveStorageDomain, new ArrayList<>(Arrays.asList(new VdcActionParametersBase[] { new StorageDomainParametersBase(storageDomain.getId()) })), result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#method_after
private void onDestroy() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    StorageDomain storageDomain = getSelectedItem();
    model.startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.ForceRemoveStorageDomain, new ArrayList<>(Arrays.asList(new ActionParametersBase[] { new StorageDomainParametersBase(storageDomain.getId()) })), result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#end_block

#method_before
private void scanDisks() {
    StorageDomain storageDomain = getSelectedItem();
    if (storageDomain != null) {
        Frontend.getInstance().runAction(VdcActionType.ScanStorageForUnregisteredDisks, new StorageDomainParametersBase(storageDomain.getStoragePoolId(), storageDomain.getId()));
    }
}
#method_after
private void scanDisks() {
    StorageDomain storageDomain = getSelectedItem();
    if (storageDomain != null) {
        Frontend.getInstance().runAction(ActionType.ScanStorageForUnregisteredDisks, new StorageDomainParametersBase(storageDomain.getStoragePoolId(), storageDomain.getId()));
    }
}
#end_block

#method_before
private void saveSanStorage() {
    StorageModel storageModel = (StorageModel) getWindow();
    final SanStorageModelBase sanStorageModelBase = (SanStorageModelBase) storageModel.getCurrentStorageItem();
    Guid hostId = sanStorageModelBase.getContainer().getHost().getSelectedItem().getId();
    if (sanStorageModelBase.getAddedLuns().isEmpty()) {
        onSaveSanStorage();
        return;
    }
    List<String> unkownStatusLuns = new ArrayList<>();
    for (LunModel lunModel : sanStorageModelBase.getAddedLuns()) {
        unkownStatusLuns.add(lunModel.getLunId());
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, sanStorageModelBase.getType(), true, unkownStatusLuns), new AsyncQuery<VdcQueryReturnValue>(response -> {
        if (response.getSucceeded()) {
            List<LUNs> checkedLuns = (ArrayList<LUNs>) response.getReturnValue();
            postGetLunsMessages(sanStorageModelBase.getUsedLunsMessages(checkedLuns));
        } else {
            sanStorageModelBase.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
        }
    }, true));
}
#method_after
private void saveSanStorage() {
    StorageModel storageModel = (StorageModel) getWindow();
    final SanStorageModelBase sanStorageModelBase = (SanStorageModelBase) storageModel.getCurrentStorageItem();
    Guid hostId = sanStorageModelBase.getContainer().getHost().getSelectedItem().getId();
    if (sanStorageModelBase.getAddedLuns().isEmpty()) {
        onSaveSanStorage();
        return;
    }
    Set<String> unkownStatusLuns = new HashSet<>();
    for (LunModel lunModel : sanStorageModelBase.getAddedLuns()) {
        unkownStatusLuns.add(lunModel.getLunId());
    }
    Frontend.getInstance().runQuery(QueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, sanStorageModelBase.getType(), true, unkownStatusLuns, false), new AsyncQuery<QueryReturnValue>(response -> {
        if (response.getSucceeded()) {
            List<LUNs> checkedLuns = (ArrayList<LUNs>) response.getReturnValue();
            postGetLunsMessages(sanStorageModelBase.getUsedLunsMessages(checkedLuns));
        } else {
            sanStorageModelBase.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
        }
    }, true));
}
#end_block

#method_before
private void cancelImportConfirm() {
    cancelConfirm();
    getWindow().stopProgress();
    if (fileConnection != null) {
        Frontend.getInstance().runAction(VdcActionType.DisconnectStorageServerConnection, new StorageServerConnectionParametersBase(fileConnection, hostId, false), result -> {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            cleanConnection(storageListModel.fileConnection, storageListModel.hostId);
            storageListModel.fileConnection = null;
        }, this);
    }
}
#method_after
private void cancelImportConfirm() {
    cancelConfirm();
    getWindow().stopProgress();
    if (fileConnection != null) {
        Frontend.getInstance().runAction(ActionType.DisconnectStorageServerConnection, new StorageServerConnectionParametersBase(fileConnection, hostId, false), result -> {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            cleanConnection(storageListModel.fileConnection, storageListModel.hostId);
            storageListModel.fileConnection = null;
        }, this);
    }
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    if (getSelectedItem() != null) {
        StorageDomain storage = getSelectedItem();
        boolean isBackupStorage = storage.getStorageDomainType() == StorageDomainType.ImportExport;
        boolean isDataStorage = storage.getStorageDomainType().isDataDomain();
        boolean isImageStorage = storage.getStorageDomainType() == StorageDomainType.Image || storage.getStorageDomainType() == StorageDomainType.ISO;
        boolean isDataCenterAvailable = storage.getStorageType() != StorageType.GLANCE;
        boolean isGeneralAvailable = storage.getStorageType() != StorageType.GLANCE;
        boolean isCinderStorage = storage.getStorageType().isCinderDomain();
        boolean isGlusterStorage = storage.getStorageType() == StorageType.GLUSTERFS;
        boolean isRegsiterEntityListModelSelected = getActiveDetailModel() == vmRegisterListModel || getActiveDetailModel() == templateRegisterListModel || getActiveDetailModel() == diskImageRegisterListModel;
        boolean isRegisterSubtabsAvailable = isDataStorage && storage.getStatus() != StorageDomainStatus.Unattached && (storage.isContainsUnregisteredEntities() || isRegsiterEntityListModelSelected);
        generalModel.setIsAvailable(isGeneralAvailable);
        dcListModel.setIsAvailable(isDataCenterAvailable);
        vmBackupModel.setIsAvailable(isBackupStorage);
        templateBackupModel.setIsAvailable(isBackupStorage);
        vmListModel.setIsAvailable(isDataStorage);
        templateListModel.setIsAvailable(isDataStorage);
        vmRegisterListModel.setIsAvailable(isRegisterSubtabsAvailable);
        templateRegisterListModel.setIsAvailable(isRegisterSubtabsAvailable);
        diskImageRegisterListModel.setIsAvailable(isRegisterSubtabsAvailable);
        diskListModel.setIsAvailable(isDataStorage || isCinderStorage);
        registerDiskListModel.setIsAvailable(isCinderStorage);
        snapshotListModel.setIsAvailable(isDataStorage || isCinderStorage);
        diskProfileListModel.setIsAvailable(isDataStorage);
        storageDRListModel.setIsAvailable(isGlusterStorage);
        storageLeaseListModel.setIsAvailable(isDataStorage);
        isoListModel.setIsAvailable(isImageStorage);
    }
}
#method_after
@Override
protected void updateDetailsAvailability() {
    if (getSelectedItem() != null) {
        StorageDomain storage = getSelectedItem();
        boolean isBackupStorage = storage.getStorageDomainType() == StorageDomainType.ImportExport;
        boolean isDataStorage = storage.getStorageDomainType().isDataDomain();
        boolean isImageStorage = storage.getStorageDomainType() == StorageDomainType.Image || storage.getStorageDomainType() == StorageDomainType.ISO;
        boolean isDataCenterAvailable = storage.getStorageType() != StorageType.GLANCE;
        boolean isGeneralAvailable = storage.getStorageType() != StorageType.GLANCE;
        boolean isCinderStorage = storage.getStorageType().isCinderDomain();
        boolean isGlusterStorage = storage.getStorageType() == StorageType.GLUSTERFS;
        boolean isRegsiterEntityListModelSelected = getActiveDetailModel() == vmRegisterListModel || getActiveDetailModel() == templateRegisterListModel || getActiveDetailModel() == diskImageRegisterListModel;
        boolean isRegisterSubtabsAvailable = isDataStorage && storage.getStatus() != StorageDomainStatus.Unattached && (storage.isContainsUnregisteredEntities() || isRegsiterEntityListModelSelected);
        generalModel.setIsAvailable(isGeneralAvailable);
        dcListModel.setIsAvailable(isDataCenterAvailable);
        vmBackupModel.setIsAvailable(isBackupStorage);
        templateBackupModel.setIsAvailable(isBackupStorage);
        vmListModel.setIsAvailable(isDataStorage);
        templateListModel.setIsAvailable(isDataStorage);
        vmRegisterListModel.setIsAvailable(isRegisterSubtabsAvailable);
        templateRegisterListModel.setIsAvailable(isRegisterSubtabsAvailable);
        diskImageRegisterListModel.setIsAvailable(isRegisterSubtabsAvailable);
        diskListModel.setIsAvailable(isDataStorage || isCinderStorage);
        registerDiskListModel.setIsAvailable(isCinderStorage);
        snapshotListModel.setIsAvailable(isDataStorage || isCinderStorage);
        diskProfileListModel.setIsAvailable(isDataStorage);
        drListModel.setIsAvailable(isGlusterStorage);
        leaseListModel.setIsAvailable(isDataStorage);
        isoListModel.setIsAvailable(isImageStorage);
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    List<StorageDomain> items = getSelectedItems() != null ? getSelectedItems() : new ArrayList<StorageDomain>();
    StorageDomain item = getSelectedItem();
    getNewDomainCommand().setIsAvailable(true);
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && isEditAvailable(item));
    getRemoveCommand().setIsExecutionAllowed(items.size() == 1 && !items.get(0).getStorageType().isOpenStackDomain() && items.get(0).getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached);
    getDestroyCommand().setIsExecutionAllowed(item != null && items.size() == 1 && !items.get(0).getStorageType().isOpenStackDomain() && item.getStatus() != StorageDomainStatus.Active);
    getScanDisksCommand().setIsExecutionAllowed(item != null && items.size() == 1 && !items.get(0).getStorageType().isOpenStackDomain() && item.getStatus() == StorageDomainStatus.Active && item.getStorageDomainType().isDataDomain());
    getUpdateOvfsCommand().setIsExecutionAllowed(item != null && items.size() == 1 && item.getStorageDomainType().isDataDomain() && item.getStatus() == StorageDomainStatus.Active);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage);
    getNewDomainCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getDestroyCommand().setIsAvailable(isAvailable);
    getScanDisksCommand().setIsAvailable(isAvailable);
    getUpdateOvfsCommand().setIsAvailable(isAvailable);
}
#method_after
private void updateActionAvailability() {
    List<StorageDomain> items = getSelectedItems() != null ? getSelectedItems() : new ArrayList<StorageDomain>();
    StorageDomain item = getSelectedItem();
    getNewDomainCommand().setIsAvailable(true);
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && isEditAvailable(item));
    getRemoveCommand().setIsExecutionAllowed(items.size() == 1 && !items.get(0).getStorageType().isOpenStackDomain() && items.get(0).getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached);
    getDestroyCommand().setIsExecutionAllowed(item != null && items.size() == 1 && !items.get(0).getStorageType().isOpenStackDomain() && item.getStatus() != StorageDomainStatus.Active);
    getScanDisksCommand().setIsExecutionAllowed(item != null && items.size() == 1 && !items.get(0).getStorageType().isOpenStackDomain() && item.getStatus() == StorageDomainStatus.Active && item.getStorageDomainType().isDataDomain());
    getUpdateOvfsCommand().setIsExecutionAllowed(item != null && items.size() == 1 && item.getStorageDomainType().isDataDomain() && item.getStatus() == StorageDomainStatus.Active);
    getNewDomainCommand().setIsAvailable(true);
    getRemoveCommand().setIsAvailable(true);
    getDestroyCommand().setIsAvailable(true);
    getScanDisksCommand().setIsAvailable(true);
    getUpdateOvfsCommand().setIsAvailable(true);
}
#end_block

#method_before
private void saveDefaultedStorageProperties(StorageModel model, StorageDomainStatic storageDomainStatic) {
    storageDomainStatic.setWipeAfterDelete(model.getWipeAfterDelete().getEntity());
    storageDomainStatic.setDiscardAfterDelete(model.getDiscardAfterDelete().getEntity());
    storageDomainStatic.setWarningLowSpaceIndicator(model.getWarningLowSpaceIndicator().getEntity());
    storageDomainStatic.setCriticalSpaceActionBlocker(model.getCriticalSpaceActionBlocker().getEntity());
    storageDomainStatic.setBackup(model.isBackup().getEntity());
}
#method_after
private void saveDefaultedStorageProperties(StorageModel model, StorageDomainStatic storageDomainStatic) {
    storageDomainStatic.setWipeAfterDelete(model.getWipeAfterDelete().getEntity());
    storageDomainStatic.setDiscardAfterDelete(model.getDiscardAfterDelete().getEntity());
    storageDomainStatic.setWarningLowSpaceIndicator(model.getWarningLowSpaceIndicator().getEntity());
    storageDomainStatic.setCriticalSpaceActionBlocker(model.getCriticalSpaceActionBlocker().getEntity());
    storageDomainStatic.setBackup(model.getBackup().getEntity());
}
#end_block

#method_before
private void updateStorageDomain() {
    Frontend.getInstance().runAction(VdcActionType.UpdateStorageDomain, new StorageDomainManagementParameter(this.storageDomain), result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
    }, this);
}
#method_after
private void updateStorageDomain() {
    Frontend.getInstance().runAction(ActionType.UpdateStorageDomain, new StorageDomainManagementParameter(this.storageDomain), result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
    }, this);
}
#end_block

#method_before
public void saveNewPosixStorage() {
    StorageModel model = (StorageModel) getWindow();
    PosixStorageModel posixModel = (PosixStorageModel) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections connection = new StorageServerConnections();
    connection.setConnection(path);
    connection.setStorageType(posixModel.getType());
    connection.setVfsType(posixModel.getVfsType().getEntity());
    connection.setMountOptions(posixModel.getMountOptions().getEntity());
    if (posixModel instanceof GlusterStorageModel) {
        GlusterStorageModel glusterModel = (GlusterStorageModel) posixModel;
        Guid glusterVolId = null;
        if (glusterModel.getLinkGlusterVolume().getEntity()) {
            glusterVolId = ((GlusterStorageModel) posixModel).getGlusterVolumes().getSelectedItem() != null ? ((GlusterStorageModel) posixModel).getGlusterVolumes().getSelectedItem().getId() : null;
        }
        connection.setGlusterVolumeId(glusterVolId);
    }
    this.connection = connection;
    ArrayList<VdcActionType> actionTypes = new ArrayList<>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(posixModel.getAddStorageDomainVdcAction());
    parameters.add(new StorageServerConnectionParametersBase(this.connection, host.getId(), false));
    StorageDomainManagementParameter parameter = new StorageDomainManagementParameter(storageDomain);
    parameter.setVdsId(host.getId());
    StoragePool dataCenter = model.getDataCenter().getSelectedItem();
    parameter.setStoragePoolId(dataCenter.getId());
    parameters.add(parameter);
    IFrontendActionAsyncCallback callback1 = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
        storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
        storageListModel.connection.setId((String) vdcReturnValueBase.getActionReturnValue());
    };
    IFrontendActionAsyncCallback callback2 = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
        storageListModel.storageId = vdcReturnValueBase.getActionReturnValue();
        // Attach storage to data center as necessary.
        StorageModel storageModel = (StorageModel) storageListModel.getWindow();
        StoragePool dataCenter1 = storageModel.getDataCenter().getSelectedItem();
        if (!dataCenter1.getId().equals(StorageModel.UnassignedDataCenterId)) {
            storageListModel.attachStorageToDataCenter(storageListModel.storageId, dataCenter1.getId(), storageModel.getActivateDomain().getEntity());
        }
        storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
    };
    IFrontendActionAsyncCallback failureCallback = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
        storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2 })), failureCallback, this);
}
#method_after
public void saveNewPosixStorage() {
    StorageModel model = (StorageModel) getWindow();
    PosixStorageModel posixModel = (PosixStorageModel) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections connection = new StorageServerConnections();
    connection.setConnection(path);
    connection.setStorageType(posixModel.getType());
    connection.setVfsType(posixModel.getVfsType().getEntity());
    connection.setMountOptions(posixModel.getMountOptions().getEntity());
    if (posixModel instanceof GlusterStorageModel) {
        GlusterStorageModel glusterModel = (GlusterStorageModel) posixModel;
        Guid glusterVolId = null;
        if (glusterModel.getLinkGlusterVolume().getEntity()) {
            glusterVolId = ((GlusterStorageModel) posixModel).getGlusterVolumes().getSelectedItem() != null ? ((GlusterStorageModel) posixModel).getGlusterVolumes().getSelectedItem().getId() : null;
        }
        connection.setGlusterVolumeId(glusterVolId);
    }
    this.connection = connection;
    ArrayList<ActionType> actionTypes = new ArrayList<>();
    ArrayList<ActionParametersBase> parameters = new ArrayList<>();
    actionTypes.add(ActionType.AddStorageServerConnection);
    actionTypes.add(posixModel.getAddStorageDomainVdcAction());
    parameters.add(new StorageServerConnectionParametersBase(this.connection, host.getId(), false));
    StorageDomainManagementParameter parameter = new StorageDomainManagementParameter(storageDomain);
    parameter.setVdsId(host.getId());
    StoragePool dataCenter = model.getDataCenter().getSelectedItem();
    parameter.setStoragePoolId(dataCenter.getId());
    parameters.add(parameter);
    IFrontendActionAsyncCallback callback1 = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        ActionReturnValue actionReturnValue = result.getReturnValue();
        storageListModel.storageDomain.setStorage((String) actionReturnValue.getActionReturnValue());
        storageListModel.connection.setId((String) actionReturnValue.getActionReturnValue());
    };
    IFrontendActionAsyncCallback callback2 = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        ActionReturnValue actionReturnValue = result.getReturnValue();
        storageListModel.storageId = actionReturnValue.getActionReturnValue();
        // Attach storage to data center as necessary.
        StorageModel storageModel = (StorageModel) storageListModel.getWindow();
        StoragePool dataCenter1 = storageModel.getDataCenter().getSelectedItem();
        if (!dataCenter1.getId().equals(StorageModel.UnassignedDataCenterId)) {
            storageListModel.attachStorageToDataCenter(storageListModel.storageId, dataCenter1.getId(), storageModel.getActivateDomain().getEntity());
        }
        storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
    };
    IFrontendActionAsyncCallback failureCallback = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
        storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2 })), failureCallback, this);
}
#end_block

#method_before
private void updatePath() {
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    Guid hostId = Guid.Empty;
    if (host != null) {
        hostId = host.getId();
    }
    IStorageModel storageModel = model.getCurrentStorageItem();
    connection = new StorageServerConnections();
    connection.setId(storageDomain.getStorage());
    connection.setConnection(path);
    connection.setStorageType(storageModel.getType());
    if (storageModel.getType().equals(StorageType.NFS)) {
        updateNFSProperties(storageModel);
    } else if (storageModel instanceof PosixStorageModel) {
        updatePosixProperties(storageModel);
    }
    StorageServerConnectionParametersBase parameters = new StorageServerConnectionParametersBase(connection, hostId, false);
    Frontend.getInstance().runAction(VdcActionType.UpdateStorageServerConnection, parameters, result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
    }, this);
}
#method_after
private void updatePath() {
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    Guid hostId = Guid.Empty;
    if (host != null) {
        hostId = host.getId();
    }
    IStorageModel storageModel = model.getCurrentStorageItem();
    connection = new StorageServerConnections();
    connection.setId(storageDomain.getStorage());
    connection.setConnection(path);
    connection.setStorageType(storageModel.getType());
    if (storageModel.getType().equals(StorageType.NFS)) {
        updateNFSProperties(storageModel);
    } else if (storageModel instanceof PosixStorageModel) {
        updatePosixProperties(storageModel);
    }
    StorageServerConnectionParametersBase parameters = new StorageServerConnectionParametersBase(connection, hostId, false);
    Frontend.getInstance().runAction(ActionType.UpdateStorageServerConnection, parameters, result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
    }, this);
}
#end_block

#method_before
public void saveNewNfsStorage() {
    StorageModel model = (StorageModel) getWindow();
    NfsStorageModel nfsModel = (NfsStorageModel) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections storageConnection = new StorageServerConnections();
    storageConnection.setConnection(path);
    storageConnection.setStorageType(nfsModel.getType());
    if (isConnectionOverriden()) {
        storageConnection.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
        storageConnection.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
        storageConnection.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
        storageConnection.setMountOptions(nfsModel.getMountOptions().getEntity());
    }
    connection = storageConnection;
    ArrayList<VdcActionType> actionTypes = new ArrayList<>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddNFSStorageDomain);
    actionTypes.add(VdcActionType.DisconnectStorageServerConnection);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId(), false));
    StorageDomainManagementParameter tempVar2 = new StorageDomainManagementParameter(storageDomain);
    tempVar2.setVdsId(host.getId());
    StoragePool dataCenter = model.getDataCenter().getSelectedItem();
    tempVar2.setStoragePoolId(dataCenter.getId());
    parameters.add(tempVar2);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId(), false));
    IFrontendActionAsyncCallback callback1 = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
        storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
        storageListModel.connection.setId((String) vdcReturnValueBase.getActionReturnValue());
    };
    IFrontendActionAsyncCallback callback2 = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
        storageListModel.storageId = vdcReturnValueBase.getActionReturnValue();
    };
    IFrontendActionAsyncCallback callback3 = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        StorageModel storageModel = (StorageModel) storageListModel.getWindow();
        // Attach storage to data center as necessary.
        StoragePool dataCenter1 = storageModel.getDataCenter().getSelectedItem();
        if (!dataCenter1.getId().equals(StorageModel.UnassignedDataCenterId)) {
            storageListModel.attachStorageToDataCenter(storageListModel.storageId, dataCenter1.getId(), storageModel.getActivateDomain().getEntity());
        }
        storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
    };
    IFrontendActionAsyncCallback failureCallback = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
        storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<>(Arrays.asList(callback1, callback2, callback3)), failureCallback, this);
}
#method_after
public void saveNewNfsStorage() {
    StorageModel model = (StorageModel) getWindow();
    NfsStorageModel nfsModel = (NfsStorageModel) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections storageConnection = new StorageServerConnections();
    storageConnection.setConnection(path);
    storageConnection.setStorageType(nfsModel.getType());
    if (isConnectionOverriden()) {
        storageConnection.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
        storageConnection.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
        storageConnection.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
        storageConnection.setMountOptions(nfsModel.getMountOptions().getEntity());
    }
    connection = storageConnection;
    ArrayList<ActionType> actionTypes = new ArrayList<>();
    ArrayList<ActionParametersBase> parameters = new ArrayList<>();
    actionTypes.add(ActionType.AddStorageServerConnection);
    actionTypes.add(ActionType.AddNFSStorageDomain);
    actionTypes.add(ActionType.DisconnectStorageServerConnection);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId(), false));
    StorageDomainManagementParameter tempVar2 = new StorageDomainManagementParameter(storageDomain);
    tempVar2.setVdsId(host.getId());
    StoragePool dataCenter = model.getDataCenter().getSelectedItem();
    tempVar2.setStoragePoolId(dataCenter.getId());
    parameters.add(tempVar2);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId(), false));
    IFrontendActionAsyncCallback callback1 = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        ActionReturnValue actionReturnValue = result.getReturnValue();
        storageListModel.storageDomain.setStorage((String) actionReturnValue.getActionReturnValue());
        storageListModel.connection.setId((String) actionReturnValue.getActionReturnValue());
    };
    IFrontendActionAsyncCallback callback2 = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        ActionReturnValue actionReturnValue = result.getReturnValue();
        storageListModel.storageId = actionReturnValue.getActionReturnValue();
    };
    IFrontendActionAsyncCallback callback3 = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        StorageModel storageModel = (StorageModel) storageListModel.getWindow();
        // Attach storage to data center as necessary.
        StoragePool dataCenter1 = storageModel.getDataCenter().getSelectedItem();
        if (!dataCenter1.getId().equals(StorageModel.UnassignedDataCenterId)) {
            storageListModel.attachStorageToDataCenter(storageListModel.storageId, dataCenter1.getId(), storageModel.getActivateDomain().getEntity());
        }
        storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
    };
    IFrontendActionAsyncCallback failureCallback = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
        storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<>(Arrays.asList(callback1, callback2, callback3)), failureCallback, this);
}
#end_block

#method_before
public void saveNewSanStorage() {
    StorageModel model = (StorageModel) getWindow();
    SanStorageModelBase sanModel = (SanStorageModelBase) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    boolean force = sanModel.isForce();
    HashSet<String> lunIds = new HashSet<>();
    for (LunModel lun : sanModel.getAddedLuns()) {
        lunIds.add(lun.getLunId());
    }
    AddSANStorageDomainParameters params = new AddSANStorageDomainParameters(storageDomain);
    params.setVdsId(host.getId());
    params.setLunIds(new ArrayList<>(lunIds));
    params.setForce(force);
    Frontend.getInstance().runAction(VdcActionType.AddSANStorageDomain, params, result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        StorageModel storageModel = (StorageModel) storageListModel.getWindow();
        storageListModel.storageModel = storageModel.getCurrentStorageItem();
        if (!result.getReturnValue().getSucceeded()) {
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
            return;
        }
        StoragePool dataCenter = storageModel.getDataCenter().getSelectedItem();
        if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            Guid storageId = returnValue.getActionReturnValue();
            storageListModel.attachStorageToDataCenter(storageId, dataCenter.getId(), storageModel.getActivateDomain().getEntity());
        }
        storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
    }, this);
}
#method_after
public void saveNewSanStorage() {
    StorageModel model = (StorageModel) getWindow();
    SanStorageModelBase sanModel = (SanStorageModelBase) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    boolean force = sanModel.isForce();
    HashSet<String> lunIds = new HashSet<>();
    for (LunModel lun : sanModel.getAddedLuns()) {
        lunIds.add(lun.getLunId());
    }
    AddSANStorageDomainParameters params = new AddSANStorageDomainParameters(storageDomain);
    params.setVdsId(host.getId());
    params.setLunIds(lunIds);
    params.setForce(force);
    Frontend.getInstance().runAction(ActionType.AddSANStorageDomain, params, result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        StorageModel storageModel = (StorageModel) storageListModel.getWindow();
        storageListModel.storageModel = storageModel.getCurrentStorageItem();
        if (!result.getReturnValue().getSucceeded()) {
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
            return;
        }
        StoragePool dataCenter = storageModel.getDataCenter().getSelectedItem();
        if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
            ActionReturnValue returnValue = result.getReturnValue();
            Guid storageId = returnValue.getActionReturnValue();
            storageListModel.attachStorageToDataCenter(storageId, dataCenter.getId(), storageModel.getActivateDomain().getEntity());
        }
        storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
    }, this);
}
#end_block

#method_before
public void saveNewLocalStorage() {
    StorageModel model = (StorageModel) getWindow();
    LocalStorageModel localModel = (LocalStorageModel) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections tempVar = new StorageServerConnections();
    tempVar.setConnection(path);
    tempVar.setStorageType(localModel.getType());
    connection = tempVar;
    ArrayList<VdcActionType> actionTypes = new ArrayList<>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddLocalStorageDomain);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId(), false));
    StorageDomainManagementParameter tempVar2 = new StorageDomainManagementParameter(storageDomain);
    tempVar2.setVdsId(host.getId());
    parameters.add(tempVar2);
    IFrontendActionAsyncCallback callback1 = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        storageListModel.removeConnection = true;
        VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
        storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
        storageListModel.connection.setId((String) vdcReturnValueBase.getActionReturnValue());
    };
    IFrontendActionAsyncCallback callback2 = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        storageListModel.removeConnection = false;
        storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
    };
    IFrontendActionAsyncCallback failureCallback = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        if (storageListModel.removeConnection) {
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.removeConnection = false;
        }
        storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2 })), failureCallback, this);
}
#method_after
public void saveNewLocalStorage() {
    StorageModel model = (StorageModel) getWindow();
    LocalStorageModel localModel = (LocalStorageModel) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections tempVar = new StorageServerConnections();
    tempVar.setConnection(path);
    tempVar.setStorageType(localModel.getType());
    connection = tempVar;
    ArrayList<ActionType> actionTypes = new ArrayList<>();
    ArrayList<ActionParametersBase> parameters = new ArrayList<>();
    actionTypes.add(ActionType.AddStorageServerConnection);
    actionTypes.add(ActionType.AddLocalStorageDomain);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId(), false));
    StorageDomainManagementParameter tempVar2 = new StorageDomainManagementParameter(storageDomain);
    tempVar2.setVdsId(host.getId());
    parameters.add(tempVar2);
    IFrontendActionAsyncCallback callback1 = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        storageListModel.removeConnection = true;
        ActionReturnValue actionReturnValue = result.getReturnValue();
        storageListModel.storageDomain.setStorage((String) actionReturnValue.getActionReturnValue());
        storageListModel.connection.setId((String) actionReturnValue.getActionReturnValue());
    };
    IFrontendActionAsyncCallback callback2 = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        storageListModel.removeConnection = false;
        storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
    };
    IFrontendActionAsyncCallback failureCallback = result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        if (storageListModel.removeConnection) {
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.removeConnection = false;
        }
        storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2 })), failureCallback, this);
}
#end_block

#method_before
private void saveSanStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    SanStorageModelBase sanModel = (SanStorageModelBase) model.getCurrentStorageItem();
    StorageDomain storage = getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(storage.getStorageStaticData());
    storageDomain.setStorageType(isNew ? sanModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? sanModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageFormat(isNew ? sanModel.getContainer().getFormat().getSelectedItem() : storageDomain.getStorageFormat());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    saveCommonStorageProperties(model);
    if (isNew) {
        saveNewSanStorage();
    } else {
        Frontend.getInstance().runAction(VdcActionType.UpdateStorageDomain, new StorageDomainManagementParameter(storageDomain), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                StorageListModel storageListModel = (StorageListModel) result.getState();
                StorageModel storageModel = (StorageModel) getWindow();
                SanStorageModelBase sanStorageModelBase = (SanStorageModelBase) storageModel.getCurrentStorageItem();
                boolean force = sanStorageModelBase.isForce();
                StorageDomain storageDomain1 = storageListModel.getSelectedItem();
                ArrayList<String> lunIds = new ArrayList<>();
                for (LunModel lun : sanStorageModelBase.getAddedLuns()) {
                    lunIds.add(lun.getLunId());
                }
                if (lunIds.size() > 0) {
                    Frontend.getInstance().runAction(VdcActionType.ExtendSANStorageDomain, new ExtendSANStorageDomainParameters(storageDomain1.getId(), lunIds, force), null, this);
                }
                ArrayList<String> lunToRefreshIds = new ArrayList<>();
                for (LunModel lun : sanStorageModelBase.getLunsToRefresh()) {
                    lunToRefreshIds.add(lun.getLunId());
                }
                if (lunToRefreshIds.size() > 0) {
                    Frontend.getInstance().runAction(VdcActionType.RefreshLunsSize, new ExtendSANStorageDomainParameters(storageDomain1.getId(), lunToRefreshIds, false), null, this);
                }
                storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
            }
        }, this);
    }
}
#method_after
private void saveSanStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    SanStorageModelBase sanModel = (SanStorageModelBase) model.getCurrentStorageItem();
    StorageDomain storage = getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(storage.getStorageStaticData());
    storageDomain.setStorageType(isNew ? sanModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? sanModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageFormat(isNew ? sanModel.getContainer().getFormat().getSelectedItem() : storageDomain.getStorageFormat());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    saveCommonStorageProperties(model);
    if (isNew) {
        saveNewSanStorage();
    } else {
        Frontend.getInstance().runAction(ActionType.UpdateStorageDomain, new StorageDomainManagementParameter(storageDomain), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                StorageListModel storageListModel = (StorageListModel) result.getState();
                StorageModel storageModel = (StorageModel) getWindow();
                SanStorageModelBase sanStorageModelBase = (SanStorageModelBase) storageModel.getCurrentStorageItem();
                boolean force = sanStorageModelBase.isForce();
                StorageDomain storageDomain1 = storageListModel.getSelectedItem();
                HashSet<String> lunIds = new HashSet<>();
                for (LunModel lun : sanStorageModelBase.getAddedLuns()) {
                    lunIds.add(lun.getLunId());
                }
                if (lunIds.size() > 0) {
                    Frontend.getInstance().runAction(ActionType.ExtendSANStorageDomain, new ExtendSANStorageDomainParameters(storageDomain1.getId(), new HashSet<>(lunIds), force), null, this);
                }
                Set<String> lunToRefreshIds = new HashSet<>();
                for (LunModel lun : sanStorageModelBase.getLunsToRefresh()) {
                    lunToRefreshIds.add(lun.getLunId());
                }
                if (lunToRefreshIds.size() > 0) {
                    Frontend.getInstance().runAction(ActionType.RefreshLunsSize, new ExtendSANStorageDomainParameters(storageDomain1.getId(), lunToRefreshIds, false), null, this);
                }
                storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
            }
        }, this);
    }
}
#end_block

#method_before
private void attachStorageToDataCenter(Guid storageId, Guid dataCenterId, Boolean activateDomain) {
    AttachStorageDomainToPoolParameters params = new AttachStorageDomainToPoolParameters(storageId, dataCenterId);
    if (activateDomain != null) {
        params.setActivate(activateDomain);
    }
    Frontend.getInstance().runAction(VdcActionType.AttachStorageDomainToPool, params, null, this);
}
#method_after
private void attachStorageToDataCenter(Guid storageId, Guid dataCenterId, Boolean activateDomain) {
    AttachStorageDomainToPoolParameters params = new AttachStorageDomainToPoolParameters(storageId, dataCenterId);
    if (activateDomain != null) {
        params.setActivate(activateDomain);
    }
    Frontend.getInstance().runAction(ActionType.AttachStorageDomainToPool, params, null, this);
}
#end_block

#method_before
private void onImportSanDomainApprove() {
    ArrayList<Object> data = (ArrayList<Object>) context.getState();
    hostId = (Guid) data.get(1);
    ImportSanStorageModel importSanStorageModel = (ImportSanStorageModel) storageModel;
    final List<StorageDomain> storageDomains = importSanStorageModel.getStorageDomains().getSelectedItems();
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<>(items.size());
    List<IFrontendActionAsyncCallback> callbacks = new LinkedList<>();
    for (final StorageDomain storageDomain : storageDomains) {
        StorageDomainStatic staticData = storageDomain.getStorageStaticData();
        saveDefaultedStorageProperties((StorageModel) getWindow(), staticData);
        StorageDomainManagementParameter parameters = new StorageDomainManagementParameter(staticData);
        parameters.setVdsId(hostId);
        parametersList.add(parameters);
        callbacks.add(result -> {
            VdcReturnValueBase returnValue = result.getReturnValue();
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success) {
                StorageModel model = (StorageModel) getWindow();
                StoragePool dataCenter = model.getDataCenter().getSelectedItem();
                if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                    attachStorageToDataCenter(storageDomain.getId(), dataCenter.getId(), model.getActivateDomain().getEntity());
                }
                boolean isLastDomain = storageDomain == storageDomains.get(storageDomains.size() - 1);
                if (isLastDomain) {
                    onFinish(context, true, storageModel);
                }
            } else {
                onFinish(context, false, storageModel);
            }
        });
    }
    Frontend.getInstance().runMultipleActions(VdcActionType.AddExistingBlockStorageDomain, parametersList, callbacks);
}
#method_after
private void onImportSanDomainApprove() {
    ArrayList<Object> data = (ArrayList<Object>) context.getState();
    hostId = (Guid) data.get(1);
    ImportSanStorageModel importSanStorageModel = (ImportSanStorageModel) storageModel;
    final List<StorageDomain> storageDomains = importSanStorageModel.getStorageDomains().getSelectedItems();
    ArrayList<ActionParametersBase> parametersList = new ArrayList<>(items.size());
    List<IFrontendActionAsyncCallback> callbacks = new LinkedList<>();
    for (final StorageDomain storageDomain : storageDomains) {
        StorageDomainStatic staticData = storageDomain.getStorageStaticData();
        saveDefaultedStorageProperties((StorageModel) getWindow(), staticData);
        StorageDomainManagementParameter parameters = new StorageDomainManagementParameter(staticData);
        parameters.setVdsId(hostId);
        parametersList.add(parameters);
        callbacks.add(result -> {
            ActionReturnValue returnValue = result.getReturnValue();
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success) {
                StorageModel model = (StorageModel) getWindow();
                StoragePool dataCenter = model.getDataCenter().getSelectedItem();
                if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                    attachStorageToDataCenter(storageDomain.getId(), dataCenter.getId(), model.getActivateDomain().getEntity());
                }
                boolean isLastDomain = storageDomain == storageDomains.get(storageDomains.size() - 1);
                if (isLastDomain) {
                    onFinish(context, true, storageModel);
                }
            } else {
                onFinish(context, false, storageModel);
            }
        });
    }
    Frontend.getInstance().runMultipleActions(ActionType.AddExistingBlockStorageDomain, parametersList, callbacks);
}
#end_block

#method_before
public void importFileStorageInit() {
    if (fileConnection != null) {
        // Clean nfs connection
        Frontend.getInstance().runAction(VdcActionType.DisconnectStorageServerConnection, new StorageServerConnectionParametersBase(fileConnection, hostId, false), result -> {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                storageListModel.fileConnection = null;
            }
            storageListModel.importFileStoragePostInit();
        }, this);
    } else {
        importFileStoragePostInit();
    }
}
#method_after
public void importFileStorageInit() {
    if (fileConnection != null) {
        // Clean nfs connection
        Frontend.getInstance().runAction(ActionType.DisconnectStorageServerConnection, new StorageServerConnectionParametersBase(fileConnection, hostId, false), result -> {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            ActionReturnValue returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                storageListModel.fileConnection = null;
            }
            storageListModel.importFileStoragePostInit();
        }, this);
    } else {
        importFileStoragePostInit();
    }
}
#end_block

#method_before
public void importFileStorageConnect() {
    Frontend.getInstance().runAction(VdcActionType.AddStorageServerConnection, new StorageServerConnectionParametersBase(fileConnection, hostId, false), result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        VdcReturnValueBase returnVal = result.getReturnValue();
        boolean success = returnVal != null && returnVal.getSucceeded();
        if (success) {
            storageListModel.fileConnection.setId((String) returnVal.getActionReturnValue());
            if (storageModel.getRole() == StorageDomainType.Data) {
                // $NON-NLS-1$
                checkFileDomainAttachedToDc("OnImportFile", storageListModel.fileConnection);
            } else {
                getExistingStorageDomainList();
            }
        } else {
            postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getConstants().failedToRetrieveExistingStorageDomainInformationMsg());
        }
    }, this);
}
#method_after
public void importFileStorageConnect() {
    Frontend.getInstance().runAction(ActionType.AddStorageServerConnection, new StorageServerConnectionParametersBase(fileConnection, hostId, false), result -> {
        StorageListModel storageListModel = (StorageListModel) result.getState();
        ActionReturnValue returnVal = result.getReturnValue();
        boolean success = returnVal != null && returnVal.getSucceeded();
        if (success) {
            storageListModel.fileConnection.setId((String) returnVal.getActionReturnValue());
            if (storageModel.getRole() == StorageDomainType.Data) {
                // $NON-NLS-1$
                checkFileDomainAttachedToDc("OnImportFile", storageListModel.fileConnection);
            } else {
                getExistingStorageDomainList();
            }
        } else {
            postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getConstants().failedToRetrieveExistingStorageDomainInformationMsg());
        }
    }, this);
}
#end_block

#method_before
public void addExistingFileStorageDomain() {
    StorageDomain sdToAdd = Linq.firstOrNull(storageDomainsToAdd);
    StorageDomainStatic sdsToAdd = sdToAdd.getStorageStaticData();
    storageDomain = sdsToAdd;
    saveBaseStorageProperties((StorageModel) getWindow());
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sdsToAdd);
    params.setVdsId(hostId);
    Frontend.getInstance().runAction(VdcActionType.AddExistingFileStorageDomain, params, result -> {
        Object[] array = (Object[]) result.getState();
        StorageListModel storageListModel = (StorageListModel) array[0];
        StorageDomain sdToAdd1 = (StorageDomain) array[1];
        VdcReturnValueBase returnVal = result.getReturnValue();
        boolean success = returnVal != null && returnVal.getSucceeded();
        if (success) {
            StorageModel model = (StorageModel) storageListModel.getWindow();
            StoragePool dataCenter = model.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter(sdToAdd1.getId(), dataCenter.getId(), model.getActivateDomain().getEntity());
                onFinish(storageListModel.context, true, storageListModel.storageModel, null);
            } else {
                postImportFileStorage(storageListModel.context, true, storageListModel.storageModel, null);
            }
        } else {
            // $NON-NLS-1$
            postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, "");
            cleanConnection(fileConnection, hostId);
        }
    }, new Object[] { this, sdToAdd });
}
#method_after
public void addExistingFileStorageDomain() {
    StorageDomain sdToAdd = Linq.firstOrNull(storageDomainsToAdd);
    StorageDomainStatic sdsToAdd = sdToAdd.getStorageStaticData();
    storageDomain = sdsToAdd;
    saveBaseStorageProperties((StorageModel) getWindow());
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sdsToAdd);
    params.setVdsId(hostId);
    Frontend.getInstance().runAction(ActionType.AddExistingFileStorageDomain, params, result -> {
        Object[] array = (Object[]) result.getState();
        StorageListModel storageListModel = (StorageListModel) array[0];
        StorageDomain sdToAdd1 = (StorageDomain) array[1];
        ActionReturnValue returnVal = result.getReturnValue();
        boolean success = returnVal != null && returnVal.getSucceeded();
        if (success) {
            StorageModel model = (StorageModel) storageListModel.getWindow();
            StoragePool dataCenter = model.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter(sdToAdd1.getId(), dataCenter.getId(), model.getActivateDomain().getEntity());
                onFinish(storageListModel.context, true, storageListModel.storageModel, null);
            } else {
                postImportFileStorage(storageListModel.context, true, storageListModel.storageModel, null);
            }
        } else {
            // $NON-NLS-1$
            postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, "");
            cleanConnection(fileConnection, hostId);
        }
    }, new Object[] { this, sdToAdd });
}
#end_block

#method_before
public void postImportFileStorage(TaskContext context, boolean isSucceeded, IStorageModel model, String message) {
    Frontend.getInstance().runAction(VdcActionType.DisconnectStorageServerConnection, new StorageServerConnectionParametersBase(fileConnection, hostId, false), result -> {
        VdcReturnValueBase returnValue = result.getReturnValue();
        boolean success = returnValue != null && returnValue.getSucceeded();
        if (success) {
            fileConnection = null;
        }
        Object[] array = (Object[]) result.getState();
        onFinish((TaskContext) array[0], (Boolean) array[1], (IStorageModel) array[2], (String) array[3]);
    }, new Object[] { context, isSucceeded, model, message });
}
#method_after
public void postImportFileStorage(TaskContext context, boolean isSucceeded, IStorageModel model, String message) {
    Frontend.getInstance().runAction(ActionType.DisconnectStorageServerConnection, new StorageServerConnectionParametersBase(fileConnection, hostId, false), result -> {
        ActionReturnValue returnValue = result.getReturnValue();
        boolean success = returnValue != null && returnValue.getSucceeded();
        if (success) {
            fileConnection = null;
        }
        Object[] array = (Object[]) result.getState();
        onFinish((TaskContext) array[0], (Boolean) array[1], (IStorageModel) array[2], (String) array[3]);
    }, new Object[] { context, isSucceeded, model, message });
}
#end_block

#method_before
@Override
public void onLoad() {
    super.onLoad();
    int rowCount = getRowCount();
    int height = getLoadingIndicator() != null ? LOADING_MIN_HEIGHT : NO_ITEMS_HEIGHT;
    if (rowCount > 0) {
        height = rowCount * ROW_HEIGHT;
    }
    final int newHeight = height;
    updateGridSize(newHeight);
}
#method_after
@Override
public void onLoad() {
    super.onLoad();
    int rowCount = getRowCount();
    int height = getLoadingIndicator() != null ? LOADING_HEIGHT : NO_ITEMS_HEIGHT;
    if (rowCount > 0) {
        height = rowCount * ROW_HEIGHT;
    }
    final int newHeight = height;
    updateGridSize(newHeight);
}
#end_block

#method_before
@Override
public void setHeight(String height) {
    super.setHeight(height);
    redraw();
    heightSet = true;
}
#method_after
@Override
public void setHeight(String height) {
    super.setHeight(height);
    redraw();
    isHeightSet = true;
}
#end_block

#method_before
public void updateGridSize(final int rowHeight) {
    Scheduler.get().scheduleDeferred(() -> {
        int gridHeaderHeight = getGridHeaderHeight();
        if (!heightSet && gridHeaderHeight > 0) {
            resizeGridToContentHeight(rowHeight + gridHeaderHeight);
        }
    });
}
#method_after
public void updateGridSize(final int rowHeight) {
    Scheduler.get().scheduleDeferred(() -> {
        int gridHeaderHeight = getGridHeaderHeight();
        if (!isHeightSet && gridHeaderHeight > 0) {
            resizeGridToContentHeight(rowHeight + gridHeaderHeight);
        }
    });
}
#end_block

#method_before
private void resizeGridToFullHeight() {
    int top = getAbsoluteTop();
    int windowHeight = Window.getClientHeight();
    int contentHeight = this.getTableBodyElement().getOffsetHeight();
    if (contentHeight == 0) {
        contentHeight = this.getLoadingIndicator() != null ? LOADING_MIN_HEIGHT : NO_ITEMS_HEIGHT;
    } else {
        contentHeight += getGridHeaderHeight();
    }
    if (isHorizontalScrollbarVisible()) {
        contentHeight += scrollbarThickness;
    }
    // This is to prevent scrolling in the grid without a visible scrollbar. The 3 works in FF and leaves a 1px
    // gap in chrome. 2 is fine in Chrome but leaves the scrolling in FF.
    contentHeight += 3;
    int maxGridHeight = windowHeight - top;
    maxGridHeight -= GRID_SUBTRACT;
    if (top > 0 && top < windowHeight) {
        super.setHeight(Math.min(maxGridHeight, contentHeight) + Unit.PX.getType());
    }
    redraw();
}
#method_after
private void resizeGridToFullHeight() {
    int top = getAbsoluteTop();
    int windowHeight = Window.getClientHeight();
    int contentHeight = this.getTableBodyElement().getOffsetHeight();
    if (contentHeight == 0) {
        contentHeight = this.getLoadingIndicator() != null ? LOADING_HEIGHT : NO_ITEMS_HEIGHT;
    } else {
        contentHeight += getGridHeaderHeight();
    }
    if (isHorizontalScrollbarVisible()) {
        contentHeight += scrollbarThickness;
    }
    // This is to prevent scrolling in the grid without a visible scrollbar. The 3 works in FF and leaves a 1px
    // gap in chrome. 2 is fine in Chrome but leaves the scrolling in FF.
    contentHeight += 3;
    int maxGridHeight = windowHeight - top;
    maxGridHeight -= GRID_SUBTRACT;
    if (top > 0 && top < windowHeight) {
        super.setHeight(Math.min(maxGridHeight, contentHeight) + Unit.PX.getType());
    }
    redraw();
}
#end_block

#method_before
@Override
protected void setUpQueryExpectations(String query) throws Exception {
    setUpEntityQueryExpectations(1);
}
#method_after
@Override
protected void setUpQueryExpectations(String query) throws Exception {
    setUpEntityQueryExpectations(null);
}
#end_block

#method_before
@Override
protected void setUpQueryExpectations(String query, Object failure) throws Exception {
    setUpEntityQueryExpectations(1, failure);
}
#method_after
@Override
protected void setUpQueryExpectations(String query, Object failure) throws Exception {
    setUpEntityQueryExpectations(failure);
}
#end_block

#method_before
protected void setUpEntityQueryExpectations(int times, Object failure) throws Exception {
    while (times-- > 0) {
        setUpEntityQueryExpectations(QueryType.GetAllDisks, QueryParametersBase.class, new String[] {}, new Object[] {}, getEntityList(), failure);
    }
}
#method_after
private void setUpEntityQueryExpectations(Object failure) throws Exception {
    setUpEntityQueryExpectations(QueryType.GetAllDisksWithSnapshots, QueryParametersBase.class, new String[] {}, new Object[] {}, getEntityList(), failure);
}
#end_block

#method_before
protected List<org.ovirt.engine.core.common.businessentities.storage.Disk> getEntityList() {
    List<org.ovirt.engine.core.common.businessentities.storage.Disk> entities = new ArrayList<>();
    for (int i = 0; i < NAMES.length; i++) {
        entities.add(getEntity(i));
    }
    return entities;
}
#method_after
private List<org.ovirt.engine.core.common.businessentities.storage.Disk> getEntityList() {
    return IntStream.range(0, NAMES.length).mapToObj(this::getEntity).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public Disks list() {
    return mapCollection(getBackendCollection(QueryType.GetAllDisks, new QueryParametersBase()));
}
#method_after
@Override
public Disks list() {
    return mapCollection(getBackendCollection(QueryType.GetAllDisksWithSnapshots, new QueryParametersBase()));
}
#end_block

#method_before
private static void mapDiskImageToDiskFields(DiskImage entity, Disk model) {
    if (entity.getImageId() != null) {
        model.setImageId(entity.getImageId().toString());
    }
    model.setProvisionedSize(entity.getSize());
    if (entity.hasActualSize()) {
        model.setActualSize(entity.getActualSizeInBytes());
    }
    if (entity.hasActualSize()) {
        model.setTotalSize(Double.valueOf(model.getActualSize() + entity.getActualDiskWithSnapshotsSizeInBytes()).longValue());
    }
    if (entity.getSnapshotId() != null) {
        model.setSnapshot(new Snapshot());
        model.getSnapshot().setId(entity.getSnapshotId().toString());
    }
    if (entity.getVolumeFormat() != null) {
        model.setFormat(map(entity.getVolumeFormat(), null));
    }
    if (entity.getQcowCompat() != null) {
        model.setQcowVersion(mapQcowCompat(entity.getQcowCompat()));
    }
    if (entity.getImageStatus() != null) {
        model.setStatus(mapDiskStatus(entity.getImageStatus()));
    }
    model.setSparse(VolumeType.Sparse == entity.getVolumeType());
    if (entity.getStorageIds() != null && entity.getStorageIds().size() > 0) {
        if (!model.isSetStorageDomains()) {
            model.setStorageDomains(new StorageDomains());
        }
        for (Guid id : entity.getStorageIds()) {
            StorageDomain storageDomain = new StorageDomain();
            storageDomain.setId(id.toString());
            model.getStorageDomains().getStorageDomains().add(storageDomain);
        }
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getDiskProfileId() != null) {
        DiskProfile diskProfile = new DiskProfile();
        diskProfile.setId(entity.getDiskProfileId().toString());
        model.setDiskProfile(diskProfile);
    }
    if (entity.getCinderVolumeType() != null) {
        OpenStackVolumeType volumeType = model.getOpenstackVolumeType();
        if (volumeType == null) {
            volumeType = new OpenStackVolumeType();
            model.setOpenstackVolumeType(volumeType);
        }
        volumeType.setName(entity.getCinderVolumeType());
    }
}
#method_after
private static void mapDiskImageToDiskFields(DiskImage entity, Disk model) {
    if (entity.getImageId() != null) {
        model.setImageId(entity.getImageId().toString());
    }
    model.setProvisionedSize(entity.getSize());
    if (entity.hasActualSize()) {
        model.setActualSize(entity.getActualSizeInBytes());
        if (entity.isAllowSnapshot()) {
            model.setTotalSize(Double.valueOf(entity.getActualDiskWithSnapshotsSizeInBytes()).longValue());
        }
    }
    if (entity.getSnapshotId() != null) {
        model.setSnapshot(new Snapshot());
        model.getSnapshot().setId(entity.getSnapshotId().toString());
    }
    if (entity.getVolumeFormat() != null) {
        model.setFormat(map(entity.getVolumeFormat(), null));
    }
    if (entity.getQcowCompat() != null) {
        model.setQcowVersion(mapQcowCompat(entity.getQcowCompat()));
    }
    if (entity.getImageStatus() != null) {
        model.setStatus(mapDiskStatus(entity.getImageStatus()));
    }
    model.setSparse(VolumeType.Sparse == entity.getVolumeType());
    if (entity.getStorageIds() != null && entity.getStorageIds().size() > 0) {
        if (!model.isSetStorageDomains()) {
            model.setStorageDomains(new StorageDomains());
        }
        for (Guid id : entity.getStorageIds()) {
            StorageDomain storageDomain = new StorageDomain();
            storageDomain.setId(id.toString());
            model.getStorageDomains().getStorageDomains().add(storageDomain);
        }
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getDiskProfileId() != null) {
        DiskProfile diskProfile = new DiskProfile();
        diskProfile.setId(entity.getDiskProfileId().toString());
        model.setDiskProfile(diskProfile);
    }
    if (entity.getCinderVolumeType() != null) {
        OpenStackVolumeType volumeType = model.getOpenstackVolumeType();
        if (volumeType == null) {
            volumeType = new OpenStackVolumeType();
            model.setOpenstackVolumeType(volumeType);
        }
        volumeType.setName(entity.getCinderVolumeType());
    }
}
#end_block

#method_before
private void activateDataCenter() {
    StorageDomain masterDomain = storageDomainDao.getStorageDomains(getStoragePool().getId(), StorageDomainType.Master).stream().findFirst().orElse(null);
    calcStoragePoolStatusByDomainsStatus();
    // fence spm if moving from not operational and master domain is active
    log.info("Master domain id:'{}' Master domain status:'{}'", masterDomain != null ? masterDomain.getId() : null, masterDomain != null ? masterDomain.getStatus() : null);
    if (masterDomain != null && (masterDomain.getStatus() == StorageDomainStatus.Active || masterDomain.getStatus() == StorageDomainStatus.Unknown || masterDomain.getStatus() == StorageDomainStatus.Inactive)) {
        resetSPM();
    }
}
#method_after
private void activateDataCenter() {
    StorageDomain masterDomain = storageDomainDao.getStorageDomains(getStoragePool().getId(), StorageDomainType.Master).stream().findFirst().orElse(null);
    calcStoragePoolStatusByDomainsStatus();
    // fence spm if moving from not operational and master domain is active
    if (masterDomain == null) {
        log.info("no master domain found");
    } else {
        log.info("Master domain id:'{}' has status:'{}'", masterDomain.getId(), masterDomain.getStatus());
        if (masterDomain.getStatus() == StorageDomainStatus.Active || masterDomain.getStatus() == StorageDomainStatus.Unknown || masterDomain.getStatus() == StorageDomainStatus.Inactive) {
            resetSPM();
        }
    }
}
#end_block

#method_before
protected void displayHighPerformanceConfirmationPopup() {
    List<String> recommendations = new ArrayList<>();
    final PoolModel model = (PoolModel) getWindow();
    if (model == null || model.getProgress() != null) {
        return;
    }
    VmHighPerformanceConfigurationModel confirmModel = new VmHighPerformanceConfigurationModel();
    // Handle CPU Pinning topology
    final boolean isVmAssignedToSpecificHosts = !model.getIsAutoAssign().getEntity();
    final boolean isVmCpuPinningSet = model.getCpuPinning().getIsChangable() && model.getCpuPinning().getEntity() != null && !model.getCpuPinning().getEntity().isEmpty();
    confirmModel.addRecommendationForCpuPinning(isVmAssignedToSpecificHosts, isVmCpuPinningSet);
    // Handle KSM (Kernel Same Page Merging)
    confirmModel.addRecommendationForKsm(model.getSelectedCluster().isEnableKsm(), model.getSelectedCluster().getName());
    // Handle Huge Pages
    KeyValueModel keyValue = model.getCustomPropertySheet();
    // $NON-NLS-1$
    final boolean isVmHugePagesSet = keyValue != null && keyValue.getUsedKeys().contains("hugepages");
    confirmModel.addRecommendationForHugePages(isVmHugePagesSet);
    if (!confirmModel.getRecommendationsList().isEmpty()) {
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().configurationChangesForHighPerformancePoolTitle());
        confirmModel.setHelpTag(HelpTag.configuration_changes_for_high_performance_pool);
        // $NON-NLS-1$
        confirmModel.setHashName("configuration_changes_for_high_performance_pool");
        confirmModel.getCommands().add(// $NON-NLS-1$
        new UICommand("OnSave_Phase2", PoolListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
        confirmModel.getCommands().add(// $NON-NLS-1$
        UICommand.createCancelUiCommand("CancelConfirmation", PoolListModel.this));
        setConfirmWindow(null);
        setConfirmWindow(confirmModel);
    } else {
        savePoolPostValidation();
    }
}
#method_after
protected void displayHighPerformanceConfirmationPopup() {
    final PoolModel model = (PoolModel) getWindow();
    if (model == null || model.getProgress() != null) {
        return;
    }
    VmHighPerformanceConfigurationModel confirmModel = new VmHighPerformanceConfigurationModel();
    // Handle CPU Pinning topology
    final boolean isVmAssignedToSpecificHosts = !model.getIsAutoAssign().getEntity();
    final boolean isVmCpuPinningSet = model.getCpuPinning().getIsChangable() && model.getCpuPinning().getEntity() != null && !model.getCpuPinning().getEntity().isEmpty();
    confirmModel.addRecommendationForCpuPinning(isVmAssignedToSpecificHosts, isVmCpuPinningSet);
    // Handle KSM (Kernel Same Page Merging)
    confirmModel.addRecommendationForKsm(model.getSelectedCluster().isEnableKsm(), model.getSelectedCluster().getName());
    // Handle Huge Pages
    KeyValueModel keyValue = model.getCustomPropertySheet();
    // $NON-NLS-1$
    final boolean isVmHugePagesSet = keyValue != null && keyValue.getUsedKeys().contains("hugepages");
    confirmModel.addRecommendationForHugePages(isVmHugePagesSet);
    if (!confirmModel.getRecommendationsList().isEmpty()) {
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().configurationChangesForHighPerformancePoolTitle());
        confirmModel.setHelpTag(HelpTag.configuration_changes_for_high_performance_pool);
        // $NON-NLS-1$
        confirmModel.setHashName("configuration_changes_for_high_performance_pool");
        confirmModel.getCommands().add(// $NON-NLS-1$
        new UICommand("OnSave_Phase2", PoolListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
        confirmModel.getCommands().add(// $NON-NLS-1$
        UICommand.createCancelUiCommand("CancelConfirmation", PoolListModel.this));
        setConfirmWindow(null);
        setConfirmWindow(confirmModel);
    } else {
        savePoolPostValidation();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Menu
    bindSingletonPresenterWidget(MenuPresenterWidget.class, MenuPresenterWidget.ViewDef.class, MenuView.class);
    bind(MenuDetailsProvider.class).to(MenuPresenterWidget.class).in(Singleton.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    bindPresenterWidget(AffinityLabelPopupPresenterWidget.class, AffinityLabelPopupPresenterWidget.ViewDef.class, AffinityLabelPopupView.class);
    // Main section: main tabs
    bindPresenter(MainDataCenterPresenter.class, MainDataCenterPresenter.ViewDef.class, MainDataCenterView.class, MainDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainClusterPresenter.class, MainClusterPresenter.ViewDef.class, MainClusterView.class, MainClusterPresenter.ProxyDef.class);
    bindPresenter(MainHostPresenter.class, MainHostPresenter.ViewDef.class, MainHostView.class, MainHostPresenter.ProxyDef.class);
    bindPresenter(MainNetworkPresenter.class, MainNetworkPresenter.ViewDef.class, MainNetworkView.class, MainNetworkPresenter.ProxyDef.class);
    bindPresenter(MainVnicProfilePresenter.class, MainVnicProfilePresenter.ViewDef.class, MainVnicProfileView.class, MainVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainProviderPresenter.class, MainProviderPresenter.ViewDef.class, MainProviderView.class, MainProviderPresenter.ProxyDef.class);
    bindPresenter(MainEngineErrataPresenter.class, MainEngineErrataPresenter.ViewDef.class, MainEngineErrataView.class, MainEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainSessionPresenter.class, MainSessionPresenter.ViewDef.class, MainSessionView.class, MainSessionPresenter.ProxyDef.class);
    bindPresenter(MainStoragePresenter.class, MainStoragePresenter.ViewDef.class, MainStorageView.class, MainStoragePresenter.ProxyDef.class);
    bindPresenter(MainVirtualMachinePresenter.class, MainVirtualMachinePresenter.ViewDef.class, MainVirtualMachineView.class, MainVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainPoolPresenter.class, MainPoolPresenter.ViewDef.class, MainPoolView.class, MainPoolPresenter.ProxyDef.class);
    bindPresenter(MainTemplatePresenter.class, MainTemplatePresenter.ViewDef.class, MainTemplateView.class, MainTemplatePresenter.ProxyDef.class);
    bindPresenter(MainUserPresenter.class, MainUserPresenter.ViewDef.class, MainUserView.class, MainUserPresenter.ProxyDef.class);
    bindPresenter(MainEventPresenter.class, MainEventPresenter.ViewDef.class, MainEventView.class, MainEventPresenter.ProxyDef.class);
    bindPresenter(MainQuotaPresenter.class, MainQuotaPresenter.ViewDef.class, MainQuotaView.class, MainQuotaPresenter.ProxyDef.class);
    bindPresenter(MainVolumePresenter.class, MainVolumePresenter.ViewDef.class, MainVolumeView.class, MainVolumePresenter.ProxyDef.class);
    bindPresenter(MainDiskPresenter.class, MainDiskPresenter.ViewDef.class, MainDiskView.class, MainDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQosPresenter.class, SubTabDataCenterQosPresenter.ViewDef.class, SubTabDataCenterQosView.class, SubTabDataCenterQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelView<DataCenterListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StoragePool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StoragePool, DataCenterListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StoragePool>>() {
    }, new TypeLiteral<ActionPanelView<StoragePool>>() {
    });
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDRPresenter.class, SubTabStorageDRPresenter.ViewDef.class, SubTabStorageDRView.class, SubTabStorageDRPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageLeasePresenter.class, SubTabStorageLeasePresenter.ViewDef.class, SubTabStorageLeaseView.class, SubTabStorageLeasePresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<StorageListModel>>() {
    }, new TypeLiteral<SearchPanelView<StorageListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StorageDomain>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StorageDomain, StorageListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDomain>>() {
    }, new TypeLiteral<ActionPanelView<StorageDomain>>() {
    });
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    bindPresenter(SubTabClusterAffinityLabelPresenter.class, SubTabClusterAffinityLabelPresenter.ViewDef.class, SubTabClusterAffinityLabelView.class, SubTabClusterAffinityLabelPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<ClusterListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Cluster>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Cluster, ClusterListModel<Void>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Cluster>>() {
    }, new TypeLiteral<ActionPanelView<Cluster>>() {
    });
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPresenter.class, HostGeneralSubTabPresenter.ViewDef.class, HostGeneralSubTabView.class, HostGeneralSubTabPresenter.ProxyDef.class);
    bindPresenter(SubTabHostErrataPresenter.class, SubTabHostErrataPresenter.ViewDef.class, SubTabHostErrataView.class, SubTabHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<HostListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VDS>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VDS, HostListModel<Void>>>() {
    });
    bindPresenter(SubTabHostAffinityLabelPresenter.class, SubTabHostAffinityLabelPresenter.ViewDef.class, SubTabHostAffinityLabelView.class, SubTabHostAffinityLabelPresenter.ProxyDef.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VDS>>() {
    }, new TypeLiteral<ActionPanelView<VDS>>() {
    });
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<VmListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VM>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VM, VmListModel<Void>>>() {
    });
    bindPresenter(SubTabVirtualMachineAffinityLabelPresenter.class, SubTabVirtualMachineAffinityLabelPresenter.ViewDef.class, SubTabVirtualMachineAffinityLabelView.class, SubTabVirtualMachineAffinityLabelPresenter.ProxyDef.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VM>>() {
    }, new TypeLiteral<ActionPanelView<VM>>() {
    });
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<PoolListModel>>() {
    }, new TypeLiteral<SearchPanelView<PoolListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VmPool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VmPool, PoolListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmPool>>() {
    }, new TypeLiteral<ActionPanelView<VmPool>>() {
    });
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmTemplate, TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelView<TemplateListModel>>() {
    });
    bindPresenterWidget(TemplateBreadCrumbsPresenterWidget.class, TemplateBreadCrumbsPresenterWidget.TemplateBreadCrumbsViewDef.class, TemplateBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmTemplate>>() {
    }, new TypeLiteral<ActionPanelView<VmTemplate>>() {
    });
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<UserListModel>>() {
    }, new TypeLiteral<SearchPanelView<UserListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<DbUser>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<DbUser, UserListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DbUser>>() {
    }, new TypeLiteral<ActionPanelView<DbUser>>() {
    });
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Quota, QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelView<QuotaListModel>>() {
    });
    bindPresenterWidget(QuotaBreadCrumbsPresenterWidget.class, QuotaBreadCrumbsPresenterWidget.QuotaBreadCrumbsViewDef.class, QuotaBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Quota>>() {
    }, new TypeLiteral<ActionPanelView<Quota>>() {
    });
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DiskListModel>>() {
    }, new TypeLiteral<SearchPanelView<DiskListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Disk>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Disk, DiskListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Disk>>() {
    }, new TypeLiteral<ActionPanelView<Disk>>() {
    });
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<NetworkView, NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelView<NetworkListModel>>() {
    });
    bindPresenterWidget(NetworkBreadCrumbsPresenterWidget.class, NetworkBreadCrumbsPresenterWidget.NetworkBreadCrumbsViewDef.class, NetworkBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkView>>() {
    }, new TypeLiteral<ActionPanelView<NetworkView>>() {
    });
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelView<ProviderListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Provider>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Provider, ProviderListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Provider>>() {
    }, new TypeLiteral<ActionPanelView<Provider>>() {
    });
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Erratum, EngineErrataListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Erratum>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Erratum, EngineErrataListModel>>() {
    });
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    bindPresenterWidget(VnicProfileBreadCrumbsPresenterWidget.class, VnicProfileBreadCrumbsPresenterWidget.VnicProfileBreadCrumbsViewDef.class, VnicProfileBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VnicProfileView>>() {
    }, new TypeLiteral<ActionPanelView<VnicProfileView>>() {
    });
    // User Sessions
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<SessionListModel>>() {
    }, new TypeLiteral<SearchPanelView<SessionListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<UserSession>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<UserSession, SessionListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<UserSession>>() {
    }, new TypeLiteral<ActionPanelView<UserSession>>() {
    });
    // Volume
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelView<VolumeListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<GlusterVolumeEntity>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<GlusterVolumeEntity, VolumeListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeEntity>>() {
    });
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    bindPresenterWidget(VmHighPerformanceConfigurationPresenterWidget.class, VmHighPerformanceConfigurationPresenterWidget.ViewDef.class, VmHighPerformanceConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    bindPresenterWidget(HostMaintenanceConfirmationPopupPresenterWidget.class, HostMaintenanceConfirmationPopupPresenterWidget.ViewDef.class, HostMaintenanceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(VnicProfileMappingPopupPresenterWidget.class, VnicProfileMappingPopupPresenterWidget.ViewDef.class, VnicProfileMappingPopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    bindPresenterWidget(StorageDRPopupPresenterWidget.class, StorageDRPopupPresenterWidget.ViewDef.class, StorageDRPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // VM Sparsify Disk
    bindPresenterWidget(VmDiskSparsifyPopupPresenterWidget.class, VmDiskSparsifyPopupPresenterWidget.ViewDef.class, VmDiskSparsifyPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(StorageQosRemovePopupPresenterWidget.class, StorageQosRemovePopupPresenterWidget.ViewDef.class, StorageQosRemovePopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<EventListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<AuditLog>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<AuditLog, EventListModel<Void>>>() {
    });
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
    bindPresenterWidget(ExpandAllButtonPresenterWidget.class, ExpandAllButtonPresenterWidget.ViewDef.class, ExpandAllButtonView.class);
    // Overlays
    // Tasks
    bindPresenter(TasksPresenter.class, TasksPresenter.ViewDef.class, TasksView.class, TasksPresenter.ProxyDef.class);
    // Bookmarks
    bindPresenter(BookmarkPresenter.class, BookmarkPresenter.ViewDef.class, BookmarkView.class, BookmarkPresenter.ProxyDef.class);
    // Tags
    bindPresenter(TagsPresenter.class, TagsPresenter.ViewDef.class, TagsView.class, TagsPresenter.ProxyDef.class);
    // Popup/detail Action panels
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Label>>() {
    }, new TypeLiteral<ActionPanelView<Label>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterHookEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterHookEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Network>>() {
    }, new TypeLiteral<ActionPanelView<Network>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<IscsiBond>>() {
    }, new TypeLiteral<ActionPanelView<IscsiBond>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterBrickEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterBrickEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeOptionEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeOptionEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDevice>>() {
    }, new TypeLiteral<ActionPanelView<StorageDevice>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeSnapshotEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeSnapshotEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterServerService>>() {
    }, new TypeLiteral<ActionPanelView<GlusterServerService>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkCluster>>() {
    }, new TypeLiteral<ActionPanelView<NetworkCluster>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<ExternalSubnet>>() {
    }, new TypeLiteral<ActionPanelView<ExternalSubnet>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<LibvirtSecret>>() {
    }, new TypeLiteral<ActionPanelView<LibvirtSecret>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Permission>>() {
    }, new TypeLiteral<ActionPanelView<Permission>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterGeoRepSession>>() {
    }, new TypeLiteral<ActionPanelView<GlusterGeoRepSession>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<Cluster, NetworkCluster>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<Cluster, NetworkCluster>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<VdsNetworkInterface, VDS>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<VdsNetworkInterface, VDS>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<VmNetworkInterface, VM>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<VmNetworkInterface, VM>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<VmNetworkInterface, VmTemplate>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<VmNetworkInterface, VmTemplate>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDomainDR>>() {
    }, new TypeLiteral<ActionPanelView<StorageDomainDR>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<RepoImage>>() {
    }, new TypeLiteral<ActionPanelView<RepoImage>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DiskModel>>() {
    }, new TypeLiteral<ActionPanelView<DiskModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<EventSubscriber>>() {
    }, new TypeLiteral<ActionPanelView<EventSubscriber>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<AffinityGroup>>() {
    }, new TypeLiteral<ActionPanelView<AffinityGroup>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<MacPool>>() {
    }, new TypeLiteral<ActionPanelView<MacPool>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Role>>() {
    }, new TypeLiteral<ActionPanelView<Role>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<ClusterPolicy>>() {
    }, new TypeLiteral<ActionPanelView<ClusterPolicy>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<InstanceType>>() {
    }, new TypeLiteral<ActionPanelView<InstanceType>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<CpuQos>>() {
    }, new TypeLiteral<ActionPanelView<CpuQos>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkQoS>>() {
    }, new TypeLiteral<ActionPanelView<NetworkQoS>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostNetworkQos>>() {
    }, new TypeLiteral<ActionPanelView<HostNetworkQos>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DiskProfile>>() {
    }, new TypeLiteral<ActionPanelView<DiskProfile>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<CpuProfile>>() {
    }, new TypeLiteral<ActionPanelView<CpuProfile>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmNetworkInterface>>() {
    }, new TypeLiteral<ActionPanelView<VmNetworkInterface>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Snapshot>>() {
    }, new TypeLiteral<ActionPanelView<Snapshot>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostDeviceView>>() {
    }, new TypeLiteral<ActionPanelView<HostDeviceView>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostInterfaceLineModel>>() {
    }, new TypeLiteral<ActionPanelView<HostInterfaceLineModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageQos>>() {
    }, new TypeLiteral<ActionPanelView<StorageQos>>() {
    });
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Menu
    bindSingletonPresenterWidget(MenuPresenterWidget.class, MenuPresenterWidget.ViewDef.class, MenuView.class);
    bind(MenuDetailsProvider.class).to(MenuPresenterWidget.class).in(Singleton.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    bindPresenterWidget(AffinityLabelPopupPresenterWidget.class, AffinityLabelPopupPresenterWidget.ViewDef.class, AffinityLabelPopupView.class);
    // Main section: main tabs
    bindPresenter(MainDataCenterPresenter.class, MainDataCenterPresenter.ViewDef.class, MainDataCenterView.class, MainDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainClusterPresenter.class, MainClusterPresenter.ViewDef.class, MainClusterView.class, MainClusterPresenter.ProxyDef.class);
    bindPresenter(MainHostPresenter.class, MainHostPresenter.ViewDef.class, MainHostView.class, MainHostPresenter.ProxyDef.class);
    bindPresenter(MainNetworkPresenter.class, MainNetworkPresenter.ViewDef.class, MainNetworkView.class, MainNetworkPresenter.ProxyDef.class);
    bindPresenter(MainVnicProfilePresenter.class, MainVnicProfilePresenter.ViewDef.class, MainVnicProfileView.class, MainVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainProviderPresenter.class, MainProviderPresenter.ViewDef.class, MainProviderView.class, MainProviderPresenter.ProxyDef.class);
    bindPresenter(MainEngineErrataPresenter.class, MainEngineErrataPresenter.ViewDef.class, MainEngineErrataView.class, MainEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainSessionPresenter.class, MainSessionPresenter.ViewDef.class, MainSessionView.class, MainSessionPresenter.ProxyDef.class);
    bindPresenter(MainStoragePresenter.class, MainStoragePresenter.ViewDef.class, MainStorageView.class, MainStoragePresenter.ProxyDef.class);
    bindPresenter(MainVirtualMachinePresenter.class, MainVirtualMachinePresenter.ViewDef.class, MainVirtualMachineView.class, MainVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainPoolPresenter.class, MainPoolPresenter.ViewDef.class, MainPoolView.class, MainPoolPresenter.ProxyDef.class);
    bindPresenter(MainTemplatePresenter.class, MainTemplatePresenter.ViewDef.class, MainTemplateView.class, MainTemplatePresenter.ProxyDef.class);
    bindPresenter(MainUserPresenter.class, MainUserPresenter.ViewDef.class, MainUserView.class, MainUserPresenter.ProxyDef.class);
    bindPresenter(MainEventPresenter.class, MainEventPresenter.ViewDef.class, MainEventView.class, MainEventPresenter.ProxyDef.class);
    bindPresenter(MainQuotaPresenter.class, MainQuotaPresenter.ViewDef.class, MainQuotaView.class, MainQuotaPresenter.ProxyDef.class);
    bindPresenter(MainVolumePresenter.class, MainVolumePresenter.ViewDef.class, MainVolumeView.class, MainVolumePresenter.ProxyDef.class);
    bindPresenter(MainDiskPresenter.class, MainDiskPresenter.ViewDef.class, MainDiskView.class, MainDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQosPresenter.class, SubTabDataCenterQosPresenter.ViewDef.class, SubTabDataCenterQosView.class, SubTabDataCenterQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelView<DataCenterListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StoragePool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StoragePool, DataCenterListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StoragePool>>() {
    }, new TypeLiteral<ActionPanelView<StoragePool>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<StoragePool>>() {
    }, new TypeLiteral<DetailActionPanelView<StoragePool>>() {
    });
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDRPresenter.class, SubTabStorageDRPresenter.ViewDef.class, SubTabStorageDRView.class, SubTabStorageDRPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageLeasePresenter.class, SubTabStorageLeasePresenter.ViewDef.class, SubTabStorageLeaseView.class, SubTabStorageLeasePresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<StorageListModel>>() {
    }, new TypeLiteral<SearchPanelView<StorageListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StorageDomain>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StorageDomain, StorageListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDomain>>() {
    }, new TypeLiteral<ActionPanelView<StorageDomain>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<StorageDomain>>() {
    }, new TypeLiteral<DetailActionPanelView<StorageDomain>>() {
    });
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    bindPresenter(SubTabClusterAffinityLabelPresenter.class, SubTabClusterAffinityLabelPresenter.ViewDef.class, SubTabClusterAffinityLabelView.class, SubTabClusterAffinityLabelPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<ClusterListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Cluster>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Cluster, ClusterListModel<Void>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Cluster>>() {
    }, new TypeLiteral<ActionPanelView<Cluster>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<Cluster>>() {
    }, new TypeLiteral<DetailActionPanelView<Cluster>>() {
    });
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPresenter.class, HostGeneralSubTabPresenter.ViewDef.class, HostGeneralSubTabView.class, HostGeneralSubTabPresenter.ProxyDef.class);
    bindPresenter(SubTabHostErrataPresenter.class, SubTabHostErrataPresenter.ViewDef.class, SubTabHostErrataView.class, SubTabHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<HostListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VDS>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VDS, HostListModel<Void>>>() {
    });
    bindPresenter(SubTabHostAffinityLabelPresenter.class, SubTabHostAffinityLabelPresenter.ViewDef.class, SubTabHostAffinityLabelView.class, SubTabHostAffinityLabelPresenter.ProxyDef.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VDS>>() {
    }, new TypeLiteral<ActionPanelView<VDS>>() {
    });
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<VmListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VM>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VM, VmListModel<Void>>>() {
    });
    bindPresenter(SubTabVirtualMachineAffinityLabelPresenter.class, SubTabVirtualMachineAffinityLabelPresenter.ViewDef.class, SubTabVirtualMachineAffinityLabelView.class, SubTabVirtualMachineAffinityLabelPresenter.ProxyDef.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VM>>() {
    }, new TypeLiteral<ActionPanelView<VM>>() {
    });
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<PoolListModel>>() {
    }, new TypeLiteral<SearchPanelView<PoolListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VmPool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VmPool, PoolListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmPool>>() {
    }, new TypeLiteral<ActionPanelView<VmPool>>() {
    });
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmTemplate, TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelView<TemplateListModel>>() {
    });
    bindPresenterWidget(TemplateBreadCrumbsPresenterWidget.class, TemplateBreadCrumbsPresenterWidget.TemplateBreadCrumbsViewDef.class, TemplateBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmTemplate>>() {
    }, new TypeLiteral<ActionPanelView<VmTemplate>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<VmTemplate>>() {
    }, new TypeLiteral<DetailActionPanelView<VmTemplate>>() {
    });
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<UserListModel>>() {
    }, new TypeLiteral<SearchPanelView<UserListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<DbUser>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<DbUser, UserListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DbUser>>() {
    }, new TypeLiteral<ActionPanelView<DbUser>>() {
    });
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Quota, QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelView<QuotaListModel>>() {
    });
    bindPresenterWidget(QuotaBreadCrumbsPresenterWidget.class, QuotaBreadCrumbsPresenterWidget.QuotaBreadCrumbsViewDef.class, QuotaBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Quota>>() {
    }, new TypeLiteral<ActionPanelView<Quota>>() {
    });
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DiskListModel>>() {
    }, new TypeLiteral<SearchPanelView<DiskListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Disk>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Disk, DiskListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Disk>>() {
    }, new TypeLiteral<ActionPanelView<Disk>>() {
    });
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<NetworkView, NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelView<NetworkListModel>>() {
    });
    bindPresenterWidget(NetworkBreadCrumbsPresenterWidget.class, NetworkBreadCrumbsPresenterWidget.NetworkBreadCrumbsViewDef.class, NetworkBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkView>>() {
    }, new TypeLiteral<ActionPanelView<NetworkView>>() {
    });
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelView<ProviderListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Provider>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Provider, ProviderListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Provider>>() {
    }, new TypeLiteral<ActionPanelView<Provider>>() {
    });
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Erratum, EngineErrataListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Erratum>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Erratum, EngineErrataListModel>>() {
    });
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    bindPresenterWidget(VnicProfileBreadCrumbsPresenterWidget.class, VnicProfileBreadCrumbsPresenterWidget.VnicProfileBreadCrumbsViewDef.class, VnicProfileBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VnicProfileView>>() {
    }, new TypeLiteral<ActionPanelView<VnicProfileView>>() {
    });
    // User Sessions
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<SessionListModel>>() {
    }, new TypeLiteral<SearchPanelView<SessionListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<UserSession>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<UserSession, SessionListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<UserSession>>() {
    }, new TypeLiteral<ActionPanelView<UserSession>>() {
    });
    // Volume
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelView<VolumeListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<GlusterVolumeEntity>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<GlusterVolumeEntity, VolumeListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeEntity>>() {
    });
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    bindPresenterWidget(VmHighPerformanceConfigurationPresenterWidget.class, VmHighPerformanceConfigurationPresenterWidget.ViewDef.class, VmHighPerformanceConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    bindPresenterWidget(HostMaintenanceConfirmationPopupPresenterWidget.class, HostMaintenanceConfirmationPopupPresenterWidget.ViewDef.class, HostMaintenanceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(VnicProfileMappingPopupPresenterWidget.class, VnicProfileMappingPopupPresenterWidget.ViewDef.class, VnicProfileMappingPopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    bindPresenterWidget(StorageDRPopupPresenterWidget.class, StorageDRPopupPresenterWidget.ViewDef.class, StorageDRPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // VM Sparsify Disk
    bindPresenterWidget(VmDiskSparsifyPopupPresenterWidget.class, VmDiskSparsifyPopupPresenterWidget.ViewDef.class, VmDiskSparsifyPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(StorageQosRemovePopupPresenterWidget.class, StorageQosRemovePopupPresenterWidget.ViewDef.class, StorageQosRemovePopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<EventListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<AuditLog>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<AuditLog, EventListModel<Void>>>() {
    });
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
    bindPresenterWidget(ExpandAllButtonPresenterWidget.class, ExpandAllButtonPresenterWidget.ViewDef.class, ExpandAllButtonView.class);
    // Overlays
    // Tasks
    bindPresenterWidget(TasksPresenterWidget.class, TasksPresenterWidget.ViewDef.class, TasksView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPresenterWidget.class, BookmarkPresenterWidget.ViewDef.class, BookmarkView.class);
    // Tags
    bindPresenterWidget(TagsPresenterWidget.class, TagsPresenterWidget.ViewDef.class, TagsView.class);
    // Popup/detail Action panels
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Permission>>() {
    }, new TypeLiteral<ActionPanelView<Permission>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<MacPool>>() {
    }, new TypeLiteral<ActionPanelView<MacPool>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Role>>() {
    }, new TypeLiteral<ActionPanelView<Role>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<ClusterPolicy>>() {
    }, new TypeLiteral<ActionPanelView<ClusterPolicy>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<InstanceType>>() {
    }, new TypeLiteral<ActionPanelView<InstanceType>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<CpuQos>>() {
    }, new TypeLiteral<ActionPanelView<CpuQos>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkQoS>>() {
    }, new TypeLiteral<ActionPanelView<NetworkQoS>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostNetworkQos>>() {
    }, new TypeLiteral<ActionPanelView<HostNetworkQos>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DiskProfile>>() {
    }, new TypeLiteral<ActionPanelView<DiskProfile>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<CpuProfile>>() {
    }, new TypeLiteral<ActionPanelView<CpuProfile>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmNetworkInterface>>() {
    }, new TypeLiteral<ActionPanelView<VmNetworkInterface>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Snapshot>>() {
    }, new TypeLiteral<ActionPanelView<Snapshot>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostDeviceView>>() {
    }, new TypeLiteral<ActionPanelView<HostDeviceView>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<Label>>() {
    }, new TypeLiteral<DetailActionPanelView<Label>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<GlusterHookEntity>>() {
    }, new TypeLiteral<DetailActionPanelView<GlusterHookEntity>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<Network>>() {
    }, new TypeLiteral<DetailActionPanelView<Network>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<IscsiBond>>() {
    }, new TypeLiteral<DetailActionPanelView<IscsiBond>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<GlusterBrickEntity>>() {
    }, new TypeLiteral<DetailActionPanelView<GlusterBrickEntity>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<GlusterVolumeOptionEntity>>() {
    }, new TypeLiteral<DetailActionPanelView<GlusterVolumeOptionEntity>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<StorageDevice>>() {
    }, new TypeLiteral<DetailActionPanelView<StorageDevice>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<GlusterVolumeSnapshotEntity>>() {
    }, new TypeLiteral<DetailActionPanelView<GlusterVolumeSnapshotEntity>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<GlusterServerService>>() {
    }, new TypeLiteral<DetailActionPanelView<GlusterServerService>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<NetworkCluster>>() {
    }, new TypeLiteral<DetailActionPanelView<NetworkCluster>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<ExternalSubnet>>() {
    }, new TypeLiteral<DetailActionPanelView<ExternalSubnet>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<LibvirtSecret>>() {
    }, new TypeLiteral<DetailActionPanelView<LibvirtSecret>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<Permission>>() {
    }, new TypeLiteral<DetailActionPanelView<Permission>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<GlusterGeoRepSession>>() {
    }, new TypeLiteral<DetailActionPanelView<GlusterGeoRepSession>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<PairQueryable<Cluster, NetworkCluster>>>() {
    }, new TypeLiteral<DetailActionPanelView<PairQueryable<Cluster, NetworkCluster>>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<PairQueryable<VdsNetworkInterface, VDS>>>() {
    }, new TypeLiteral<DetailActionPanelView<PairQueryable<VdsNetworkInterface, VDS>>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<PairQueryable<VmNetworkInterface, VM>>>() {
    }, new TypeLiteral<DetailActionPanelView<PairQueryable<VmNetworkInterface, VM>>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<PairQueryable<VmNetworkInterface, VmTemplate>>>() {
    }, new TypeLiteral<DetailActionPanelView<PairQueryable<VmNetworkInterface, VmTemplate>>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<StorageDomainDR>>() {
    }, new TypeLiteral<DetailActionPanelView<StorageDomainDR>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<RepoImage>>() {
    }, new TypeLiteral<DetailActionPanelView<RepoImage>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<DiskModel>>() {
    }, new TypeLiteral<DetailActionPanelView<DiskModel>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<EventSubscriber>>() {
    }, new TypeLiteral<DetailActionPanelView<EventSubscriber>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<AffinityGroup>>() {
    }, new TypeLiteral<DetailActionPanelView<AffinityGroup>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<MacPool>>() {
    }, new TypeLiteral<DetailActionPanelView<MacPool>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<Role>>() {
    }, new TypeLiteral<DetailActionPanelView<Role>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<ClusterPolicy>>() {
    }, new TypeLiteral<DetailActionPanelView<ClusterPolicy>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<InstanceType>>() {
    }, new TypeLiteral<DetailActionPanelView<InstanceType>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<CpuQos>>() {
    }, new TypeLiteral<DetailActionPanelView<CpuQos>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<NetworkQoS>>() {
    }, new TypeLiteral<DetailActionPanelView<NetworkQoS>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<HostNetworkQos>>() {
    }, new TypeLiteral<DetailActionPanelView<HostNetworkQos>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<DiskProfile>>() {
    }, new TypeLiteral<DetailActionPanelView<DiskProfile>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<CpuProfile>>() {
    }, new TypeLiteral<DetailActionPanelView<CpuProfile>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<VmNetworkInterface>>() {
    }, new TypeLiteral<DetailActionPanelView<VmNetworkInterface>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<Snapshot>>() {
    }, new TypeLiteral<DetailActionPanelView<Snapshot>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<HostDeviceView>>() {
    }, new TypeLiteral<DetailActionPanelView<HostDeviceView>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<HostInterfaceLineModel>>() {
    }, new TypeLiteral<DetailActionPanelView<HostInterfaceLineModel>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<StorageQos>>() {
    }, new TypeLiteral<DetailActionPanelView<StorageQos>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<VDS>>() {
    }, new TypeLiteral<DetailActionPanelView<VDS>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<Quota>>() {
    }, new TypeLiteral<DetailActionPanelView<Quota>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<VM>>() {
    }, new TypeLiteral<DetailActionPanelView<VM>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<VnicProfileView>>() {
    }, new TypeLiteral<DetailActionPanelView<VnicProfileView>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<NetworkView>>() {
    }, new TypeLiteral<DetailActionPanelView<NetworkView>>() {
    });
    bindActionPanel(new TypeLiteral<DetailActionPanelPresenterWidget.ViewDef<Disk>>() {
    }, new TypeLiteral<DetailActionPanelView<Disk>>() {
    });
}
#end_block

#method_before
// TODO: this isn't accurate, should be revisited
@InputDetail
default void inputDetail() {
    optional(storageDomain().name());
    mandatory(storageDomain().storage().logicalUnits()[COLLECTION].address());
    mandatory(storageDomain().storage().logicalUnits()[COLLECTION].id());
    mandatory(storageDomain().storage().logicalUnits()[COLLECTION].lunMapping());
    mandatory(storageDomain().storage().logicalUnits()[COLLECTION].password());
    mandatory(storageDomain().storage().logicalUnits()[COLLECTION].paths());
    mandatory(storageDomain().storage().logicalUnits()[COLLECTION].port());
    mandatory(storageDomain().storage().logicalUnits()[COLLECTION].portal());
    mandatory(storageDomain().storage().logicalUnits()[COLLECTION].productId());
    mandatory(storageDomain().storage().logicalUnits()[COLLECTION].serial());
    mandatory(storageDomain().storage().logicalUnits()[COLLECTION].target());
    mandatory(storageDomain().storage().logicalUnits()[COLLECTION].username());
    mandatory(storageDomain().storage().logicalUnits()[COLLECTION].vendorId());
    optional(storageDomain().comment());
    optional(storageDomain().criticalSpaceActionBlocker());
    // DEPRECATED
    optional(storageDomain().host().id());
    optional(storageDomain().storage().overrideLuns());
    optional(storageDomain().warningLowSpaceIndicator());
    optional(storageDomain().wipeAfterDelete());
}
#method_after
default void inputDetail() {
    optional(storageDomain().name());
    optional(storageDomain().storage().logicalUnits()[COLLECTION].address());
    optional(storageDomain().storage().logicalUnits()[COLLECTION].id());
    optional(storageDomain().storage().logicalUnits()[COLLECTION].port());
    optional(storageDomain().storage().logicalUnits()[COLLECTION].target());
    optional(storageDomain().storage().logicalUnits()[COLLECTION].lunMapping());
    optional(storageDomain().storage().logicalUnits()[COLLECTION].password());
    optional(storageDomain().storage().logicalUnits()[COLLECTION].paths());
    optional(storageDomain().storage().logicalUnits()[COLLECTION].portal());
    optional(storageDomain().storage().logicalUnits()[COLLECTION].productId());
    optional(storageDomain().storage().logicalUnits()[COLLECTION].serial());
    optional(storageDomain().storage().logicalUnits()[COLLECTION].username());
    optional(storageDomain().storage().logicalUnits()[COLLECTION].vendorId());
    optional(storageDomain().comment());
    optional(storageDomain().criticalSpaceActionBlocker());
    // DEPRECATED
    optional(storageDomain().host().id());
    optional(storageDomain().storage().overrideLuns());
    optional(storageDomain().warningLowSpaceIndicator());
    optional(storageDomain().wipeAfterDelete());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    StorageDomain storageDomain = storageDomainDao.get(getParameters().getId());
    if (storageDomain.getStorageType().isCinderDomain()) {
        List<DiskImage> diskImages = diskImageDao.getAllForStorageDomain(getParameters().getId());
        getQueryReturnValue().setReturnValue(diskImages);
    } else {
        List<DiskImage> diskImages = diskImageDao.getAllSnapshotsForStorageDomain(getParameters().getId());
        getQueryReturnValue().setReturnValue(imagesHandler.aggregateDiskImagesSnapshots(diskImages));
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    StorageDomain storageDomain = storageDomainDao.get(getParameters().getId());
    if (storageDomain.getStorageType().isCinderDomain()) {
        List<DiskImage> diskImages = diskImageDao.getAllForStorageDomain(getParameters().getId());
        getQueryReturnValue().setReturnValue(diskImages);
    } else {
        List<DiskImage> diskImages = diskImageDao.getAllSnapshotsForStorageDomain(getParameters().getId());
        getQueryReturnValue().setReturnValue(new ArrayList<>(imagesHandler.aggregateDiskImagesSnapshots(diskImages)));
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private static List<BaseResource> getInlineResources(Object obj) {
    ArrayList<BaseResource> ret = new ArrayList<>();
    for (Method method : getRelevantMethods(obj.getClass())) {
        // We need to recursively scan everything that is in the model package, as there may be references
        // to resources deeply nested:
        Object inline = null;
        try {
            inline = method.invoke(obj);
        } catch (Exception e) {
        // invocation target exception should not occur on simple getter
        }
        if (inline != null) {
            if (inline instanceof BaseResource) {
                ret.add((BaseResource) inline);
            } else if (inline instanceof BaseResources) {
                BaseResources entities = (BaseResources) inline;
                Method getter = EntityHelper.getCollectionGetter(entities);
                try {
                    List<BaseResource> entitiesList = (List<BaseResource>) getter.invoke(entities);
                    for (BaseResource entity : entitiesList) {
                        ret.add(entity);
                    }
                } catch (Exception e) {
                // invocation target exception should not occur
                }
            } else {
                ret.addAll(getInlineResources(inline));
            }
        }
    }
    return ret;
}
#method_after
@SuppressWarnings("unchecked")
private static List<BaseResource> getInlineResources(Object obj) {
    ArrayList<BaseResource> ret = new ArrayList<>();
    for (Method method : getRelevantMethods(obj.getClass())) {
        // We need to recursively scan everything that is in the model package, as there may be references
        // to resources deeply nested:
        Object inline = null;
        try {
            inline = method.invoke(obj);
        } catch (Exception e) {
        // invocation target exception should not occur on simple getter
        }
        if (inline != null) {
            if (inline instanceof BaseResource) {
                ret.add((BaseResource) inline);
            } else if (inline instanceof BaseResources) {
                BaseResources entities = (BaseResources) inline;
                Method getter = EntityHelper.getCollectionGetter(entities);
                try {
                    List<BaseResource> entitiesList = (List<BaseResource>) getter.invoke(entities);
                    for (BaseResource entity : entitiesList) {
                        ret.add(entity);
                    }
                } catch (Exception e) {
                    log.error("Error invoking method '{}' on class '{}'.", method.getName(), entities.getClass().getSimpleName());
                    log.error("Exception", e);
                }
            } else {
                ret.addAll(getInlineResources(inline));
            }
        }
    }
    return ret;
}
#end_block

#method_before
public void scheduleJobs() {
    SchedulerUtil sched = getSchedulUtil();
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    registeredJobs.add(sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS));
    vmsRefresher = getRefresherFactory().create(this, resourceManager);
    vmsRefresher.startMonitoring();
    hostRefresher = new HostConnectionRefresher(this, resourceManager);
    hostRefresher.start();
}
#method_after
public void scheduleJobs() {
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    registeredJobs.add(executor.scheduleWithFixedDelay(this::refresh, refreshRate, refreshRate, TimeUnit.MILLISECONDS));
    vmsRefresher = getRefresherFactory().create(this, resourceManager);
    vmsRefresher.startMonitoring();
    hostRefresher = new HostConnectionRefresher(this, resourceManager);
    hostRefresher.start();
}
#end_block

#method_before
private void handleVdsRecoveringException(VDSRecoveringException ex) {
    if (cachedVds.getStatus() != VDSStatus.Initializing && cachedVds.getStatus() != VDSStatus.NonOperational) {
        setStatus(VDSStatus.Initializing, cachedVds);
        vdsDynamicDao.updateStatus(cachedVds.getId(), VDSStatus.Initializing);
        AuditLogable logable = createAuditLogableForHost(cachedVds);
        logable.addCustomValue("ErrorMessage", ex.getMessage());
        logable.updateCallStackFromThrowable(ex);
        auditLogDirector.log(logable, AuditLogType.VDS_INITIALIZING);
        log.warn("Failed to refresh VDS, continuing, vds='{}'({}): {}", cachedVds.getName(), cachedVds.getId(), ex.getMessage());
        log.debug("Exception", ex);
        final int VDS_RECOVERY_TIMEOUT_IN_MINUTES = Config.<Integer>getValue(ConfigValues.VdsRecoveryTimeoutInMinutes);
        String jobId = getSchedulUtil().scheduleAOneTimeJob(this, "onTimerHandleVdsRecovering", new Class[0], new Object[0], VDS_RECOVERY_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        recoveringJobIdMap.put(cachedVds.getId(), jobId);
    }
}
#method_after
private void handleVdsRecoveringException(VDSRecoveringException ex) {
    if (cachedVds.getStatus() != VDSStatus.Initializing && cachedVds.getStatus() != VDSStatus.NonOperational) {
        setStatus(VDSStatus.Initializing, cachedVds);
        vdsDynamicDao.updateStatus(cachedVds.getId(), VDSStatus.Initializing);
        AuditLogable logable = createAuditLogableForHost(cachedVds);
        logable.addCustomValue("ErrorMessage", ex.getMessage());
        logable.updateCallStackFromThrowable(ex);
        auditLogDirector.log(logable, AuditLogType.VDS_INITIALIZING);
        log.warn("Failed to refresh VDS, continuing, vds='{}'({}): {}", cachedVds.getName(), cachedVds.getId(), ex.getMessage());
        log.debug("Exception", ex);
        final int VDS_RECOVERY_TIMEOUT_IN_MINUTES = Config.<Integer>getValue(ConfigValues.VdsRecoveryTimeoutInMinutes);
        ScheduledFuture scheduled = executor.schedule(this::handleVdsRecovering, VDS_RECOVERY_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        recoveringJobIdMap.put(cachedVds.getId(), scheduled);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("recoverFromError")
public void recoverFromError() {
    VDS vds = vdsDao.get(getVdsId());
    /**
     * Move cachedVds to Up status from error
     */
    if (vds != null && vds.getStatus() == VDSStatus.Error) {
        setStatus(VDSStatus.Up, vds);
        vdsDynamicDao.updateStatus(getVdsId(), VDSStatus.Up);
        log.info("Settings host '{}' to up after {} failed attempts to run a VM", vds.getName(), failedToRunVmAttempts);
        failedToRunVmAttempts.set(0);
    }
}
#method_after
public void recoverFromError() {
    VDS vds = vdsDao.get(getVdsId());
    /**
     * Move cachedVds to Up status from error
     */
    if (vds != null && vds.getStatus() == VDSStatus.Error) {
        setStatus(VDSStatus.Up, vds);
        vdsDynamicDao.updateStatus(getVdsId(), VDSStatus.Up);
        log.info("Settings host '{}' to up after {} failed attempts to run a VM", vds.getName(), failedToRunVmAttempts);
        failedToRunVmAttempts.set(0);
    }
}
#end_block

#method_before
public void failedToRunVm(VDS vds) {
    if (failedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && failedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        resourceManager.runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = getSchedulUtil();
        sched.scheduleAOneTimeJob(this, "recoverFromError", new Class[0], new Object[0], Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes), TimeUnit.MINUTES);
        AuditLogable logable = createAuditLogableForHost(vds);
        logable.addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString());
        auditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.info("Vds '{}' moved to Error mode after {} attempts. Time: {}", vds.getName(), failedToRunVmAttempts, new Date());
    }
}
#method_after
public void failedToRunVm(VDS vds) {
    if (failedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && failedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        resourceManager.runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        executor.schedule(this::recoverFromError, Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes), TimeUnit.MINUTES);
        AuditLogable logable = createAuditLogableForHost(vds);
        logable.addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString());
        auditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.info("Vds '{}' moved to Error mode after {} attempts. Time: {}", vds.getName(), failedToRunVmAttempts, new Date());
    }
}
#end_block

#method_before
public void dispose() {
    log.info("vdsManager::disposing");
    for (String jobId : registeredJobs) {
        getSchedulUtil().deleteJob(jobId);
    }
    vmsRefresher.stopMonitoring();
    hostRefresher.stop();
    vdsProxy.close();
}
#method_after
public void dispose() {
    log.info("vdsManager::disposing");
    for (ScheduledFuture job : registeredJobs) {
        job.cancel(true);
    }
    vmsRefresher.stopMonitoring();
    hostRefresher.stop();
    vdsProxy.close();
}
#end_block

#method_before
public void cancelRecoveryJob() {
    String jobId = recoveringJobIdMap.remove(vdsId);
    if (jobId != null) {
        log.info("Cancelling the recovery from crash timer for VDS '{}' because vds started initializing", vdsId);
        try {
            Injector.get(SchedulerUtilQuartzImpl.class).deleteJob(jobId);
        } catch (Exception e) {
            log.warn("Failed deleting job '{}' at cancelRecoveryJob: {}", jobId, e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#method_after
public void cancelRecoveryJob() {
    ScheduledFuture scheduled = recoveringJobIdMap.remove(vdsId);
    if (scheduled != null) {
        log.info("Cancelling the recovery from crash timer for VDS '{}' because vds started initializing", vdsId);
        try {
            scheduled.cancel(true);
        } catch (Exception e) {
            log.warn("Failed deleting cancelRecoveryJob: {} for VDS '{}'", e.getMessage(), vdsId);
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
protected void initDisksTable() {
    disksTable = new EntityModelCellTable<>(false, true);
    disksTable.enableColumnResizing();
    // $NON-NLS-1$
    disksTable.addColumn(new DiskImageStatusColumn(), constants.empty(), "30px");
    AbstractTextColumn<DiskImage> aliasColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            return object.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(aliasColumn, constants.aliasDisk(), "80px");
    AbstractDiskSizeColumn<DiskImage> sizeColumn = new AbstractDiskSizeColumn<DiskImage>() {

        @Override
        protected Long getRawValue(DiskImage object) {
            return object.getSize();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(sizeColumn, constants.provisionedSizeDisk(), "80px");
    AbstractDiskSizeColumn<DiskImage> actualSizeColumn = new AbstractDiskSizeColumn<DiskImage>() {

        @Override
        protected Long getRawValue(DiskImage object) {
            return object.getActualSizeInBytes();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(actualSizeColumn, constants.sizeDisk(), "80px");
    AbstractTextColumn<DiskImage> allocationColumn = new AbstractEnumColumn<DiskImage, VolumeType>() {

        @Override
        protected VolumeType getRawValue(DiskImage object) {
            return VolumeType.forValue(object.getVolumeType().getValue());
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(allocationColumn, constants.allocationDisk(), "110px");
    AbstractTextColumn<DiskImage> statusColumn = new AbstractEnumColumn<DiskImage, ImageStatus>() {

        @Override
        protected ImageStatus getRawValue(DiskImage object) {
            return object.getImageStatus();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(statusColumn, constants.statusDisk(), "65px");
    AbstractTextColumn<DiskImage> dateCreatedColumn = new AbstractFullDateTimeColumn<DiskImage>() {

        @Override
        protected Date getRawValue(DiskImage object) {
            return object.getCreationDate();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(dateCreatedColumn, constants.creationDateDisk(), "100px");
    AbstractTextColumn<DiskImage> descriptionColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            return object.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(descriptionColumn, constants.descriptionDisk(), "100px");
    if (registerEntityModel.isQuotaEnabled()) {
        // $NON-NLS-1$
        disksTable.addColumn(getDiskQuotaColumn(), constants.quotaVm(), "100px");
    }
    disksTable.setRowData(new ArrayList<EntityModel>());
    disksTable.setWidth(100 + Style.Unit.PCT.getType());
    disksTable.setSelectionModel(new NoSelectionModel());
}
#method_after
protected void initDisksTable() {
    disksTable = new EntityModelCellTable<>(false, true);
    disksTable.enableColumnResizing();
    // $NON-NLS-1$
    disksTable.addColumn(new DiskImageStatusColumn(), constants.empty(), "30px");
    AbstractTextColumn<DiskImage> aliasColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            return object.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(aliasColumn, constants.aliasDisk(), "80px");
    AbstractDiskSizeColumn<DiskImage> sizeColumn = new AbstractDiskSizeColumn<DiskImage>() {

        @Override
        protected Long getRawValue(DiskImage object) {
            return object.getSize();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(sizeColumn, constants.provisionedSizeDisk(), "80px");
    AbstractDiskSizeColumn<DiskImage> actualSizeColumn = new AbstractDiskSizeColumn<DiskImage>() {

        @Override
        protected Long getRawValue(DiskImage object) {
            return object.getActualSizeInBytes();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(actualSizeColumn, constants.sizeDisk(), "80px");
    AbstractTextColumn<DiskImage> allocationColumn = new AbstractEnumColumn<DiskImage, VolumeType>() {

        @Override
        protected VolumeType getRawValue(DiskImage object) {
            return VolumeType.forValue(object.getVolumeType().getValue());
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(allocationColumn, constants.allocationDisk(), "110px");
    AbstractTextColumn<DiskImage> statusColumn = new AbstractEnumColumn<DiskImage, ImageStatus>() {

        @Override
        protected ImageStatus getRawValue(DiskImage object) {
            return object.getImageStatus();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(statusColumn, constants.statusDisk(), "65px");
    AbstractTextColumn<DiskImage> dateCreatedColumn = new AbstractFullDateTimeColumn<DiskImage>() {

        @Override
        protected Date getRawValue(DiskImage object) {
            return object.getCreationDate();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(dateCreatedColumn, constants.creationDateDisk(), "100px");
    AbstractTextColumn<DiskImage> descriptionColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            return object.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(descriptionColumn, constants.descriptionDisk(), "100px");
    if (registerEntityModel.isQuotaEnabled()) {
        // $NON-NLS-1$
        disksTable.addColumn(getDiskQuotaColumn(), constants.quotaVm(), "100px");
    }
    disksTable.setRowData(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    disksTable.setWidth("100%");
    disksTable.setSelectionModel(new NoSelectionModel());
}
#end_block

#method_before
protected void initNicsTable() {
    nicsTable = new EntityModelCellTable<>(false, true);
    nicsTable.enableColumnResizing();
    AbstractTextColumn<VmNetworkInterface> nameColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(nameColumn, constants.nameInterface(), "90px");
    AbstractTextColumn<VmNetworkInterface> networkNameColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getNetworkName();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(networkNameColumn, constants.networkNameInterface(), "90px");
    AbstractTextColumn<VmNetworkInterface> profileNameColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getVnicProfileName();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(profileNameColumn, constants.profileNameInterface(), "90px");
    AbstractTextColumn<VmNetworkInterface> typeColumn = new AbstractEnumColumn<VmNetworkInterface, VmInterfaceType>() {

        @Override
        protected VmInterfaceType getRawValue(VmNetworkInterface object) {
            return VmInterfaceType.forValue(object.getType());
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(typeColumn, constants.typeInterface(), "90px");
    AbstractTextColumn<VmNetworkInterface> macColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getMacAddress();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(macColumn, constants.macInterface(), "90px");
    AbstractTextColumn<VmNetworkInterface> speedColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().toString();
            } else {
                return null;
            }
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(speedColumn, templates.sub(constants.speedInterface(), constants.mbps()), "90px");
    AbstractTextColumn<VmNetworkInterface> rxColumn = new AbstractRxTxRateColumn<VmNetworkInterface>() {

        @Override
        protected Double getRate(VmNetworkInterface object) {
            return object.getStatistics().getReceiveRate();
        }

        @Override
        protected Double getSpeed(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().doubleValue();
            } else {
                return null;
            }
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(rxColumn, templates.sub(constants.rxRate(), constants.mbps()), "90px");
    AbstractTextColumn<VmNetworkInterface> txColumn = new AbstractRxTxRateColumn<VmNetworkInterface>() {

        @Override
        protected Double getRate(VmNetworkInterface object) {
            return object.getStatistics().getTransmitRate();
        }

        @Override
        protected Double getSpeed(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().doubleValue();
            } else {
                return null;
            }
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(txColumn, templates.sub(constants.txRate(), constants.mbps()), "90px");
    AbstractTextColumn<VmNetworkInterface> dropsColumn = new AbstractSumUpColumn<VmNetworkInterface>() {

        @Override
        protected Double[] getRawValue(VmNetworkInterface object) {
            Double receiveDropRate = object != null ? object.getStatistics().getReceiveDropRate() : null;
            Double transmitDropRate = object != null ? object.getStatistics().getTransmitDropRate() : null;
            return new Double[] { receiveDropRate, transmitDropRate };
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(dropsColumn, templates.sub(constants.dropsInterface(), constants.pkts()), "90px");
    nicsTable.setRowData(new ArrayList<EntityModel>());
    nicsTable.setWidth(100 + Style.Unit.PCT.getType());
    nicsTable.setSelectionModel(new NoSelectionModel());
}
#method_after
protected void initNicsTable() {
    nicsTable = new EntityModelCellTable<>(false, true);
    nicsTable.enableColumnResizing();
    AbstractTextColumn<VmNetworkInterface> nameColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(nameColumn, constants.nameInterface(), "90px");
    AbstractTextColumn<VmNetworkInterface> networkNameColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getNetworkName();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(networkNameColumn, constants.networkNameInterface(), "90px");
    AbstractTextColumn<VmNetworkInterface> profileNameColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getVnicProfileName();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(profileNameColumn, constants.profileNameInterface(), "90px");
    AbstractTextColumn<VmNetworkInterface> typeColumn = new AbstractEnumColumn<VmNetworkInterface, VmInterfaceType>() {

        @Override
        protected VmInterfaceType getRawValue(VmNetworkInterface object) {
            return VmInterfaceType.forValue(object.getType());
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(typeColumn, constants.typeInterface(), "90px");
    AbstractTextColumn<VmNetworkInterface> macColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getMacAddress();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(macColumn, constants.macInterface(), "90px");
    AbstractTextColumn<VmNetworkInterface> speedColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().toString();
            } else {
                return null;
            }
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(speedColumn, templates.sub(constants.speedInterface(), constants.mbps()), "90px");
    AbstractTextColumn<VmNetworkInterface> rxColumn = new AbstractRxTxRateColumn<VmNetworkInterface>() {

        @Override
        protected Double getRate(VmNetworkInterface object) {
            return object.getStatistics().getReceiveRate();
        }

        @Override
        protected Double getSpeed(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().doubleValue();
            } else {
                return null;
            }
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(rxColumn, templates.sub(constants.rxRate(), constants.mbps()), "90px");
    AbstractTextColumn<VmNetworkInterface> txColumn = new AbstractRxTxRateColumn<VmNetworkInterface>() {

        @Override
        protected Double getRate(VmNetworkInterface object) {
            return object.getStatistics().getTransmitRate();
        }

        @Override
        protected Double getSpeed(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().doubleValue();
            } else {
                return null;
            }
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(txColumn, templates.sub(constants.txRate(), constants.mbps()), "90px");
    AbstractTextColumn<VmNetworkInterface> dropsColumn = new AbstractSumUpColumn<VmNetworkInterface>() {

        @Override
        protected Double[] getRawValue(VmNetworkInterface object) {
            Double receiveDropRate = object != null ? object.getStatistics().getReceiveDropRate() : null;
            Double transmitDropRate = object != null ? object.getStatistics().getTransmitDropRate() : null;
            return new Double[] { receiveDropRate, transmitDropRate };
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(dropsColumn, templates.sub(constants.dropsInterface(), constants.pkts()), "90px");
    nicsTable.setRowData(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    nicsTable.setWidth("100%");
    nicsTable.setSelectionModel(new NoSelectionModel());
}
#end_block

#method_before
protected void initAppsTable() {
    appsTable = new EntityModelCellTable<>(false, true);
    AbstractTextColumn<String> appNameColumn = new AbstractTextColumn<String>() {

        @Override
        public String getValue(String appName) {
            return appName;
        }
    };
    appsTable.addColumn(appNameColumn, constants.nameSnapshot());
    appsTable.setRowData(new ArrayList<EntityModel>());
    appsTable.setWidth(100 + Style.Unit.PCT.getType());
    appsTable.setSelectionModel(new NoSelectionModel());
}
#method_after
protected void initAppsTable() {
    appsTable = new EntityModelCellTable<>(false, true);
    AbstractTextColumn<String> appNameColumn = new AbstractTextColumn<String>() {

        @Override
        public String getValue(String appName) {
            return appName;
        }
    };
    appsTable.addColumn(appNameColumn, constants.nameSnapshot());
    appsTable.setRowData(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    appsTable.setWidth("100%");
    appsTable.setSelectionModel(new NoSelectionModel());
}
#end_block

#method_before
protected void initContainersTable() {
    containersTable = new EntityModelCellTable<>(false, true);
    containersTable.addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getId().toString();
        }
    }, constants.idContainer());
    containersTable.addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            // $NON-NLS-1$
            return String.join(", ", row.getNames());
        }
    }, constants.namesContainer());
    containersTable.addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getImage();
        }
    }, constants.imageContainer());
    containersTable.addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getCommand();
        }
    }, constants.commandContainer());
    containersTable.addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getStatus();
        }
    }, constants.statusContainer());
    containersTable.setRowData(new ArrayList<EntityModel>());
    containersTable.setWidth(100 + Style.Unit.PCT.getType());
    containersTable.setSelectionModel(new NoSelectionModel());
}
#method_after
protected void initContainersTable() {
    containersTable = new EntityModelCellTable<>(false, true);
    containersTable.addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getId().toString();
        }
    }, constants.idContainer());
    containersTable.addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            // $NON-NLS-1$
            return String.join(", ", row.getNames());
        }
    }, constants.namesContainer());
    containersTable.addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getImage();
        }
    }, constants.imageContainer());
    containersTable.addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getCommand();
        }
    }, constants.commandContainer());
    containersTable.addColumn(new AbstractTextColumn<GuestContainer>() {

        @Override
        public String getValue(GuestContainer row) {
            return row.getStatus();
        }
    }, constants.statusContainer());
    containersTable.setRowData(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    containersTable.setWidth("100%");
    containersTable.setSelectionModel(new NoSelectionModel());
}
#end_block

#method_before
@Override
protected void initHeader() {
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.domainNameStorage(), "");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.domainTypeStorage(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.statusStorage(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.freeSpaceStorage(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.usedSpaceStorage(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.totalSpaceStorage(), "120px");
    table.setHeight(30 + Unit.PX.getType());
}
#method_after
@Override
protected void initHeader() {
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.domainNameStorage(), "");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.domainTypeStorage(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.statusStorage(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.freeSpaceStorage(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.usedSpaceStorage(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.totalSpaceStorage(), "120px");
    // $NON-NLS-1$
    table.setHeight("30px");
}
#end_block

#method_before
@Override
protected void initHeader() {
    table.addColumn(new EmptyColumn(), constants.aliasVm());
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.disksVm(), "80px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.templateVm(), "160px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.vSizeVm(), "110px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.actualSizeVm(), "110px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.creationDateVm(), "170px");
    table.setHeight(30 + Unit.PX.getType());
}
#method_after
@Override
protected void initHeader() {
    table.addColumn(new EmptyColumn(), constants.aliasVm());
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.disksVm(), "80px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.templateVm(), "160px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.vSizeVm(), "110px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.actualSizeVm(), "110px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.creationDateVm(), "170px");
    // $NON-NLS-1$
    table.setHeight("30px");
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected TreeItem createLeafNode(ListModel leafModel) {
    TreeItem item = new TreeItem();
    List<LunModel> items = (List<LunModel>) leafModel.getItems();
    if (hideLeaf || items.isEmpty()) {
        item.setUserObject(Boolean.TRUE);
        return item;
    }
    final SortedListModel sortedLeafModel = new SortedListModel();
    sortedLeafModel.setItems(items);
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunTableResources.class));
    table.initModelSortHandler(sortedLeafModel);
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn(multiSelection) {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "30px");
    AbstractLunTextColumn lunIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    };
    lunIdColumn.makeSortable();
    table.addColumn(lunIdColumn, constants.lunIdSanStorage());
    AbstractLunTextColumn devSizeColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return messages.gigabytes(String.valueOf(model.getSize()));
        }
    };
    devSizeColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(devSizeColumn, constants.devSizeSanStorage(), "70px");
    AbstractLunTextColumn path = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    };
    path.makeSortable();
    // $NON-NLS-1$
    table.addColumn(path, constants.pathSanStorage(), "55px");
    AbstractLunTextColumn vendorIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    };
    vendorIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "100px");
    AbstractLunTextColumn productIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    };
    productIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(productIdColumn, constants.productIdSanStorage(), "100px");
    AbstractLunTextColumn serialNumColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    };
    serialNumColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(serialNumColumn, constants.serialSanStorage(), "120px");
    table.setRowData(items);
    final Object selectedItem = sortedLeafModel.getSelectedItem();
    sortedLeafModel.setSelectedItem(null);
    table.asEditor().edit(sortedLeafModel);
    sortedLeafModel.setSelectedItem(selectedItem);
    table.setWidth(100 + Style.Unit.PCT.getType());
    if (!multiSelection) {
        for (LunModel lunModel : items) {
            if (lunModel.getIsSelected()) {
                table.getSelectionModel().setSelected(lunModel, true);
            }
        }
        table.getSelectionModel().addSelectionChangeHandler(event -> {
            SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
            selectedLunModel = SingleSelectionModel.getSelectedObject() == null ? selectedLunModel : (LunModel) SingleSelectionModel.getSelectedObject();
            if (selectedLunModel != null) {
                updateSelectedLunWarning(selectedLunModel);
                sortedLeafModel.setSelectedItem(selectedLunModel);
            }
        });
    } else {
        for (LunModel lunModel : items) {
            table.getSelectionModel().setSelected(lunModel, lunModel.getIsSelected());
        }
        table.getSelectionModel().addSelectionChangeHandler(event -> model.updateLunWarningForDiscardAfterDelete());
    }
    ScrollPanel panel = new ScrollPanel();
    panel.add(table);
    item.setWidget(panel);
    // Display LUNs as grayed-out if needed
    for (LunModel lunModel : items) {
        if (lunModel.getIsGrayedOut()) {
            grayOutItem(lunModel.getGrayedOutReasons(), lunModel, table);
        }
    }
    return item;
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected TreeItem createLeafNode(ListModel leafModel) {
    TreeItem item = new TreeItem();
    List<LunModel> items = (List<LunModel>) leafModel.getItems();
    if (hideLeaf || items.isEmpty()) {
        item.setUserObject(Boolean.TRUE);
        return item;
    }
    final SortedListModel sortedLeafModel = new SortedListModel();
    sortedLeafModel.setItems(items);
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunTableResources.class));
    table.initModelSortHandler(sortedLeafModel);
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn(multiSelection) {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "30px");
    AbstractLunTextColumn lunIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    };
    lunIdColumn.makeSortable();
    table.addColumn(lunIdColumn, constants.lunIdSanStorage());
    AbstractLunTextColumn devSizeColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return messages.gigabytes(String.valueOf(model.getSize()));
        }
    };
    devSizeColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(devSizeColumn, constants.devSizeSanStorage(), "70px");
    AbstractLunTextColumn path = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    };
    path.makeSortable();
    // $NON-NLS-1$
    table.addColumn(path, constants.pathSanStorage(), "55px");
    AbstractLunTextColumn vendorIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    };
    vendorIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "100px");
    AbstractLunTextColumn productIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    };
    productIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(productIdColumn, constants.productIdSanStorage(), "100px");
    AbstractLunTextColumn serialNumColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    };
    serialNumColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(serialNumColumn, constants.serialSanStorage(), "120px");
    table.setRowData(items);
    final Object selectedItem = sortedLeafModel.getSelectedItem();
    sortedLeafModel.setSelectedItem(null);
    table.asEditor().edit(sortedLeafModel);
    sortedLeafModel.setSelectedItem(selectedItem);
    // $NON-NLS-1$
    table.setWidth("100%");
    if (!multiSelection) {
        for (LunModel lunModel : items) {
            if (lunModel.getIsSelected()) {
                table.getSelectionModel().setSelected(lunModel, true);
            }
        }
        table.getSelectionModel().addSelectionChangeHandler(event -> {
            SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
            selectedLunModel = SingleSelectionModel.getSelectedObject() == null ? selectedLunModel : (LunModel) SingleSelectionModel.getSelectedObject();
            if (selectedLunModel != null) {
                updateSelectedLunWarning(selectedLunModel);
                sortedLeafModel.setSelectedItem(selectedLunModel);
            }
        });
    } else {
        for (LunModel lunModel : items) {
            table.getSelectionModel().setSelected(lunModel, lunModel.getIsSelected());
        }
        table.getSelectionModel().addSelectionChangeHandler(event -> model.updateLunWarningForDiscardAfterDelete());
    }
    ScrollPanel panel = new ScrollPanel();
    panel.add(table);
    item.setWidget(panel);
    // Display LUNs as grayed-out if needed
    for (LunModel lunModel : items) {
        if (lunModel.getIsGrayedOut()) {
            grayOutItem(lunModel.getGrayedOutReasons(), lunModel, table);
        }
    }
    return item;
}
#end_block

#method_before
@Override
protected void initHeader() {
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.aliasDisk(), "");
    ImageResourceHeader readOnlyColumnHeader = new ImageResourceHeader(resources.readOnlyDiskIcon(), SafeHtmlUtils.fromSafeConstant(constants.readOnly()));
    // $NON-NLS-1$);
    table.addColumn(new EmptyColumn(), readOnlyColumnHeader, "60px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.provisionedSizeDisk(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.sizeDisk(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.statusDisk(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.allocationDisk(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.interfaceDisk(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.typeDisk(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.creationDateDisk(), "150px");
    table.setHeight(30 + Unit.PX.getType());
}
#method_after
@Override
protected void initHeader() {
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.aliasDisk(), "");
    ImageResourceHeader readOnlyColumnHeader = new ImageResourceHeader(resources.readOnlyDiskIcon(), SafeHtmlUtils.fromSafeConstant(constants.readOnly()));
    // $NON-NLS-1$);
    table.addColumn(new EmptyColumn(), readOnlyColumnHeader, "60px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.provisionedSizeDisk(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.sizeDisk(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.statusDisk(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.allocationDisk(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.interfaceDisk(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.typeDisk(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.creationDateDisk(), "150px");
    // $NON-NLS-1$
    table.setHeight("30px");
}
#end_block

#method_before
public static int determineScrollbarThickness() {
    FlowPanel panel = new FlowPanel();
    panel.getElement().getStyle().setWidth(100, Unit.PX);
    panel.getElement().getStyle().setHeight(100, Unit.PX);
    panel.getElement().getStyle().setOverflow(Overflow.SCROLL);
    Document.get().getBody().appendChild(panel.getElement());
    int scrollbarHeight = panel.getOffsetHeight() - panel.getElement().getClientHeight();
    Document.get().getBody().removeChild(panel.getElement());
    return scrollbarHeight;
}
#method_after
public static int determineScrollbarThickness() {
    Element panel = DOM.createDiv();
    panel.getStyle().setWidth(100, Unit.PX);
    panel.getStyle().setHeight(100, Unit.PX);
    panel.getStyle().setOverflow(Overflow.SCROLL);
    Document.get().getBody().appendChild(panel);
    int scrollbarHeight = panel.getOffsetHeight() - panel.getClientHeight();
    Document.get().getBody().removeChild(panel);
    return scrollbarHeight;
}
#end_block

#method_before
@Override
protected TreeItem createRootNode(LunModel rootModel) {
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunRootResources.class));
    // Create table
    initRootNodeTable(table);
    // Set custom selection column
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn(multiSelection) {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "20px");
    // Add items
    List<LunModel> items = new ArrayList<>();
    items.add(rootModel);
    ListModel<LunModel> listModel = new ListModel<>();
    listModel.setItems(items);
    // Update table
    table.setRowData(items);
    table.asEditor().edit(listModel);
    table.setWidth(100 + Style.Unit.PCT.getType());
    rootModel.getPropertyChangedEvent().removeListener(lunModelSelectedItemListener);
    rootModel.getPropertyChangedEvent().addListener(lunModelSelectedItemListener, table);
    if (!multiSelection) {
        table.getSelectionModel().addSelectionChangeHandler(event -> {
            SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
            LunModel selectedLunModel = (LunModel) SingleSelectionModel.getSelectedObject();
            if (selectedLunModel != null) {
                updateSelectedLunWarning(selectedLunModel);
            }
        });
    } else {
        table.getSelectionModel().setSelected(rootModel, rootModel.getIsSelected());
        table.getSelectionModel().addSelectionChangeHandler(event -> model.updateLunWarningForDiscardAfterDelete());
    }
    // Create tree item
    HorizontalPanel panel = new HorizontalPanel();
    panel.add(table);
    panel.setWidth(100 + Style.Unit.PCT.getType());
    panel.getElement().getStyle().setTableLayout(TableLayout.FIXED);
    TreeItem item = new TreeItem(panel);
    // Display LUNs as grayed-out if needed
    if (rootModel.getIsGrayedOut()) {
        grayOutItem(rootModel.getGrayedOutReasons(), rootModel, table);
    }
    return item;
}
#method_after
@Override
protected TreeItem createRootNode(LunModel rootModel) {
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunRootResources.class));
    // Create table
    initRootNodeTable(table);
    // Set custom selection column
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn(multiSelection) {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "20px");
    // Add items
    List<LunModel> items = new ArrayList<>();
    items.add(rootModel);
    ListModel<LunModel> listModel = new ListModel<>();
    listModel.setItems(items);
    // Update table
    table.setRowData(items);
    table.asEditor().edit(listModel);
    // $NON-NLS-1$
    table.setWidth("100%");
    rootModel.getPropertyChangedEvent().removeListener(lunModelSelectedItemListener);
    rootModel.getPropertyChangedEvent().addListener(lunModelSelectedItemListener, table);
    if (!multiSelection) {
        table.getSelectionModel().addSelectionChangeHandler(event -> {
            SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
            LunModel selectedLunModel = (LunModel) SingleSelectionModel.getSelectedObject();
            if (selectedLunModel != null) {
                updateSelectedLunWarning(selectedLunModel);
            }
        });
    } else {
        table.getSelectionModel().setSelected(rootModel, rootModel.getIsSelected());
        table.getSelectionModel().addSelectionChangeHandler(event -> model.updateLunWarningForDiscardAfterDelete());
    }
    // Create tree item
    HorizontalPanel panel = new HorizontalPanel();
    panel.add(table);
    // $NON-NLS-1$
    panel.setWidth("100%");
    panel.getElement().getStyle().setTableLayout(TableLayout.FIXED);
    TreeItem item = new TreeItem(panel);
    // Display LUNs as grayed-out if needed
    if (rootModel.getIsGrayedOut()) {
        grayOutItem(rootModel.getGrayedOutReasons(), rootModel, table);
    }
    return item;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected TreeItem createLeafNode(ListModel leafModel) {
    if (hideLeaf) {
        return null;
    }
    EntityModelCellTable<ListModel> table = new EntityModelCellTable<>(false, (Resources) GWT.create(SanStorageListTargetTableResources.class), true);
    table.addColumn(new TextColumn<SanTargetModel>() {

        @Override
        public String getValue(SanTargetModel model) {
            return model.getName();
        }
    }, constants.targetNameSanStorage());
    table.addColumn(new TextColumn<SanTargetModel>() {

        @Override
        public String getValue(SanTargetModel model) {
            return model.getAddress();
        }
    }, constants.addressSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new TextColumn<SanTargetModel>() {

        @Override
        public String getValue(SanTargetModel model) {
            return model.getPort();
        }
    }, constants.portSanStorage(), // $NON-NLS-1$
    "80px");
    List<SanTargetModel> items = (List<SanTargetModel>) leafModel.getItems();
    if (items.isEmpty()) {
        return null;
    }
    table.setRowData(items);
    Object selectedItem = leafModel.getSelectedItem();
    leafModel.setSelectedItem(null);
    table.asEditor().edit(leafModel);
    leafModel.setSelectedItem(selectedItem);
    table.setWidth(100 + Style.Unit.PCT.getType());
    ScrollPanel panel = new ScrollPanel();
    panel.add(table);
    TreeItem item = new TreeItem(panel);
    return item;
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected TreeItem createLeafNode(ListModel leafModel) {
    if (hideLeaf) {
        return null;
    }
    EntityModelCellTable<ListModel> table = new EntityModelCellTable<>(false, (Resources) GWT.create(SanStorageListTargetTableResources.class), true);
    table.addColumn(new TextColumn<SanTargetModel>() {

        @Override
        public String getValue(SanTargetModel model) {
            return model.getName();
        }
    }, constants.targetNameSanStorage());
    table.addColumn(new TextColumn<SanTargetModel>() {

        @Override
        public String getValue(SanTargetModel model) {
            return model.getAddress();
        }
    }, constants.addressSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new TextColumn<SanTargetModel>() {

        @Override
        public String getValue(SanTargetModel model) {
            return model.getPort();
        }
    }, constants.portSanStorage(), // $NON-NLS-1$
    "80px");
    List<SanTargetModel> items = (List<SanTargetModel>) leafModel.getItems();
    if (items.isEmpty()) {
        return null;
    }
    table.setRowData(items);
    Object selectedItem = leafModel.getSelectedItem();
    leafModel.setSelectedItem(null);
    table.asEditor().edit(leafModel);
    leafModel.setSelectedItem(selectedItem);
    // $NON-NLS-1$
    table.setWidth("100%");
    ScrollPanel panel = new ScrollPanel();
    panel.add(table);
    TreeItem item = new TreeItem(panel);
    return item;
}
#end_block

#method_before
@Override
protected void initHeader() {
    table.addColumn(new EmptyColumn(), constants.aliasTemplate());
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.disksTemplate(), "110px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.provisionedSizeTemplate(), "110px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.actualSizeTemplate(), "110px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.creationDateTemplate(), "170px");
    table.setHeight(30 + Unit.PX.getType());
}
#method_after
@Override
protected void initHeader() {
    table.addColumn(new EmptyColumn(), constants.aliasTemplate());
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.disksTemplate(), "110px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.provisionedSizeTemplate(), "110px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.actualSizeTemplate(), "110px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.creationDateTemplate(), "170px");
    // $NON-NLS-1$
    table.setHeight("30px");
}
#end_block

#method_before
private void initTable(ImportExportRepoImageBaseModel model) {
    imageList = new EntityModelCellTable<>(SelectionMode.NONE, true);
    imageList.enableColumnResizing();
    imageList.addColumn(new AbstractEntityModelTextColumn<Object>() {

        @Override
        public String getText(Object image) {
            if (image instanceof RepoImage) {
                return ((RepoImage) image).getRepoImageTitle();
            } else if (image instanceof DiskImage) {
                return ((DiskImage) image).getDiskAlias();
            }
            return constants.unknown();
        }
    }, constants.fileNameIso(), // $NON-NLS-1$
    "100%");
    if (model.isImportModel()) {
        imageList.addColumn(new DiskAliasTextColumn(new DiskAliasFieldUpdater()), templates.sub(constants.diskSnapshotAlias(), constants.clickToEdit()), // $NON-NLS-1$
        "150px");
    }
    imageList.addColumn(new AbstractEntityModelTextColumn<Object>() {

        @Override
        public String getText(Object image) {
            if (image instanceof RepoImage) {
                return ((RepoImage) image).getFileType().toString();
            } else if (image instanceof DiskImage) {
                return ImageFileType.Disk.toString();
            }
            return constants.unknown();
        }
    }, constants.typeIso(), // $NON-NLS-1$
    "75px");
    imageList.addColumn(new AbstractDiskSizeColumn<EntityModel>(SizeConverter.SizeUnit.BYTES) {

        @Override
        protected Long getRawValue(EntityModel object) {
            if (object.getEntity() instanceof RepoImage) {
                return ((RepoImage) object.getEntity()).getSize();
            } else if (object.getEntity() instanceof DiskImage) {
                return ((DiskImage) object.getEntity()).getSize();
            }
            return null;
        }
    }, constants.actualSizeTemplate(), // $NON-NLS-1$
    "75px");
    imageList.setWidth(100 + Style.Unit.PCT.getType());
    imageListPanel.setWidget(imageList);
}
#method_after
private void initTable(ImportExportRepoImageBaseModel model) {
    imageList = new EntityModelCellTable<>(SelectionMode.NONE, true);
    imageList.enableColumnResizing();
    imageList.addColumn(new AbstractEntityModelTextColumn<Object>() {

        @Override
        public String getText(Object image) {
            if (image instanceof RepoImage) {
                return ((RepoImage) image).getRepoImageTitle();
            } else if (image instanceof DiskImage) {
                return ((DiskImage) image).getDiskAlias();
            }
            return constants.unknown();
        }
    }, constants.fileNameIso(), // $NON-NLS-1$
    "100%");
    if (model.isImportModel()) {
        imageList.addColumn(new DiskAliasTextColumn(new DiskAliasFieldUpdater()), templates.sub(constants.diskSnapshotAlias(), constants.clickToEdit()), // $NON-NLS-1$
        "150px");
    }
    imageList.addColumn(new AbstractEntityModelTextColumn<Object>() {

        @Override
        public String getText(Object image) {
            if (image instanceof RepoImage) {
                return ((RepoImage) image).getFileType().toString();
            } else if (image instanceof DiskImage) {
                return ImageFileType.Disk.toString();
            }
            return constants.unknown();
        }
    }, constants.typeIso(), // $NON-NLS-1$
    "75px");
    imageList.addColumn(new AbstractDiskSizeColumn<EntityModel>(SizeConverter.SizeUnit.BYTES) {

        @Override
        protected Long getRawValue(EntityModel object) {
            if (object.getEntity() instanceof RepoImage) {
                return ((RepoImage) object.getEntity()).getSize();
            } else if (object.getEntity() instanceof DiskImage) {
                return ((DiskImage) object.getEntity()).getSize();
            }
            return null;
        }
    }, constants.actualSizeTemplate(), // $NON-NLS-1$
    "75px");
    // $NON-NLS-1$
    imageList.setWidth("100%");
    imageListPanel.setWidget(imageList);
}
#end_block

#method_before
@Override
protected TreeItem getRootItem(StorageDomainModel storageDomainModel) {
    HorizontalPanel panel = new HorizontalPanel();
    panel.setSpacing(1);
    panel.setWidth(100 + Style.Unit.PCT.getType());
    StorageDomain storage = storageDomainModel.getStorageDomain();
    // $NON-NLS-1$
    addItemToPanel(panel, new Image(resources.storageImage()), "25px");
    // $NON-NLS-1$
    addTextBoxToPanel(panel, new StringValueLabel(), storage.getStorageName(), "");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<StorageDomainType>(), storage.getStorageDomainType(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<StorageDomainSharedStatus>(), storage.getStorageDomainSharedStatus(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DiskSizeLabel<Integer>(), storage.getAvailableDiskSize(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DiskSizeLabel<Integer>(), storage.getUsedDiskSize(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DiskSizeLabel<Integer>(), storage.getTotalDiskSize(), "90px");
    TreeItem treeItem = new TreeItem(panel);
    treeItem.setUserObject(storage.getId());
    return treeItem;
}
#method_after
@Override
protected TreeItem getRootItem(StorageDomainModel storageDomainModel) {
    HorizontalPanel panel = new HorizontalPanel();
    panel.setSpacing(1);
    // $NON-NLS-1$
    panel.setWidth("100%");
    StorageDomain storage = storageDomainModel.getStorageDomain();
    // $NON-NLS-1$
    addItemToPanel(panel, new Image(resources.storageImage()), "25px");
    // $NON-NLS-1$
    addTextBoxToPanel(panel, new StringValueLabel(), storage.getStorageName(), "");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<StorageDomainType>(), storage.getStorageDomainType(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<StorageDomainSharedStatus>(), storage.getStorageDomainSharedStatus(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DiskSizeLabel<Integer>(), storage.getAvailableDiskSize(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DiskSizeLabel<Integer>(), storage.getUsedDiskSize(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DiskSizeLabel<Integer>(), storage.getTotalDiskSize(), "90px");
    TreeItem treeItem = new TreeItem(panel);
    treeItem.setUserObject(storage.getId());
    return treeItem;
}
#end_block

#method_before
@Override
protected TreeItem getNodeItem(DiskModel diskModel) {
    HorizontalPanel panel = new HorizontalPanel();
    panel.setSpacing(1);
    panel.setWidth(100 + Style.Unit.PCT.getType());
    DiskImage disk = (DiskImage) diskModel.getDisk();
    // $NON-NLS-1$
    addItemToPanel(panel, new Image(resources.diskImage()), "30px");
    // $NON-NLS-1$
    addTextBoxToPanel(panel, new StringValueLabel(), disk.getDiskAlias(), "");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DiskSizeLabel<Long>(), disk.getSizeInGigabytes(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<ImageStatus>(), disk.getImageStatus(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<VolumeType>(), disk.getVolumeType(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<DiskInterface>(), disk.getDiskVmElements().iterator().next().getDiskInterface(), "110px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<DiskStorageType>(), disk.getDiskStorageType(), "110px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DateLabel(), disk.getCreationDate(), "100px");
    TreeItem treeItem = new TreeItem(panel);
    treeItem.setUserObject(getEntityId(diskModel));
    return treeItem;
}
#method_after
@Override
protected TreeItem getNodeItem(DiskModel diskModel) {
    HorizontalPanel panel = new HorizontalPanel();
    panel.setSpacing(1);
    // $NON-NLS-1$
    panel.setWidth("100%");
    DiskImage disk = (DiskImage) diskModel.getDisk();
    // $NON-NLS-1$
    addItemToPanel(panel, new Image(resources.diskImage()), "30px");
    // $NON-NLS-1$
    addTextBoxToPanel(panel, new StringValueLabel(), disk.getDiskAlias(), "");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DiskSizeLabel<Long>(), disk.getSizeInGigabytes(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<ImageStatus>(), disk.getImageStatus(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<VolumeType>(), disk.getVolumeType(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<DiskInterface>(), disk.getDiskVmElements().iterator().next().getDiskInterface(), "110px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<DiskStorageType>(), disk.getDiskStorageType(), "110px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DateLabel(), disk.getCreationDate(), "100px");
    TreeItem treeItem = new TreeItem(panel);
    treeItem.setUserObject(getEntityId(diskModel));
    return treeItem;
}
#end_block

#method_before
@Override
protected TreeItem getNodeHeader() {
    EntityModelCellTable<ListModel> table = new EntityModelCellTable<>(false, true);
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.empty(), "30px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.aliasDisk(), "");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.sizeStorageTree(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.statusStorageTree(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.allocationStorageTree(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.interfaceStorageTree(), "110px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.typeDisk(), "110px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.creationDateStorageTree(), "100px");
    table.setRowData(new ArrayList());
    table.setWidth(100 + Style.Unit.PCT.getType());
    table.setHeight(30 + Style.Unit.PX.getType());
    TreeItem item = new TreeItem(table);
    item.setUserObject(NODE_HEADER);
    item.getElement().getStyle().setPadding(0, Unit.PX);
    return item;
}
#method_after
@Override
protected TreeItem getNodeHeader() {
    EntityModelCellTable<ListModel> table = new EntityModelCellTable<>(false, true);
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.empty(), "30px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.aliasDisk(), "");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.sizeStorageTree(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.statusStorageTree(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.allocationStorageTree(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.interfaceStorageTree(), "110px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.typeDisk(), "110px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.creationDateStorageTree(), "100px");
    table.setRowData(new ArrayList());
    // $NON-NLS-1$
    table.setWidth("100%");
    // $NON-NLS-1$
    table.setHeight("30px");
    TreeItem item = new TreeItem(table);
    item.setUserObject(NODE_HEADER);
    item.getElement().getStyle().setPadding(0, Unit.PX);
    return item;
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    OvirtSelectionModel<?> tableSelectionModel = getTable() != null ? getTable().getSelectionModel() : null;
    if (tableSelectionModel != null) {
        registerHandler(tableSelectionModel.addSelectionChangeHandler(event -> {
            // Update detail model selection
            updateDetailModelSelection();
        }));
    }
    OvirtSelectionModel<T> mainModelSelectionModel = modelProvider.getMainModel().getSelectionModel();
    if (mainModelSelectionModel != null) {
        registerHandler(mainModelSelectionModel.addSelectionChangeHandler(event -> {
            itemChanged(getSelectedMainItems().getSelectedItem());
        }));
    }
    initializeHandlers();
    getSelectedMainItems().registerListener(this);
    itemChanged(getSelectedMainItems().getSelectedItem());
    setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    OvirtSelectionModel<?> tableSelectionModel = getTable() != null ? getTable().getSelectionModel() : null;
    if (tableSelectionModel != null) {
        registerHandler(tableSelectionModel.addSelectionChangeHandler(event -> {
            // Update detail model selection
            updateDetailModelSelection();
        }));
    }
    OvirtSelectionModel<T> mainModelSelectionModel = modelProvider.getMainModel().getSelectionModel();
    if (mainModelSelectionModel != null) {
        registerHandler(mainModelSelectionModel.addSelectionChangeHandler(event -> {
            itemChanged(getSelectedMainItems().getSelectedItem());
        }));
    }
    initializeHandlers();
    registerHandler(getView().addWindowResizeHandler(e -> {
        Scheduler.get().scheduleDeferred(() -> getView().resizeToFullHeight());
    }));
    getSelectedMainItems().registerListener(this);
    itemChanged(getSelectedMainItems().getSelectedItem());
    setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
}
#end_block

#method_before
@Override
public void itemChanged(T item) {
    boolean widgetVisible = getView().asWidget().isVisible();
    if (item != null && widgetVisible) {
        getView().setMainSelectedItem(item);
    } else if (item == null && widgetVisible && modelProvider.getMainModel().getItems().isEmpty()) {
        // No selection so we can't positively show anything, switch to grid.
        placeManager.revealPlace(getMainContentRequest());
    }
}
#method_after
@Override
public void itemChanged(T item) {
    boolean widgetVisible = getView().asWidget().isVisible();
    if (item != null && widgetVisible) {
        getView().setMainSelectedItem(item);
    } else if (item == null && widgetVisible && (modelProvider.getMainModel().getItems() == null || modelProvider.getMainModel().getItems().isEmpty())) {
        // No selection so we can't positively show anything, switch to grid.
        placeManager.revealPlace(getMainContentRequest());
    }
}
#end_block

#method_before
private void resizeGridToFullHeight() {
    int top = getAbsoluteTop();
    int windowHeight = Window.getClientHeight();
    int contentHeight = this.getTableBodyElement().getOffsetHeight();
    if (contentHeight == 0) {
        contentHeight = NO_ITEMS_HEIGHT;
    } else {
        contentHeight += getGridHeaderHeight();
    }
    if (isHorizontalScrollbarVisible()) {
        contentHeight += scrollbarThickness;
    }
    contentHeight += 3;
    int maxGridHeight = windowHeight - top;
    maxGridHeight -= GRID_SUBTRACT;
    if (top > 0 && top < windowHeight) {
        super.setHeight(Math.min(maxGridHeight, contentHeight) + Unit.PX.getType());
    }
    redraw();
}
#method_after
private void resizeGridToFullHeight() {
    int top = getAbsoluteTop();
    int windowHeight = Window.getClientHeight();
    int contentHeight = this.getTableBodyElement().getOffsetHeight();
    if (contentHeight == 0) {
        contentHeight = NO_ITEMS_HEIGHT;
    } else {
        contentHeight += getGridHeaderHeight();
    }
    if (isHorizontalScrollbarVisible()) {
        contentHeight += scrollbarThickness;
    }
    // This is to prevent scrolling in the grid without a visible scrollbar. The 3 works in FF and leaves a 1px
    // gap in chrome. 2 is fine in Chrome but leaves the scrolling in FF.
    contentHeight += 3;
    int maxGridHeight = windowHeight - top;
    maxGridHeight -= GRID_SUBTRACT;
    if (top > 0 && top < windowHeight) {
        super.setHeight(Math.min(maxGridHeight, contentHeight) + Unit.PX.getType());
    }
    redraw();
}
#end_block

#method_before
private void initDiskImagesTable() {
    imageDiskTable.enableColumnResizing();
    AbstractTextColumn<EntityModel> aliasColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(aliasColumn, constants.aliasVmDiskTable(), "85px");
    AbstractTextColumn<EntityModel> descriptionColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(descriptionColumn, constants.descriptionVmDiskTable(), "85px");
    AbstractTextColumn<EntityModel> idColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getId().toString();
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(idColumn, constants.idVmDiskTable(), "85px");
    AbstractDiskSizeColumn<EntityModel> sizeColumn = new AbstractDiskSizeColumn<EntityModel>() {

        @Override
        protected Long getRawValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getSize();
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(sizeColumn, constants.provisionedSizeVmDiskTable(), "100px");
    AbstractDiskSizeColumn<EntityModel> actualSizeColumn = new AbstractDiskSizeColumn<EntityModel>() {

        @Override
        protected Long getRawValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getActualSizeInBytes();
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(actualSizeColumn, constants.sizeVmDiskTable(), "100px");
    AbstractTextColumn<EntityModel> storageDomainColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getStoragesNames().get(0);
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(storageDomainColumn, constants.storageDomainVmDiskTable(), "100px");
    // $NON-NLS-1$
    imageDiskTable.addColumn(getDiskInterfaceSelectionColumn(), constants.interfaceVmDiskPopup(), "115px");
    imageDiskTable.addColumn(getReadOnlyCheckBoxColumn(), new ImageResourceHeader(resources.readOnlyDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.readOnly())), // $NON-NLS-1$
    "30px");
    imageDiskTable.addColumn(getBootCheckBoxColumn(), new ImageResourceHeader(resources.bootableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.bootableDisk())), // $NON-NLS-1$
    "30px");
    imageDiskTable.addColumn(new AbstractImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.isShareable() ? resources.shareableDiskIcon() : null;
        }

        @Override
        public SafeHtml getTooltip(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            if (disk.isShareable()) {
                return SafeHtmlUtils.fromSafeConstant(constants.shareable());
            }
            return null;
        }
    }, new ImageResourceHeader(resources.shareableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.shareable())), // $NON-NLS-1$
    "30px");
    imageDiskTable.setWidth(100 + Style.Unit.PCT.getType());
    imageDiskTable.setHeight(100 + Style.Unit.PCT.getType());
}
#method_after
private void initDiskImagesTable() {
    imageDiskTable.enableColumnResizing();
    AbstractTextColumn<EntityModel> aliasColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(aliasColumn, constants.aliasVmDiskTable(), "85px");
    AbstractTextColumn<EntityModel> descriptionColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(descriptionColumn, constants.descriptionVmDiskTable(), "85px");
    AbstractTextColumn<EntityModel> idColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getId().toString();
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(idColumn, constants.idVmDiskTable(), "85px");
    AbstractDiskSizeColumn<EntityModel> sizeColumn = new AbstractDiskSizeColumn<EntityModel>() {

        @Override
        protected Long getRawValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getSize();
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(sizeColumn, constants.provisionedSizeVmDiskTable(), "100px");
    AbstractDiskSizeColumn<EntityModel> actualSizeColumn = new AbstractDiskSizeColumn<EntityModel>() {

        @Override
        protected Long getRawValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getActualSizeInBytes();
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(actualSizeColumn, constants.sizeVmDiskTable(), "100px");
    AbstractTextColumn<EntityModel> storageDomainColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getStoragesNames().get(0);
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(storageDomainColumn, constants.storageDomainVmDiskTable(), "100px");
    // $NON-NLS-1$
    imageDiskTable.addColumn(getDiskInterfaceSelectionColumn(), constants.interfaceVmDiskPopup(), "115px");
    imageDiskTable.addColumn(getReadOnlyCheckBoxColumn(), new ImageResourceHeader(resources.readOnlyDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.readOnly())), // $NON-NLS-1$
    "30px");
    imageDiskTable.addColumn(getBootCheckBoxColumn(), new ImageResourceHeader(resources.bootableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.bootableDisk())), // $NON-NLS-1$
    "30px");
    imageDiskTable.addColumn(new AbstractImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.isShareable() ? resources.shareableDiskIcon() : null;
        }

        @Override
        public SafeHtml getTooltip(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            if (disk.isShareable()) {
                return SafeHtmlUtils.fromSafeConstant(constants.shareable());
            }
            return null;
        }
    }, new ImageResourceHeader(resources.shareableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.shareable())), // $NON-NLS-1$
    "30px");
    // $NON-NLS-1$
    imageDiskTable.setWidth("100%");
    // $NON-NLS-1$
    imageDiskTable.setHeight("100%");
}
#end_block

#method_before
private void initLunDisksTable() {
    lunDiskTable.enableColumnResizing();
    AbstractTextColumn<EntityModel> aliasColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(aliasColumn, constants.aliasVmDiskTable(), "60px");
    AbstractTextColumn<EntityModel> descriptionColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(descriptionColumn, constants.descriptionVmDiskTable(), "85px");
    AbstractTextColumn<EntityModel> lunIdColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getLun().getLUNId();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(lunIdColumn, constants.lunIdSanStorage(), "60px");
    AbstractTextColumn<EntityModel> idColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getId().toString();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(idColumn, constants.idVmDiskTable(), "60px");
    AbstractDiskSizeColumn<EntityModel> sizeColumn = new AbstractDiskSizeColumn<EntityModel>(SizeConverter.SizeUnit.GiB) {

        @Override
        protected Long getRawValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return (long) disk.getLun().getDeviceSize();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(sizeColumn, constants.devSizeSanStorage(), "70px");
    AbstractTextColumn<EntityModel> pathColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return String.valueOf(disk.getLun().getPathCount());
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(pathColumn, constants.pathSanStorage(), "40px");
    AbstractTextColumn<EntityModel> vendorIdColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getLun().getVendorId();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "70px");
    AbstractTextColumn<EntityModel> productIdColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getLun().getProductId();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(productIdColumn, constants.productIdSanStorage(), "70px");
    AbstractTextColumn<EntityModel> serialColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getLun().getSerial();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(serialColumn, constants.serialSanStorage(), "70px");
    // $NON-NLS-1$
    lunDiskTable.addColumn(getDiskInterfaceSelectionColumn(), constants.interfaceVmDiskPopup(), "115px");
    lunDiskTable.addColumn(getReadOnlyCheckBoxColumn(), new ImageResourceHeader(resources.readOnlyDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.readOnly())), // $NON-NLS-1$
    "30px");
    lunDiskTable.addColumn(getBootCheckBoxColumn(), new ImageResourceHeader(resources.bootableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.bootableDisk())), // $NON-NLS-1$
    "30px");
    lunDiskTable.addColumn(new AbstractImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.isShareable() ? resources.shareableDiskIcon() : null;
        }

        @Override
        public SafeHtml getTooltip(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            if (disk.isShareable()) {
                return SafeHtmlUtils.fromSafeConstant(constants.shareable());
            }
            return null;
        }
    }, new ImageResourceHeader(resources.shareableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.shareable())), // $NON-NLS-1$
    "30px");
    lunDiskTable.setWidth(100 + Style.Unit.PCT.getType());
    lunDiskTable.setHeight(100 + Style.Unit.PCT.getType());
}
#method_after
private void initLunDisksTable() {
    lunDiskTable.enableColumnResizing();
    AbstractTextColumn<EntityModel> aliasColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(aliasColumn, constants.aliasVmDiskTable(), "60px");
    AbstractTextColumn<EntityModel> descriptionColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(descriptionColumn, constants.descriptionVmDiskTable(), "85px");
    AbstractTextColumn<EntityModel> lunIdColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getLun().getLUNId();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(lunIdColumn, constants.lunIdSanStorage(), "60px");
    AbstractTextColumn<EntityModel> idColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getId().toString();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(idColumn, constants.idVmDiskTable(), "60px");
    AbstractDiskSizeColumn<EntityModel> sizeColumn = new AbstractDiskSizeColumn<EntityModel>(SizeConverter.SizeUnit.GiB) {

        @Override
        protected Long getRawValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return (long) disk.getLun().getDeviceSize();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(sizeColumn, constants.devSizeSanStorage(), "70px");
    AbstractTextColumn<EntityModel> pathColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return String.valueOf(disk.getLun().getPathCount());
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(pathColumn, constants.pathSanStorage(), "40px");
    AbstractTextColumn<EntityModel> vendorIdColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getLun().getVendorId();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "70px");
    AbstractTextColumn<EntityModel> productIdColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getLun().getProductId();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(productIdColumn, constants.productIdSanStorage(), "70px");
    AbstractTextColumn<EntityModel> serialColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getLun().getSerial();
        }
    };
    // $NON-NLS-1$
    lunDiskTable.addColumn(serialColumn, constants.serialSanStorage(), "70px");
    // $NON-NLS-1$
    lunDiskTable.addColumn(getDiskInterfaceSelectionColumn(), constants.interfaceVmDiskPopup(), "115px");
    lunDiskTable.addColumn(getReadOnlyCheckBoxColumn(), new ImageResourceHeader(resources.readOnlyDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.readOnly())), // $NON-NLS-1$
    "30px");
    lunDiskTable.addColumn(getBootCheckBoxColumn(), new ImageResourceHeader(resources.bootableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.bootableDisk())), // $NON-NLS-1$
    "30px");
    lunDiskTable.addColumn(new AbstractImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.isShareable() ? resources.shareableDiskIcon() : null;
        }

        @Override
        public SafeHtml getTooltip(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            if (disk.isShareable()) {
                return SafeHtmlUtils.fromSafeConstant(constants.shareable());
            }
            return null;
        }
    }, new ImageResourceHeader(resources.shareableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.shareable())), // $NON-NLS-1$
    "30px");
    // $NON-NLS-1$
    lunDiskTable.setWidth("100%");
    // $NON-NLS-1$
    lunDiskTable.setHeight("100%");
}
#end_block

#method_before
private void initCinderDisksTable() {
    cinderDiskTable.enableColumnResizing();
    AbstractTextColumn<EntityModel> aliasColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            CinderDisk disk = (CinderDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(aliasColumn, constants.aliasVmDiskTable(), "100px");
    AbstractTextColumn<EntityModel> descriptionColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            CinderDisk disk = (CinderDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(descriptionColumn, constants.descriptionVmDiskTable(), "100px");
    AbstractDiskSizeColumn<EntityModel> sizeColumn = new AbstractDiskSizeColumn<EntityModel>(SizeConverter.SizeUnit.GiB) {

        @Override
        protected Long getRawValue(EntityModel object) {
            CinderDisk disk = (CinderDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getSizeInGigabytes();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(sizeColumn, constants.provisionedSizeVmDiskTable(), "100px");
    // $NON-NLS-1$
    cinderDiskTable.addColumn(getDiskInterfaceSelectionColumn(), constants.interfaceVmDiskPopup(), "115px");
    AbstractTextColumn<EntityModel> cinderVolumeTypeColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.getCinderVolumeType();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(cinderVolumeTypeColumn, constants.cinderVolumeTypeDisk(), "90px");
    cinderDiskTable.addColumn(getReadOnlyCheckBoxColumn(), new ImageResourceHeader(resources.readOnlyDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.readOnly())), // $NON-NLS-1$
    "30px");
    cinderDiskTable.addColumn(getBootCheckBoxColumn(), new ImageResourceHeader(resources.bootableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.bootableDisk())), // $NON-NLS-1$
    "30px");
    cinderDiskTable.addColumn(new AbstractImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.isShareable() ? resources.shareableDiskIcon() : null;
        }

        @Override
        public SafeHtml getTooltip(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            if (disk.isShareable()) {
                return SafeHtmlUtils.fromSafeConstant(constants.shareable());
            }
            return null;
        }
    }, new ImageResourceHeader(resources.shareableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.shareable())), // $NON-NLS-1$
    "30px");
    cinderDiskTable.setWidth(100 + Style.Unit.PCT.getType());
    cinderDiskTable.setHeight(100 + Style.Unit.PCT.getType());
}
#method_after
private void initCinderDisksTable() {
    cinderDiskTable.enableColumnResizing();
    AbstractTextColumn<EntityModel> aliasColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            CinderDisk disk = (CinderDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(aliasColumn, constants.aliasVmDiskTable(), "100px");
    AbstractTextColumn<EntityModel> descriptionColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            CinderDisk disk = (CinderDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(descriptionColumn, constants.descriptionVmDiskTable(), "100px");
    AbstractDiskSizeColumn<EntityModel> sizeColumn = new AbstractDiskSizeColumn<EntityModel>(SizeConverter.SizeUnit.GiB) {

        @Override
        protected Long getRawValue(EntityModel object) {
            CinderDisk disk = (CinderDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getSizeInGigabytes();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(sizeColumn, constants.provisionedSizeVmDiskTable(), "100px");
    // $NON-NLS-1$
    cinderDiskTable.addColumn(getDiskInterfaceSelectionColumn(), constants.interfaceVmDiskPopup(), "115px");
    AbstractTextColumn<EntityModel> cinderVolumeTypeColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.getCinderVolumeType();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(cinderVolumeTypeColumn, constants.cinderVolumeTypeDisk(), "90px");
    cinderDiskTable.addColumn(getReadOnlyCheckBoxColumn(), new ImageResourceHeader(resources.readOnlyDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.readOnly())), // $NON-NLS-1$
    "30px");
    cinderDiskTable.addColumn(getBootCheckBoxColumn(), new ImageResourceHeader(resources.bootableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.bootableDisk())), // $NON-NLS-1$
    "30px");
    cinderDiskTable.addColumn(new AbstractImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.isShareable() ? resources.shareableDiskIcon() : null;
        }

        @Override
        public SafeHtml getTooltip(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            if (disk.isShareable()) {
                return SafeHtmlUtils.fromSafeConstant(constants.shareable());
            }
            return null;
        }
    }, new ImageResourceHeader(resources.shareableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.shareable())), // $NON-NLS-1$
    "30px");
    // $NON-NLS-1$
    cinderDiskTable.setWidth("100%");
    // $NON-NLS-1$
    cinderDiskTable.setHeight("100%");
}
#end_block

#method_before
void addModelSearchStringChangeListener(final SearchableListModel<?, ?> model) {
    if (model.supportsServerSideSorting()) {
        model.getPropertyChangedEvent().addListener((ev, sender, args) -> {
            if ("SearchString".equals(args.propertyName)) {
                // $NON-NLS-1$
                if (!model.isSearchValidForServerSideSorting()) {
                    model.clearSortOptions();
                    clearColumnSort();
                }
            }
        });
    }
}
#method_after
void addModelSearchStringChangeListener(final SearchableListModel<?, ?> model) {
    if (model.supportsServerSideSorting()) {
        model.getPropertyChangedEvent().addListener((ev, sender, args) -> {
            if ("SearchString".equals(args.propertyName)) {
                // $NON-NLS-1$
                if (!model.isSearchValidForServerSideSorting()) {
                    model.clearSortOptions();
                    table.clearColumnSort();
                }
            }
        });
    }
}
#end_block

#method_before
public void enableColumnResizing() {
    // Column resizing is supported only when the tableHeader widget is visible
    if (isTableHeaderVisible()) {
        table.enableColumnResizing();
    }
}
#method_after
public void enableColumnResizing() {
    table.enableColumnResizing();
}
#end_block

#method_before
private void resizeToFullHeight() {
    scrollPanel.setHeight(calculateTotalAvailableSpace() + Unit.PX.getType());
}
#method_after
@Override
public void resizeToFullHeight() {
    scrollPanel.setHeight(calculateTotalAvailableSpace() + Unit.PX.getType());
}
#end_block

#method_before
private void initTable() {
    table = new EntityModelCellTable<>(true, false, true);
    table.setWidth(100 + Style.Unit.PCT.getType());
    AbstractTextColumn<MoveHostData> nameColumn = new AbstractTextColumn<MoveHostData>() {

        @Override
        public String getValue(MoveHostData object) {
            return object.getEntity().getName();
        }
    };
    table.addColumn(nameColumn, constants.nameHost());
    AbstractTextColumn<MoveHostData> hostColumn = new AbstractTextColumn<MoveHostData>() {

        @Override
        public String getValue(MoveHostData object) {
            return object.getEntity().getHostName();
        }
    };
    table.addColumn(hostColumn, constants.ipHost());
    AbstractTextColumn<EntityModel<VDS>> statusColumn = new AbstractEnumColumn<EntityModel<VDS>, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(EntityModel<VDS> object) {
            return object.getEntity().getStatus();
        }
    };
    // $NON-NLS-1$
    table.addColumn(statusColumn, constants.statusHost(), "90px");
    final Column<MoveHostData, Boolean> activateColumn = new Column<MoveHostData, Boolean>(new ActivateCheckboxCell()) {

        @Override
        public Boolean getValue(MoveHostData object) {
            return object.getActivateHost();
        }
    };
    activateColumn.setFieldUpdater((idx, object, value) -> object.setActivateHost(value));
    // $NON-NLS-1$
    table.addColumn(activateColumn, constants.activateHost(), "60px");
}
#method_after
private void initTable() {
    table = new EntityModelCellTable<>(true, false, true);
    // $NON-NLS-1$
    table.setWidth("100%");
    AbstractTextColumn<MoveHostData> nameColumn = new AbstractTextColumn<MoveHostData>() {

        @Override
        public String getValue(MoveHostData object) {
            return object.getEntity().getName();
        }
    };
    table.addColumn(nameColumn, constants.nameHost());
    AbstractTextColumn<MoveHostData> hostColumn = new AbstractTextColumn<MoveHostData>() {

        @Override
        public String getValue(MoveHostData object) {
            return object.getEntity().getHostName();
        }
    };
    table.addColumn(hostColumn, constants.ipHost());
    AbstractTextColumn<EntityModel<VDS>> statusColumn = new AbstractEnumColumn<EntityModel<VDS>, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(EntityModel<VDS> object) {
            return object.getEntity().getStatus();
        }
    };
    // $NON-NLS-1$
    table.addColumn(statusColumn, constants.statusHost(), "90px");
    final Column<MoveHostData, Boolean> activateColumn = new Column<MoveHostData, Boolean>(new ActivateCheckboxCell()) {

        @Override
        public Boolean getValue(MoveHostData object) {
            return object.getActivateHost();
        }
    };
    activateColumn.setFieldUpdater((idx, object, value) -> object.setActivateHost(value));
    // $NON-NLS-1$
    table.addColumn(activateColumn, constants.activateHost(), "60px");
}
#end_block

#method_before
private void initDisksTable() {
    disksTable = new EntityModelCellTable<>(false, true);
    disksTable.enableColumnResizing();
    // $NON-NLS-1$
    disksTable.addColumn(new DiskImageStatusColumn(), constants.empty(), "30px");
    AbstractTextColumn<DiskImage> aliasColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            return object.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(aliasColumn, constants.aliasDisk(), "70px");
    AbstractDiskSizeColumn<DiskImage> sizeColumn = new AbstractDiskSizeColumn<DiskImage>() {

        @Override
        protected Long getRawValue(DiskImage object) {
            return object.getSize();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(sizeColumn, constants.provisionedSizeDisk(), "70px");
    AbstractDiskSizeColumn<DiskImage> actualSizeColumn = new AbstractDiskSizeColumn<DiskImage>() {

        @Override
        protected Long getRawValue(DiskImage object) {
            return object.getActualSizeInBytes();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(actualSizeColumn, constants.sizeDisk(), "70px");
    AbstractTextColumn<DiskImage> allocationColumn = new AbstractEnumColumn<DiskImage, VolumeType>() {

        @Override
        protected VolumeType getRawValue(DiskImage object) {
            return VolumeType.forValue(object.getVolumeType().getValue());
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(allocationColumn, constants.allocationDisk(), "110px");
    AbstractTextColumn<DiskImage> interfaceColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            if (object.getDiskVmElements().size() == 1) {
                return object.getDiskVmElements().iterator().next().getDiskInterface().toString();
            }
            return null;
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(interfaceColumn, constants.interfaceDisk(), "95px");
    AbstractTextColumn<DiskImage> statusColumn = new AbstractEnumColumn<DiskImage, ImageStatus>() {

        @Override
        protected ImageStatus getRawValue(DiskImage object) {
            return object.getImageStatus();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(statusColumn, constants.statusDisk(), "65px");
    AbstractTextColumn<DiskImage> dateCreatedColumn = new AbstractFullDateTimeColumn<DiskImage>() {

        @Override
        protected Date getRawValue(DiskImage object) {
            return object.getCreationDate();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(dateCreatedColumn, constants.creationDateDisk(), "80px");
    AbstractTextColumn<DiskImage> diskSnapshotIDColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage diskImage) {
            return diskImage.getImageId().toString();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(diskSnapshotIDColumn, constants.diskSnapshotIDDisk(), "260px");
    AbstractTextColumn<Disk> diskStorageTypeColumn = new AbstractEnumColumn<Disk, DiskStorageType>() {

        @Override
        protected DiskStorageType getRawValue(Disk object) {
            return object.getDiskStorageType();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(diskStorageTypeColumn, constants.typeDisk(), "80px");
    AbstractTextColumn<DiskImage> descriptionColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            return object.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(descriptionColumn, constants.descriptionDisk(), "80px");
    disksTable.setRowData(new ArrayList<EntityModel>());
    disksTable.setWidth(100 + Style.Unit.PCT.getType());
    disksTable.setSelectionModel(new NoSelectionModel());
}
#method_after
private void initDisksTable() {
    disksTable = new EntityModelCellTable<>(false, true);
    disksTable.enableColumnResizing();
    // $NON-NLS-1$
    disksTable.addColumn(new DiskImageStatusColumn(), constants.empty(), "30px");
    AbstractTextColumn<DiskImage> aliasColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            return object.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(aliasColumn, constants.aliasDisk(), "70px");
    AbstractDiskSizeColumn<DiskImage> sizeColumn = new AbstractDiskSizeColumn<DiskImage>() {

        @Override
        protected Long getRawValue(DiskImage object) {
            return object.getSize();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(sizeColumn, constants.provisionedSizeDisk(), "70px");
    AbstractDiskSizeColumn<DiskImage> actualSizeColumn = new AbstractDiskSizeColumn<DiskImage>() {

        @Override
        protected Long getRawValue(DiskImage object) {
            return object.getActualSizeInBytes();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(actualSizeColumn, constants.sizeDisk(), "70px");
    AbstractTextColumn<DiskImage> allocationColumn = new AbstractEnumColumn<DiskImage, VolumeType>() {

        @Override
        protected VolumeType getRawValue(DiskImage object) {
            return VolumeType.forValue(object.getVolumeType().getValue());
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(allocationColumn, constants.allocationDisk(), "110px");
    AbstractTextColumn<DiskImage> interfaceColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            if (object.getDiskVmElements().size() == 1) {
                return object.getDiskVmElements().iterator().next().getDiskInterface().toString();
            }
            return null;
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(interfaceColumn, constants.interfaceDisk(), "95px");
    AbstractTextColumn<DiskImage> statusColumn = new AbstractEnumColumn<DiskImage, ImageStatus>() {

        @Override
        protected ImageStatus getRawValue(DiskImage object) {
            return object.getImageStatus();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(statusColumn, constants.statusDisk(), "65px");
    AbstractTextColumn<DiskImage> dateCreatedColumn = new AbstractFullDateTimeColumn<DiskImage>() {

        @Override
        protected Date getRawValue(DiskImage object) {
            return object.getCreationDate();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(dateCreatedColumn, constants.creationDateDisk(), "80px");
    AbstractTextColumn<DiskImage> diskSnapshotIDColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage diskImage) {
            return diskImage.getImageId().toString();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(diskSnapshotIDColumn, constants.diskSnapshotIDDisk(), "260px");
    AbstractTextColumn<Disk> diskStorageTypeColumn = new AbstractEnumColumn<Disk, DiskStorageType>() {

        @Override
        protected DiskStorageType getRawValue(Disk object) {
            return object.getDiskStorageType();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(diskStorageTypeColumn, constants.typeDisk(), "80px");
    AbstractTextColumn<DiskImage> descriptionColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            return object.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    disksTable.addColumn(descriptionColumn, constants.descriptionDisk(), "80px");
    disksTable.setRowData(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    disksTable.setWidth("100%");
    disksTable.setSelectionModel(new NoSelectionModel());
}
#end_block

#method_before
private void initNicsTable() {
    nicsTable = new EntityModelCellTable<>(false, true);
    nicsTable.enableColumnResizing();
    AbstractTextColumn<VmNetworkInterface> nameColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(nameColumn, constants.nameInterface(), "80px");
    AbstractTextColumn<VmNetworkInterface> networkNameColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getNetworkName();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(networkNameColumn, constants.networkNameInterface(), "80px");
    AbstractTextColumn<VmNetworkInterface> profileNameColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getVnicProfileName();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(profileNameColumn, constants.profileNameInterface(), "80px");
    AbstractTextColumn<VmNetworkInterface> typeColumn = new AbstractEnumColumn<VmNetworkInterface, VmInterfaceType>() {

        @Override
        protected VmInterfaceType getRawValue(VmNetworkInterface object) {
            return VmInterfaceType.forValue(object.getType());
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(typeColumn, constants.typeInterface(), "80px");
    AbstractTextColumn<VmNetworkInterface> macColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getMacAddress();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(macColumn, constants.macInterface(), "80px");
    AbstractTextColumn<VmNetworkInterface> speedColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().toString();
            } else {
                return null;
            }
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(speedColumn, templates.sub(constants.speedInterface(), constants.mbps()), "80px");
    AbstractTextColumn<VmNetworkInterface> rxColumn = new AbstractRxTxRateColumn<VmNetworkInterface>() {

        @Override
        protected Double getRate(VmNetworkInterface object) {
            return object.getStatistics().getReceiveRate();
        }

        @Override
        protected Double getSpeed(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().doubleValue();
            } else {
                return null;
            }
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(rxColumn, templates.sub(constants.rxRate(), constants.mbps()), "80px");
    AbstractTextColumn<VmNetworkInterface> txColumn = new AbstractRxTxRateColumn<VmNetworkInterface>() {

        @Override
        protected Double getRate(VmNetworkInterface object) {
            return object.getStatistics().getTransmitRate();
        }

        @Override
        protected Double getSpeed(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().doubleValue();
            } else {
                return null;
            }
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(txColumn, templates.sub(constants.txRate(), constants.mbps()), "80px");
    AbstractTextColumn<VmNetworkInterface> dropsColumn = new AbstractSumUpColumn<VmNetworkInterface>() {

        @Override
        protected Double[] getRawValue(VmNetworkInterface object) {
            Double receiveDropRate = object != null ? object.getStatistics().getReceiveDropRate() : null;
            Double transmitDropRate = object != null ? object.getStatistics().getTransmitDropRate() : null;
            return new Double[] { receiveDropRate, transmitDropRate };
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(dropsColumn, templates.sub(constants.dropsInterface(), constants.pkts()), "80px");
    nicsTable.setRowData(new ArrayList<EntityModel>());
    nicsTable.setWidth(100 + Style.Unit.PCT.getType());
    nicsTable.setSelectionModel(new NoSelectionModel());
}
#method_after
private void initNicsTable() {
    nicsTable = new EntityModelCellTable<>(false, true);
    nicsTable.enableColumnResizing();
    AbstractTextColumn<VmNetworkInterface> nameColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(nameColumn, constants.nameInterface(), "80px");
    AbstractTextColumn<VmNetworkInterface> networkNameColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getNetworkName();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(networkNameColumn, constants.networkNameInterface(), "80px");
    AbstractTextColumn<VmNetworkInterface> profileNameColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getVnicProfileName();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(profileNameColumn, constants.profileNameInterface(), "80px");
    AbstractTextColumn<VmNetworkInterface> typeColumn = new AbstractEnumColumn<VmNetworkInterface, VmInterfaceType>() {

        @Override
        protected VmInterfaceType getRawValue(VmNetworkInterface object) {
            return VmInterfaceType.forValue(object.getType());
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(typeColumn, constants.typeInterface(), "80px");
    AbstractTextColumn<VmNetworkInterface> macColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getMacAddress();
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(macColumn, constants.macInterface(), "80px");
    AbstractTextColumn<VmNetworkInterface> speedColumn = new AbstractTextColumn<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().toString();
            } else {
                return null;
            }
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(speedColumn, templates.sub(constants.speedInterface(), constants.mbps()), "80px");
    AbstractTextColumn<VmNetworkInterface> rxColumn = new AbstractRxTxRateColumn<VmNetworkInterface>() {

        @Override
        protected Double getRate(VmNetworkInterface object) {
            return object.getStatistics().getReceiveRate();
        }

        @Override
        protected Double getSpeed(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().doubleValue();
            } else {
                return null;
            }
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(rxColumn, templates.sub(constants.rxRate(), constants.mbps()), "80px");
    AbstractTextColumn<VmNetworkInterface> txColumn = new AbstractRxTxRateColumn<VmNetworkInterface>() {

        @Override
        protected Double getRate(VmNetworkInterface object) {
            return object.getStatistics().getTransmitRate();
        }

        @Override
        protected Double getSpeed(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().doubleValue();
            } else {
                return null;
            }
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(txColumn, templates.sub(constants.txRate(), constants.mbps()), "80px");
    AbstractTextColumn<VmNetworkInterface> dropsColumn = new AbstractSumUpColumn<VmNetworkInterface>() {

        @Override
        protected Double[] getRawValue(VmNetworkInterface object) {
            Double receiveDropRate = object != null ? object.getStatistics().getReceiveDropRate() : null;
            Double transmitDropRate = object != null ? object.getStatistics().getTransmitDropRate() : null;
            return new Double[] { receiveDropRate, transmitDropRate };
        }
    };
    // $NON-NLS-1$
    nicsTable.addColumn(dropsColumn, templates.sub(constants.dropsInterface(), constants.pkts()), "80px");
    nicsTable.setRowData(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    nicsTable.setWidth("100%");
    nicsTable.setSelectionModel(new NoSelectionModel());
}
#end_block

#method_before
private void initAppsTable() {
    appsTable = new EntityModelCellTable<>(false, true);
    AbstractTextColumn<String> appNameColumn = new AbstractTextColumn<String>() {

        @Override
        public String getValue(String appName) {
            return appName;
        }
    };
    appsTable.addColumn(appNameColumn, constants.nameSnapshot());
    appsTable.setRowData(new ArrayList<EntityModel>());
    appsTable.setWidth(100 + Style.Unit.PCT.getType());
    appsTable.setSelectionModel(new NoSelectionModel());
}
#method_after
private void initAppsTable() {
    appsTable = new EntityModelCellTable<>(false, true);
    AbstractTextColumn<String> appNameColumn = new AbstractTextColumn<String>() {

        @Override
        public String getValue(String appName) {
            return appName;
        }
    };
    appsTable.addColumn(appNameColumn, constants.nameSnapshot());
    appsTable.setRowData(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    appsTable.setWidth("100%");
    appsTable.setSelectionModel(new NoSelectionModel());
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    registerHandler(getTable().getSelectionModel().addSelectionChangeHandler(event -> {
        // Update main model selection
        modelProvider.setSelectedItems(getSelectedItems());
        // Let others know that the table selection has changed
        fireTableSelectionChangeEvent();
        // quick switch search is run.
        if (isVisible()) {
            handlePlaceTransition(false);
        }
    }));
    registerHandler(getEventBus().addHandler(ApplySearchStringEvent.getType(), event -> {
        applySearchString(event.getSearchString());
    }));
    getView().setDetailPlaceTransitionHandler(this);
    String searchString = searchStringCollector.getSearchStringPrefix(modelProvider.getModel().getSearchString());
    if (searchString != null) {
        // Someone set search string before we were instantiated, update the search string.
        applySearchString(searchString);
    }
    if (hasSearchPanelPresenterWidget()) {
        setInSlot(TYPE_SetSearchPanel, searchPanelPresenterWidget);
    }
    if (hasActionPanelPresenterWidget()) {
        setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
    }
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    registerHandler(getTable().getSelectionModel().addSelectionChangeHandler(event -> {
        // Update main model selection
        modelProvider.setSelectedItems(getSelectedItems());
        // Let others know that the table selection has changed
        fireTableSelectionChangeEvent();
        // quick switch search is run.
        if (isVisible()) {
            handlePlaceTransition(false);
        }
    }));
    registerHandler(getEventBus().addHandler(ApplySearchStringEvent.getType(), event -> {
        applySearchString(event.getSearchString());
    }));
    getView().setDetailPlaceTransitionHandler(this);
    registerHandler(getView().addWindowResizeHandler(e -> {
        Scheduler.get().scheduleDeferred(() -> getView().resizeToFullHeight());
    }));
    String searchString = searchStringCollector.getSearchStringPrefix(modelProvider.getModel().getSearchString());
    if (searchString != null) {
        // Someone set search string before we were instantiated, update the search string.
        applySearchString(searchString);
    }
    if (hasSearchPanelPresenterWidget()) {
        setInSlot(TYPE_SetSearchPanel, searchPanelPresenterWidget);
    }
    if (hasActionPanelPresenterWidget()) {
        setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
    }
}
#end_block

#method_before
public void switchTab(TabListItem tabItem) {
    boolean found = false;
    for (int i = 0; i < navTabs.getWidgetCount(); i++) {
        TabListItem tabListItem = (TabListItem) navTabs.getWidget(i);
        if (tabItem.getText().equals(tabListItem.getText())) {
            tabListItem.showTab();
            TabPane tabPane = (TabPane) tabContent.getWidget(i);
            // Detach and immediately re-attach so the content gets the onAttach event so they can react to being
            // made visible. Otherwise there is no way for the content to know if they are visible or not due to
            // the visibility being controlled by the 'active' class on the tab, which doesn't trigger any GWT
            // events when added.
            tabContent.remove(tabPane);
            tabContent.insert(tabPane, i);
            ((FlowPanel) tabPane.getWidget(0)).insert(tabHeaderContainer, 0);
            tabPane.getWidget(0).setHeight(height);
            tabPane.setActive(true);
            activeTab = (TabListItem) navTabs.getWidget(i);
            found = true;
        } else {
            TabPane tabPane = (TabPane) tabContent.getWidget(i);
            ((FlowPanel) tabPane.getWidget(0)).remove(tabHeaderContainer);
            tabPane.setActive(false);
        }
    }
    // If not found, set first active.
    if (!found && navTabs.getWidgetCount() > 0) {
        ((TabListItem) navTabs.getWidget(0)).showTab();
        TabPane tabPane = (TabPane) tabContent.getWidget(0);
        ((FlowPanel) tabPane.getWidget(0)).insert(tabHeaderContainer, 0);
        tabPane.setActive(true);
    }
}
#method_after
public void switchTab(TabListItem tabItem) {
    boolean found = false;
    for (int i = 0; i < navTabs.getWidgetCount(); i++) {
        TabListItem currentTabItem = (TabListItem) navTabs.getWidget(i);
        if (tabItem.getText().equals(currentTabItem.getText())) {
            currentTabItem.showTab();
            TabPane tabPane = (TabPane) tabContent.getWidget(i);
            // Detach and immediately re-attach so the content gets the onAttach event so they can react to being
            // made visible. Otherwise there is no way for the content to know if they are visible or not due to
            // the visibility being controlled by the 'active' class on the tab, which doesn't trigger any GWT
            // events when added.
            tabContent.remove(tabPane);
            tabContent.insert(tabPane, i);
            ((FlowPanel) tabPane.getWidget(0)).insert(tabHeaderContainer, 0);
            tabPane.getWidget(0).setHeight(height);
            tabPane.setActive(true);
            activeTab = (TabListItem) navTabs.getWidget(i);
            found = true;
        } else {
            TabPane tabPane = (TabPane) tabContent.getWidget(i);
            ((FlowPanel) tabPane.getWidget(0)).remove(tabHeaderContainer);
            tabPane.setActive(false);
        }
    }
    // If not found, set first active.
    if (!found && navTabs.getWidgetCount() > 0) {
        ((TabListItem) navTabs.getWidget(0)).showTab();
        TabPane tabPane = (TabPane) tabContent.getWidget(0);
        ((FlowPanel) tabPane.getWidget(0)).insert(tabHeaderContainer, 0);
        tabPane.setActive(true);
    }
}
#end_block

#method_before
void updateListHeader() {
    // $NON-NLS-1$
    String width = calculateColumnWidthPercentage() + "%";
    listHeader = new EntityModelCellTable<>(false, (Resources) GWT.create(PopupSimpleTableResources.class), true);
    listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.aliasDisk(), width);
    listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.provisionedSizeDisk(), width);
    if (showVolumeType) {
        listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.allocationDisk(), width);
    }
    if (showVolumeFormat) {
        listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.formatDisk(), width);
    }
    if (showSource) {
        listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.sourceDisk(), width);
    }
    if (showTarget) {
        listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.targetDisk(), width);
    }
    listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.diskProfile(), width);
    if (showQuota) {
        listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.quotaDisk(), width);
    }
    listHeader.setRowData(new ArrayList<DisksAllocationModel>());
    listHeader.setWidth(100 + Unit.PCT.getType());
    diskListHeaderPanel.setWidget(listHeader);
}
#method_after
void updateListHeader() {
    // $NON-NLS-1$
    String width = calculateColumnWidthPercentage() + "%";
    listHeader = new EntityModelCellTable<>(false, (Resources) GWT.create(PopupSimpleTableResources.class), true);
    listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.aliasDisk(), width);
    listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.provisionedSizeDisk(), width);
    if (showVolumeType) {
        listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.allocationDisk(), width);
    }
    if (showVolumeFormat) {
        listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.formatDisk(), width);
    }
    if (showSource) {
        listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.sourceDisk(), width);
    }
    if (showTarget) {
        listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.targetDisk(), width);
    }
    listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.diskProfile(), width);
    if (showQuota) {
        listHeader.addColumn(new EmptyColumn<DisksAllocationModel>(), constants.quotaDisk(), width);
    }
    listHeader.setRowData(new ArrayList<DisksAllocationModel>());
    // $NON-NLS-1$
    listHeader.setWidth("100%");
    diskListHeaderPanel.setWidget(listHeader);
}
#end_block

#method_before
void updateListHeader(ChangeQuotaModel model) {
    // $NON-NLS-1$
    String width = "100px";
    listHeader = new EntityModelCellTable(false, (Resources) GWT.create(PopupSimpleTableResources.class), true);
    listHeader.addColumn(new EmptyColumn(), constants.elementName(), width);
    listHeader.addColumn(new EmptyColumn(), constants.storageDomainDisk(), width);
    listHeader.addColumn(new EmptyColumn(), constants.currentQuota(), width);
    listHeader.addColumn(new EmptyColumn(), constants.quotaDisk(), width);
    listHeader.setRowData(new ArrayList());
    listHeader.setWidth(100 + Style.Unit.PCT.getType());
    listHeaderPanel.setWidget(listHeader);
}
#method_after
void updateListHeader(ChangeQuotaModel model) {
    // $NON-NLS-1$
    String width = "100px";
    listHeader = new EntityModelCellTable(false, (Resources) GWT.create(PopupSimpleTableResources.class), true);
    listHeader.addColumn(new EmptyColumn(), constants.elementName(), width);
    listHeader.addColumn(new EmptyColumn(), constants.storageDomainDisk(), width);
    listHeader.addColumn(new EmptyColumn(), constants.currentQuota(), width);
    listHeader.addColumn(new EmptyColumn(), constants.quotaDisk(), width);
    listHeader.setRowData(new ArrayList());
    // $NON-NLS-1$
    listHeader.setWidth("100%");
    listHeaderPanel.setWidget(listHeader);
}
#end_block

#method_before
private Container createGuestAgentContainerPanel(VmNetworkInterface networkInterface, List<VmGuestAgentInterface> allGuestAgentData) {
    Row content = new Row();
    Column column = new Column(ColumnSize.MD_12);
    content.add(column);
    for (VmGuestAgentInterface guestAgentInterface : allGuestAgentData) {
        if (guestAgentInterface.getMacAddress() != null && guestAgentInterface.getMacAddress().equals(networkInterface.getMacAddress())) {
            DListElement dl = Document.get().createDLElement();
            dl.addClassName(DL_HORIZONTAL);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.nameVmGuestAgent()), guestAgentInterface.getInterfaceName(), dl);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv4VmGuestAgent()), guestAgentInterface.getIpv4Addresses() != null ? String.join(COMMA_DELIMITOR, guestAgentInterface.getIpv4Addresses()) : constants.notAvailableLabel(), dl);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv6VmGuestAgent()), guestAgentInterface.getIpv6Addresses() != null ? String.join(COMMA_DELIMITOR, guestAgentInterface.getIpv6Addresses()) : constants.notAvailableLabel(), dl);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.macVmGuestAgent()), guestAgentInterface.getMacAddress(), dl);
            column.getElement().appendChild(dl);
        }
    }
    if (allGuestAgentData.isEmpty()) {
        Span noDataSpan = new Span();
        noDataSpan.setText(constants.notAvailableLabel());
        column.add(noDataSpan);
    }
    return createItemContainerPanel(content);
}
#method_after
private Container createGuestAgentContainerPanel(VmNetworkInterface networkInterface, List<VmGuestAgentInterface> allGuestAgentData) {
    Row content = new Row();
    Column column = new Column(ColumnSize.MD_12);
    content.add(column);
    for (VmGuestAgentInterface guestAgentInterface : allGuestAgentData) {
        if (guestAgentInterface.getMacAddress() != null && guestAgentInterface.getMacAddress().equals(networkInterface.getMacAddress())) {
            DListElement dl = Document.get().createDLElement();
            dl.addClassName(DL_HORIZONTAL);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.nameVmGuestAgent()), guestAgentInterface.getInterfaceName(), dl);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv4VmGuestAgent()), guestAgentInterface.getIpv4Addresses() != null ? String.join(COMMA_DELIMITER, guestAgentInterface.getIpv4Addresses()) : constants.notAvailableLabel(), dl);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv6VmGuestAgent()), guestAgentInterface.getIpv6Addresses() != null ? String.join(COMMA_DELIMITER, guestAgentInterface.getIpv6Addresses()) : constants.notAvailableLabel(), dl);
            addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.macVmGuestAgent()), guestAgentInterface.getMacAddress(), dl);
            column.getElement().appendChild(dl);
        }
    }
    if (allGuestAgentData.isEmpty()) {
        Span noDataSpan = new Span();
        noDataSpan.setText(constants.notAvailableLabel());
        column.add(noDataSpan);
    }
    return createItemContainerPanel(content);
}
#end_block

#method_before
protected void addNetworkMainInfo(VmNetworkInterface networkInterface, HasWidgets targetPanel) {
    DListElement dl = Document.get().createDLElement();
    FlowPanel infoPanel = new FlowPanel();
    StringJoiner ipv4AddressJoiner = new StringJoiner(COMMA_DELIMITOR);
    StringJoiner ipv6AddressJoiner = new StringJoiner(COMMA_DELIMITOR);
    for (VmGuestAgentInterface guestAgentInterface : allGuestAgentData) {
        if (guestAgentInterface.getIpv4Addresses() != null) {
            ipv4AddressJoiner.add(String.join(COMMA_DELIMITOR, guestAgentInterface.getIpv4Addresses()));
        }
        if (guestAgentInterface.getIpv6Addresses() != null) {
            ipv6AddressJoiner.add(String.join(COMMA_DELIMITOR, guestAgentInterface.getIpv6Addresses()));
        }
    }
    String ipv4Address = ipv4AddressJoiner.toString();
    if (ipv4Address.isEmpty()) {
        ipv4Address = constants.notAvailableLabel();
    }
    String ipv6Address = ipv6AddressJoiner.toString();
    if (ipv6Address.isEmpty()) {
        ipv6Address = constants.notAvailableLabel();
    }
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.networkNameInterface()), networkInterface.getNetworkName() != null ? networkInterface.getNetworkName() : constants.unAvailablePropertyLabel(), dl);
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv4VmGuestAgent()), ipv4Address, dl);
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv6VmGuestAgent()), ipv6Address, dl);
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.macVmGuestAgent()), networkInterface.getMacAddress(), dl);
    infoPanel.getElement().appendChild(dl);
    targetPanel.add(infoPanel);
}
#method_after
protected void addNetworkMainInfo(VmNetworkInterface networkInterface, HasWidgets targetPanel) {
    DListElement dl = Document.get().createDLElement();
    FlowPanel infoPanel = new FlowPanel();
    StringJoiner ipv4AddressJoiner = new StringJoiner(COMMA_DELIMITER);
    StringJoiner ipv6AddressJoiner = new StringJoiner(COMMA_DELIMITER);
    for (VmGuestAgentInterface guestAgentInterface : allGuestAgentData) {
        if (guestAgentInterface.getIpv4Addresses() != null) {
            ipv4AddressJoiner.add(String.join(COMMA_DELIMITER, guestAgentInterface.getIpv4Addresses()));
        }
        if (guestAgentInterface.getIpv6Addresses() != null) {
            ipv6AddressJoiner.add(String.join(COMMA_DELIMITER, guestAgentInterface.getIpv6Addresses()));
        }
    }
    String ipv4Address = ipv4AddressJoiner.toString();
    if (ipv4Address.isEmpty()) {
        ipv4Address = constants.notAvailableLabel();
    }
    String ipv6Address = ipv6AddressJoiner.toString();
    if (ipv6Address.isEmpty()) {
        ipv6Address = constants.notAvailableLabel();
    }
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.networkNameInterface()), networkInterface.getNetworkName() != null ? networkInterface.getNetworkName() : constants.unAvailablePropertyLabel(), dl);
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv4VmGuestAgent()), ipv4Address, dl);
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.ipv6VmGuestAgent()), ipv6Address, dl);
    addStackedDetailItem(SafeHtmlUtils.fromSafeConstant(constants.macVmGuestAgent()), networkInterface.getMacAddress(), dl);
    infoPanel.getElement().appendChild(dl);
    targetPanel.add(infoPanel);
}
#end_block

#method_before
@Override
protected TreeItem getNodeItem(StorageDomain storage) {
    HorizontalPanel panel = new HorizontalPanel();
    panel.setSpacing(1);
    panel.setWidth(100 + Style.Unit.PCT.getType());
    // $NON-NLS-1$
    addItemToPanel(panel, new Image(resources.storageImage()), "25px");
    // $NON-NLS-1$
    addTextBoxToPanel(panel, new StringValueLabel(), storage.getStorageName(), "");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<StorageDomainType>(), storage.getStorageDomainType(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<StorageDomainSharedStatus>(), storage.getStorageDomainSharedStatus(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DiskSizeLabel<Integer>(), storage.getAvailableDiskSize(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DiskSizeLabel<Integer>(), storage.getUsedDiskSize(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DiskSizeLabel<Integer>(), storage.getTotalDiskSize(), "120px");
    TreeItem treeItem = new TreeItem(panel);
    treeItem.setUserObject(storage.getId());
    return treeItem;
}
#method_after
@Override
protected TreeItem getNodeItem(StorageDomain storage) {
    HorizontalPanel panel = new HorizontalPanel();
    panel.setSpacing(1);
    // $NON-NLS-1$
    panel.setWidth("100%");
    // $NON-NLS-1$
    addItemToPanel(panel, new Image(resources.storageImage()), "25px");
    // $NON-NLS-1$
    addTextBoxToPanel(panel, new StringValueLabel(), storage.getStorageName(), "");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<StorageDomainType>(), storage.getStorageDomainType(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new EnumLabel<StorageDomainSharedStatus>(), storage.getStorageDomainSharedStatus(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DiskSizeLabel<Integer>(), storage.getAvailableDiskSize(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DiskSizeLabel<Integer>(), storage.getUsedDiskSize(), "120px");
    // $NON-NLS-1$
    addValueLabelToPanel(panel, new DiskSizeLabel<Integer>(), storage.getTotalDiskSize(), "120px");
    TreeItem treeItem = new TreeItem(panel);
    treeItem.setUserObject(storage.getId());
    return treeItem;
}
#end_block

#method_before
@Override
protected TreeItem getNodeHeader() {
    EntityModelCellTable<ListModel> table = new EntityModelCellTable<>(false, true);
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.empty(), "20px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.domainNameDisksTree(), "");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.domainTypeDisksTree(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.statusDisksTree(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.freeSpaceDisksTree(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.usedSpaceDisksTree(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.totalSpaceDisksTree(), "130px");
    table.setRowData(new ArrayList());
    table.setWidth(100 + Style.Unit.PCT.getType());
    table.setHeight(30 + Style.Unit.PX.getType());
    return new TreeItem(table);
}
#method_after
@Override
protected TreeItem getNodeHeader() {
    EntityModelCellTable<ListModel> table = new EntityModelCellTable<>(false, true);
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.empty(), "20px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.domainNameDisksTree(), "");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.domainTypeDisksTree(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.statusDisksTree(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.freeSpaceDisksTree(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.usedSpaceDisksTree(), "120px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.totalSpaceDisksTree(), "130px");
    table.setRowData(new ArrayList());
    // $NON-NLS-1$
    table.setWidth("100%");
    // $NON-NLS-1$
    table.setHeight("30px");
    return new TreeItem(table);
}
#end_block

#method_before
private void initNetworksTable() {
    networksTable.enableColumnResizing();
    AbstractTextColumn<Network> nameColumn = new AbstractTextColumn<Network>() {

        @Override
        public String getValue(Network network) {
            return network.getName();
        }
    };
    // $NON-NLS-1$
    networksTable.addColumn(nameColumn, constants.name(), "40%");
    AbstractTextColumn<Network> descriptionColumn = new AbstractTextColumn<Network>() {

        @Override
        public String getValue(Network network) {
            return network.getDescription();
        }
    };
    // $NON-NLS-1$
    networksTable.addColumn(descriptionColumn, constants.description(), "60%");
    networksTable.setWidth(100 + Style.Unit.PCT.getType());
}
#method_after
private void initNetworksTable() {
    networksTable.enableColumnResizing();
    AbstractTextColumn<Network> nameColumn = new AbstractTextColumn<Network>() {

        @Override
        public String getValue(Network network) {
            return network.getName();
        }
    };
    // $NON-NLS-1$
    networksTable.addColumn(nameColumn, constants.name(), "40%");
    AbstractTextColumn<Network> descriptionColumn = new AbstractTextColumn<Network>() {

        @Override
        public String getValue(Network network) {
            return network.getDescription();
        }
    };
    // $NON-NLS-1$
    networksTable.addColumn(descriptionColumn, constants.description(), "60%");
    // $NON-NLS-1$
    networksTable.setWidth("100%");
}
#end_block

#method_before
private void initConnectionsTable() {
    connectionsTable.enableColumnResizing();
    AbstractTextColumn<StorageServerConnections> iqnColumn = new AbstractTextColumn<StorageServerConnections>() {

        @Override
        public String getValue(StorageServerConnections conn) {
            return conn.getIqn();
        }
    };
    // $NON-NLS-1$
    connectionsTable.addColumn(iqnColumn, constants.iqn(), "40%");
    AbstractTextColumn<StorageServerConnections> addressColumn = new AbstractTextColumn<StorageServerConnections>() {

        @Override
        public String getValue(StorageServerConnections conn) {
            return conn.getConnection();
        }
    };
    // $NON-NLS-1$
    connectionsTable.addColumn(addressColumn, constants.addressSanStorage(), "30%");
    AbstractTextColumn<StorageServerConnections> portColumn = new AbstractTextColumn<StorageServerConnections>() {

        @Override
        public String getValue(StorageServerConnections conn) {
            return conn.getPort();
        }
    };
    // $NON-NLS-1$
    connectionsTable.addColumn(portColumn, constants.portSanStorage(), "30%");
    connectionsTable.setWidth(100 + Style.Unit.PCT.getType());
}
#method_after
private void initConnectionsTable() {
    connectionsTable.enableColumnResizing();
    AbstractTextColumn<StorageServerConnections> iqnColumn = new AbstractTextColumn<StorageServerConnections>() {

        @Override
        public String getValue(StorageServerConnections conn) {
            return conn.getIqn();
        }
    };
    // $NON-NLS-1$
    connectionsTable.addColumn(iqnColumn, constants.iqn(), "40%");
    AbstractTextColumn<StorageServerConnections> addressColumn = new AbstractTextColumn<StorageServerConnections>() {

        @Override
        public String getValue(StorageServerConnections conn) {
            return conn.getConnection();
        }
    };
    // $NON-NLS-1$
    connectionsTable.addColumn(addressColumn, constants.addressSanStorage(), "30%");
    AbstractTextColumn<StorageServerConnections> portColumn = new AbstractTextColumn<StorageServerConnections>() {

        @Override
        public String getValue(StorageServerConnections conn) {
            return conn.getPort();
        }
    };
    // $NON-NLS-1$
    connectionsTable.addColumn(portColumn, constants.portSanStorage(), "30%");
    // $NON-NLS-1$
    connectionsTable.setWidth("100%");
}
#end_block

#method_before
protected <P extends ActionParametersBase> P sessionize(P parameters) {
    String sessionId = getCurrent().getSessionId();
    parameters.setSessionId(sessionId);
    return parameters;
}
#method_after
protected <P extends QueryParametersBase> P sessionize(P parameters) {
    String sessionId = getCurrent().getSessionId();
    parameters.setSessionId(sessionId);
    return parameters;
}
#end_block

#method_before
@PostConstruct
void initialize() {
    try {
        List<org.ovirt.engine.core.common.businessentities.MacPool> macPools = macPoolDao.getAll();
        for (org.ovirt.engine.core.common.businessentities.MacPool macPool : macPools) {
            initializeMacPool(macPool);
        }
        log.info("Successfully initialized");
    } catch (RuntimeException e) {
        log.error("Error initializing: {}", e.getMessage());
        throw e;
    }
}
#method_after
@PostConstruct
void initialize() {
    try {
        List<org.ovirt.engine.core.common.businessentities.MacPool> macPools = macPoolDao.getAll();
        for (org.ovirt.engine.core.common.businessentities.MacPool macPool : macPools) {
            createPoolInternal(macPool, true);
        }
        log.info("Successfully initialized");
    } catch (RuntimeException e) {
        log.error("Error initializing: {}", e.getMessage());
        throw e;
    }
}
#end_block

#method_before
public void createPool(org.ovirt.engine.core.common.businessentities.MacPool macPool) {
    try (AutoCloseableLock lock = writeLockResource()) {
        createPoolInternal(macPool);
    }
}
#method_after
public void createPool(org.ovirt.engine.core.common.businessentities.MacPool macPool) {
    try (AutoCloseableLock lock = writeLockResource()) {
        createPoolInternal(macPool, false);
    }
}
#end_block

#method_before
private MacPool createPoolInternal(org.ovirt.engine.core.common.businessentities.MacPool macPool) {
    if (macPools.containsKey(macPool.getId())) {
        throw new IllegalStateException(UNABLE_TO_CREATE_MAC_POOL_IT_ALREADY_EXIST);
    }
    log.debug("Creating new MacPool {}.", macPool);
    MacPool poolForScope = macPoolFactory.createMacPool(macPool);
    macPools.put(macPool.getId(), poolForScope);
    return poolForScope;
}
#method_after
private MacPool createPoolInternal(org.ovirt.engine.core.common.businessentities.MacPool macPool, boolean engineStartup) {
    if (macPools.containsKey(macPool.getId())) {
        throw new IllegalStateException(UNABLE_TO_CREATE_MAC_POOL_IT_ALREADY_EXIST);
    }
    log.debug("Creating new MacPool {}.", macPool);
    MacPool poolForScope = macPoolFactory.createMacPool(macPool, engineStartup);
    macPools.put(macPool.getId(), poolForScope);
    return poolForScope;
}
#end_block

#method_before
public void modifyPool(org.ovirt.engine.core.common.businessentities.MacPool macPool) {
    try (AutoCloseableLock lock = writeLockResource()) {
        Guid macPoolId = macPool.getId();
        if (!macPools.containsKey(macPoolId)) {
            throw new IllegalStateException(createExceptionMessageMacPoolHavingIdDoesNotExist(macPoolId));
        }
        log.debug("Updating pool {}. (old will be deleted and new initialized from db entity)", macPool);
        removeWithoutLocking(macPoolId);
        initializeMacPool(macPool);
    }
}
#method_after
public void modifyPool(org.ovirt.engine.core.common.businessentities.MacPool macPool) {
    try (AutoCloseableLock lock = writeLockResource()) {
        Guid macPoolId = macPool.getId();
        if (!macPools.containsKey(macPoolId)) {
            throw new IllegalStateException(createExceptionMessageMacPoolHavingIdDoesNotExist(macPoolId));
        }
        log.debug("Updating pool {}. (old will be deleted and new initialized from db entity)", macPool);
        removeWithoutLocking(macPoolId);
        createPoolInternal(macPool, false);
    }
}
#end_block

#method_before
private void initialize() {
    log.info("Initializing {}", this);
    this.macsStorage = createMacsStorage(rangesBoundaries);
    log.info("Finished initializing {}. Available MACs in pool: {}", this, macsStorage.getAvailableMacsCount());
}
#method_after
void initialize(boolean engineStartup, List<String> macsForMacPool) {
    log.info("Initializing {}", this);
    this.macsStorage = createMacsStorage(this.rangesBoundaries);
    log.debug("Initializing {} with macs: {}", this, macsForMacPool);
    List<String> notAddedMacs = addMacs(macsForMacPool);
    if (!notAddedMacs.isEmpty()) {
        if (engineStartup) {
            String auditLogMessage = "Following MACs violates duplicity restriction, and was pushed into MAC pool without respect to it:" + notAddedMacs;
            auditLogDirector.log(new AuditLogableImpl(), AuditLogType.MAC_ADDRESS_VIOLATES_NO_DUPLICATES_SETTING, auditLogMessage);
            forceAddMacs(notAddedMacs);
        } else {
            throw new EngineException(EngineError.MAC_POOL_INITIALIZATION_FAILED, "Unable to initialize MAC pool due to existing duplicates");
        }
    }
    log.info("Finished initializing {}. Available MACs in pool: {}", this, macsStorage.getAvailableMacsCount());
}
#end_block

#method_before
private void logWhenMacPoolIsEmpty() {
    if (!macsStorage.availableMacExist()) {
        AuditLogableBase logable = new AuditLogableBase();
        new AuditLogDirector().log(logable, AuditLogType.MAC_POOL_EMPTY);
    }
}
#method_after
private void logWhenMacPoolIsEmpty() {
    if (!macsStorage.availableMacExist()) {
        AuditLogable logable = new AuditLogableImpl();
        Injector.get(AuditLogDirector.class).log(logable, AuditLogType.MAC_POOL_EMPTY);
    }
}
#end_block

#method_before
private VmInitNetwork createVmInitNetwork() {
    final VmInitNetwork vmInitNetwork = new VmInitNetwork();
    vmInitNetwork.setName(IFACE_NAME);
    vmInitNetwork.setBootProtocol(Ipv4BootProtocol.STATIC_IP);
    vmInitNetwork.setIp(IPV4_ADDRESS);
    vmInitNetwork.setNetmask(IPV4_NETMASK);
    vmInitNetwork.setGateway(IPV4_GATEWAY);
    /*
        vmInitNetwork.setIpv6BootProtocol(Ipv6BootProtocol.STATIC_IP);
        vmInitNetwork.setIpv6Address(IPV6_ADDRESS);
        vmInitNetwork.setIpv6Prefix(IPV6_PREFIX);
        vmInitNetwork.setIpv6Gateway(IPV6_GATEWAY);
*/
    return vmInitNetwork;
}
#method_after
private VmInitNetwork createVmInitNetwork() {
    final VmInitNetwork vmInitNetwork = new VmInitNetwork();
    vmInitNetwork.setName(IFACE_NAME);
    vmInitNetwork.setBootProtocol(Ipv4BootProtocol.STATIC_IP);
    vmInitNetwork.setIp(IPV4_ADDRESS);
    vmInitNetwork.setNetmask(IPV4_NETMASK);
    vmInitNetwork.setGateway(IPV4_GATEWAY);
    // vmInitNetwork.setIpv6Gateway(IPV6_GATEWAY);
    return vmInitNetwork;
}
#end_block

#method_before
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // Load the thread pools
    serviceLoader.load(EngineThreadPools.class);
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    serviceLoader.load(VmMigrationProgressMonitoring.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // Load the thread pools
    serviceLoader.load(EngineThreadPools.class);
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    serviceLoader.load(AsyncTaskManager.class);
    serviceLoader.load(CommandCoordinatorUtil.class);
    serviceLoader.load(CommandCallbacksPoller.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    serviceLoader.load(VmMigrationProgressMonitoring.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
@Loggable
@Override
public ActionReturnValue runAction(ActionType actionType, ActionParametersBase parameters) {
    ActionReturnValue returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        return returnValue;
    }
    return runActionImpl(actionType, parameters, false, null);
}
#method_after
@Override
@InvocationLogger
public ActionReturnValue runAction(ActionType actionType, ActionParametersBase parameters) {
    ActionReturnValue returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        return returnValue;
    }
    return runActionImpl(actionType, parameters, false, null);
}
#end_block

#method_before
@Loggable
@Override
public QueryReturnValue runQuery(QueryType actionType, QueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true, null);
}
#method_after
@InvocationLogger
@Override
public QueryReturnValue runQuery(QueryType actionType, QueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true, null);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected List<VM> getVmsFromExportDomain() {
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetVmsFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    return (List<VM>) (qRetVal.getSucceeded() ? qRetVal.getReturnValue() : Collections.emptyList());
}
#method_after
@SuppressWarnings("unchecked")
protected List<VM> getVmsFromExportDomain() {
    QueryReturnValue qRetVal = runInternalQuery(QueryType.GetVmsFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    return (List<VM>) (qRetVal.getSucceeded() ? qRetVal.getReturnValue() : Collections.emptyList());
}
#end_block

#method_before
private Predicate<VmNetworkInterface> getVnicRequiresNewMacPredicate() {
    return ((Predicate<VmNetworkInterface>) this::nicWithoutMacAddress).or(this::shouldMacBeReassigned);
}
#method_after
private Predicate<VmNetworkInterface> getVnicRequiresNewMacPredicate() {
    return ((Predicate<VmNetworkInterface>) this::nicWithoutMacAddress).or(iface -> getParameters().isReassignBadMacs() && vNicHasBadMac(iface));
}
#end_block

#method_before
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    if (qRetVal.getSucceeded()) {
        Map<VmTemplate, ?> templates = qRetVal.getReturnValue();
        for (VmTemplate template : templates.keySet()) {
            if (getParameters().getVm().getVmtGuid().equals(template.getId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    QueryReturnValue qRetVal = runInternalQuery(QueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    if (qRetVal.getSucceeded()) {
        Map<VmTemplate, ?> templates = qRetVal.getReturnValue();
        for (VmTemplate template : templates.keySet()) {
            if (getParameters().getVm().getVmtGuid().equals(template.getId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = validate(getImportValidator().verifyDisks(imageList, imageToDestinationDomainMap));
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        Set<Guid> domainsId = domains.stream().map(StorageDomain::getId).collect(Collectors.toSet());
        if (!domainsId.isEmpty() && Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = validate(getImportValidator().verifyDisks(imageList, imageToDestinationDomainMap));
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = runInternalQuery(QueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        Set<Guid> domainsId = domains.stream().map(StorageDomain::getId).collect(Collectors.toSet());
        if (!domainsId.isEmpty() && Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
private void copyAllMemoryImages(Guid containerId) {
    for (String memoryVolumes : MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots())) {
        List<Guid> guids = GuidUtils.getGuidListFromString(memoryVolumes);
        // copy the memory dump image
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy memory image");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy metadata image");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
private void copyAllMemoryImages(Guid containerId) {
    for (String memoryVolumes : MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots())) {
        List<Guid> guids = Guid.createGuidListFromString(memoryVolumes);
        // copy the memory dump image
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy memory image");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy metadata image");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy disk!");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy disk!");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
protected void setQcowCompat(DiskImage diskImage) {
    diskImage.setQcowCompat(QcowCompat.QCOW2_V2);
    if (FeatureSupported.qcowCompatSupported(getStoragePool().getCompatibilityVersion())) {
        QemuImageInfo qemuImageInfo = ImagesHandler.getQemuImageInfoFromVdsm(diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId(), null, true);
        if (qemuImageInfo != null) {
            diskImage.setQcowCompat(qemuImageInfo.getQcowCompat());
        }
    }
    imageDao.update(diskImage.getImage());
}
#method_after
protected void setQcowCompat(DiskImage diskImage) {
    diskImage.setQcowCompat(QcowCompat.QCOW2_V2);
    if (FeatureSupported.qcowCompatSupported(getStoragePool().getCompatibilityVersion())) {
        QemuImageInfo qemuImageInfo = imagesHandler.getQemuImageInfoFromVdsm(diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId(), null, true);
        if (qemuImageInfo != null) {
            diskImage.setQcowCompat(qemuImageInfo.getQcowCompat());
        }
    }
    imageDao.update(diskImage.getImage());
}
#end_block

#method_before
protected void saveImage(DiskImage disk) {
    ImagesHandler.saveImage(disk);
}
#method_after
protected void saveImage(DiskImage disk) {
    imagesHandler.saveImage(disk);
}
#end_block

#method_before
private void updateMemoryDisks(Snapshot snapshot) {
    List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
    snapshot.setMemoryDiskId(guids.get(2));
    snapshot.setMetadataDiskId(guids.get(4));
}
#method_after
private void updateMemoryDisks(Snapshot snapshot) {
    List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
    snapshot.setMemoryDiskId(guids.get(2));
    snapshot.setMetadataDiskId(guids.get(4));
}
#end_block

#method_before
private void addMemoryImages() {
    getVm().getSnapshots().stream().filter(snapshot -> !StringUtils.isEmpty(snapshot.getMemoryVolume())).forEach(snapshot -> {
        addDisk(createMemoryDisk(snapshot));
        addDisk(createMetadaaDisk(snapshot));
    });
}
#method_after
private void addMemoryImages() {
    getVm().getSnapshots().stream().filter(snapshot -> !StringUtils.isEmpty(snapshot.getMemoryVolume())).forEach(snapshot -> {
        addDisk(createMemoryDisk(snapshot));
        addDisk(createMetadataDisk(getVm(), snapshot));
    });
}
#end_block

#method_before
private DiskImage createMemoryDisk(Snapshot snapshot) {
    List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
    VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
    DiskImage memoryDisk = MemoryUtils.createMemoryDisk(vm, storageDomainStaticDao.get(guids.get(0)).getStorageType(), vmOverheadCalculator);
    memoryDisk.setId(guids.get(2));
    memoryDisk.setImageId(guids.get(3));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    return memoryDisk;
}
#method_after
private DiskImage createMemoryDisk(Snapshot snapshot) {
    List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
    StorageDomainStatic sd = validateStorageDomainExistsInDb(snapshot, guids.get(0), guids.get(2), guids.get(3));
    if (sd == null) {
        return null;
    }
    VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
    DiskImage memoryDisk = MemoryUtils.createMemoryDisk(vm, sd.getStorageType(), vmOverheadCalculator, MemoryUtils.generateMemoryDiskDescription(vm, snapshot.getDescription()));
    memoryDisk.setId(guids.get(2));
    memoryDisk.setImageId(guids.get(3));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    return memoryDisk;
}
#end_block

#method_before
private void addDisk(DiskImage disk) {
    saveImage(disk);
    saveBaseDisk(disk);
    saveDiskImageDynamic(disk);
}
#method_after
private void addDisk(DiskImage disk) {
    if (disk != null) {
        saveImage(disk);
        saveBaseDisk(disk);
        saveDiskImageDynamic(disk);
    } else {
        log.error("Memory metadata/dump disk could not be added");
    }
}
#end_block

#method_before
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = runInternalAction(ActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId), cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        log.error("Failed to remove memory volumes '{}'", memoryVolume);
    }
}
#method_after
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    ActionReturnValue retVal = runInternalAction(ActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId), cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        log.error("Failed to remove memory volumes '{}'", memoryVolume);
    }
}
#end_block

#method_before
@Before
@SuppressWarnings("unchecked")
public void setupMocks() {
    vmInterfaceManager = spy(new VmInterfaceManager(macPool));
    doReturn(vmNetworkStatisticsDao).when(vmInterfaceManager).getVmNetworkStatisticsDao();
    doReturn(vmNicDao).when(vmInterfaceManager).getVmNicDao();
    doReturn(auditLogDirector).when(vmInterfaceManager).getAuditLogDirector();
    doNothing().when(vmInterfaceManager).removeFromExternalNetworks(anyList());
    injectorRule.bind(TransactionManager.class, transactionManager);
}
#method_after
@Before
@SuppressWarnings("unchecked")
public void setupMocks() {
    vmInterfaceManager = spy(new VmInterfaceManager(macPool));
    doReturn(vmNetworkStatisticsDao).when(vmInterfaceManager).getVmNetworkStatisticsDao();
    doReturn(vmNicDao).when(vmInterfaceManager).getVmNicDao();
    doReturn(auditLogDirector).when(vmInterfaceManager).getAuditLogDirector();
    doNothing().when(vmInterfaceManager).removeFromExternalNetworks(any());
    injectorRule.bind(TransactionManager.class, transactionManager);
}
#end_block

#method_before
@Test
public void add() {
    // TODO MMUCHA: Dear code reviewer! former reserve=false/assign=false, meant don't do anything with macs,
    // because it's manipulation was (duplicately) done beforehand. I moved that allocation inside of method add,
    // thus current false/false scenario does not exist-it's not possible & no one needs it. Therefore I'm changing
    // this test, to cover previously missing scenario. (Other previously-missing-in-tests scenarios disappeared with
    // refactoring, and some of still missing will disappear in next patch.)
    runAddAndVerify(createNewInterface(), true);
}
#method_after
@Test
public void add() {
    runAddAndVerify(createNewInterface(), true);
}
#end_block

#method_before
// TODO MMUCHA: Dear code reviewer!
// method: verifyAddDelegatedCorrectly was inlined because: 1 usage, duplicate verification of forceAddMac.
// having done that, we see duplicate verification, and see, that addMacVerification is dependent on
// reserveExistingMac, and it can be simplified and written explicitly, like times(1) in if clause on #114.
protected void runAddAndVerify(VmNic iface, boolean reassignMac) {
    if (!reassignMac) {
        // we need to mock successful addition of MAC to pool, otherwise error is thrown
        when(macPool.addMac(eq(iface.getMacAddress()))).thenReturn(true);
    }
    vmInterfaceManager.add(iface, NoOpCompensationContext.getInstance(), reassignMac);
    if (reassignMac) {
        verify(macPool).allocateNewMac();
    } else {
        verify(macPool).addMac(iface.getMacAddress());
    }
    verify(vmNicDao).save(iface);
    verify(vmNetworkStatisticsDao).save(iface.getStatistics());
}
#method_after
protected void runAddAndVerify(VmNic iface, boolean reassignMac) {
    if (!reassignMac) {
        // we need to mock successful addition of MAC to pool, otherwise error is thrown
        when(macPool.addMac(eq(iface.getMacAddress()))).thenReturn(true);
    }
    vmInterfaceManager.add(iface, NoOpCompensationContext.getInstance(), reassignMac);
    if (reassignMac) {
        verify(macPool).allocateNewMac();
    } else {
        verify(macPool).addMac(iface.getMacAddress());
    }
    verify(vmNicDao).save(iface);
    verify(vmNetworkStatisticsDao).save(iface.getStatistics());
}
#end_block

#method_before
@Test
public void removeAll() {
    List<VmNic> interfaces = Arrays.asList(createNewInterface(), createNewInterface());
    when(vmNicDao.getAllForVm(any(Guid.class))).thenReturn(interfaces);
    vmInterfaceManager.removeAllAndReleaseMacAddresses(Guid.newGuid());
    for (VmNic iface : interfaces) {
        verify(vmNicDao).remove(iface.getId());
        verify(vmNetworkStatisticsDao).remove(iface.getId());
    }
    verify(macPool).freeMacs(interfaces.stream().map(VmNic::getMacAddress).collect(Collectors.toList()));
}
#method_after
@Test
public void removeAll() {
    List<VmNic> interfaces = Arrays.asList(createNewInterface(), createNewInterface());
    when(vmNicDao.getAllForVm(any())).thenReturn(interfaces);
    vmInterfaceManager.removeAllAndReleaseMacAddresses(Guid.newGuid());
    for (VmNic iface : interfaces) {
        verify(vmNicDao).remove(iface.getId());
        verify(vmNetworkStatisticsDao).remove(iface.getId());
    }
    verify(macPool).freeMacs(interfaces.stream().map(VmNic::getMacAddress).collect(Collectors.toList()));
}
#end_block

#method_before
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    List<VmNetworkInterface> nicsUnableToBeImported = getVm().getInterfaces().stream().filter(this::ifaceMacCannotBeAddedToMacPool).collect(Collectors.toList());
    if (!nicsUnableToBeImported.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_ADD_IFACE_DUE_TO_MAC_DUPLICATES;
        Collection<String> replacements = ReplacementUtils.getListVariableAssignmentString(engineMessage, nicsUnableToBeImported);
        return validate(new ValidationResult(engineMessage, replacements));
    }
    return true;
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    // in the postConstruct phase.
    if (parameters.isImportAsNewEntity() && parameters.getVmId().equals(parameters.getVm().getId())) {
        parameters.getVm().setId(Guid.newGuid());
    }
    setClusterId(parameters.getClusterId());
    setVm(parameters.getVm());
    initEffectiveCompatibilityVersion();
}
#method_after
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    // in the postConstruct phase.
    if (parameters.isImportAsNewEntity() && parameters.getVmId().equals(parameters.getVm().getId())) {
        parameters.getVm().setId(Guid.newGuid());
    }
    setClusterId(parameters.getClusterId());
    setVm(parameters.getVm());
    if (parameters.getVm() != null) {
        setVmId(parameters.getVm().getId());
    }
    initEffectiveCompatibilityVersion();
}
#end_block

#method_before
protected List<DiskImage> createDiskDummiesForSpaceValidations(List<DiskImage> disksList) {
    List<DiskImage> dummies = new ArrayList<>(disksList.size());
    for (DiskImage image : disksList) {
        Guid targetSdId = imageToDestinationDomainMap.get(image.getId());
        DiskImage dummy = ImagesHandler.createDiskImageWithExcessData(image, targetSdId);
        dummies.add(dummy);
    }
    return dummies;
}
#method_after
protected List<DiskImage> createDiskDummiesForSpaceValidations(List<DiskImage> disksList) {
    List<DiskImage> dummies = new ArrayList<>(disksList.size());
    for (DiskImage image : disksList) {
        Guid targetSdId = imageToDestinationDomainMap.get(image.getId());
        DiskImage dummy = imagesHandler.createDiskImageWithExcessData(image, targetSdId);
        dummies.add(dummy);
    }
    return dummies;
}
#end_block

#method_before
protected void addVmToDb() {
    TransactionSupport.executeInNewTransaction(() -> {
        addVmStatic();
        addVmDynamic();
        addVmStatistics();
        addVmInterfaces();
        getCompensationContext().stateChanged();
        return null;
    });
}
#method_after
protected void addVmToDb() {
    TransactionSupport.executeInNewTransaction(() -> {
        addVmStatic();
        addVmDynamic();
        addVmStatistics();
        addVmInterfaces();
        addVmPermission();
        getCompensationContext().stateChanged();
        return null;
    });
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(macPool);
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getClusterId(), getStoragePoolId(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    if (!getParameters().isImportAsNewEntity() && isExternalMacsToBeReported()) {
        reportExternalMacs();
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        boolean reassignMac = shouldMacBeReassigned(iface) || getParameters().isImportAsNewEntity();
        vmInterfaceManager.add(iface, getCompensationContext(), reassignMac);
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(macPool);
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getClusterId(), getStoragePoolId(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    if (!getParameters().isImportAsNewEntity() && isExternalMacsToBeReported()) {
        reportExternalMacs();
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), shouldReassignMac(iface));
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#end_block

#method_before
private void registerIfaceInMacPool(VmNic iface, boolean reassignMac) {
    if (reassignMac) {
        iface.setMacAddress(macPool.allocateNewMac());
    } else {
        // TODO MMUCHA: Dear code reviewer! I really don't understand, why we checked getOsRepository().hasNicHotplugSupport here. But I think it's safe to remove it now. Please advise.
        if (!macPool.addMac(iface.getMacAddress())) {
            auditLogMacInUse(iface);
            throw new EngineException(EngineError.MAC_ADDRESS_IS_IN_USE);
        }
    }
}
#method_after
private void registerIfaceInMacPool(VmNic iface, boolean reassignMac) {
    if (reassignMac) {
        iface.setMacAddress(macPool.allocateNewMac());
    } else if (!macPool.addMac(iface.getMacAddress())) {
        auditLogMacInUse(iface);
        throw new EngineException(EngineError.MAC_ADDRESS_IS_IN_USE);
    }
}
#end_block

#method_before
protected void removeFromExternalNetworks(List<? extends VmNic> interfaces) {
    Transaction transaction = TransactionSupport.suspend();
    for (VmNic iface : interfaces) {
        new ExternalNetworkManager(iface).deallocateIfExternal();
    }
    TransactionSupport.resume(transaction);
}
#method_after
protected void removeFromExternalNetworks(List<? extends VmNic> interfaces) {
    Transaction transaction = TransactionSupport.suspend();
    for (VmNic iface : interfaces) {
        getExternalNetworkManagerFactory().create(iface).deallocateIfExternal();
    }
    TransactionSupport.resume(transaction);
}
#end_block

#method_before
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, SnapshotStatus.OK, "", null, compensationContext);
}
#method_after
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, SnapshotStatus.OK, "", null, null, compensationContext);
}
#end_block

#method_before
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, SnapshotStatus snapshotStatus, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, snapshotStatus, "", null, compensationContext);
}
#method_after
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, SnapshotStatus snapshotStatus, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, snapshotStatus, "", null, null, compensationContext);
}
#end_block

#method_before
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, String memoryVolume, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, SnapshotStatus.OK, memoryVolume, null, compensationContext);
}
#method_after
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, String memoryVolume, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, SnapshotStatus.OK, memoryVolume, null, null, compensationContext);
}
#end_block

#method_before
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, SnapshotStatus snapshotStatus, String memoryVolume, List<DiskImage> disks, final CompensationContext compensationContext) {
    return addSnapshot(snapshotId, "Active VM", snapshotStatus, SnapshotType.ACTIVE, vm, false, memoryVolume, disks, compensationContext);
}
#method_after
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, String memoryVolume, Date creationDate, List<DiskImage> disks, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, SnapshotStatus.OK, memoryVolume, creationDate, disks, compensationContext);
}
#end_block

#method_before
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, SnapshotStatus snapshotStatus, String memoryVolume, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, snapshotStatus, memoryVolume, null, compensationContext);
}
#method_after
public Snapshot addActiveSnapshot(Guid snapshotId, VM vm, SnapshotStatus snapshotStatus, String memoryVolume, final CompensationContext compensationContext) {
    return addActiveSnapshot(snapshotId, vm, snapshotStatus, memoryVolume, null, null, compensationContext);
}
#end_block

#method_before
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotType snapshotType, VM vm, String memoryVolume, final CompensationContext compensationContext) {
    return addSnapshot(snapshotId, description, SnapshotStatus.LOCKED, snapshotType, vm, true, memoryVolume, null, compensationContext);
}
#method_after
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotType snapshotType, VM vm, String memoryVolume, final CompensationContext compensationContext) {
    return addSnapshot(snapshotId, description, SnapshotStatus.LOCKED, snapshotType, vm, true, memoryVolume, null, null, compensationContext);
}
#end_block

#method_before
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotStatus snapshotStatus, SnapshotType snapshotType, VM vm, boolean saveVmConfiguration, String memoryVolume, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices, final CompensationContext compensationContext) {
    final Snapshot snapshot = new Snapshot(snapshotId, snapshotStatus, vm.getId(), saveVmConfiguration ? generateVmConfiguration(vm, disks, vmDevices) : null, snapshotType, description, new Date(), vm.getAppList(), memoryVolume, MemoryUtils.getMemoryDiskId(memoryVolume), MemoryUtils.getMetadataDiskId(memoryVolume));
    snapshotDao.save(snapshot);
    compensationContext.snapshotNewEntity(snapshot);
    return snapshot;
}
#method_after
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotStatus snapshotStatus, SnapshotType snapshotType, VM vm, boolean saveVmConfiguration, String memoryVolume, Date creationDate, List<DiskImage> disks, final CompensationContext compensationContext) {
    return addSnapshot(snapshotId, description, snapshotStatus, snapshotType, vm, saveVmConfiguration, memoryVolume, creationDate, disks, null, compensationContext);
}
#end_block

#method_before
protected String generateVmConfiguration(VM vm, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices) {
    if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(vmNetworkInterfaceDao.getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = vmTemplateDao.get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    if (vmDevices == null) {
        vmDeviceUtils.setVmDevices(vm.getStaticData());
    } else {
        vm.getStaticData().setManagedDeviceMap(vmDevices);
    }
    if (disks == null) {
        disks = DisksFilter.filterImageDisks(diskDao.getAllForVm(vm.getId()), ONLY_SNAPABLE, ONLY_ACTIVE);
        disks.addAll(ImagesHandler.getCinderLeafImages(diskDao.getAllForVm(vm.getId())));
    }
    populateDisksWithVmData(disks, vm.getId());
    disks.forEach(image -> image.setStorageIds(null));
    return ovfManager.exportVm(vm, new ArrayList<>(disks), ClusterUtils.getCompatibilityVersion(vm));
}
#method_after
protected String generateVmConfiguration(VM vm, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices) {
    if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(vmNetworkInterfaceDao.getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = vmTemplateDao.get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    if (vmDevices == null) {
        vmDeviceUtils.setVmDevices(vm.getStaticData());
    } else {
        vm.getStaticData().setManagedDeviceMap(vmDevices);
    }
    if (disks == null) {
        disks = DisksFilter.filterImageDisks(diskDao.getAllForVm(vm.getId()), ONLY_SNAPABLE, ONLY_ACTIVE);
        disks.addAll(imagesHandler.getCinderLeafImages(diskDao.getAllForVm(vm.getId())));
    }
    populateDisksWithVmData(disks, vm.getId());
    disks.forEach(image -> image.setStorageIds(null));
    return ovfManager.exportVm(vm, new ArrayList<>(disks), clusterUtils.getCompatibilityVersion(vm));
}
#end_block

#method_before
public void removeAllIllegalDisks(Guid snapshotId, Guid vmId) {
    for (DiskImage diskImage : diskImageDao.getAllSnapshotsForVmSnapshot(snapshotId)) {
        if (diskImage.getImageStatus() == ImageStatus.ILLEGAL) {
            ImagesHandler.removeDiskImage(diskImage, vmId);
        }
    }
}
#method_after
public void removeAllIllegalDisks(Guid snapshotId, Guid vmId) {
    for (DiskImage diskImage : diskImageDao.getAllSnapshotsForVmSnapshot(snapshotId)) {
        if (diskImage.getImageStatus() == ImageStatus.ILLEGAL) {
            imagesHandler.removeDiskImage(diskImage, vmId);
        }
    }
}
#end_block

#method_before
public void attempToRestoreVmConfigurationFromSnapshot(VM vm, Snapshot snapshot, Guid activeSnapshotId, List<DiskImage> images, CompensationContext compensationContext, DbUser user, VmInterfaceManager vmInterfaceManager, boolean withMemory) {
    boolean vmUpdatedFromConfiguration = false;
    if (snapshot.getVmConfiguration() != null) {
        vmUpdatedFromConfiguration = updateVmFromConfiguration(vm, snapshot.getVmConfiguration());
        if (images != null) {
            vmUpdatedFromConfiguration &= updateImagesByConfiguration(vm, images);
        }
    }
    if (!vmUpdatedFromConfiguration) {
        if (images == null) {
            images = diskImageDao.getAllSnapshotsForVmSnapshot(snapshot.getId());
        }
        vm.setImages(new ArrayList<>(images));
    }
    vm.setAppList(snapshot.getAppList());
    vmDynamicDao.update(vm.getDynamicData());
    synchronizeDisksFromSnapshot(vm.getId(), snapshot.getId(), activeSnapshotId, vm.getImages(), vm.getName());
    if (vmUpdatedFromConfiguration) {
        vmStaticDao.update(vm.getStaticData());
        synchronizeNics(vm, compensationContext, user, vmInterfaceManager);
        for (VmDevice vmDevice : vmDeviceDao.getVmDeviceByVmId(vm.getId())) {
            if (deviceCanBeRemoved(vmDevice)) {
                vmDeviceDao.remove(vmDevice.getId());
            }
        }
        vmDeviceUtils.addImportedDevices(vm.getStaticData(), false, withMemory);
    }
}
#method_after
public void attempToRestoreVmConfigurationFromSnapshot(VM vm, Snapshot snapshot, Guid activeSnapshotId, List<DiskImage> images, CompensationContext compensationContext, DbUser user, VmInterfaceManager vmInterfaceManager, boolean withMemory) {
    boolean vmUpdatedFromConfiguration = false;
    if (snapshot.getVmConfiguration() != null) {
        vmUpdatedFromConfiguration = updateVmFromConfiguration(vm, snapshot.getVmConfiguration());
        if (images != null) {
            vmUpdatedFromConfiguration &= updateImagesByConfiguration(vm, images);
        }
    }
    if (!vmUpdatedFromConfiguration) {
        if (images == null) {
            images = diskImageDao.getAllSnapshotsForVmSnapshot(snapshot.getId());
        }
        vm.setImages(new ArrayList<>(images));
    }
    vm.setAppList(snapshot.getAppList());
    vmDynamicDao.update(vm.getDynamicData());
    synchronizeDisksFromSnapshot(vm.getId(), snapshot.getId(), activeSnapshotId, vm.getImages(), vm.getName());
    if (vmUpdatedFromConfiguration) {
        vmStaticDao.update(vm.getStaticData());
        boolean macsInSnapshotAreExpectedToBeAlreadyAllocated = SnapshotType.STATELESS.equals(snapshot.getType());
        synchronizeNics(vm, compensationContext, user, vmInterfaceManager, macsInSnapshotAreExpectedToBeAlreadyAllocated);
        for (VmDevice vmDevice : vmDeviceDao.getVmDeviceByVmId(vm.getId())) {
            if (deviceCanBeRemoved(vmDevice)) {
                vmDeviceDao.remove(vmDevice.getId());
            }
        }
        vmDeviceUtils.addImportedDevices(vm.getStaticData(), false, withMemory);
    }
}
#end_block

#method_before
private void synchronizeNics(VM vm, CompensationContext compensationContext, DbUser user, VmInterfaceManager vmInterfaceManager) {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(vm.getClusterId(), vm.getStoragePoolId(), AuditLogType.IMPORTEXPORT_SNAPSHOT_VM_INVALID_INTERFACES);
    MacPool macPool = vmInterfaceManager.getMacPool();
    List<VmNic> dbNics = vmNicDao.getAllForVm(vm.getId());
    List<VmNetworkInterface> newNics = vm.getInterfaces();
    Map<String, Long> preexistingMacsUsageFrequency = countMacUsageFrequency(dbNics);
    Map<String, Long> macsFromRequestUsageFrequency = countMacUsageFrequency(newNics);
    vmInterfaceManager.removeAll(dbNics);
    releaseExtraMacs(macPool, preexistingMacsUsageFrequency, macsFromRequestUsageFrequency);
    for (VmNetworkInterface vmInterface : newNics) {
        vmInterface.setVmId(vm.getId());
        // These fields might not be saved in the OVF, so fill them with reasonable values.
        if (vmInterface.getId() == null) {
            vmInterface.setId(Guid.newGuid());
        }
        vnicProfileHelper.updateNicWithVnicProfileForUser(vmInterface, user);
        vmInterfaceManager.persistIface(vmInterface, compensationContext);
    }
    allocateMacsMissingInMacPool(macPool, preexistingMacsUsageFrequency, macsFromRequestUsageFrequency);
    vnicProfileHelper.auditInvalidInterfaces(vm.getName());
}
#method_after
private void synchronizeNics(VM snapshotedVm, CompensationContext compensationContext, DbUser user, VmInterfaceManager vmInterfaceManager, boolean macsInSnapshotAreExpectedToBeAlreadyAllocated) {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(snapshotedVm.getClusterId(), snapshotedVm.getStoragePoolId(), AuditLogType.IMPORTEXPORT_SNAPSHOT_VM_INVALID_INTERFACES);
    MacPool macPool = vmInterfaceManager.getMacPool();
    /*what is at moment of calling this in DB are data related to (stateless) VM being updated/overwritten by
         * snapshot data.
         */
    List<VmNic> dbNics = vmNicDao.getAllForVm(snapshotedVm.getId());
    /*
         * while snapshotedVm.getInterfaces() are interfaces taken from VM passed into here via parameter. This instance originates from same DB
         * record, but it was updated with ovf snapshot, so at the moment of calling this, VM is filled with data to
         * which we need to revert for example stateless VM being stopped.
         */
    new SyncMacsOfDbNicsWithSnapshot(macPool, auditLogDirector, macsInSnapshotAreExpectedToBeAlreadyAllocated).sync(dbNics, snapshotedVm.getInterfaces());
    vmInterfaceManager.removeAll(dbNics);
    for (VmNetworkInterface vmInterface : snapshotedVm.getInterfaces()) {
        vmInterface.setVmId(snapshotedVm.getId());
        // These fields might not be saved in the OVF, so fill them with reasonable values.
        if (vmInterface.getId() == null) {
            vmInterface.setId(Guid.newGuid());
        }
        vnicProfileHelper.updateNicWithVnicProfileForUser(vmInterface, user);
        vmInterfaceManager.persistIface(vmInterface, compensationContext);
    }
    vnicProfileHelper.auditInvalidInterfaces(snapshotedVm.getName());
}
#end_block

#method_before
protected void synchronizeDisksFromSnapshot(Guid vmId, Guid snapshotId, Guid activeSnapshotId, List<DiskImage> disksFromSnapshot, String vmName) {
    List<Guid> diskIdsFromSnapshot = new ArrayList<>();
    // Sync disks that exist or existed in the snapshot.
    int count = 1;
    for (DiskImage diskImage : disksFromSnapshot) {
        diskIdsFromSnapshot.add(diskImage.getId());
        if (baseDiskDao.exists(diskImage.getId())) {
            baseDiskDao.update(diskImage);
            DiskVmElement dve = diskVmElementDao.get(diskImage.getDiskVmElementForVm(vmId).getId());
            if (dve != null && !dve.equals(diskImage.getDiskVmElementForVm(vmId))) {
                diskVmElementDao.update(diskImage.getDiskVmElementForVm(vmId));
            }
        } else {
            // If can't find the image, insert it as illegal so that it can't be used and make the device unplugged.
            if (diskImageDao.getSnapshotById(diskImage.getImageId()) == null) {
                diskImage.setImageStatus(ImageStatus.ILLEGAL);
                diskImage.setVmSnapshotId(activeSnapshotId);
                ImagesHandler.addImage(diskImage, true, (diskImage.getStorageIds() == null) ? null : new ImageStorageDomainMap(diskImage.getImageId(), diskImage.getStorageIds().get(0), diskImage.getQuotaId(), diskImage.getDiskProfileId()));
            }
            ImagesHandler.addDiskToVm(diskImage, vmId);
        }
        diskImage.setDiskAlias(ImagesHandler.getSuggestedDiskAlias(diskImage, vmName, count));
        count++;
    }
    removeDisksNotInSnapshot(vmId, diskIdsFromSnapshot);
}
#method_after
protected void synchronizeDisksFromSnapshot(Guid vmId, Guid snapshotId, Guid activeSnapshotId, List<DiskImage> disksFromSnapshot, String vmName) {
    List<Guid> diskIdsFromSnapshot = new ArrayList<>();
    // Sync disks that exist or existed in the snapshot.
    int count = 1;
    for (DiskImage diskImage : disksFromSnapshot) {
        diskIdsFromSnapshot.add(diskImage.getId());
        if (baseDiskDao.exists(diskImage.getId())) {
            baseDiskDao.update(diskImage);
            DiskVmElement dve = diskVmElementDao.get(diskImage.getDiskVmElementForVm(vmId).getId());
            if (dve != null && !dve.equals(diskImage.getDiskVmElementForVm(vmId))) {
                diskVmElementDao.update(diskImage.getDiskVmElementForVm(vmId));
            }
        } else {
            // If can't find the image, insert it as illegal so that it can't be used and make the device unplugged.
            if (diskImageDao.getSnapshotById(diskImage.getImageId()) == null) {
                diskImage.setImageStatus(ImageStatus.ILLEGAL);
                diskImage.setVmSnapshotId(activeSnapshotId);
                imagesHandler.addImage(diskImage, true, (diskImage.getStorageIds() == null) ? null : new ImageStorageDomainMap(diskImage.getImageId(), diskImage.getStorageIds().get(0), diskImage.getQuotaId(), diskImage.getDiskProfileId()));
            }
            imagesHandler.addDiskToVm(diskImage, vmId);
        }
        diskImage.setDiskAlias(imagesHandler.getSuggestedDiskAlias(diskImage, vmName, count));
        count++;
    }
    removeDisksNotInSnapshot(vmId, diskIdsFromSnapshot);
}
#end_block

#method_before
public List<String> getMacsForMacPool(Guid macPoolId) {
    List<Guid> idsOfAllClustersHavingMacPool = getIdsOfAllClustersHavingMacPool(macPoolId);
    Map<Guid, VM> vmsById = idsOfAllClustersHavingMacPool.stream().flatMap(clusterId -> vmDao.getAllForCluster(clusterId).stream()).collect(Collectors.toMap(VM::getId, Function.identity()));
    // TODO MMUCHA: test filtering for runinng vm.
    Stream<Guid> idsOfRunningVMs = vmsById.values().stream().filter(VM::isRunning).map(VM::getId);
    Stream<VM> statelessSnapshotsOfRunningVMs = idsOfRunningVMs.map(snapshotsManager::getVmConfigurationInStatelessSnapshotOfVm).filter(Optional::isPresent).map(Optional::get);
    Map<Guid, List<VmNetworkInterface>> snapshottedInterfacesByVmId = statelessSnapshotsOfRunningVMs.collect(Collectors.toMap(VM::getId, VM::getInterfaces));
    List<String> macsToBeAllocated = vmsById.keySet().stream().flatMap(vmId -> calculateAllMacsUsedInVmAndItsSnapshot(vmsById.get(vmId).getInterfaces(), snapshottedInterfacesByVmId.get(vmId))).collect(Collectors.toList());
    return macsToBeAllocated;
}
#method_after
public List<String> getMacsForMacPool(Guid macPoolId) {
    List<Guid> idsOfAllClustersHavingMacPool = getIdsOfAllClustersHavingMacPool(macPoolId);
    Map<Guid, VM> vmsById = idsOfAllClustersHavingMacPool.stream().flatMap(clusterId -> vmDao.getAllForCluster(clusterId).stream()).collect(Collectors.toMap(VM::getId, Function.identity()));
    Stream<Guid> idsOfRunningStatelessVMs = vmsById.values().stream().filter(VM::isRunning).filter(VM::isStateless).map(VM::getId);
    Stream<VM> statelessSnapshotsOfRunningVMs = idsOfRunningStatelessVMs.map(snapshotsManager::getVmConfigurationInStatelessSnapshotOfVm).filter(Optional::isPresent).map(Optional::get);
    Map<Guid, List<VmNetworkInterface>> snapshottedInterfacesByVmId = statelessSnapshotsOfRunningVMs.collect(Collectors.toMap(VM::getId, VM::getInterfaces));
    List<String> macsToBeAllocated = vmsById.keySet().stream().flatMap(vmId -> calculateAllMacsUsedInVmAndItsSnapshot(vmsById.get(vmId).getInterfaces(), snapshottedInterfacesByVmId.get(vmId))).collect(Collectors.toList());
    return macsToBeAllocated;
}
#end_block

#method_before
private Stream<String> calculateAllMacsUsedInVmAndItsSnapshot(List<VmNetworkInterface> vmInterfaces, List<VmNetworkInterface> snapshotInterfaces) {
    Map<Guid, String> vmNicToMacMapping = nicIdToMacMapping(vmInterfaces);
    Map<Guid, String> snapshotNicToMacMapping = nicIdToMacMapping(snapshotInterfaces);
    Stream<Guid> idsOfVmInterfaces = Stream.of(vmNicToMacMapping, snapshotNicToMacMapping).flatMap(e -> e.keySet().stream()).distinct();
    Stream<String> allMacsForThisNic = idsOfVmInterfaces.flatMap(id -> macsOnCurrentAndSnapshottedInterface(vmNicToMacMapping.get(id), snapshotNicToMacMapping.get(id)));
    return allMacsForThisNic;
}
#method_after
private Stream<String> calculateAllMacsUsedInVmAndItsSnapshot(List<VmNetworkInterface> vmInterfaces, List<VmNetworkInterface> snapshotInterfaces) {
    CountMacUsageDifference countMacUsageDifference = new CountMacUsageDifference(macAddressesOfInterfaces(snapshotInterfaces), macAddressesOfInterfaces(vmInterfaces));
    Stream<String> macsDuplicatedByNumberOfTimesTheyAreUsed = countMacUsageDifference.maxUsage().entrySet().stream().flatMap(entry -> LongStream.range(0, entry.getValue()).boxed().map(e -> entry.getKey()));
    return macsDuplicatedByNumberOfTimesTheyAreUsed;
}
#end_block

#method_before
@Test
public void testGetMacsForMacPool() {
    MacPool macPool = createMacPool();
    String mac1 = "mac1";
    String mac2 = "mac2";
    String mac31 = "mac31";
    String mac32 = "mac32";
    String mac41 = "mac41";
    String mac42 = "mac42";
    Cluster cluster1 = createCluster(macPool);
    VmNetworkInterface nic1 = createNic(mac1);
    VM vm1 = createVm(cluster1, nic1);
    Cluster cluster2 = createCluster(macPool);
    VmNetworkInterface nic2 = createNic(mac2);
    VmNetworkInterface nic2_fromSnapshot = createNic(mac2, nic2.getId());
    VM vm2 = createVm(cluster2, nic2);
    VM snapshot2 = createSnapshot(cluster2, vm2, nic2_fromSnapshot);
    Cluster cluster3 = createCluster(macPool);
    Guid nic3Id = Guid.newGuid();
    VmNetworkInterface nic3 = createNic(mac31, nic3Id);
    VM vm3 = createVm(cluster3, nic3);
    VmNetworkInterface nic3_fromSnapshot = createNic(mac32, nic3Id);
    VM snapshot3 = createSnapshot(cluster3, vm3, nic3_fromSnapshot);
    Cluster cluster4 = createCluster(macPool);
    VmNetworkInterface nic41 = createNic(mac41);
    VmNetworkInterface nic41_fromSnapshot = createNic(mac41);
    VmNetworkInterface nic42 = createNic(mac42);
    VM vm4 = createVm(cluster4, nic41, nic42);
    VM snapshot4 = createSnapshot(cluster4, vm4, nic41_fromSnapshot);
    // mocking:
    when(clusterDao.getAllClustersByMacPoolId(macPool.getId())).thenReturn(Arrays.asList(cluster1, cluster2, cluster3, cluster4));
    when(vmDao.getAllForCluster(cluster1.getId())).thenReturn(Collections.singletonList(vm1));
    when(vmDao.getAllForCluster(cluster2.getId())).thenReturn(Collections.singletonList(vm2));
    when(vmDao.getAllForCluster(cluster3.getId())).thenReturn(Collections.singletonList(vm3));
    when(vmDao.getAllForCluster(cluster4.getId())).thenReturn(Collections.singletonList(vm4));
    when(snapshotsManager.getVmConfigurationInStatelessSnapshotOfVm(vm1.getId())).thenReturn(Optional.empty());
    when(snapshotsManager.getVmConfigurationInStatelessSnapshotOfVm(vm2.getId())).thenReturn(Optional.of(snapshot2));
    when(snapshotsManager.getVmConfigurationInStatelessSnapshotOfVm(vm3.getId())).thenReturn(Optional.of(snapshot3));
    when(snapshotsManager.getVmConfigurationInStatelessSnapshotOfVm(vm4.getId())).thenReturn(Optional.of(snapshot4));
    // verifying
    List<String> macsForMacPool = underTest.getMacsForMacPool(macPool.getId());
    assertThat(macsForMacPool, Matchers.containsInAnyOrder(mac1, mac2, mac31, mac32, mac41, mac41, mac42));
}
#method_after
@Test
public void testGetMacsForMacPool() {
    MacPool macPool = createMacPool();
    String mac1 = "mac1";
    String mac2 = "mac2";
    String mac31 = "mac31";
    String mac32 = "mac32";
    String mac41 = "mac41";
    String mac42 = "mac42";
    String mac51 = "mac51";
    String mac52 = "mac52";
    String mac61 = "mac61";
    String mac62 = "mac62";
    String mac7 = "mac7";
    String mac8 = "mac8";
    Cluster cluster1 = createCluster(macPool);
    VmNetworkInterface nic1 = createNic(mac1);
    VM vm1 = createVm(cluster1, nic1);
    Cluster cluster2 = createCluster(macPool);
    VmNetworkInterface nic2 = createNic(mac2);
    VmNetworkInterface nic2_fromSnapshot = createNic(mac2, nic2.getId());
    VM vm2 = createVm(cluster2, nic2);
    VM snapshot2 = createSnapshot(cluster2, vm2, nic2_fromSnapshot);
    Cluster cluster3 = createCluster(macPool);
    Guid nic3Id = Guid.newGuid();
    VmNetworkInterface nic3 = createNic(mac31, nic3Id);
    VM vm3 = createVm(cluster3, nic3);
    VmNetworkInterface nic3_fromSnapshot = createNic(mac32, nic3Id);
    VM snapshot3 = createSnapshot(cluster3, vm3, nic3_fromSnapshot);
    Cluster cluster4 = createCluster(macPool);
    VmNetworkInterface nic41 = createNic(mac42);
    VmNetworkInterface nic41_fromSnapshot = createNic(mac41);
    VmNetworkInterface nic42 = createNic(mac41);
    VM vm4 = createVm(cluster4, nic41, nic42);
    VM snapshot4 = createSnapshot(cluster4, vm4, nic41_fromSnapshot);
    Cluster cluster5 = createCluster(macPool);
    VmNetworkInterface nic5 = createNic(mac51);
    VmNetworkInterface nic5_fromSnapshot = createNic(mac52);
    VM notRunningVm = createVm(cluster5, Guid.newGuid(), false, true, nic5);
    VM snapshot5 = createSnapshot(cluster5, notRunningVm, nic5_fromSnapshot);
    VmNetworkInterface nic6 = createNic(mac61);
    VmNetworkInterface nic6_fromSnapshot = createNic(mac62);
    VM notStatelessVm = createVm(cluster5, Guid.newGuid(), true, false, nic6);
    VM snapshot6 = createSnapshot(cluster5, notStatelessVm, nic6_fromSnapshot);
    Cluster cluster6 = createCluster(macPool);
    VmNetworkInterface nic71 = createNic(mac7);
    VmNetworkInterface nic72 = createNic(mac7);
    VM vmWithDuplicates = createVm(cluster6, nic71, nic72);
    VmNetworkInterface nic81 = createNic(mac8);
    VmNetworkInterface nic82 = createNic(mac8);
    VmNetworkInterface nic83 = createNic(mac8);
    VM vmHavingSnapshotWithDuplicates = createVm(cluster6, nic83);
    VM snapshot7 = createSnapshot(cluster6, vmHavingSnapshotWithDuplicates, nic81, nic82);
    // mocking:
    when(clusterDao.getAllClustersByMacPoolId(macPool.getId())).thenReturn(Arrays.asList(cluster1, cluster2, cluster3, cluster4, cluster5, cluster6));
    mockClusterVms(cluster1, vm1);
    mockClusterVms(cluster2, vm2);
    mockClusterVms(cluster3, vm3);
    mockClusterVms(cluster4, vm4);
    mockClusterVms(cluster5, notRunningVm, notStatelessVm);
    mockClusterVms(cluster6, vmWithDuplicates, vmHavingSnapshotWithDuplicates);
    mockVmSnapshots(vm1, Optional.empty());
    mockVmSnapshots(vm2, Optional.of(snapshot2));
    mockVmSnapshots(vm3, Optional.of(snapshot3));
    mockVmSnapshots(vm4, Optional.of(snapshot4));
    mockVmSnapshots(notRunningVm, Optional.of(snapshot5));
    mockVmSnapshots(notStatelessVm, Optional.of(snapshot6));
    mockVmSnapshots(vmHavingSnapshotWithDuplicates, Optional.of(snapshot7));
    // verifying
    List<String> macsForMacPool = underTest.getMacsForMacPool(macPool.getId());
    assertThat(macsForMacPool, Matchers.containsInAnyOrder(mac1, mac2, mac31, mac32, mac41, mac42, mac51, mac61, mac7, mac7, mac8, mac8));
}
#end_block

#method_before
private VM createSnapshot(Cluster cluster, VM vm, VmNetworkInterface nic) {
    VM vm1 = new VM();
    vm1.setId(vm.getId());
    vm1.setInterfaces(new ArrayList<>(Arrays.asList(nic)));
    vm1.setClusterId(cluster.getId());
    return vm1;
}
#method_after
private VM createSnapshot(Cluster cluster, VM vm, VmNetworkInterface... nic) {
    VM vm1 = new VM();
    vm1.setId(vm.getId());
    vm1.setInterfaces(new ArrayList<>(Arrays.asList(nic)));
    vm1.setClusterId(cluster.getId());
    return vm1;
}
#end_block

#method_before
private VM createVm(Cluster cluster, Guid vmId, VmNetworkInterface... nics) {
    VM vm = new VM();
    vm.setId(vmId);
    vm.setInterfaces(new ArrayList<>(Arrays.asList(nics)));
    vm.setClusterId(cluster.getId());
    vm.setStatus(VMStatus.Up);
    return vm;
}
#method_after
private VM createVm(Cluster cluster, Guid vmId, VmNetworkInterface... nics) {
    return createVm(cluster, vmId, true, true, nics);
}
#end_block

#method_before
private VM createVm(Cluster cluster, Guid vmId, VmNetworkInterface... nics) {
    VM vm = new VM();
    vm.setId(vmId);
    vm.setInterfaces(new ArrayList<>(Arrays.asList(nics)));
    vm.setClusterId(cluster.getId());
    vm.setStatus(VMStatus.Up);
    return vm;
}
#method_after
private VM createVm(Cluster cluster, Guid vmId, boolean running, boolean stateless, VmNetworkInterface... nics) {
    VM vm = new VM();
    vm.setId(vmId);
    vm.setInterfaces(new ArrayList<>(Arrays.asList(nics)));
    vm.setClusterId(cluster.getId());
    vm.setStatus(running ? VMStatus.Up : VMStatus.Down);
    vm.setStateless(stateless);
    return vm;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    injectorRule.bind(AuditLogDirector.class, auditLogDirector);
    commandContext = CommandContext.createContext(SESSION_ID);
    macPool = createMacPool(MAC_FROM, MAC_TO);
    cluster = createCluster(macPool);
    vmNic = createVmNic();
    when(decoratedMacPoolFactory.createDecoratedPool(any(org.ovirt.engine.core.bll.network.macpool.MacPool.class), anyList())).thenAnswer(invocation -> invocation.getArguments()[0]);
    mockUsedMacsInSystem(macPool.getId());
    macPoolPerCluster = new MacPoolPerCluster(macPoolDao, clusterDao, macPoolFactory, decoratedMacPoolFactory);
}
#method_after
@Before
public void setUp() throws Exception {
    injectorRule.bind(AuditLogDirector.class, auditLogDirector);
    commandContext = CommandContext.createContext(SESSION_ID);
    macPool = createMacPool(MAC_FROM, MAC_TO);
    cluster = createCluster(macPool);
    vmNic = createVmNic();
    when(decoratedMacPoolFactory.createDecoratedPool(any(), any())).thenAnswer(AdditionalAnswers.returnsFirstArg());
    mockUsedMacsInSystem(macPool.getId());
    macPoolPerCluster = new MacPoolPerCluster(macPoolDao, clusterDao, macPoolFactory, decoratedMacPoolFactory);
}
#end_block

#method_before
public Response add(Disk disk) {
    @Deprecated
    boolean // unregistered support for add disk has moved to BackendAttachedStorageDomainDiskResource (version 4.2).
    unregistered = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, UNREGISTERED, true, false);
    if (unregistered) {
        // First we need to query the backend to fill in all the information about the disk from the VDSM.
        // We don't just use the information from the Disk object because it's missing a few things like creation
        // date and last modified date.
        Guid dataCenterId = BackendDataCenterHelper.lookupByStorageDomainId(this, storageDomainId);
        GetUnregisteredDiskQueryParameters getDiskParams = new GetUnregisteredDiskQueryParameters(asGuid(disk.getId()), storageDomainId, dataCenterId);
        DiskImage unregisteredDisk = getEntity(DiskImage.class, QueryType.GetUnregisteredDisk, getDiskParams, disk.getId());
        unregisteredDisk = (DiskImage) getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.storage.Disk.class).map(disk, unregisteredDisk);
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(unregisteredDisk, storageDomainId);
        return performCreate(ActionType.RegisterDisk, registerDiskParams, ID_RESOLVER);
    } else {
        validateDiskForCreation(disk);
        AddDiskParameters params = new AddDiskParameters();
        params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.storage.Disk.class).map(disk, null));
        params.setStorageDomainId(this.storageDomainId);
        return performCreate(ActionType.AddDisk, params, ID_RESOLVER);
    }
}
#method_after
public Response add(Disk disk) {
    // Unregistering a disk using this method was deprecated in version 4.2
    // unregistered support for add disk has moved to BackendAttachedStorageDomainDiskResource..
    boolean unregistered = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, UNREGISTERED, true, false);
    if (unregistered) {
        // First we need to query the backend to fill in all the information about the disk from the VDSM.
        // We don't just use the information from the Disk object because it's missing a few things like creation
        // date and last modified date.
        Guid dataCenterId = BackendDataCenterHelper.lookupByStorageDomainId(this, storageDomainId);
        GetUnregisteredDiskQueryParameters getDiskParams = new GetUnregisteredDiskQueryParameters(asGuid(disk.getId()), storageDomainId, dataCenterId);
        DiskImage unregisteredDisk = getEntity(DiskImage.class, QueryType.GetUnregisteredDisk, getDiskParams, disk.getId());
        unregisteredDisk = (DiskImage) getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.storage.Disk.class).map(disk, unregisteredDisk);
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(unregisteredDisk, storageDomainId);
        return performCreate(ActionType.RegisterDisk, registerDiskParams, ID_RESOLVER);
    } else {
        validateDiskForCreation(disk);
        AddDiskParameters params = new AddDiskParameters();
        params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.storage.Disk.class).map(disk, null));
        params.setStorageDomainId(this.storageDomainId);
        return performCreate(ActionType.AddDisk, params, ID_RESOLVER);
    }
}
#end_block

#method_before
@PostConstruct
private void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    pollingRate = Config.<Integer>getValue(ConfigValues.AsyncCommandPollingLoopInSeconds);
    initCommandExecutor();
    executor.scheduleWithFixedDelay(() -> invokeCallbackMethods(), pollingRate, pollingRate, TimeUnit.SECONDS);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#method_after
@PostConstruct
private void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    pollingRate = Config.<Integer>getValue(ConfigValues.AsyncCommandPollingLoopInSeconds);
    initCommandExecutor();
    executor.scheduleWithFixedDelay(this::invokeCallbackMethods, pollingRate, pollingRate, TimeUnit.SECONDS);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
public void invokeCallbackMethods() {
    Iterator<Entry<Guid, CallbackTiming>> iterator = commandsRepository.getCallbacksTiming().entrySet().iterator();
    while (iterator.hasNext()) {
        Entry<Guid, CallbackTiming> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CallbackTiming callbackTiming = entry.getValue();
        CommandEntity commandEntity = commandsRepository.getCommandEntity(cmdId);
        CorrelationIdTracker.setCorrelationId(commandEntity != null ? commandEntity.getCommandParameters().getCorrelationId() : null);
        if (commandEntity != null && updateCommandWaitingForEvent(commandEntity, callbackTiming)) {
            continue;
        }
        // Decrement counter; execute if it reaches 0
        callbackTiming.setRemainingDelay(callbackTiming.getRemainingDelay() - pollingRate);
        if (callbackTiming.getRemainingDelay() > 0) {
            continue;
        }
        CommandCallback callback = callbackTiming.getCallback();
        CommandStatus status = commandsRepository.getCommandStatus(cmdId);
        boolean runCallbackAgain = false;
        boolean errorInCallback = false;
        try {
            switch(status) {
                case FAILED:
                case SUCCEEDED:
                    runCallbackAgain = endCallback(cmdId, callback, status);
                    break;
                case ACTIVE:
                    if (commandEntity != null && commandEntity.isExecuted()) {
                        callback.doPolling(cmdId, getChildCommandIds(cmdId));
                    }
                    break;
                case EXECUTION_FAILED:
                    if (callback.pollOnExecutionFailed()) {
                        callback.doPolling(cmdId, getChildCommandIds(cmdId));
                    }
                    break;
                default:
                    break;
            }
        } catch (Exception ex) {
            errorInCallback = true;
            handleError(ex, status, cmdId);
        } finally {
            if ((CommandStatus.FAILED == status || (CommandStatus.SUCCEEDED == status && !errorInCallback)) && !runCallbackAgain) {
                commandsRepository.updateCallbackNotified(cmdId);
                iterator.remove();
                CommandEntity cmdEntity = commandsRepository.getCommandEntity(entry.getKey());
                if (cmdEntity != null) {
                    // When a child finishes, its parent's callback should execute shortly thereafter
                    CallbackTiming rootCmdContainer = commandsRepository.getCallbackTiming(cmdEntity.getRootCommandId());
                    if (rootCmdContainer != null) {
                        rootCmdContainer.setInitialDelay(pollingRate);
                        rootCmdContainer.setRemainingDelay(pollingRate);
                    }
                }
            } else if (status != commandsRepository.getCommandStatus(cmdId)) {
                callbackTiming.setInitialDelay(pollingRate);
                callbackTiming.setRemainingDelay(pollingRate);
            } else {
                int maxDelay = Config.<Integer>getValue(ConfigValues.AsyncCommandPollingRateInSeconds);
                callbackTiming.setInitialDelay(Math.min(maxDelay, callbackTiming.getInitialDelay() * 2));
                callbackTiming.setRemainingDelay(callbackTiming.getInitialDelay());
            }
        }
    }
    CorrelationIdTracker.setCorrelationId(null);
    commandsRepository.markExpiredCommandsAsFailure();
}
#method_after
private void invokeCallbackMethods() {
    try {
        invokeCallbackMethodsImpl();
    } catch (Throwable t) {
        log.error("Exception in invokeCallbackMethods: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
private void init(CommandCoordinator coco) {
    this.coco = coco;
    _tasks = new ConcurrentHashMap<>();
    executor.scheduleWithFixedDelay(() -> timerElapsed(), Config.<Integer>getValue(ConfigValues.AsyncTaskPollingRate), Config.<Integer>getValue(ConfigValues.AsyncTaskPollingRate), TimeUnit.SECONDS);
    executor.scheduleWithFixedDelay(() -> cacheTimerElapsed(), Config.<Integer>getValue(ConfigValues.AsyncTaskStatusCacheRefreshRateInSeconds), Config.<Integer>getValue(ConfigValues.AsyncTaskStatusCacheRefreshRateInSeconds), TimeUnit.SECONDS);
}
#method_after
@PostConstruct
private void init() {
    cacheTimeInMinutes = Config.<Integer>getValue(ConfigValues.AsyncTaskStatusCachingTimeInMinutes);
    tasks = new ConcurrentHashMap<>();
    schedulerService.scheduleWithFixedDelay(this::timerElapsed, Config.<Integer>getValue(ConfigValues.AsyncTaskPollingRate), Config.<Integer>getValue(ConfigValues.AsyncTaskPollingRate), TimeUnit.SECONDS);
    schedulerService.scheduleWithFixedDelay(this::cacheTimerElapsed, Config.<Integer>getValue(ConfigValues.AsyncTaskStatusCacheRefreshRateInSeconds), Config.<Integer>getValue(ConfigValues.AsyncTaskStatusCacheRefreshRateInSeconds), TimeUnit.SECONDS);
    initAsyncTaskManager();
}
#end_block

#method_before
public synchronized void timerElapsed() {
    if (thereAreTasksToPoll()) {
        pollAndUpdateAsyncTasks();
        if (thereAreTasksToPoll() && logChangedMap) {
            log.info("Finished polling Tasks, will poll again in {} seconds.", Config.<Integer>getValue(ConfigValues.AsyncTaskPollingRate));
            // Set indication to false for not logging the same message next
            // time.
            logChangedMap = false;
        }
        // check for zombie tasks
        if (_tasks.size() > 0) {
            cleanZombieTasks();
        }
    }
}
#method_after
private synchronized void timerElapsed() {
    try {
        timerElapsedImpl();
    } catch (Throwable t) {
        log.error("Exception in timerElapsed: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
public void cacheTimerElapsed() {
    removeClearedAndOldTasks();
}
#method_after
private void cacheTimerElapsed() {
    try {
        removeClearedAndOldTasks();
    } catch (Throwable t) {
        log.error("Exception in cacheTimerElapsed: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
public synchronized boolean cachingOver(SPMTask task) {
    // Get time in milliseconds that the task should be cached
    long SubtractMinutesAsMills = TimeUnit.MINUTES.toMillis(_cacheTimeInMinutes);
    // for SubtractMinutesAsMills of minutes.
    return (task.getState() == AsyncTaskState.Cleared || task.getState() == AsyncTaskState.ClearFailed) && task.getLastAccessToStatusSinceEnd() < (System.currentTimeMillis() - SubtractMinutesAsMills);
}
#method_after
public synchronized boolean cachingOver(SPMTask task) {
    // Get time in milliseconds that the task should be cached
    long SubtractMinutesAsMills = TimeUnit.MINUTES.toMillis(cacheTimeInMinutes);
    // for SubtractMinutesAsMills of minutes.
    return (task.getState() == AsyncTaskState.Cleared || task.getState() == AsyncTaskState.ClearFailed) && task.getLastAccessToStatusSinceEnd() < (System.currentTimeMillis() - SubtractMinutesAsMills);
}
#end_block

#method_before
public synchronized boolean hasTasksByStoragePoolId(Guid storagePoolID) {
    boolean retVal = false;
    if (_tasks != null) {
        for (SPMTask task : _tasks.values()) {
            if (task.getStoragePoolID().equals(storagePoolID)) {
                retVal = true;
                break;
            }
        }
    }
    return retVal;
}
#method_after
public synchronized boolean hasTasksByStoragePoolId(Guid storagePoolID) {
    boolean retVal = false;
    if (tasks != null) {
        for (SPMTask task : tasks.values()) {
            if (task.getStoragePoolID().equals(storagePoolID)) {
                retVal = true;
                break;
            }
        }
    }
    return retVal;
}
#end_block

#method_before
public synchronized boolean hasTasksForEntityIdAndAction(Guid id, VdcActionType type) {
    if (_tasks != null) {
        for (SPMTask task : _tasks.values()) {
            if (isCurrentTaskLookedFor(id, task) && type.equals(task.getParameters().getDbAsyncTask().getActionType())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
public synchronized boolean hasTasksForEntityIdAndAction(Guid id, ActionType type) {
    if (tasks != null) {
        for (SPMTask task : tasks.values()) {
            if (isCurrentTaskLookedFor(id, task) && type.equals(task.getParameters().getDbAsyncTask().getActionType())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
public void handlePartiallyExecuteTasksOfCommand(final List<AsyncTask> tasks) {
    ThreadPoolUtil.execute(new Runnable() {

        @SuppressWarnings("synthetic-access")
        @Override
        public void run() {
            TransactionSupport.executeInNewTransaction(() -> {
                try {
                    for (AsyncTask task : tasks) {
                        handlePartiallyExecutedTaskOfCommand(task);
                    }
                    return null;
                } finally {
                    irsBrokerLatch.countDown();
                }
            });
        }
    });
}
#method_after
public void handlePartiallyExecuteTasksOfCommand(final List<AsyncTask> tasks) {
    ThreadPoolUtil.execute(() -> TransactionSupport.executeInNewTransaction(() -> {
        try {
            for (AsyncTask task : tasks) {
                handlePartiallyExecutedTaskOfCommand(task);
            }
            return null;
        } finally {
            irsBrokerLatch.countDown();
        }
    }));
}
#end_block

#method_before
public void logAndFailPartiallySubmittedTaskOfCommand(final AsyncTask task, String message) {
    log.info("Failing partially submitted task AsyncTaskType '{}': Task '{}' Parent Command '{}'", task.getTaskType(), task.getTaskId(), task.getActionType());
    task.getTaskParameters().setTaskGroupSuccess(false);
    if (task.getActionType() == VdcActionType.Unknown) {
        removeTaskFromDbByTaskId(task.getTaskId());
        log.info("Not calling endAction for partially submitted task and AsyncTaskType '{}': Task '{}' Parent Command '{}'", task.getTaskType(), task.getTaskId(), task.getActionType());
        return;
    }
    log.info("Calling updateTask for partially submitted task and AsyncTaskType '{}': Task '{}' Parent Command" + " '{}' Parameters class '{}'", task.getTaskType(), task.getTaskId(), task.getActionType());
    AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo(Guid.Empty, task.getTaskType(), task.getStoragePoolId());
    SPMTask spmTask = coco.construct(creationInfo, task);
    AsyncTaskStatus failureStatus = new AsyncTaskStatus();
    failureStatus.setStatus(AsyncTaskStatusEnum.finished);
    failureStatus.setResult(AsyncTaskResultEnum.failure);
    failureStatus.setMessage(message);
    spmTask.setState(AsyncTaskState.Ended);
    spmTask.setLastTaskStatus(failureStatus);
    spmTask.updateTask(failureStatus);
}
#method_after
public void logAndFailPartiallySubmittedTaskOfCommand(final AsyncTask task, String message) {
    log.info("Failing partially submitted task AsyncTaskType '{}': Task '{}' Parent Command '{}'", task.getTaskType(), task.getTaskId(), task.getActionType());
    task.getTaskParameters().setTaskGroupSuccess(false);
    if (task.getActionType() == ActionType.Unknown) {
        removeTaskFromDbByTaskId(task.getTaskId());
        log.info("Not calling endAction for partially submitted task and AsyncTaskType '{}': Task '{}' Parent Command '{}'", task.getTaskType(), task.getTaskId(), task.getActionType());
        return;
    }
    log.info("Calling updateTask for partially submitted task and AsyncTaskType '{}': Task '{}' Parent Command" + " '{}' Parameters class '{}'", task.getTaskType(), task.getTaskId(), task.getActionType());
    AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo(Guid.Empty, task.getTaskType(), task.getStoragePoolId());
    SPMTask spmTask = coco.construct(creationInfo, task);
    AsyncTaskStatus failureStatus = new AsyncTaskStatus();
    failureStatus.setStatus(AsyncTaskStatusEnum.finished);
    failureStatus.setResult(AsyncTaskResultEnum.failure);
    failureStatus.setMessage(message);
    spmTask.setState(AsyncTaskState.Ended);
    spmTask.setLastTaskStatus(failureStatus);
    spmTask.updateTask(failureStatus);
}
#end_block

#method_before
public static void removeTaskFromDbByTaskId(Guid taskId) {
    try {
        if (CommandCoordinatorUtil.callRemoveTaskFromDbByTaskId(taskId) != 0) {
            log.info("Removed task '{}' from DataBase", taskId);
        }
    } catch (RuntimeException e) {
        log.error("Removing task '{}' from DataBase threw an exception: {}", taskId, e.getMessage());
        log.debug("Exception", e);
    }
}
#method_after
public void removeTaskFromDbByTaskId(Guid taskId) {
    try {
        if (coco.removeTaskFromDbByTaskId(taskId) != 0) {
            log.info("Removed task '{}' from DataBase", taskId);
        }
    } catch (RuntimeException e) {
        log.error("Removing task '{}' from DataBase threw an exception: {}", taskId, e.getMessage());
        log.debug("Exception", e);
    }
}
#end_block

#method_before
private void cleanZombieTasks() {
    long maxTime = DateTime.getNow().addMinutes(-1 * Config.<Integer>getValue(ConfigValues.AsyncTaskZombieTaskLifeInMinutes)).getTime();
    for (SPMTask task : _tasks.values()) {
        if (task.getParameters().getDbAsyncTask().getStartTime().getTime() < maxTime) {
            AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
            logable.addCustomValue("CommandName", task.getParameters().getDbAsyncTask().getActionType().toString());
            logable.addCustomValue("Date", task.getParameters().getDbAsyncTask().getStartTime().toString());
            // status
            if (task.getLastTaskStatus().getStatus() != AsyncTaskStatusEnum.finished && task.getLastTaskStatus().getStatus() != AsyncTaskStatusEnum.unknown) {
                // mark it as a zombie task, Will result in failure of the command
                task.setZombieTask(true);
                auditLogDirector.log(logable, AuditLogType.TASK_STOPPING_ASYNC_TASK);
                log.info("Cleaning zombie tasks: Stopping async task '{}' that started at '{}'", task.getParameters().getDbAsyncTask().getActionType(), task.getParameters().getDbAsyncTask().getStartTime());
                task.stopTask(true);
            } else {
                auditLogDirector.log(logable, AuditLogType.TASK_CLEARING_ASYNC_TASK);
                log.info("Cleaning zombie tasks: Clearing async task '{}' that started at '{}'", task.getParameters().getDbAsyncTask().getActionType(), task.getParameters().getDbAsyncTask().getStartTime());
                task.clearAsyncTask(true);
            }
        }
    }
}
#method_after
private void cleanZombieTasks() {
    long maxTime = DateTime.getNow().addMinutes(-1 * Config.<Integer>getValue(ConfigValues.AsyncTaskZombieTaskLifeInMinutes)).getTime();
    for (SPMTask task : tasks.values()) {
        if (task.getParameters().getDbAsyncTask().getStartTime().getTime() < maxTime) {
            AuditLogable logable = new AuditLogableImpl();
            logable.addCustomValue("CommandName", task.getParameters().getDbAsyncTask().getActionType().toString());
            logable.addCustomValue("Date", task.getParameters().getDbAsyncTask().getStartTime().toString());
            // status
            if (task.getLastTaskStatus().getStatus() != AsyncTaskStatusEnum.finished && task.getLastTaskStatus().getStatus() != AsyncTaskStatusEnum.unknown) {
                // mark it as a zombie task, Will result in failure of the command
                task.setZombieTask(true);
                auditLogDirector.log(logable, AuditLogType.TASK_STOPPING_ASYNC_TASK);
                log.info("Cleaning zombie tasks: Stopping async task '{}' that started at '{}'", task.getParameters().getDbAsyncTask().getActionType(), task.getParameters().getDbAsyncTask().getStartTime());
                task.stopTask(true);
            } else {
                auditLogDirector.log(logable, AuditLogType.TASK_CLEARING_ASYNC_TASK);
                log.info("Cleaning zombie tasks: Clearing async task '{}' that started at '{}'", task.getParameters().getDbAsyncTask().getActionType(), task.getParameters().getDbAsyncTask().getStartTime());
                task.clearAsyncTask(true);
            }
        }
    }
}
#end_block

#method_before
private int numberOfTasksToPoll() {
    int retValue = 0;
    for (SPMTask task : _tasks.values()) {
        if (task.getShouldPoll()) {
            retValue++;
        }
    }
    return retValue;
}
#method_after
private int numberOfTasksToPoll() {
    int retValue = 0;
    for (SPMTask task : tasks.values()) {
        if (task.getShouldPoll()) {
            retValue++;
        }
    }
    return retValue;
}
#end_block

#method_before
private boolean thereAreTasksToPoll() {
    for (SPMTask task : _tasks.values()) {
        if (task.getShouldPoll()) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean thereAreTasksToPoll() {
    for (SPMTask task : tasks.values()) {
        if (task.getShouldPoll()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void pollAndUpdateAsyncTasks() {
    if (logChangedMap) {
        log.info("Polling and updating Async Tasks: {} tasks, {} tasks to poll now", _tasks.size(), numberOfTasksToPoll());
    }
    // Fetch Set of pool id's
    Set<Guid> poolsOfActiveTasks = getPoolIdsTasks();
    // Get all tasks from all the SPMs.
    Map<Guid, Map<Guid, AsyncTaskStatus>> poolsAllTasksMap = getSPMsTasksStatuses(poolsOfActiveTasks);
    // For each task that found on each pool id
    updateTaskStatuses(poolsAllTasksMap);
}
#method_after
private void pollAndUpdateAsyncTasks() {
    if (logChangedMap) {
        log.info("Polling and updating Async Tasks: {} tasks, {} tasks to poll now", tasks.size(), numberOfTasksToPoll());
    }
    // Fetch Set of pool id's
    Set<Guid> poolsOfActiveTasks = getPoolIdsTasks();
    // Get all tasks from all the SPMs.
    Map<Guid, Map<Guid, AsyncTaskStatus>> poolsAllTasksMap = getSPMsTasksStatuses(poolsOfActiveTasks);
    // For each task that found on each pool id
    updateTaskStatuses(poolsAllTasksMap);
}
#end_block

#method_before
private void updateTaskStatuses(Map<Guid, Map<Guid, AsyncTaskStatus>> poolsAllTasksMap) {
    for (SPMTask task : _tasks.values()) {
        if (task.getShouldPoll()) {
            Map<Guid, AsyncTaskStatus> asyncTasksForPoolMap = poolsAllTasksMap.get(task.getStoragePoolID());
            // If the storage pool id exists
            if (asyncTasksForPoolMap != null) {
                AsyncTaskStatus cachedAsyncTaskStatus = asyncTasksForPoolMap.get(task.getVdsmTaskId());
                log.debug("Updating task of command {} with id '{}' to status '{}'.", task.getParameters().getDbAsyncTask().getActionType(), task.getCommandId(), cachedAsyncTaskStatus);
                // task found in VDSM.
                task.updateTask(cachedAsyncTaskStatus);
            }
        } else {
            log.debug("Not updating task of command {} with id '{}' and status '{}'.", task.getParameters().getDbAsyncTask().getActionType(), task.getCommandId(), task.getLastTaskStatus());
        }
    }
}
#method_after
private void updateTaskStatuses(Map<Guid, Map<Guid, AsyncTaskStatus>> poolsAllTasksMap) {
    for (SPMTask task : tasks.values()) {
        if (task.getShouldPoll()) {
            Map<Guid, AsyncTaskStatus> asyncTasksForPoolMap = poolsAllTasksMap.get(task.getStoragePoolID());
            // If the storage pool id exists
            if (asyncTasksForPoolMap != null) {
                AsyncTaskStatus cachedAsyncTaskStatus = asyncTasksForPoolMap.get(task.getVdsmTaskId());
                log.debug("Updating task of command {} with id '{}' to status '{}'.", task.getParameters().getDbAsyncTask().getActionType(), task.getCommandId(), cachedAsyncTaskStatus);
                // task found in VDSM.
                task.updateTask(cachedAsyncTaskStatus);
            }
        } else {
            log.debug("Not updating task of command {} with id '{}' and status '{}'.", task.getParameters().getDbAsyncTask().getActionType(), task.getCommandId(), task.getLastTaskStatus());
        }
    }
}
#end_block

#method_before
private Set<Guid> getPoolIdsTasks() {
    Set<Guid> poolsOfActiveTasks = new HashSet<>();
    for (SPMTask task : _tasks.values()) {
        if (task.getShouldPoll()) {
            poolsOfActiveTasks.add(task.getStoragePoolID());
        }
    }
    return poolsOfActiveTasks;
}
#method_after
private Set<Guid> getPoolIdsTasks() {
    Set<Guid> poolsOfActiveTasks = new HashSet<>();
    for (SPMTask task : tasks.values()) {
        if (task.getShouldPoll()) {
            poolsOfActiveTasks.add(task.getStoragePoolID());
        }
    }
    return poolsOfActiveTasks;
}
#end_block

#method_before
private synchronized void removeClearedAndOldTasks() {
    Set<Guid> poolsOfActiveTasks = new HashSet<>();
    Set<Guid> poolsOfClearedAndOldTasks = new HashSet<>();
    ConcurrentMap<Guid, SPMTask> activeTaskMap = new ConcurrentHashMap<>();
    for (SPMTask task : _tasks.values()) {
        if (!cachingOver(task)) {
            activeTaskMap.put(task.getVdsmTaskId(), task);
            poolsOfActiveTasks.add(task.getStoragePoolID());
        } else {
            poolsOfClearedAndOldTasks.add(task.getStoragePoolID());
        }
    }
    // Check if _tasks need to be updated with less tasks (activated tasks).
    if (poolsOfClearedAndOldTasks.size() > 0) {
        setNewMap(activeTaskMap);
        poolsOfClearedAndOldTasks.removeAll(poolsOfActiveTasks);
    }
    for (Guid storagePoolID : poolsOfClearedAndOldTasks) {
        log.info("Cleared all tasks of pool '{}'.", storagePoolID);
    }
}
#method_after
private synchronized void removeClearedAndOldTasks() {
    Set<Guid> poolsOfActiveTasks = new HashSet<>();
    Set<Guid> poolsOfClearedAndOldTasks = new HashSet<>();
    ConcurrentMap<Guid, SPMTask> activeTaskMap = new ConcurrentHashMap<>();
    for (SPMTask task : tasks.values()) {
        if (!cachingOver(task)) {
            activeTaskMap.put(task.getVdsmTaskId(), task);
            poolsOfActiveTasks.add(task.getStoragePoolID());
        } else {
            poolsOfClearedAndOldTasks.add(task.getStoragePoolID());
        }
    }
    // Check if tasks need to be updated with less tasks (activated tasks).
    if (poolsOfClearedAndOldTasks.size() > 0) {
        setNewMap(activeTaskMap);
        poolsOfClearedAndOldTasks.removeAll(poolsOfActiveTasks);
    }
    for (Guid storagePoolID : poolsOfClearedAndOldTasks) {
        log.info("Cleared all tasks of pool '{}'.", storagePoolID);
    }
}
#end_block

#method_before
private void addTaskToManager(SPMTask task) {
    if (task == null) {
        log.error("Cannot add a null task.");
    } else {
        if (!_tasks.containsKey(task.getVdsmTaskId())) {
            log.info("Adding task '{}' (Parent Command '{}', Parameters Type '{}'), {}.", task.getVdsmTaskId(), task.getParameters().getDbAsyncTask().getActionType(), task.getParameters().getClass().getName(), task.getShouldPoll() ? "polling started." : "polling hasn't started yet.");
            // Set the indication to true for logging _tasks status on next
            // quartz execution.
            addTaskToMap(task.getVdsmTaskId(), task);
        } else {
            SPMTask existingTask = _tasks.get(task.getVdsmTaskId());
            if (existingTask.getParameters().getDbAsyncTask().getActionType() == VdcActionType.Unknown && task.getParameters().getDbAsyncTask().getActionType() != VdcActionType.Unknown) {
                log.info("Task '{}' already exists with action type 'Unknown', now overriding it with action type '{}'", task.getVdsmTaskId(), task.getParameters().getDbAsyncTask().getActionType());
                // Set the indication to true for logging _tasks status on
                // next quartz execution.
                addTaskToMap(task.getVdsmTaskId(), task);
            }
        }
    }
}
#method_after
private void addTaskToManager(SPMTask task) {
    if (task == null) {
        log.error("Cannot add a null task.");
    } else {
        if (!tasks.containsKey(task.getVdsmTaskId())) {
            log.info("Adding task '{}' (Parent Command '{}', Parameters Type '{}'), {}.", task.getVdsmTaskId(), task.getParameters().getDbAsyncTask().getActionType(), task.getParameters().getClass().getName(), task.getShouldPoll() ? "polling started." : "polling hasn't started yet.");
            // Set the indication to true for logging tasks status on next
            // quartz execution.
            addTaskToMap(task.getVdsmTaskId(), task);
        } else {
            SPMTask existingTask = tasks.get(task.getVdsmTaskId());
            if (existingTask.getParameters().getDbAsyncTask().getActionType() == ActionType.Unknown && task.getParameters().getDbAsyncTask().getActionType() != ActionType.Unknown) {
                log.info("Task '{}' already exists with action type 'Unknown', now overriding it with action type '{}'", task.getVdsmTaskId(), task.getParameters().getDbAsyncTask().getActionType());
                // Set the indication to true for logging tasks status on
                // next quartz execution.
                addTaskToMap(task.getVdsmTaskId(), task);
            }
        }
    }
}
#end_block

#method_before
private void addTaskToMap(Guid guid, SPMTask asyncTask) {
    _tasks.put(guid, asyncTask);
    logChangedMap = true;
}
#method_after
private void addTaskToMap(Guid guid, SPMTask asyncTask) {
    tasks.put(guid, asyncTask);
    logChangedMap = true;
}
#end_block

#method_before
private void setNewMap(ConcurrentMap<Guid, SPMTask> asyncTaskMap) {
    // If not the same set _tasks to be as asyncTaskMap.
    _tasks = asyncTaskMap;
    // Set the indication to true for logging.
    logChangedMap = true;
    // Log tasks to poll now.
    log.info("Setting new tasks map. The map contains now {} tasks", _tasks.size());
}
#method_after
private void setNewMap(ConcurrentMap<Guid, SPMTask> asyncTaskMap) {
    // If not the same set tasks to be as asyncTaskMap.
    tasks = asyncTaskMap;
    // Set the indication to true for logging.
    logChangedMap = true;
    // Log tasks to poll now.
    log.info("Setting new tasks map. The map contains now {} tasks", tasks.size());
}
#end_block

#method_before
public synchronized void startPollingTask(Guid vdsmTaskId) {
    if (_tasks.containsKey(vdsmTaskId)) {
        _tasks.get(vdsmTaskId).startPollingTask();
    }
}
#method_after
public synchronized void startPollingTask(Guid vdsmTaskId) {
    if (tasks.containsKey(vdsmTaskId)) {
        tasks.get(vdsmTaskId).startPollingTask();
    }
}
#end_block

#method_before
public synchronized ArrayList<AsyncTaskStatus> pollTasks(ArrayList<Guid> vdsmTaskIdList) {
    ArrayList<AsyncTaskStatus> returnValue = new ArrayList<>();
    if (vdsmTaskIdList != null && vdsmTaskIdList.size() > 0) {
        for (Guid vdsmTaskId : vdsmTaskIdList) {
            if (_tasks.containsKey(vdsmTaskId)) {
                // task is still running or is still in the cache:
                _tasks.get(vdsmTaskId).setLastStatusAccessTime();
                returnValue.add(_tasks.get(vdsmTaskId).getLastTaskStatus());
            } else {
                // task doesn't exist in the manager (shouldn't happen) ->
                // assume it has been ended successfully.
                log.warn("Polling tasks. Task ID '{}' doesn't exist in the manager -> assuming 'finished'.", vdsmTaskId);
                AsyncTaskStatus tempVar = new AsyncTaskStatus();
                tempVar.setStatus(AsyncTaskStatusEnum.finished);
                tempVar.setResult(AsyncTaskResultEnum.success);
                returnValue.add(tempVar);
            }
        }
    }
    return returnValue;
}
#method_after
public synchronized ArrayList<AsyncTaskStatus> pollTasks(ArrayList<Guid> vdsmTaskIdList) {
    ArrayList<AsyncTaskStatus> returnValue = new ArrayList<>();
    if (vdsmTaskIdList != null && vdsmTaskIdList.size() > 0) {
        for (Guid vdsmTaskId : vdsmTaskIdList) {
            if (tasks.containsKey(vdsmTaskId)) {
                // task is still running or is still in the cache:
                tasks.get(vdsmTaskId).setLastStatusAccessTime();
                returnValue.add(tasks.get(vdsmTaskId).getLastTaskStatus());
            } else {
                // task doesn't exist in the manager (shouldn't happen) ->
                // assume it has been ended successfully.
                log.warn("Polling tasks. Task ID '{}' doesn't exist in the manager -> assuming 'finished'.", vdsmTaskId);
                AsyncTaskStatus tempVar = new AsyncTaskStatus();
                tempVar.setStatus(AsyncTaskStatusEnum.finished);
                tempVar.setResult(AsyncTaskResultEnum.success);
                returnValue.add(tempVar);
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
public void addStoragePoolExistingTasks(StoragePool sp) {
    List<AsyncTaskCreationInfo> currPoolTasks = null;
    try {
        currPoolTasks = coco.getAllTasksInfo(sp.getId());
    } catch (RuntimeException e) {
        log.error("Getting existing tasks on Storage Pool '{}' failed: {}", sp.getName(), e.getMessage());
        log.debug("Exception", e);
    }
    if (currPoolTasks != null && currPoolTasks.size() > 0) {
        synchronized (this) {
            final List<SPMTask> newlyAddedTasks = new ArrayList<>();
            for (AsyncTaskCreationInfo creationInfo : currPoolTasks) {
                creationInfo.setStoragePoolID(sp.getId());
                if (!_tasks.containsKey(creationInfo.getVdsmTaskId())) {
                    try {
                        SPMTask task;
                        if (partiallyCompletedCommandTasks.containsKey(creationInfo.getVdsmTaskId())) {
                            AsyncTask asyncTaskInDb = partiallyCompletedCommandTasks.get(creationInfo.getVdsmTaskId());
                            task = coco.construct(creationInfo, asyncTaskInDb);
                            if (task.getEntitiesMap() == null) {
                                task.setEntitiesMap(new HashMap<>());
                            }
                            partiallyCompletedCommandTasks.remove(task.getVdsmTaskId());
                            // mark it as a task of a partially completed command
                            // Will result in failure of the command
                            task.setPartiallyCompletedCommandTask(true);
                        } else {
                            task = coco.construct(creationInfo);
                        }
                        addTaskToManager(task);
                        newlyAddedTasks.add(task);
                    } catch (Exception e) {
                        log.error("Failed to load task of type '{}' with id '{}': {}.", creationInfo.getTaskType(), creationInfo.getVdsmTaskId(), ExceptionUtils.getRootCauseMessage(e));
                        log.debug("Exception", e);
                    }
                }
            }
            TransactionSupport.executeInNewTransaction(() -> {
                for (SPMTask task : newlyAddedTasks) {
                    AsyncTaskUtils.addOrUpdateTaskInDB(task);
                }
                return null;
            });
            for (SPMTask task : newlyAddedTasks) {
                startPollingTask(task.getVdsmTaskId());
            }
            log.info("Discovered {} tasks on Storage Pool '{}', {} added to manager.", currPoolTasks.size(), sp.getName(), newlyAddedTasks.size());
        }
    } else {
        log.info("Discovered no tasks on Storage Pool '{}'", sp.getName());
    }
    List<AsyncTask> tasksInDForStoragePool = tasksInDbAfterRestart.get(sp.getId());
    if (tasksInDForStoragePool != null) {
        for (AsyncTask task : tasksInDForStoragePool) {
            if (!_tasks.containsKey(task.getVdsmTaskId())) {
                coco.removeByVdsmTaskId(task.getVdsmTaskId());
            }
        }
    }
    // Either the tasks were only in DB - so they were removed from db, or they are polled -
    // in any case no need to hold them in the map that represents the tasksInDbAfterRestart
    tasksInDbAfterRestart.remove(sp.getId());
}
#method_after
public void addStoragePoolExistingTasks(StoragePool sp) {
    List<AsyncTaskCreationInfo> currPoolTasks = null;
    try {
        currPoolTasks = coco.getAllTasksInfo(sp.getId());
    } catch (RuntimeException e) {
        log.error("Getting existing tasks on Storage Pool '{}' failed: {}", sp.getName(), e.getMessage());
        log.debug("Exception", e);
    }
    if (currPoolTasks != null && currPoolTasks.size() > 0) {
        synchronized (this) {
            final List<SPMTask> newlyAddedTasks = new ArrayList<>();
            for (AsyncTaskCreationInfo creationInfo : currPoolTasks) {
                creationInfo.setStoragePoolID(sp.getId());
                if (!tasks.containsKey(creationInfo.getVdsmTaskId())) {
                    try {
                        SPMTask task;
                        if (partiallyCompletedCommandTasks.containsKey(creationInfo.getVdsmTaskId())) {
                            AsyncTask asyncTaskInDb = partiallyCompletedCommandTasks.get(creationInfo.getVdsmTaskId());
                            task = coco.construct(creationInfo, asyncTaskInDb);
                            if (task.getEntitiesMap() == null) {
                                task.setEntitiesMap(new HashMap<>());
                            }
                            partiallyCompletedCommandTasks.remove(task.getVdsmTaskId());
                            // mark it as a task of a partially completed command
                            // Will result in failure of the command
                            task.setPartiallyCompletedCommandTask(true);
                        } else {
                            task = asyncTaskFactory.construct(creationInfo);
                        }
                        addTaskToManager(task);
                        newlyAddedTasks.add(task);
                    } catch (Exception e) {
                        log.error("Failed to load task of type '{}' with id '{}': {}.", creationInfo.getTaskType(), creationInfo.getVdsmTaskId(), ExceptionUtils.getRootCauseMessage(e));
                        log.debug("Exception", e);
                    }
                }
            }
            TransactionSupport.executeInNewTransaction(() -> {
                for (SPMTask task : newlyAddedTasks) {
                    AsyncTaskUtils.addOrUpdateTaskInDB(coco, task);
                }
                return null;
            });
            for (SPMTask task : newlyAddedTasks) {
                startPollingTask(task.getVdsmTaskId());
            }
            log.info("Discovered {} tasks on Storage Pool '{}', {} added to manager.", currPoolTasks.size(), sp.getName(), newlyAddedTasks.size());
        }
    } else {
        log.info("Discovered no tasks on Storage Pool '{}'", sp.getName());
    }
    List<AsyncTask> tasksInDForStoragePool = tasksInDbAfterRestart.get(sp.getId());
    if (tasksInDForStoragePool != null) {
        for (AsyncTask task : tasksInDForStoragePool) {
            if (!tasks.containsKey(task.getVdsmTaskId())) {
                coco.removeByVdsmTaskId(task.getVdsmTaskId());
            }
        }
    }
    // Either the tasks were only in DB - so they were removed from db, or they are polled -
    // in any case no need to hold them in the map that represents the tasksInDbAfterRestart
    tasksInDbAfterRestart.remove(sp.getId());
}
#end_block

#method_before
public synchronized void cancelTask(Guid vdsmTaskId) {
    if (_tasks.containsKey(vdsmTaskId)) {
        log.info("Attempting to cancel task '{}'.", vdsmTaskId);
        _tasks.get(vdsmTaskId).stopTask();
        _tasks.get(vdsmTaskId).concreteStartPollingTask();
    }
}
#method_after
public synchronized void cancelTask(Guid vdsmTaskId) {
    if (tasks.containsKey(vdsmTaskId)) {
        log.info("Attempting to cancel task '{}'.", vdsmTaskId);
        tasks.get(vdsmTaskId).stopTask();
        tasks.get(vdsmTaskId).concreteStartPollingTask();
    }
}
#end_block

#method_before
public synchronized boolean entityHasTasks(Guid id) {
    for (SPMTask task : _tasks.values()) {
        if (isCurrentTaskLookedFor(id, task)) {
            return true;
        }
    }
    return false;
}
#method_after
public synchronized boolean entityHasTasks(Guid id) {
    for (SPMTask task : tasks.values()) {
        if (isCurrentTaskLookedFor(id, task)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public Collection<Guid> getUserIdsForVdsmTaskIds(List<Guid> vdsmTaskIds) {
    Set<Guid> users = new TreeSet<>();
    for (Guid id : vdsmTaskIds) {
        if (_tasks.containsKey(id)) {
            users.add(_tasks.get(id).getParameters().getDbAsyncTask().getUserId());
        }
    }
    return users;
}
#method_after
public Collection<Guid> getUserIdsForVdsmTaskIds(List<Guid> vdsmTaskIds) {
    Set<Guid> users = new TreeSet<>();
    for (Guid id : vdsmTaskIds) {
        if (tasks.containsKey(id)) {
            users.add(tasks.get(id).getParameters().getDbAsyncTask().getUserId());
        }
    }
    return users;
}
#end_block

#method_before
public boolean doesCommandContainAsyncTask(Guid cmdId) {
    for (SPMTask task : _tasks.values()) {
        if (task.getParameters().getDbAsyncTask().getCommandId().equals(cmdId)) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean doesCommandContainAsyncTask(Guid cmdId) {
    for (SPMTask task : tasks.values()) {
        if (task.getParameters().getDbAsyncTask().getCommandId().equals(cmdId)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public void ovfUpdate() {
    try {
        List<StoragePool> storagePools = storagePoolDao.getAllByStatus(StoragePoolStatus.Up);
        updateOvfData(storagePools);
    } catch (Throwable t) {
        log.error("Exception updating ovf data: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#method_after
public void ovfUpdate() {
    lock.lock();
    try {
        List<StoragePool> storagePools = storagePoolDao.getAllByStatus(StoragePoolStatus.Up);
        updateOvfData(storagePools);
    } catch (Throwable t) {
        log.error("Exception updating ovf data: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    } finally {
        lock.unlock();
    }
}
#end_block

#method_before
public void triggerNow() {
    if (updateTimerJob != null) {
        try {
            updateTimerJob.cancel(true);
        } catch (Throwable t) {
            log.debug("Exception cancelling existing job: {}", ExceptionUtils.getRootCauseMessage(t));
        }
    }
    updateTimerJob = schedulerService.scheduleWithFixedDelay(this::ovfUpdate, 0, Config.<Integer>getValue(ConfigValues.OvfUpdateIntervalInMinutes), TimeUnit.MINUTES);
}
#method_after
public void triggerNow() {
    if (updateTimerJob != null) {
        try {
            updateTimerJob.cancel(false);
        } catch (Throwable t) {
            log.debug("Exception cancelling existing job: {}", ExceptionUtils.getRootCauseMessage(t));
        }
    }
    updateTimerJob = schedulerService.scheduleWithFixedDelay(this::ovfUpdate, 0, Config.<Integer>getValue(ConfigValues.OvfUpdateIntervalInMinutes), TimeUnit.MINUTES);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = vmDynamicDao.get(getVmId());
        if (!isVmStatusValid(vmDynamic.getStatus())) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        vmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        ScheduledFuture job = updateVmsJobMap.remove(getParameters().getBaseTemplateId());
        if (job != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                job.cancel(true);
            } catch (Exception e) {
                log.warn("Failed deleting job at cancelRecoveryJob for template '{}' ", getParameters().getBaseTemplateId());
            }
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmTemplateToDb();
        getCompensationContext().stateChanged();
        return null;
    });
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = addAllTemplateDisks();
    srcDeviceIdToTargetDeviceIdMapping.forEach((oldImageId, newImageId) -> addTemplateDiskVmElement(newImageId, oldImageId));
    TransactionSupport.executeInNewTransaction(() -> {
        addPermission();
        addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
        Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
        if (isVmInDb) {
            getVmDeviceUtils().copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVmDeviceUtils().hasMemoryBalloon(getVmId()), graphicsToSkip, false, getEffectiveCompatibilityVersion());
        } else {
            // for instance type and new template without a VM
            getVmDeviceUtils().copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), Boolean.TRUE.equals(getParameters().isBalloonEnabled()), graphicsToSkip, false, getEffectiveCompatibilityVersion());
        }
        updateWatchdog(getVmTemplateId());
        updateRngDevice(getVmTemplateId());
        addGraphicsDevice();
        setSucceeded(true);
        return null;
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        vmHandler.warnMemorySizeLegal(getVmTemplate(), getVm().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !commandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = vmDynamicDao.get(getVmId());
        if (!isVmStatusValid(vmDynamic.getStatus())) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        vmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobHashMap.remove(getParameters().getBaseTemplateId());
        if (!StringUtils.isEmpty(jobId)) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                updateVmsJobMap.remove(getParameters().getBaseTemplateId()).cancel(true);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmTemplateToDb();
        getCompensationContext().stateChanged();
        return null;
    });
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = addAllTemplateDisks();
    srcDeviceIdToTargetDeviceIdMapping.forEach((oldImageId, newImageId) -> addTemplateDiskVmElement(newImageId, oldImageId));
    TransactionSupport.executeInNewTransaction(() -> {
        addPermission();
        addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
        Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
        if (isVmInDb) {
            getVmDeviceUtils().copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVmDeviceUtils().hasMemoryBalloon(getVmId()), graphicsToSkip, false, getEffectiveCompatibilityVersion());
        } else {
            // for instance type and new template without a VM
            getVmDeviceUtils().copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), Boolean.TRUE.equals(getParameters().isBalloonEnabled()), graphicsToSkip, false, getEffectiveCompatibilityVersion());
        }
        updateWatchdog(getVmTemplateId());
        updateRngDevice(getVmTemplateId());
        addGraphicsDevice();
        setSucceeded(true);
        return null;
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        vmHandler.warnMemorySizeLegal(getVmTemplate(), getVm().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !commandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
private boolean validateCluster() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!vmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the display type is supported
    Guid srcId = isVmInDb ? getVmId() : VmTemplateHandler.BLANK_VM_TEMPLATE_ID;
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getMasterVm().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(srcId), getParameters().getGraphicsDevices()), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getValidationMessages(), getVm().getCompatibilityVersion())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVm().getCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVm().getCompatibilityVersion(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    return true;
}
#method_after
private boolean validateCluster() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!vmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the display type is supported
    Guid srcId = isVmInDb ? getVmId() : VmTemplateHandler.BLANK_VM_TEMPLATE_ID;
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getMasterVm().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(srcId), getParameters().getGraphicsDevices()), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getValidationMessages(), getVm().getCompatibilityVersion())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getMasterVm()))) {
        return false;
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVm().getCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVm().getCompatibilityVersion(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void endDefaultOperations() {
    endUnlockOps();
    // in case of new version of a template, update vms marked to use latest
    if (isTemplateVersion()) {
        ScheduledFuture job = schedulerService.schedule(this::updateVmVersion, 0, TimeUnit.SECONDS);
        updateVmsJobMap.put(getParameters().getBaseTemplateId(), job);
    }
}
#method_after
private void endDefaultOperations() {
    endUnlockOps();
    // in case of new version of a template, update vms marked to use latest
    if (isTemplateVersion()) {
        updateVmsJobHashMap.put(getParameters().getBaseTemplateId(), StringUtils.EMPTY);
        ScheduledFuture job = schedulerService.schedule(this::updateVmVersion, 0, TimeUnit.SECONDS);
        updateVmsJobMap.put(getParameters().getBaseTemplateId(), job);
        updateVmsJobHashMap.put(getParameters().getBaseTemplateId(), Integer.toString(job.hashCode()));
    }
}
#end_block

#method_before
private void updateVmVersion() {
    for (Guid vmId : vmDao.getVmIdsForVersionUpdate(getParameters().getBaseTemplateId())) {
        // if the job was removed, stop executing, we probably have new version creation going on
        if (!updateVmsJobMap.containsKey(getParameters().getBaseTemplateId())) {
            break;
        }
        UpdateVmVersionParameters params = new UpdateVmVersionParameters(vmId);
        params.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(ActionType.UpdateVmVersion, params, cloneContextAndDetachFromParent());
    }
    updateVmsJobMap.remove(getParameters().getBaseTemplateId());
}
#method_after
private void updateVmVersion() {
    for (Guid vmId : vmDao.getVmIdsForVersionUpdate(getParameters().getBaseTemplateId())) {
        // if the job was removed, stop executing, we probably have new version creation going on
        if (!updateVmsJobHashMap.containsKey(getParameters().getBaseTemplateId())) {
            break;
        }
        UpdateVmVersionParameters params = new UpdateVmVersionParameters(vmId);
        params.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(ActionType.UpdateVmVersion, params, cloneContextAndDetachFromParent());
    }
    updateVmsJobHashMap.remove(getParameters().getBaseTemplateId());
    updateVmsJobMap.remove(getParameters().getBaseTemplateId());
}
#end_block

#method_before
public void triggerPoolMonitoringJob() {
    try {
        poolMonitoringJob.cancel(true);
    } catch (Throwable t) {
        log.debug("Exception cancelling existing job: {}", ExceptionUtils.getRootCauseMessage(t));
    }
    poolMonitoringJob = schedulerService.scheduleWithFixedDelay(this::managePrestartedVmsInAllVmPools, 0, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
}
#method_after
public void triggerPoolMonitoringJob() {
    try {
        poolMonitoringJob.cancel(false);
    } catch (Throwable t) {
        log.debug("Exception cancelling existing job: {}", ExceptionUtils.getRootCauseMessage(t));
    }
    poolMonitoringJob = schedulerService.scheduleWithFixedDelay(this::managePrestartedVmsInAllVmPools, 0, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
}
#end_block

#method_before
private void managePrestartedVmsInAllVmPools() {
    try {
        vmPoolDao.getAll().stream().filter(pool -> pool.getPrestartedVms() > 0).forEach(this::managePrestartedVmsInPool);
    } catch (Throwable t) {
        log.error("Exception managing prestarted VMs in all VM pools: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#method_after
private void managePrestartedVmsInAllVmPools() {
    lock.lock();
    try {
        vmPoolDao.getAll().stream().filter(pool -> pool.getPrestartedVms() > 0).forEach(this::managePrestartedVmsInPool);
    } catch (Throwable t) {
        log.error("Exception managing prestarted VMs in all VM pools: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    } finally {
        lock.unlock();
    }
}
#end_block

#method_before
private void mockAnswers() {
    doAnswer(invocation -> {
        ActionReturnValue returnValueBase = new ActionReturnValue();
        Map<Guid, Boolean> domains = new HashMap<>();
        Set<Guid> domainIds = new HashSet<>();
        domainIds.add(Guid.newGuid());
        domainIds.add(Guid.newGuid());
        for (Guid domainId : domainIds) {
            domains.put(domainId, Boolean.FALSE);
        }
        returnValueBase.setActionReturnValue(domainIds);
        Guid storagePoolId = (Guid) invocation.getArguments()[0];
        map.put(storagePoolId, domains);
        return returnValueBase;
    }).when(ovfDataUpdater).performOvfUpdateForStoragePool(any(Guid.class));
    doAnswer(invocation -> {
        Guid storagePoolId = (Guid) invocation.getArguments()[0];
        Guid storageDomainId = (Guid) invocation.getArguments()[1];
        map.get(storagePoolId).put(storageDomainId, Boolean.TRUE);
        return null;
    }).when(ovfDataUpdater).performOvfUpdateForDomain(any(Guid.class), any(Guid.class));
}
#method_after
private void mockAnswers() {
    doAnswer(invocation -> {
        ActionReturnValue returnValueBase = new ActionReturnValue();
        Map<Guid, Boolean> domains = new HashMap<>();
        Set<Guid> domainIds = new HashSet<>();
        domainIds.add(Guid.newGuid());
        domainIds.add(Guid.newGuid());
        for (Guid domainId : domainIds) {
            domains.put(domainId, Boolean.FALSE);
        }
        returnValueBase.setActionReturnValue(domainIds);
        Guid storagePoolId = (Guid) invocation.getArguments()[0];
        map.put(storagePoolId, domains);
        return returnValueBase;
    }).when(ovfDataUpdater).performOvfUpdateForStoragePool(any());
    doAnswer(invocation -> {
        Guid storagePoolId = (Guid) invocation.getArguments()[0];
        Guid storageDomainId = (Guid) invocation.getArguments()[1];
        map.get(storagePoolId).put(storageDomainId, Boolean.TRUE);
        return null;
    }).when(ovfDataUpdater).performOvfUpdateForDomain(any(), any());
}
#end_block

#method_before
public final void cleanExpiredUsersSessions() {
    Date now = new Date();
    Iterator<Entry<String, SessionInfo>> iter = sessionInfoMap.entrySet().iterator();
    Set<String> tokens = sessionInfoMap.values().stream().map(sessionInfo -> (String) sessionInfo.contentOfSession.get(SSO_ACCESS_TOKEN_PARAMETER_NAME)).collect(Collectors.toSet());
    // retrieve session statues from SSO
    Map<String, Boolean> sessionStatuses = ssoSessionValidator.getSessionStatuses(tokens);
    while (iter.hasNext()) {
        Entry<String, SessionInfo> entry = iter.next();
        ConcurrentMap<String, Object> sessionMap = entry.getValue().contentOfSession;
        Date hardLimit = (Date) sessionMap.get(HARD_LIMIT_PARAMETER_NAME);
        Date softLimit = (Date) sessionMap.get(SOFT_LIMIT_PARAMETER_NAME);
        String token = (String) sessionMap.get(SSO_ACCESS_TOKEN_PARAMETER_NAME);
        // in the next iteration.
        if (!sessionStatuses.containsKey(token)) {
            continue;
        }
        boolean sessionValid = StringUtils.isEmpty(token) ? false : sessionStatuses.get(token);
        if (((hardLimit != null && hardLimit.before(now)) || (softLimit != null && softLimit.before(now))) || !(boolean) sessionMap.get(SESSION_VALID_PARAMETER_NAME) || !sessionValid) {
            removeSessionImpl(entry.getKey(), Acct.ReportReason.PRINCIPAL_SESSION_EXPIRED, "Session has expired for principal %1$s", getUserName(entry.getKey()));
            if (sessionValid) {
                SsoOAuthServiceUtils.revoke((String) sessionMap.get(SSO_ACCESS_TOKEN_PARAMETER_NAME), "");
            }
        }
    }
}
#method_after
public final void cleanExpiredUsersSessions() {
    try {
        cleanExpiredUsersSessionsImpl();
    } catch (Throwable t) {
        log.error("Exception in cleanExpiredUsersSessions: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
public final void updateSessionLastActiveTime(String sessionId) {
    if (isSessionExists(sessionId)) {
        setData(sessionId, SESSION_LAST_ACTIVE_TIME, new Date());
    }
}
#method_after
public final void updateSessionLastActiveTime(String sessionId) {
    if (isSessionExists(sessionId)) {
        setData(sessionId, SESSION_LAST_ACTIVE_TIME, new Date());
        refresh(sessionId);
    }
}
#end_block

#method_before
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // initialize ThreadPoolUtil
    ThreadPoolUtil.setExecutorService(managedExecutorService);
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    scheduledExecutorService.scheduleAtFixedRate(() -> sessionDataContainer.cleanExpiredUsersSessions(), 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmsMonitoring.class);
    serviceLoader.load(VmDevicesMonitoring.class);
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    serviceLoader.load(VmMigrationProgressMonitoring.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // Load the thread pools
    serviceLoader.load(EngineThreadPools.class);
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    serviceLoader.load(AsyncTaskManager.class);
    serviceLoader.load(CommandCoordinatorUtil.class);
    serviceLoader.load(CommandCallbacksPoller.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    serviceLoader.load(VmMigrationProgressMonitoring.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
private void updatePredefinedIcons() {
    IconLoader.load();
}
#method_after
private void updatePredefinedIcons() {
    serviceLoader.load(IconLoader.class);
}
#end_block

#method_before
@Override
@ExcludeClassInterceptors
public VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext context) {
    return runActionImpl(actionType, parameters, true, context);
}
#method_after
@Override
@ExcludeClassInterceptors
public ActionReturnValue runInternalAction(ActionType actionType, ActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, true, null);
}
#end_block

#method_before
@Override
public VdcReturnValueBase runAction(CommandBase<?> action, ExecutionContext executionContext) {
    ExecutionHandler.setExecutionContextForTasks(action.getContext(), executionContext, action.getContext().getLock());
    return runAction(action, true);
}
#method_after
@Override
public ActionReturnValue runAction(ActionType actionType, ActionParametersBase parameters) {
    ActionReturnValue returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        return returnValue;
    }
    return runActionImpl(actionType, parameters, false, null);
}
#end_block

#method_before
private VdcReturnValueBase notAllowToRunAction(VdcActionType actionType) {
    // Since reload of configuration values is not fully supported, we have to get this value from DB
    // and can not use the cached configuration.
    String mode = vdcOptionDao.getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion).getOptionValue();
    if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
        return getErrorCommandReturnValue(EngineMessage.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
    } else if (EngineWorkingMode.PREPARE.name().equalsIgnoreCase(mode)) {
        return notAllowedInPrepForMaintMode(actionType);
    }
    return null;
}
#method_after
private ActionReturnValue notAllowToRunAction(ActionType actionType) {
    // Since reload of configuration values is not fully supported, we have to get this value from DB
    // and can not use the cached configuration.
    String mode = vdcOptionDao.getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion).getOptionValue();
    if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
        return getErrorCommandReturnValue(EngineMessage.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
    } else if (EngineWorkingMode.PREPARE.name().equalsIgnoreCase(mode)) {
        return notAllowedInPrepForMaintMode(actionType);
    }
    return null;
}
#end_block

#method_before
private VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CommandContext context) {
    VdcReturnValueBase result;
    // If non-monitored command is invoked with JobId or ActionId as parameters, reject this command on can do action.
    if (!actionType.isActionMonitored() && !isActionExternal(actionType) && (parameters.getJobId() != null || parameters.getStepId() != null)) {
        result = new VdcReturnValueBase();
        result.getValidationMessages().add(EngineMessage.ACTION_TYPE_NON_MONITORED.toString());
        result.setValid(false);
        result.setSucceeded(false);
    } else {
        if (!runAsInternal) {
            logExecution(parameters.getSessionId(), String.format("command %s", actionType));
        }
        CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, context);
        result = runAction(command, runAsInternal);
    }
    return result;
}
#method_after
private ActionReturnValue runActionImpl(ActionType actionType, ActionParametersBase parameters, boolean runAsInternal, CommandContext context) {
    ActionReturnValue result;
    // If non-monitored command is invoked with JobId or ActionId as parameters, reject this command on can do action.
    if (!actionType.isActionMonitored() && !isActionExternal(actionType) && (parameters.getJobId() != null || parameters.getStepId() != null)) {
        result = new ActionReturnValue();
        result.getValidationMessages().add(EngineMessage.ACTION_TYPE_NON_MONITORED.toString());
        result.setValid(false);
        result.setSucceeded(false);
    } else {
        if (!runAsInternal) {
            logExecution(parameters.getSessionId(), String.format("command %s", actionType));
        }
        CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, context);
        result = runAction(command, runAsInternal);
    }
    return result;
}
#end_block

#method_before
private boolean isActionExternal(VdcActionType actionType) {
    return actionType == VdcActionType.EndExternalJob || actionType == VdcActionType.EndExternalStep || actionType == VdcActionType.ClearExternalJob;
}
#method_after
private boolean isActionExternal(ActionType actionType) {
    return actionType == ActionType.EndExternalJob || actionType == ActionType.EndExternalStep || actionType == ActionType.ClearExternalJob;
}
#end_block

#method_before
protected VdcReturnValueBase runAction(CommandBase<?> command, boolean runAsInternal) {
    VdcReturnValueBase returnValue = evaluateCorrelationId(command);
    if (returnValue != null) {
        return returnValue;
    }
    command.setInternalExecution(runAsInternal);
    executionHandler.prepareCommandForMonitoring(command, command.getActionType(), runAsInternal);
    returnValue = actionExecutor.get().execute(command);
    returnValue.setCorrelationId(command.getParameters().getCorrelationId());
    returnValue.setJobId(command.getJobId());
    return returnValue;
}
#method_after
protected ActionReturnValue runAction(CommandBase<?> command, boolean runAsInternal) {
    ActionReturnValue returnValue = evaluateCorrelationId(command);
    if (returnValue != null) {
        return returnValue;
    }
    command.setInternalExecution(runAsInternal);
    executionHandler.prepareCommandForMonitoring(command, command.getActionType(), runAsInternal);
    returnValue = actionExecutor.get().execute(command);
    returnValue.setCorrelationId(command.getParameters().getCorrelationId());
    returnValue.setJobId(command.getJobId());
    return returnValue;
}
#end_block

#method_before
protected VdcReturnValueBase evaluateCorrelationId(CommandBase<?> commandBase) {
    VdcActionParametersBase cmdParams = commandBase.getParameters();
    if (cmdParams.getCorrelationId() == null && cmdParams.getParentParameters() != null) {
        cmdParams.setCorrelationId(cmdParams.getParentParameters().getCorrelationId());
    }
    // Evaluate and set the correlationId on the parameters, fails on invalid correlation id
    VdcReturnValueBase returnValue = ExecutionHandler.evaluateCorrelationId(cmdParams);
    if (returnValue != null) {
        log.warn("Validation of action '{}' failed. Reasons: {}", commandBase.getActionType(), StringUtils.join(returnValue.getValidationMessages(), ','));
    }
    // Set the correlation-id on the command
    commandBase.setCorrelationId(cmdParams.getCorrelationId());
    return returnValue;
}
#method_after
protected ActionReturnValue evaluateCorrelationId(CommandBase<?> commandBase) {
    ActionParametersBase cmdParams = commandBase.getParameters();
    if (cmdParams.getCorrelationId() == null && cmdParams.getParentParameters() != null) {
        cmdParams.setCorrelationId(cmdParams.getParentParameters().getCorrelationId());
    }
    // Evaluate and set the correlationId on the parameters, fails on invalid correlation id
    ActionReturnValue returnValue = ExecutionHandler.evaluateCorrelationId(cmdParams);
    if (returnValue != null) {
        log.warn("Validation of action '{}' failed. Reasons: {}", commandBase.getActionType(), StringUtils.join(returnValue.getValidationMessages(), ','));
    }
    // Set the correlation-id on the command
    commandBase.setCorrelationId(cmdParams.getCorrelationId());
    return returnValue;
}
#end_block

#method_before
@Override
public VdcReturnValueBase endAction(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext context) {
    return CommandsFactory.createCommand(actionType, parameters, context).endAction();
}
#method_after
@Override
public ActionReturnValue endAction(ActionType actionType, ActionParametersBase parameters, CommandContext context) {
    return CommandsFactory.createCommand(actionType, parameters, context).endAction();
}
#end_block

#method_before
@Override
public VdcQueryReturnValue runInternalQuery(VdcQueryType queryType, VdcQueryParametersBase queryParameters) {
    return runInternalQuery(queryType, queryParameters, null);
}
#method_after
@Override
@ExcludeClassInterceptors
public QueryReturnValue runInternalQuery(QueryType actionType, QueryParametersBase parameters, EngineContext engineContext) {
    return runQueryImpl(actionType, parameters, false, engineContext);
}
#end_block

#method_before
@Override
public VdcQueryReturnValue runQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true, null);
}
#method_after
@Override
public QueryReturnValue runQuery(QueryType actionType, QueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true, null);
}
#end_block

#method_before
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    return runQueryImpl(actionType, parameters, isPerformUserCheck, null);
}
#method_after
protected QueryReturnValue runQueryImpl(QueryType actionType, QueryParametersBase parameters, boolean isPerformUserCheck, EngineContext engineContext) {
    if (isPerformUserCheck) {
        String sessionId = parameters.getSessionId();
        if (StringUtils.isEmpty(sessionId) || sessionDataContainer.getUser(sessionId, parameters.getRefresh()) == null) {
            log.debug("Unable to execute query {} as no user session was found", actionType);
            return getErrorQueryReturnValue(EngineMessage.USER_IS_NOT_LOGGED_IN);
        }
        logExecution(sessionId, String.format("query %s with isFiltered : %s", actionType, parameters.isFiltered()));
    }
    Class<?> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = vdcOptionDao.getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion).getOptionValue();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(EngineMessage.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    if (parameters.getCorrelationId() == null) {
        parameters.setCorrelationId(CorrelationIdTracker.getCorrelationId());
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters, engineContext);
    command.setInternalExecution(!isPerformUserCheck);
    QueryReturnValue returnValue = queryExecutor.get().execute(command, actionType);
    if (returnValue.getCorrelationId() == null) {
        returnValue.setCorrelationId(parameters.getCorrelationId());
    }
    CorrelationIdTracker.setCorrelationId(parameters.getCorrelationId());
    return returnValue;
}
#end_block

#method_before
@Override
public ArrayList<VdcReturnValueBase> runMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isRunOnlyIfAllValidationPass, boolean waitForResult) {
    VdcReturnValueBase returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        ArrayList<VdcReturnValueBase> list = new ArrayList<>();
        list.add(returnValue);
        return list;
    } else {
        return runMultipleActionsImpl(actionType, parameters, false, isRunOnlyIfAllValidationPass, waitForResult, null);
    }
}
#method_after
@Override
public List<ActionReturnValue> runMultipleActions(ActionType actionType, List<ActionParametersBase> parameters, boolean isRunOnlyIfAllValidationPass) {
    return runMultipleActions(actionType, parameters, isRunOnlyIfAllValidationPass, false);
}
#end_block

#method_before
@Override
@ExcludeClassInterceptors
public ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, CommandContext commandContext) {
    return runMultipleActionsImpl(actionType, parameters, true, false, false, commandContext);
}
#method_after
@Override
@ExcludeClassInterceptors
public List<ActionReturnValue> runInternalMultipleActions(ActionType actionType, List<ActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, true, false, false, null);
}
#end_block

#method_before
private ArrayList<VdcReturnValueBase> runMultipleActionsImpl(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isInternal, boolean isRunOnlyIfAllValidationPass, boolean isWaitForResult, CommandContext commandContext) {
    MultipleActionsRunner runner = multipleActionsRunnersFactory.createMultipleActionsRunner(actionType, parameters, isInternal, commandContext);
    runner.setIsRunOnlyIfAllValidatePass(isRunOnlyIfAllValidationPass);
    runner.setIsWaitForResult(isWaitForResult);
    return runner.execute();
}
#method_after
private List<ActionReturnValue> runMultipleActionsImpl(ActionType actionType, List<ActionParametersBase> parameters, boolean isInternal, boolean isRunOnlyIfAllValidationPass, boolean isWaitForResult, CommandContext commandContext) {
    MultipleActionsRunner runner = multipleActionsRunnersFactory.createMultipleActionsRunner(actionType, parameters, isInternal, commandContext);
    runner.setIsRunOnlyIfAllValidatePass(isRunOnlyIfAllValidationPass);
    runner.setIsWaitForResult(isWaitForResult);
    return runner.execute();
}
#end_block

#method_before
@Override
public VdcReturnValueBase logoff(VdcActionParametersBase parameters) {
    return runAction(VdcActionType.LogoutSession, parameters);
}
#method_after
@Override
public ActionReturnValue logoff(ActionParametersBase parameters) {
    return runAction(ActionType.LogoutSession, parameters);
}
#end_block

#method_before
@Override
public VdcQueryReturnValue runPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    parameters.setRefresh(false);
    switch(actionType) {
        case GetAAAProfileList:
        case RegisterVds:
        case CheckDBConnection:
        case GetDbUserBySession:
        case GetEngineSessionIdForSsoToken:
        case ValidateSession:
        case GetDefaultAllowedOrigins:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
            switch(configParameters.getConfigValue()) {
                case VdcVersion:
                case ProductRPMVersion:
                case ApplicationMode:
                case UserSessionTimeOutInterval:
                case CORSSupport:
                case CORSAllowedOrigins:
                case CORSAllowDefaultOrigins:
                case CORSDefaultOriginSuffixes:
                    return runQueryImpl(actionType, parameters, false);
                default:
                    break;
            }
        default:
            break;
    }
    return getErrorQueryReturnValue(EngineMessage.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
}
#method_after
@Override
public QueryReturnValue runPublicQuery(QueryType actionType, QueryParametersBase parameters) {
    parameters.setRefresh(false);
    switch(actionType) {
        case GetAAAProfileList:
        case RegisterVds:
        case CheckDBConnection:
        case GetDbUserBySession:
        case GetEngineSessionIdForSsoToken:
        case ValidateSession:
        case GetDefaultAllowedOrigins:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
            switch(configParameters.getConfigValue()) {
                case VdcVersion:
                case ProductRPMVersion:
                case ApplicationMode:
                case UserSessionTimeOutInterval:
                case CORSSupport:
                case CORSAllowedOrigins:
                case CORSAllowDefaultOrigins:
                case CORSDefaultOriginSuffixes:
                    return runQueryImpl(actionType, parameters, false);
                default:
                    break;
            }
        default:
            break;
    }
    return getErrorQueryReturnValue(EngineMessage.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
}
#end_block

#method_before
private VdcReturnValueBase getErrorCommandReturnValue(EngineMessage message) {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setValid(false);
    returnValue.getValidationMessages().add(message.toString());
    return returnValue;
}
#method_after
private ActionReturnValue getErrorCommandReturnValue(EngineMessage message) {
    ActionReturnValue returnValue = new ActionReturnValue();
    returnValue.setValid(false);
    returnValue.getValidationMessages().add(message.toString());
    return returnValue;
}
#end_block

#method_before
private VdcReturnValueBase notAllowedInPrepForMaintMode(VdcActionType action) {
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getCommandClass(action.name());
    if (clazz.isAnnotationPresent(DisableInPrepareMode.class)) {
        return getErrorCommandReturnValue(EngineMessage.ENGINE_IS_RUNNING_IN_PREPARE_MODE);
    }
    return null;
}
#method_after
private ActionReturnValue notAllowedInPrepForMaintMode(ActionType action) {
    Class<?> clazz = CommandsFactory.getCommandClass(action.name());
    if (clazz.isAnnotationPresent(DisableInPrepareMode.class)) {
        return getErrorCommandReturnValue(EngineMessage.ENGINE_IS_RUNNING_IN_PREPARE_MODE);
    }
    return null;
}
#end_block

#method_before
private VdcQueryReturnValue getErrorQueryReturnValue(EngineMessage errorMessage) {
    VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
    returnValue.setSucceeded(false);
    returnValue.setExceptionString(errorMessage.toString());
    return returnValue;
}
#method_after
private QueryReturnValue getErrorQueryReturnValue(EngineMessage errorMessage) {
    QueryReturnValue returnValue = new QueryReturnValue();
    returnValue.setSucceeded(false);
    returnValue.setExceptionString(errorMessage.toString());
    return returnValue;
}
#end_block

#method_before
protected QueriesCommandBase<?> createQueryCommand(VdcQueryType actionType, VdcQueryParametersBase parameters, EngineContext engineContext) {
    return CommandsFactory.createQueryCommand(actionType, parameters, engineContext);
}
#method_after
protected QueriesCommandBase<?> createQueryCommand(QueryType actionType, QueryParametersBase parameters, EngineContext engineContext) {
    return CommandsFactory.createQueryCommand(actionType, parameters, engineContext);
}
#end_block

#method_before
@Override
public CommandBase<?> createAction(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext context) {
    return CommandsFactory.createCommand(actionType, parameters, context);
}
#method_after
@Override
public CommandBase<?> createAction(ActionType actionType, ActionParametersBase parameters, CommandContext context) {
    return CommandsFactory.createCommand(actionType, parameters, context);
}
#end_block

#method_before
@Override
public VdcReturnValueBase runAction(CommandBase<?> action, ExecutionContext executionContext) {
    ExecutionHandler.setExecutionContextForTasks(action.getContext(), executionContext, action.getContext().getLock());
    return runAction(action, true);
}
#method_after
@Override
public ActionReturnValue runAction(CommandBase<?> action, ExecutionContext executionContext) {
    ExecutionHandler.setExecutionContextForTasks(action.getContext(), executionContext, action.getContext().getLock());
    return runAction(action, true);
}
#end_block

#method_before
private void loadClusterPolicies() {
    // Load internal cluster policies
    policyMap.putAll(InternalClusterPolicies.getClusterPolicies());
    Map<Guid, PolicyUnitType> internalTypes = new HashMap<>();
    for (PolicyUnitImpl unit : policyUnits.values()) {
        internalTypes.put(unit.getGuid(), unit.getType());
    }
    // Get all user provided cluster policies
    List<ClusterPolicy> allClusterPolicies = getClusterPolicyDao().getAll(Collections.unmodifiableMap(internalTypes));
    for (ClusterPolicy clusterPolicy : allClusterPolicies) {
        policyMap.put(clusterPolicy.getId(), clusterPolicy);
    }
}
#method_after
private void loadClusterPolicies() {
    // Load internal cluster policies
    policyMap.putAll(InternalClusterPolicies.getClusterPolicies());
    Map<Guid, PolicyUnitType> internalTypes = new HashMap<>();
    for (PolicyUnitImpl unit : policyUnits.values()) {
        internalTypes.put(unit.getGuid(), unit.getType());
    }
    // Get all user provided cluster policies
    List<ClusterPolicy> allClusterPolicies = clusterPolicyDao.getAll(Collections.unmodifiableMap(internalTypes));
    for (ClusterPolicy clusterPolicy : allClusterPolicies) {
        policyMap.put(clusterPolicy.getId(), clusterPolicy);
    }
}
#end_block

#method_before
private void loadPolicyUnits() {
    // Load internal policy units
    for (Class<? extends PolicyUnitImpl> unitType : InternalPolicyUnits.getList()) {
        try {
            PolicyUnitImpl unit = InternalPolicyUnits.instantiate(unitType, getPendingResourceManager());
            policyUnits.put(unit.getGuid(), Injector.injectMembers(unit));
        } catch (Exception e) {
            log.error("Could not instantiate a policy unit {}.", unitType.getName(), e);
        }
    }
    // Load all external policy units
    List<PolicyUnit> allPolicyUnits = getPolicyUnitDao().getAll();
    for (PolicyUnit policyUnit : allPolicyUnits) {
        policyUnits.put(policyUnit.getId(), new ExternalPolicyUnit(policyUnit, getPendingResourceManager()));
    }
}
#method_after
private void loadPolicyUnits() {
    // Load internal policy units
    for (Class<? extends PolicyUnitImpl> unitType : InternalPolicyUnits.getList()) {
        try {
            PolicyUnitImpl unit = InternalPolicyUnits.instantiate(unitType, getPendingResourceManager());
            policyUnits.put(unit.getGuid(), Injector.injectMembers(unit));
        } catch (Exception e) {
            log.error("Could not instantiate a policy unit {}.", unitType.getName(), e);
        }
    }
    // Load all external policy units
    List<PolicyUnit> allPolicyUnits = policyUnitDao.getAll();
    for (PolicyUnit policyUnit : allPolicyUnits) {
        policyUnits.put(policyUnit.getId(), new ExternalPolicyUnit(policyUnit, getPendingResourceManager()));
    }
}
#end_block

#method_before
public Optional<Guid> schedule(Cluster cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, List<Guid> destHostIdList, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    prepareClusterLock(cluster.getId());
    try {
        log.debug("Scheduling started, correlation Id: {}", correlationId);
        checkAllowOverbooking(cluster);
        lockCluster(cluster.getId());
        List<VDS> vdsList = getVdsDao().getAllForClusterWithStatus(cluster.getId(), VDSStatus.Up);
        vdsList = removeBlacklistedHosts(vdsList, hostBlackList);
        vdsList = keepOnlyWhitelistedHosts(vdsList, hostWhiteList);
        refreshCachedPendingValues(vdsList);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), cluster, vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList.isEmpty()) {
            return Optional.empty();
        }
        Optional<Guid> bestHost = selectBestHost(cluster, vm, destHostIdList, vdsList, policy, parameters);
        if (bestHost.isPresent() && !bestHost.get().equals(vm.getRunOnVds())) {
            Guid bestHostId = bestHost.get();
            getPendingResourceManager().addPending(new PendingCpuCores(bestHostId, vm, vm.getNumOfCpus()));
            VDS bestHostEntity = vdsList.stream().filter(vds -> vds.getId().equals(bestHostId)).findFirst().get();
            getPendingResourceManager().addPending(new PendingMemory(bestHostId, vm, bestHostEntity.getGuestOverhead()));
            getPendingResourceManager().addPending(new PendingOvercommitMemory(bestHostId, vm, vm.getMemSizeMb()));
            getPendingResourceManager().addPending(new PendingVM(bestHostId, vm));
            getPendingResourceManager().notifyHostManagers(bestHostId);
            markVfsAsUsedByVm(vm, bestHostId);
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("scheduling interrupted, correlation Id: {}: {}", correlationId, e.getMessage());
        log.debug("Exception: ", e);
        return Optional.empty();
    } finally {
        releaseCluster(cluster.getId());
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#method_after
public Optional<Guid> schedule(Cluster cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, List<Guid> destHostIdList, List<String> messages, RunVmDelayer runVmDelayer, String correlationId) {
    prepareClusterLock(cluster.getId());
    try {
        log.debug("Scheduling started, correlation Id: {}", correlationId);
        checkAllowOverbooking(cluster);
        lockCluster(cluster.getId());
        List<VDS> vdsList = vdsDao.getAllForClusterWithStatus(cluster.getId(), VDSStatus.Up);
        vdsList = removeBlacklistedHosts(vdsList, hostBlackList);
        vdsList = keepOnlyWhitelistedHosts(vdsList, hostWhiteList);
        refreshCachedPendingValues(vdsList);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), cluster, vdsList, vm, parameters, policy.getFilterPositionMap(), messages, runVmDelayer, true, correlationId);
        if (vdsList.isEmpty()) {
            return Optional.empty();
        }
        Optional<Guid> bestHost = selectBestHost(cluster, vm, destHostIdList, vdsList, policy, parameters);
        if (bestHost.isPresent() && !bestHost.get().equals(vm.getRunOnVds())) {
            Guid bestHostId = bestHost.get();
            getPendingResourceManager().addPending(new PendingCpuCores(bestHostId, vm, vm.getNumOfCpus()));
            VDS bestHostEntity = vdsList.stream().filter(vds -> vds.getId().equals(bestHostId)).findFirst().get();
            getPendingResourceManager().addPending(new PendingMemory(bestHostId, vm, bestHostEntity.getGuestOverhead()));
            getPendingResourceManager().addPending(new PendingOvercommitMemory(bestHostId, vm, HugePageUtils.getRequiredMemoryWithoutHugePages(vm.getStaticData())));
            getPendingResourceManager().addPending(new PendingVM(bestHostId, vm));
            // Add pending records for all specified hugepage sizes
            for (Map.Entry<Integer, Integer> hugepage : HugePageUtils.getHugePages(vm.getStaticData()).entrySet()) {
                getPendingResourceManager().addPending(new PendingHugePages(bestHostId, vm, hugepage.getKey(), hugepage.getValue()));
            }
            getPendingResourceManager().notifyHostManagers(bestHostId);
            markVfsAsUsedByVm(vm, bestHostId);
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("scheduling interrupted, correlation Id: {}: {}", correlationId, e.getMessage());
        log.debug("Exception: ", e);
        return Optional.empty();
    } finally {
        releaseCluster(cluster.getId());
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#end_block

#method_before
public boolean canSchedule(Cluster cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, List<String> messages) {
    List<VDS> vdsList = getVdsDao().getAllForClusterWithStatus(cluster.getId(), VDSStatus.Up);
    vdsList = removeBlacklistedHosts(vdsList, vdsBlackList);
    vdsList = keepOnlyWhitelistedHosts(vdsList, vdsWhiteList);
    refreshCachedPendingValues(vdsList);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), cluster, vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, false, null);
    return vdsList != null && !vdsList.isEmpty();
}
#method_after
public boolean canSchedule(Cluster cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, List<String> messages) {
    List<VDS> vdsList = vdsDao.getAllForClusterWithStatus(cluster.getId(), VDSStatus.Up);
    vdsList = removeBlacklistedHosts(vdsList, vdsBlackList);
    vdsList = keepOnlyWhitelistedHosts(vdsList, vdsWhiteList);
    refreshCachedPendingValues(vdsList);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), cluster, vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingVmDelayer, false, null);
    return vdsList != null && !vdsList.isEmpty();
}
#end_block

#method_before
private List<VDS> runFilters(ArrayList<Guid> filters, Cluster cluster, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<>();
    // Create a local copy so we can manipulate it
    filters = new ArrayList<>(filters);
    sortFilters(filters, filterPositionMap);
    for (Guid filter : filters) {
        PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
        if (filterPolicyUnit.getPolicyUnit().isInternal()) {
            internalFilters.add(filterPolicyUnit);
        } else {
            if (filterPolicyUnit.getPolicyUnit().isEnabled()) {
                externalFilters.add(filterPolicyUnit);
            }
        }
    }
    /* Short circuit filters if there are no hosts at all */
    if (hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_NO_HOSTS.name());
        messages.addAll(result.getReasonMessages());
        return hostList;
    }
    hostList = runInternalFilters(internalFilters, cluster, hostList, vm, parameters, filterPositionMap, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalFilters.isEmpty() && !hostList.isEmpty()) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#method_after
private List<VDS> runFilters(ArrayList<Guid> filters, Cluster cluster, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, RunVmDelayer runVmDelayer, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<>();
    // Create a local copy so we can manipulate it
    filters = new ArrayList<>(filters);
    sortFilters(filters, filterPositionMap);
    for (Guid filter : filters) {
        PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
        if (filterPolicyUnit.getPolicyUnit().isInternal()) {
            internalFilters.add(filterPolicyUnit);
        } else {
            if (filterPolicyUnit.getPolicyUnit().isEnabled()) {
                externalFilters.add(filterPolicyUnit);
            }
        }
    }
    /* Short circuit filters if there are no hosts at all */
    if (hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_NO_HOSTS.name());
        messages.addAll(result.getReasonMessages());
        return hostList;
    }
    hostList = runInternalFilters(internalFilters, cluster, hostList, vm, parameters, runVmDelayer, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalFilters.isEmpty() && !hostList.isEmpty()) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, correlationId, result);
    }
    if (hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#end_block

#method_before
private List<VDS> runInternalFilters(ArrayList<PolicyUnitImpl> filters, Cluster cluster, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, VdsFreeMemoryChecker memoryChecker, String correlationId, SchedulingResult result) {
    for (PolicyUnitImpl filterPolicyUnit : filters) {
        if (hostList.isEmpty()) {
            break;
        }
        filterPolicyUnit.setMemoryChecker(memoryChecker);
        List<VDS> currentHostList = new ArrayList<>(hostList);
        hostList = filterPolicyUnit.filter(cluster, hostList, vm, parameters, result.getDetails());
        logFilterActions(currentHostList, toIdSet(hostList), EngineMessage.VAR__FILTERTYPE__INTERNAL, filterPolicyUnit.getPolicyUnit().getName(), result, correlationId);
    }
    return hostList;
}
#method_after
private List<VDS> runInternalFilters(ArrayList<PolicyUnitImpl> filters, Cluster cluster, List<VDS> hostList, VM vm, Map<String, String> parameters, RunVmDelayer runVmDelayer, String correlationId, SchedulingResult result) {
    for (PolicyUnitImpl filterPolicyUnit : filters) {
        if (hostList.isEmpty()) {
            break;
        }
        filterPolicyUnit.setRunVmDelayer(runVmDelayer);
        List<VDS> currentHostList = new ArrayList<>(hostList);
        hostList = filterPolicyUnit.filter(cluster, hostList, vm, parameters, result.getDetails());
        logFilterActions(currentHostList, toIdSet(hostList), EngineMessage.VAR__FILTERTYPE__INTERNAL, filterPolicyUnit.getPolicyUnit().getName(), result, correlationId);
    }
    return hostList;
}
#end_block

#method_before
private List<VDS> runExternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, List<String> messages, String correlationId, SchedulingResult result) {
    List<Guid> hostIDs = hostList.stream().map(VDS::getId).collect(Collectors.toList());
    List<String> filterNames = filters.stream().filter(f -> !f.getPolicyUnit().isInternal()).map(f -> f.getPolicyUnit().getName()).collect(Collectors.toList());
    List<Guid> filteredIDs = externalBroker.runFilters(filterNames, hostIDs, vm.getId(), parameters);
    logFilterActions(hostList, new HashSet<>(filteredIDs), EngineMessage.VAR__FILTERTYPE__EXTERNAL, Arrays.toString(filterNames.toArray()), result, correlationId);
    hostList = intersectHosts(hostList, filteredIDs);
    return hostList;
}
#method_after
private List<VDS> runExternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, String correlationId, SchedulingResult result) {
    List<Guid> hostIDs = hostList.stream().map(VDS::getId).collect(Collectors.toList());
    List<String> filterNames = filters.stream().filter(f -> !f.getPolicyUnit().isInternal()).map(f -> f.getPolicyUnit().getName()).collect(Collectors.toList());
    List<Guid> filteredIDs = externalBroker.runFilters(filterNames, hostIDs, vm.getId(), parameters);
    logFilterActions(hostList, new HashSet<>(filteredIDs), EngineMessage.VAR__FILTERTYPE__EXTERNAL, Arrays.toString(filterNames.toArray()), result, correlationId);
    hostList = intersectHosts(hostList, filteredIDs);
    return hostList;
}
#end_block

#method_before
private void sortFilters(ArrayList<Guid> filters, final Map<Guid, Integer> filterPositionMap) {
    Collections.sort(filters, new Comparator<Guid>() {

        @Override
        public int compare(Guid filter1, Guid filter2) {
            Integer position1 = getPosition(filterPositionMap.get(filter1));
            Integer position2 = getPosition(filterPositionMap.get(filter2));
            return position1 - position2;
        }

        private Integer getPosition(Integer position) {
            if (position == null) {
                position = 0;
            }
            return position;
        }
    });
}
#method_after
private void sortFilters(ArrayList<Guid> filters, final Map<Guid, Integer> filterPositionMap) {
    filters.sort(Comparator.comparingInt(f -> filterPositionMap.getOrDefault(f, 0)));
}
#end_block

#method_before
public void addClusterPolicy(ClusterPolicy clusterPolicy) {
    getClusterPolicyDao().save(clusterPolicy);
    policyMap.put(clusterPolicy.getId(), clusterPolicy);
}
#method_after
public void addClusterPolicy(ClusterPolicy clusterPolicy) {
    clusterPolicyDao.save(clusterPolicy);
    policyMap.put(clusterPolicy.getId(), clusterPolicy);
}
#end_block

#method_before
public void editClusterPolicy(ClusterPolicy clusterPolicy) {
    getClusterPolicyDao().update(clusterPolicy);
    policyMap.put(clusterPolicy.getId(), clusterPolicy);
}
#method_after
public void editClusterPolicy(ClusterPolicy clusterPolicy) {
    clusterPolicyDao.update(clusterPolicy);
    policyMap.put(clusterPolicy.getId(), clusterPolicy);
}
#end_block

#method_before
public void removeClusterPolicy(Guid clusterPolicyId) {
    getClusterPolicyDao().remove(clusterPolicyId);
    policyMap.remove(clusterPolicyId);
}
#method_after
public void removeClusterPolicy(Guid clusterPolicyId) {
    clusterPolicyDao.remove(clusterPolicyId);
    policyMap.remove(clusterPolicyId);
}
#end_block

#method_before
private void enableLoadBalancer() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start scheduling to enable vds load balancer");
        executor.scheduleWithFixedDelay(() -> performLoadBalancing(), Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), TimeUnit.MINUTES);
        log.info("Finished scheduling to enable vds load balancer");
    }
}
#method_after
private void enableLoadBalancer() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start scheduling to enable vds load balancer");
        executor.scheduleWithFixedDelay(this::performLoadBalancing, Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), TimeUnit.MINUTES);
        log.info("Finished scheduling to enable vds load balancer");
    }
}
#end_block

#method_before
private void enableHaReservationCheck() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start HA Reservation check");
        Integer interval = Config.<Integer>getValue(ConfigValues.VdsHaReservationIntervalInMinutes);
        executor.scheduleWithFixedDelay(() -> performHaResevationCheck(), interval, interval, TimeUnit.MINUTES);
        log.info("Finished HA Reservation check");
    }
}
#method_after
private void enableHaReservationCheck() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start HA Reservation check");
        Integer interval = Config.<Integer>getValue(ConfigValues.VdsHaReservationIntervalInMinutes);
        executor.scheduleWithFixedDelay(this::performHaResevationCheck, interval, interval, TimeUnit.MINUTES);
        log.info("Finished HA Reservation check");
    }
}
#end_block

#method_before
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<Cluster> clusters = getClusterDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling(getPendingResourceManager());
        for (Cluster cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<>();
                boolean clusterHaStatus = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!clusterHaStatus) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
                    logable.setClusterId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = returnedFailedHosts.stream().map(VDS::getName).collect(Collectors.joining(", "));
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION, auditLogDirector);
                    log.info("Cluster '{}' fail to pass HA reservation check.", cluster.getName());
                }
                boolean clusterHaStatusFromPreviousCycle = clusterId2isHaReservationSafe.containsKey(cluster.getId()) ? clusterId2isHaReservationSafe.get(cluster.getId()) : true;
                // Update the status map with the new status
                clusterId2isHaReservationSafe.put(cluster.getId(), clusterHaStatus);
                // Create Alert if the status was changed from false to true
                if (!clusterHaStatusFromPreviousCycle && clusterHaStatus) {
                    AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
                    logable.setClusterId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    AlertDirector.alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION_DOWN, auditLogDirector);
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#method_after
private void performHaResevationCheck() {
    try {
        performHaResevationCheckImpl();
    } catch (Throwable t) {
        log.error("Exception in performing HA Reservation check: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
public void performLoadBalancing() {
    log.debug("Load Balancer timer entered.");
    List<Cluster> clusters = getClusterDao().getAll();
    for (Cluster cluster : clusters) {
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        PolicyUnitImpl policyUnit = policyUnits.get(policy.getBalance());
        Optional<BalanceResult> balanceResult = Optional.empty();
        if (policyUnit.getPolicyUnit().isEnabled()) {
            List<VDS> hosts = getVdsDao().getAllForClusterWithoutMigrating(cluster.getId());
            if (policyUnit.getPolicyUnit().isInternal()) {
                balanceResult = internalRunBalance(policyUnit, cluster, hosts);
            } else if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
                balanceResult = externalRunBalance(policyUnit, cluster, hosts);
            }
        }
        if (balanceResult.isPresent() && balanceResult.get().isValid()) {
            migrationHandler.migrateVM(balanceResult.get().getCandidateHosts(), balanceResult.get().getVmToMigrate(), AuditLogDirector.getMessage(AuditLogType.MIGRATION_REASON_LOAD_BALANCING));
        }
    }
}
#method_after
private void performLoadBalancing() {
    try {
        performLoadBalancingImpl();
    } catch (Throwable t) {
        log.error("Exception in performing load balancing: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
public void removeExternalPolicyUnit(Guid policyUnitId) {
    getPolicyUnitDao().remove(policyUnitId);
    policyUnits.remove(policyUnitId);
}
#method_after
public void removeExternalPolicyUnit(Guid policyUnitId) {
    policyUnitDao.remove(policyUnitId);
    policyUnits.remove(policyUnitId);
}
#end_block

#method_before
public void updateHostSchedulingStats(VDS vds) {
    if (vds.getUsageCpuPercent() != null) {
        Cluster cluster = getClusterDao().get(vds.getClusterId());
        if (vds.getUsageCpuPercent() >= NumberUtils.toInt(cluster.getClusterPolicyProperties().get(HIGH_UTILIZATION), Config.<Integer>getValue(ConfigValues.HighUtilizationForEvenlyDistribute)) || vds.getUsageCpuPercent() <= NumberUtils.toInt(cluster.getClusterPolicyProperties().get(LOW_UTILIZATION), Config.<Integer>getValue(ConfigValues.LowUtilizationForEvenlyDistribute))) {
            if (vds.getCpuOverCommitTimestamp() == null) {
                vds.setCpuOverCommitTimestamp(new Date());
            }
        } else {
            vds.setCpuOverCommitTimestamp(null);
        }
    }
}
#method_after
public void updateHostSchedulingStats(VDS vds) {
    if (vds.getUsageCpuPercent() != null) {
        Cluster cluster = clusterDao.get(vds.getClusterId());
        if (vds.getUsageCpuPercent() >= NumberUtils.toInt(cluster.getClusterPolicyProperties().get(HIGH_UTILIZATION), Config.<Integer>getValue(ConfigValues.HighUtilizationForEvenlyDistribute)) || vds.getUsageCpuPercent() <= NumberUtils.toInt(cluster.getClusterPolicyProperties().get(LOW_UTILIZATION), Config.<Integer>getValue(ConfigValues.LowUtilizationForEvenlyDistribute))) {
            if (vds.getCpuOverCommitTimestamp() == null) {
                vds.setCpuOverCommitTimestamp(new Date());
            }
        } else {
            vds.setCpuOverCommitTimestamp(null);
        }
    }
}
#end_block

#method_before
public void clearPendingVm(VmStatic vm) {
    prepareClusterLock(vm.getClusterId());
    try {
        lockCluster(vm.getClusterId());
        getPendingResourceManager().clearVm(vm);
    } catch (InterruptedException e) {
        log.warn("Interrupted.. pending counters can be out of sync");
    } finally {
        releaseCluster(vm.getClusterId());
    }
}
#method_after
public void clearPendingVm(VmStatic vm) {
    getPendingResourceManager().clearVm(vm);
}
#end_block

#method_before
@PostConstruct
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    succeededJobTime = Config.<Integer>getValue(ConfigValues.SucceededJobCleanupTimeInMinutes);
    failedJobTime = Config.<Integer>getValue(ConfigValues.FailedJobCleanupTimeInMinutes);
    Integer cleanupFrequency = Config.<Integer>getValue(ConfigValues.JobCleanupRateInMinutes);
    executor.scheduleWithFixedDelay(() -> cleanCompletedJob(), cleanupFrequency, cleanupFrequency, TimeUnit.MINUTES);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#method_after
@PostConstruct
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    succeededJobTime = Config.<Integer>getValue(ConfigValues.SucceededJobCleanupTimeInMinutes);
    failedJobTime = Config.<Integer>getValue(ConfigValues.FailedJobCleanupTimeInMinutes);
    Integer cleanupFrequency = Config.<Integer>getValue(ConfigValues.JobCleanupRateInMinutes);
    executor.scheduleWithFixedDelay(this::cleanCompletedJob, cleanupFrequency, cleanupFrequency, TimeUnit.MINUTES);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
public void cleanCompletedJob() {
    Date succeededJobsDeleteTime = new Date(System.currentTimeMillis() - TimeUnit.MILLISECONDS.convert(succeededJobTime, TimeUnit.MINUTES));
    Date failedJobsDeleteTime = new Date(System.currentTimeMillis() - TimeUnit.MILLISECONDS.convert(failedJobTime, TimeUnit.MINUTES));
    try {
        jobDao.deleteCompletedJobs(succeededJobsDeleteTime, failedJobsDeleteTime);
    } catch (RuntimeException e) {
        log.error("Failed to delete completed jobs: {}", e.getMessage());
        log.debug("Exception", e);
    }
}
#method_after
private void cleanCompletedJob() {
    Date succeededJobsDeleteTime = new Date(System.currentTimeMillis() - TimeUnit.MILLISECONDS.convert(succeededJobTime, TimeUnit.MINUTES));
    Date failedJobsDeleteTime = new Date(System.currentTimeMillis() - TimeUnit.MILLISECONDS.convert(failedJobTime, TimeUnit.MINUTES));
    try {
        jobDao.deleteCompletedJobs(succeededJobsDeleteTime, failedJobsDeleteTime);
    } catch (Throwable t) {
        log.error("Failed to delete completed jobs: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
@Before
public void setup() {
    cluster1 = createCluster();
    cluster2 = createCluster();
    when(clusterDao.getWithoutMigratingVms()).thenReturn(Arrays.asList(cluster1, cluster2));
    when(rulesEnforcer.chooseNextVmToMigrate(eq(cluster1))).thenReturn(vm1);
    when(rulesEnforcer.chooseNextVmToMigrate(eq(cluster2))).thenReturn(vm2);
    when(arem.getExecutor()).thenReturn(Executors.newScheduledThreadPool(1));
    arem.wakeup();
}
#method_after
@Before
public void setup() {
    cluster1 = createCluster();
    cluster2 = createCluster();
    when(clusterDao.getWithoutMigratingVms()).thenReturn(Arrays.asList(cluster1, cluster2));
    when(rulesEnforcer.chooseNextVmToMigrate(eq(cluster1))).thenReturn(vm1);
    when(rulesEnforcer.chooseNextVmToMigrate(eq(cluster2))).thenReturn(vm2);
    arem.wakeup();
}
#end_block

#method_before
@Test
public void shouldMigrateOneVmPerCluster() {
    when(rulesEnforcer.chooseNextVmToMigrate(eq(cluster1))).thenReturn(vm1, mock(VM.class), mock(VM.class));
    arem.refresh();
    verify(arem, times(1)).migrateVM(eq(vm1));
    verify(arem, times(1)).migrateVM(eq(vm2));
    verify(arem, times(2)).migrateVM(any(VM.class));
}
#method_after
@Test
public void shouldMigrateOneVmPerCluster() {
    when(rulesEnforcer.chooseNextVmToMigrate(eq(cluster1))).thenReturn(vm1, mock(VM.class), mock(VM.class));
    arem.refresh();
    verify(arem, times(1)).migrateVM(eq(vm1));
    verify(arem, times(1)).migrateVM(eq(vm2));
    verify(arem, times(2)).migrateVM(any());
}
#end_block

#method_before
@Test
public void shouldNotMigrateVmOnClusterTwoWhileMigrating() {
    final VM migratingVM = new VM();
    migratingVM.setClusterId(cluster2.getId());
    when(clusterDao.getWithoutMigratingVms()).thenReturn(Collections.singletonList(cluster1));
    arem.refresh();
    verify(arem).migrateVM(vm1);
    verify(arem, times(1)).migrateVM(any(VM.class));
}
#method_after
@Test
public void shouldNotMigrateVmOnClusterTwoWhileMigrating() {
    final VM migratingVM = new VM();
    migratingVM.setClusterId(cluster2.getId());
    when(clusterDao.getWithoutMigratingVms()).thenReturn(Collections.singletonList(cluster1));
    arem.refresh();
    verify(arem).migrateVM(vm1);
    verify(arem, times(1)).migrateVM(any());
}
#end_block

#method_before
@Test
public void shouldNotMigrateVmOnClusterTwoWhileInUpgradeMode() {
    cluster2.setClusterPolicyId(ClusterPolicy.UPGRADE_POLICY_GUID);
    arem.refresh();
    verify(arem).migrateVM(vm1);
    verify(arem, times(1)).migrateVM(any(VM.class));
    verify(arem, times(0)).migrateVM(eq(vm2));
}
#method_after
@Test
public void shouldNotMigrateVmOnClusterTwoWhileInUpgradeMode() {
    cluster2.setClusterPolicyId(ClusterPolicy.UPGRADE_POLICY_GUID);
    arem.refresh();
    verify(arem).migrateVM(vm1);
    verify(arem, times(1)).migrateVM(any());
    verify(arem, times(0)).migrateVM(eq(vm2));
}
#end_block

#method_before
@Test
public void shouldNotMigrateVmOnClusterTwoWhenEnforced() {
    when(rulesEnforcer.chooseNextVmToMigrate(eq(cluster2))).thenReturn(null);
    arem.refresh();
    verify(arem).migrateVM(vm1);
    verify(arem, times(1)).migrateVM(any(VM.class));
}
#method_after
@Test
public void shouldNotMigrateVmOnClusterTwoWhenEnforced() {
    when(rulesEnforcer.chooseNextVmToMigrate(eq(cluster2))).thenReturn(null);
    arem.refresh();
    verify(arem).migrateVM(vm1);
    verify(arem, times(1)).migrateVM(any());
}
#end_block

#method_before
@Test
public void shouldHaveNotingToMigrate() {
    verify(arem, never()).migrateVM(any(VM.class));
}
#method_after
@Test
public void shouldHaveNotingToMigrate() {
    verify(arem, never()).migrateVM(any());
}
#end_block

#method_before
@PostConstruct
public void scheduleJob() {
    double interval = Config.<Double>getValue(ConfigValues.CertificationValidityCheckTimeInHours);
    final int HOURS_TO_MINUTES = 60;
    long intervalInMinutes = Math.round(interval * HOURS_TO_MINUTES);
    executor.scheduleWithFixedDelay(() -> checkCertificationValidity(), 10, intervalInMinutes, TimeUnit.MINUTES);
}
#method_after
@PostConstruct
public void scheduleJob() {
    double interval = Config.<Double>getValue(ConfigValues.CertificationValidityCheckTimeInHours);
    final int HOURS_TO_MINUTES = 60;
    long intervalInMinutes = Math.round(interval * HOURS_TO_MINUTES);
    executor.scheduleWithFixedDelay(this::checkCertificationValidity, 10, intervalInMinutes, TimeUnit.MINUTES);
}
#end_block

#method_before
public void checkCertificationValidity() {
    try {
        if (!checkCertificate(EngineEncryptionUtils.getCertificate(EngineLocalConfig.getInstance().getPKICACert()), AuditLogType.ENGINE_CA_CERTIFICATION_HAS_EXPIRED, AuditLogType.ENGINE_CA_CERTIFICATION_IS_ABOUT_TO_EXPIRE_ALERT, AuditLogType.ENGINE_CA_CERTIFICATION_IS_ABOUT_TO_EXPIRE, null) ^ !checkCertificate((X509Certificate) EngineEncryptionUtils.getCertificate(), AuditLogType.ENGINE_CERTIFICATION_HAS_EXPIRED, AuditLogType.ENGINE_CERTIFICATION_IS_ABOUT_TO_EXPIRE_ALERT, AuditLogType.ENGINE_CERTIFICATION_IS_ABOUT_TO_EXPIRE, null)) {
            return;
        }
        if (!Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication)) {
            return;
        }
        hostDao.getAll().stream().filter(host -> host.getStatus() == VDSStatus.Up || host.getStatus() == VDSStatus.NonOperational).forEach(this::checkHostCertificateValidity);
    } catch (Exception e) {
        log.error("Failed to check certification validity: {}", e.getMessage());
        log.error("Exception", e);
    }
}
#method_after
private void checkCertificationValidity() {
    try {
        if (!checkCertificate(EngineEncryptionUtils.getCertificate(EngineLocalConfig.getInstance().getPKICACert()), AuditLogType.ENGINE_CA_CERTIFICATION_HAS_EXPIRED, AuditLogType.ENGINE_CA_CERTIFICATION_IS_ABOUT_TO_EXPIRE_ALERT, AuditLogType.ENGINE_CA_CERTIFICATION_IS_ABOUT_TO_EXPIRE, null) ^ !checkCertificate((X509Certificate) EngineEncryptionUtils.getCertificate(), AuditLogType.ENGINE_CERTIFICATION_HAS_EXPIRED, AuditLogType.ENGINE_CERTIFICATION_IS_ABOUT_TO_EXPIRE_ALERT, AuditLogType.ENGINE_CERTIFICATION_IS_ABOUT_TO_EXPIRE, null)) {
            return;
        }
        if (!Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication)) {
            return;
        }
        hostDao.getAll().stream().filter(host -> host.getStatus() == VDSStatus.Up || host.getStatus() == VDSStatus.NonOperational).forEach(this::checkHostCertificateValidity);
    } catch (Throwable t) {
        log.error("Failed to check certification validity: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
private boolean checkCertificate(X509Certificate cert, AuditLogType alertExpirationEventType, AuditLogType alertAboutToExpireEventType, AuditLogType warnAboutToExpireEventType, VDS host) {
    Date expirationDate = cert.getNotAfter();
    Date certWarnTime = getExpirationDate(expirationDate, ConfigValues.CertExpirationWarnPeriodInDays);
    Date certAlertTime = getExpirationDate(expirationDate, ConfigValues.CertExpirationAlertPeriodInDays);
    Date now = new Date();
    AuditLogType eventType = null;
    if (now.compareTo(expirationDate) > 0) {
        eventType = alertExpirationEventType;
    } else if (now.compareTo(certAlertTime) > 0) {
        eventType = alertAboutToExpireEventType;
    } else if (now.compareTo(certWarnTime) > 0) {
        eventType = warnAboutToExpireEventType;
    }
    if (eventType != null) {
        AuditLogableBase event = new AuditLogableBase();
        event.addCustomValue("ExpirationDate", new SimpleDateFormat("yyyy-MM-dd").format(expirationDate));
        event.setVdsName(host.getName());
        auditLogDirector.log(event, eventType);
        return false;
    }
    return true;
}
#method_after
private boolean checkCertificate(X509Certificate cert, AuditLogType alertExpirationEventType, AuditLogType alertAboutToExpireEventType, AuditLogType warnAboutToExpireEventType, VDS host) {
    Date expirationDate = cert.getNotAfter();
    Date certWarnTime = getExpirationDate(expirationDate, ConfigValues.CertExpirationWarnPeriodInDays);
    Date certAlertTime = getExpirationDate(expirationDate, ConfigValues.CertExpirationAlertPeriodInDays);
    Date now = new Date();
    AuditLogType eventType = null;
    if (now.compareTo(expirationDate) > 0) {
        eventType = alertExpirationEventType;
    } else if (now.compareTo(certAlertTime) > 0) {
        eventType = alertAboutToExpireEventType;
    } else if (now.compareTo(certWarnTime) > 0) {
        eventType = warnAboutToExpireEventType;
    }
    if (eventType != null) {
        AuditLogable event = new AuditLogableImpl();
        event.addCustomValue("ExpirationDate", new SimpleDateFormat("yyyy-MM-dd").format(expirationDate));
        if (host != null) {
            event.setVdsName(host.getName());
            event.setVdsId(host.getId());
        }
        auditLogDirector.log(event, eventType);
        return false;
    }
    return true;
}
#end_block

#method_before
@PostConstruct
private void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    executor.scheduleWithFixedDelay(() -> onTimer(), 0, 7, TimeUnit.DAYS);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#method_after
@PostConstruct
private void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    executor.scheduleWithFixedDelay(this::checkCompatibility, 0, 7, TimeUnit.DAYS);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
private void logAlert(Version version, StoragePool storagePool) {
    AuditLogableBase auditLog = Injector.injectMembers(new AuditLogableBase());
    auditLog.setStoragePool(storagePool);
    auditLog.addCustomValue("engineVersion", version.toString());
    auditLog.addCustomValue("dcVersion", storagePool.getCompatibilityVersion().toString());
    auditLogDirector.log(auditLog, AuditLogType.STORAGE_POOL_LOWER_THAN_ENGINE_HIGHEST_CLUSTER_LEVEL);
}
#method_after
private void logAlert(Version version, StoragePool storagePool) {
    AuditLogable auditLog = new AuditLogableImpl();
    auditLog.setStoragePoolId(storagePool.getId());
    auditLog.setStoragePoolName(storagePool.getName());
    auditLog.addCustomValue("engineVersion", version.toString());
    auditLog.addCustomValue("dcVersion", storagePool.getCompatibilityVersion().toString());
    auditLogDirector.log(auditLog, AuditLogType.STORAGE_POOL_LOWER_THAN_ENGINE_HIGHEST_CLUSTER_LEVEL);
}
#end_block

#method_before
@PostConstruct
private void init() {
    int quotaCacheIntervalInMinutes = Config.<Integer>getValue(ConfigValues.QuotaCacheIntervalInMinutes);
    executor.scheduleWithFixedDelay(() -> updateQuotaCache(), 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
}
#method_after
@PostConstruct
private void init() {
    int quotaCacheIntervalInMinutes = Config.<Integer>getValue(ConfigValues.QuotaCacheIntervalInMinutes);
    executor.scheduleWithFixedDelay(this::updateQuotaCache, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
}
#end_block

#method_before
public synchronized void updateQuotaCache() {
    if (!isCacheUpdateNeeded()) {
        return;
    }
    log.debug("Updating Quota Cache...");
    long timeStart = System.currentTimeMillis();
    List<Quota> allQuotaIncludingConsumption = getQuotaDao().getAllQuotaIncludingConsumption();
    if (allQuotaIncludingConsumption.isEmpty()) {
        return;
    }
    HashMap<Guid, Map<Guid, Quota>> newStoragePoolQuotaMap = new HashMap<>();
    HashMap<Guid, Guid> newDefaultQuotaIdMap = new HashMap<>();
    for (Quota quota : allQuotaIncludingConsumption) {
        if (!newStoragePoolQuotaMap.containsKey(quota.getStoragePoolId())) {
            newStoragePoolQuotaMap.put(quota.getStoragePoolId(), new HashMap<>());
        }
        newStoragePoolQuotaMap.get(quota.getStoragePoolId()).put(quota.getId(), quota);
        if (quota.isDefault()) {
            newDefaultQuotaIdMap.put(quota.getStoragePoolId(), quota.getId());
        }
    }
    lock.writeLock().lock();
    try {
        storagePoolQuotaMap = newStoragePoolQuotaMap;
        storagePoolDefaultQuotaIdMap = newDefaultQuotaIdMap;
    } finally {
        lock.writeLock().unlock();
    }
    long timeEnd = System.currentTimeMillis();
    log.info("Quota Cache updated. ({} msec)", timeEnd - timeStart);
}
#method_after
private synchronized void updateQuotaCache() {
    try {
        updateQuotaCacheImpl();
    } catch (Throwable t) {
        log.error("Exception in updating quota cache: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
@PostConstruct
private void initialize() {
    if (Config.<Boolean>getValue(ConfigValues.PMHealthCheckEnabled)) {
        log.info("Start initializing {}", getClass().getSimpleName());
        Integer pmHealthCheckInterval = Config.<Integer>getValue(ConfigValues.PMHealthCheckIntervalInSec);
        executor.scheduleWithFixedDelay(() -> pmHealthCheck(), pmHealthCheckInterval, pmHealthCheckInterval, TimeUnit.SECONDS);
    }
    // recover from engine failure
    recover(vdsDao.getAll());
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#method_after
@PostConstruct
private void initialize() {
    if (Config.<Boolean>getValue(ConfigValues.PMHealthCheckEnabled)) {
        log.info("Start initializing {}", getClass().getSimpleName());
        Integer pmHealthCheckInterval = Config.<Integer>getValue(ConfigValues.PMHealthCheckIntervalInSec);
        executor.scheduleWithFixedDelay(this::pmHealthCheck, pmHealthCheckInterval, pmHealthCheckInterval, TimeUnit.SECONDS);
    }
    // recover from engine failure
    recover(vdsDao.getAll());
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
public void pmHealthCheck() {
    // skip PM health check if previous operation is not completed yet
    if (lock.tryLock()) {
        try {
            log.info("Power Management Health Check started.");
            List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
            for (VDS host : hosts) {
                if (host.isPmEnabled()) {
                    pmHealthCheck(host);
                }
            }
            log.info("Power Management Health Check completed.");
        } finally {
            lock.unlock();
        }
    }
}
#method_after
private void pmHealthCheck() {
    try {
        // skip PM health check if previous operation is not completed yet
        if (lock.tryLock()) {
            try {
                log.info("Power Management Health Check started.");
                List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
                for (VDS host : hosts) {
                    if (host.isPmEnabled()) {
                        pmHealthCheck(host);
                    }
                }
                log.info("Power Management Health Check completed.");
            } finally {
                lock.unlock();
            }
        }
    } catch (Throwable t) {
        log.error("Exception in checking PM health: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
private void handleAlerts(PmHealth healthStatus) {
    Guid hostId = healthStatus.getHost().getId();
    // TODO: uncomment pending implementation of removing alerts by agent-id.
    // for (Entry<FenceAgent, Boolean> entry : healthStatus.getHealthMap().entrySet()) {
    // handleAgentAlerts(entry, hostId);
    // }
    handleStartAlerts(healthStatus, hostId);
    handleStopAlerts(healthStatus, hostId);
}
#method_after
private void handleAlerts(PmHealth healthStatus) {
    VDS host = healthStatus.getHost();
    // TODO: uncomment pending implementation of removing alerts by agent-id.
    // for (Entry<FenceAgent, Boolean> entry : healthStatus.getHealthMap().entrySet()) {
    // handleAgentAlerts(entry, hostId);
    // }
    handleStartAlerts(healthStatus, host);
    handleStopAlerts(healthStatus, host);
}
#end_block

#method_before
private void handleStartAlerts(PmHealth healthStatus, Guid hostId) {
    if (healthStatus.isStartShouldWork()) {
        removeAlert(hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_START_MIGHT_FAIL);
    } else {
        addAlert(hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_START_MIGHT_FAIL);
    }
}
#method_after
private void handleStartAlerts(PmHealth healthStatus, VDS host) {
    if (healthStatus.isStartShouldWork()) {
        removeAlert(host.getId(), AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_START_MIGHT_FAIL);
    } else {
        addAlert(host, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_START_MIGHT_FAIL);
    }
}
#end_block

#method_before
private void handleStopAlerts(PmHealth healthStatus, Guid hostId) {
    if (healthStatus.isStopShouldWork()) {
        removeAlert(hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_STOP_MIGHT_FAIL);
    } else {
        addAlert(hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_STOP_MIGHT_FAIL);
    }
}
#method_after
private void handleStopAlerts(PmHealth healthStatus, VDS host) {
    if (healthStatus.isStopShouldWork()) {
        removeAlert(host.getId(), AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_STOP_MIGHT_FAIL);
    } else {
        addAlert(host, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_STOP_MIGHT_FAIL);
    }
}
#end_block

#method_before
private void removeAlert(Guid hostId, AuditLogType auditMessage) {
    AlertDirector.removeVdsAlert(hostId, auditMessage);
}
#method_after
private void removeAlert(Guid hostId, AuditLogType auditMessage) {
    alertDirector.removeVdsAlert(hostId, auditMessage);
}
#end_block

#method_before
private void addAlert(Guid hostId, AuditLogType auditMessage) {
    AlertDirector.addVdsAlert(hostId, auditMessage, auditLogDirector);
}
#method_after
private void addAlert(VDS host, AuditLogType auditMessage) {
    AuditLogable alert = new AuditLogableImpl();
    alert.setVdsId(host.getId());
    alert.setVdsName(host.getName());
    alert.setClusterId(host.getClusterId());
    alert.setClusterName(host.getClusterName());
    auditLogDirector.log(alert, auditMessage);
}
#end_block

#method_before
public void startHosts(List<VDS> hostWithPMInStatusReboot) {
    for (VDS host : hostWithPMInStatusReboot) {
        RestartVdsCommand<FenceVdsActionParameters> restartVdsCommand = new RestartVdsCommand<>(new FenceVdsActionParameters(host.getId()), null);
        if (new HostFenceActionExecutor(host).isHostPoweredOff()) {
            VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.RestartVds, restartVdsCommand.getParameters());
            if (retValue != null && retValue.getSucceeded()) {
                log.info("Host '{}' was started successfully by PM Health Check Manager", host.getName());
            } else {
                log.info("PM Health Check Manager failed to start Host '{}'", host.getName());
            }
        }
    }
}
#method_after
public void startHosts(List<VDS> hostWithPMInStatusReboot) {
    for (VDS host : hostWithPMInStatusReboot) {
        RestartVdsCommand<FenceVdsActionParameters> restartVdsCommand = new RestartVdsCommand<>(new FenceVdsActionParameters(host.getId()), null);
        if (new HostFenceActionExecutor(host).isHostPoweredOff()) {
            ActionReturnValue retValue = Backend.getInstance().runInternalAction(ActionType.RestartVds, restartVdsCommand.getParameters());
            if (retValue != null && retValue.getSucceeded()) {
                log.info("Host '{}' was started successfully by PM Health Check Manager", host.getName());
            } else {
                log.info("PM Health Check Manager failed to start Host '{}'", host.getName());
            }
        }
    }
}
#end_block

#method_before
private void executeNotRespondingTreatment(List<VDS> hosts) {
    for (VDS host : hosts) {
        ThreadPoolUtil.execute(() -> Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, new FenceVdsActionParameters(host.getId()), ExecutionHandler.createInternalJobContext()));
    }
}
#method_after
private void executeNotRespondingTreatment(List<VDS> hosts) {
    for (VDS host : hosts) {
        ThreadPoolUtil.execute(() -> Backend.getInstance().runInternalAction(ActionType.VdsNotRespondingTreatment, new FenceVdsActionParameters(host.getId()), ExecutionHandler.createInternalJobContext()));
    }
}
#end_block

#method_before
@PostConstruct
protected void wakeup() {
    AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
    auditLogDirector.log(logable, AuditLogType.AFFINITY_RULES_ENFORCEMENT_MANAGER_START);
    scheduleJobs(getRegularInterval(), getInitialInterval());
}
#method_after
@PostConstruct
protected void wakeup() {
    auditLogDirector.log(new AuditLogableImpl(), AuditLogType.AFFINITY_RULES_ENFORCEMENT_MANAGER_START);
    scheduleJobs(getRegularInterval(), getInitialInterval());
}
#end_block

#method_before
public void refresh() {
    log.debug("Affinity Rules Enforcement Manager interval reached.");
    final List<VM> vmCandidates = new ArrayList<>();
    for (Cluster cluster : clusterDao.getWithoutMigratingVms()) {
        if (!cluster.isInUpgradeMode()) {
            final VM candidate = rulesEnforcer.chooseNextVmToMigrate(cluster);
            if (candidate != null) {
                vmCandidates.add(candidate);
            }
        }
    }
    // Trigger migrations
    for (VM vm : vmCandidates) {
        migrateVM(vm);
    }
}
#method_after
public void refresh() {
    try {
        log.debug("Affinity Rules Enforcement Manager interval reached.");
        final List<VM> vmCandidates = new ArrayList<>();
        for (Cluster cluster : clusterDao.getWithoutMigratingVms()) {
            if (!cluster.isInUpgradeMode()) {
                final VM candidate = rulesEnforcer.chooseNextVmToMigrate(cluster);
                if (candidate != null) {
                    vmCandidates.add(candidate);
                }
            }
        }
        // Trigger migrations
        for (VM vm : vmCandidates) {
            migrateVM(vm);
        }
    } catch (Throwable t) {
        log.error("Exception in refreshing affinity rules: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
protected void migrateVM(final VM vmToMigrate) {
    MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate.getId());
    parameters.setReason(AuditLogDirector.getMessage(AuditLogType.MIGRATION_REASON_AFFINITY_ENFORCEMENT));
    backend.runInternalAction(VdcActionType.BalanceVm, parameters, ExecutionHandler.createInternalJobContext());
}
#method_after
protected void migrateVM(final VM vmToMigrate) {
    MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate.getId());
    parameters.setReason(MessageBundler.getMessage(AuditLogType.MIGRATION_REASON_AFFINITY_ENFORCEMENT));
    backend.runInternalAction(ActionType.BalanceVm, parameters, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
private void scheduleJobs(long regularInterval, long initialInterval) {
    getExecutor().scheduleWithFixedDelay(() -> refresh(), initialInterval, regularInterval, TimeUnit.MINUTES);
}
#method_after
private void scheduleJobs(long regularInterval, long initialInterval) {
    executor.scheduleWithFixedDelay(this::refresh, initialInterval, regularInterval, TimeUnit.MINUTES);
}
#end_block

#method_before
public void engineIsRunningNotification() {
    try {
        log.debug("DWH Heart Beat - Start");
        heartBeatVar.setDateTime(new Date());
        dwhHistoryTimekeepingDao.save(heartBeatVar);
        log.debug("DWH Heart Beat - End");
    } catch (Exception ex) {
        log.error("Error updating DWH Heart Beat: {}", ex.getMessage());
        log.debug("Exception", ex);
    }
}
#method_after
private void engineIsRunningNotification() {
    try {
        log.debug("DWH Heart Beat - Start");
        TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, () -> {
            heartBeatVar.setDateTime(new Date());
            dwhHistoryTimekeepingDao.save(heartBeatVar);
            return null;
        });
        log.debug("DWH Heart Beat - End");
    } catch (Throwable t) {
        log.error("Error updating DWH Heart Beat: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
@PostConstruct
private void init() {
    log.info("Initializing DWH Heart Beat");
    heartBeatVar = new DwhHistoryTimekeeping();
    heartBeatVar.setVariable(DwhHistoryTimekeepingVariable.HEART_BEAT);
    executor.scheduleWithFixedDelay(() -> engineIsRunningNotification(), 0, Config.<Integer>getValue(ConfigValues.DwhHeartBeatInterval), TimeUnit.SECONDS);
    log.info("DWH Heart Beat initialized");
}
#method_after
@PostConstruct
private void init() {
    log.info("Initializing DWH Heart Beat");
    heartBeatVar = new DwhHistoryTimekeeping();
    heartBeatVar.setVariable(DwhHistoryTimekeepingVariable.HEART_BEAT);
    executor.scheduleWithFixedDelay(this::engineIsRunningNotification, 0, Config.<Integer>getValue(ConfigValues.DwhHeartBeatInterval), TimeUnit.SECONDS);
    log.info("DWH Heart Beat initialized");
}
#end_block

#method_before
@PostConstruct
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    Integer backupCheckPeriodInHours = Config.<Integer>getValue(ConfigValues.BackupCheckPeriodInHours);
    // disable feature if value is negative
    if (backupCheckPeriodInHours > 0) {
        executor.scheduleWithFixedDelay(() -> backupCheck(), backupCheckPeriodInHours, backupCheckPeriodInHours, TimeUnit.HOURS);
        log.info("Finished initializing {}", getClass().getSimpleName());
    }
}
#method_after
@PostConstruct
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    Integer backupCheckPeriodInHours = Config.<Integer>getValue(ConfigValues.BackupCheckPeriodInHours);
    // disable feature if value is negative
    if (backupCheckPeriodInHours > 0) {
        executor.scheduleWithFixedDelay(this::backupCheck, backupCheckPeriodInHours, backupCheckPeriodInHours, TimeUnit.HOURS);
        log.info("Finished initializing {}", getClass().getSimpleName());
    }
}
#end_block

#method_before
public void backupCheck() {
    // skip backup check if previous operation is not completed yet
    if (lock.tryLock()) {
        try {
            log.info("Backup check started.");
            doBackupCheck();
            log.info("Backup check completed.");
        } finally {
            lock.unlock();
        }
    }
}
#method_after
private void backupCheck() {
    try {
        // skip backup check if previous operation is not completed yet
        if (lock.tryLock()) {
            try {
                log.info("Backup check started.");
                doBackupCheck();
                log.info("Backup check completed.");
            } finally {
                lock.unlock();
            }
        }
    } catch (Throwable t) {
        log.error("Exception in backupCheck: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
private void doBackupCheck() {
    AuditLogableBase alert = Injector.injectMembers(new AuditLogableBase());
    // try to get last backup record
    EngineBackupLog lastDbBackup = getLastBackupByScope(BackupScope.DB);
    EngineBackupLog lastFilesBackup = getLastBackupByScope(BackupScope.FILES);
    if (lastDbBackup == null || lastFilesBackup == null) {
        auditLogDirector.log(alert, AuditLogType.ENGINE_NO_FULL_BACKUP);
    } else {
        // check time elapsed from last full (db and files) backup
        Integer backupAlertPeriodInDays = Config.<Integer>getValue(ConfigValues.BackupAlertPeriodInDays);
        Date lastDbBackupDate = lastDbBackup.getDoneAt();
        Date lastFilesBackupDate = lastFilesBackup.getDoneAt();
        Date lastFullBackupDate = lastDbBackupDate.compareTo(lastFilesBackupDate) < 0 ? lastDbBackupDate : lastFilesBackupDate;
        long diffInDays = (Calendar.getInstance().getTimeInMillis() - lastFullBackupDate.getTime()) / TimeUnit.DAYS.toMillis(1);
        if (diffInDays > backupAlertPeriodInDays) {
            alert.addCustomValue("Date", lastFullBackupDate.toString());
            auditLogDirector.log(alert, AuditLogType.ENGINE_NO_WARM_BACKUP);
        }
    }
}
#method_after
private void doBackupCheck() {
    AuditLogable alert = new AuditLogableImpl();
    // try to get last backup record
    EngineBackupLog lastDbBackup = getLastBackupByScope(BackupScope.DB);
    EngineBackupLog lastFilesBackup = getLastBackupByScope(BackupScope.FILES);
    if (lastDbBackup == null || lastFilesBackup == null) {
        auditLogDirector.log(alert, AuditLogType.ENGINE_NO_FULL_BACKUP);
    } else {
        // check time elapsed from last full (db and files) backup
        Integer backupAlertPeriodInDays = Config.<Integer>getValue(ConfigValues.BackupAlertPeriodInDays);
        Date lastDbBackupDate = lastDbBackup.getDoneAt();
        Date lastFilesBackupDate = lastFilesBackup.getDoneAt();
        Date lastFullBackupDate = lastDbBackupDate.compareTo(lastFilesBackupDate) < 0 ? lastDbBackupDate : lastFilesBackupDate;
        long diffInDays = (Calendar.getInstance().getTimeInMillis() - lastFullBackupDate.getTime()) / TimeUnit.DAYS.toMillis(1);
        if (diffInDays > backupAlertPeriodInDays) {
            alert.addCustomValue("Date", lastFullBackupDate.toString());
            auditLogDirector.log(alert, AuditLogType.ENGINE_NO_WARM_BACKUP);
        }
    }
}
#end_block

#method_before
@PostConstruct
public void scheduleJob() {
    double availableUpdatesRefreshRate = Config.<Double>getValue(ConfigValues.HostPackagesUpdateTimeInHours);
    if (availableUpdatesRefreshRate > 0) {
        final int HOURS_TO_MINUTES = 60;
        long rateInMinutes = Math.round(availableUpdatesRefreshRate * HOURS_TO_MINUTES);
        scheduledExecutor.scheduleWithFixedDelay(() -> availableUpdates(), 15, rateInMinutes, TimeUnit.MINUTES);
    }
}
#method_after
@PostConstruct
public void scheduleJob() {
    double availableUpdatesRefreshRate = Config.<Double>getValue(ConfigValues.HostPackagesUpdateTimeInHours);
    if (availableUpdatesRefreshRate > 0) {
        final int HOURS_TO_MINUTES = 60;
        long rateInMinutes = Math.round(availableUpdatesRefreshRate * HOURS_TO_MINUTES);
        scheduledExecutor.scheduleWithFixedDelay(this::availableUpdates, 15, rateInMinutes, TimeUnit.MINUTES);
    }
}
#end_block

#method_before
public void availableUpdates() {
    hostDao.getAll().stream().filter(h -> h.getStatus().isEligibleForCheckUpdates()).forEach(this::submitCheckUpdatesForHost);
}
#method_after
private void availableUpdates() {
    try {
        hostDao.getAll().stream().filter(h -> h.getStatus().isEligibleForCheckUpdates()).forEach(this::submitCheckUpdatesForHost);
    } catch (Throwable t) {
        log.error("Exception in checking for available updates: {}", ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
@Override
public Date getNextRunTime(LastExecution lastExecution, Date date) {
    Date nextExecutionDate = generator.next(new Date());
    return nextExecutionDate;
}
#method_after
@Override
public Date getNextRunTime(LastExecution lastExecution, Date date) {
    return generator.next(new Date());
}
#end_block

#method_before
@PostConstruct
private void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    Calendar calendar = new GregorianCalendar();
    Date commandEntityCleanupTime = Config.<DateTime>getValue(ConfigValues.CommandEntityCleanupTime);
    calendar.setTimeInMillis(commandEntityCleanupTime.getTime());
    String cronExpression = String.format("%d %d %d * * ?", calendar.get(Calendar.SECOND), calendar.get(Calendar.MINUTE), calendar.get(Calendar.HOUR_OF_DAY));
    log.info("Setting command entity cleanup manager to run at: {}", cronExpression);
    executor.schedule(() -> doCleanup(), new EngineCronTrigger(cronExpression));
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#method_after
@PostConstruct
private void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    Calendar calendar = new GregorianCalendar();
    Date commandEntityCleanupTime = Config.<DateTime>getValue(ConfigValues.CommandEntityCleanupTime);
    calendar.setTimeInMillis(commandEntityCleanupTime.getTime());
    String cronExpression = String.format("%d %d %d * * ?", calendar.get(Calendar.SECOND), calendar.get(Calendar.MINUTE), calendar.get(Calendar.HOUR_OF_DAY));
    log.info("Setting command entity cleanup manager to run at: {}", cronExpression);
    executor.schedule(this::cleanup, new EngineCronTrigger(cronExpression));
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
public void addBuiltinParameters(Model model) {
    // add 'follow' parameter to get(), list() methods.
    addFollowParameters(model);
}
#method_after
public void addBuiltinParameters(Model model) {
    // add 'follow' parameter to get(), list() methods.
    model.services().forEach(this::addFollowParameters);
}
#end_block

#method_before
private void addFollowParameters(Model model) {
    for (Service service : model.getServices()) {
        if (service.getMethod(GET_METHOD_NAME) != null) {
            addFollowParameter(service.getMethod(GET_METHOD_NAME));
        }
        if (service.getMethod(LIST_METHOD_NAME) != null) {
            addFollowParameter(service.getMethod(LIST_METHOD_NAME));
        }
    }
}
#method_after
private void addFollowParameters(Service service) {
    if (service.getMethod(GET_METHOD_NAME) != null) {
        addFollowParameter(service.getMethod(GET_METHOD_NAME));
    }
    if (service.getMethod(LIST_METHOD_NAME) != null) {
        addFollowParameter(service.getMethod(LIST_METHOD_NAME));
    }
}
#end_block

#method_before
private void addFollowParameter(Method method) {
    Parameter followParameter = new Parameter();
    followParameter.setName(new Name("follow"));
    followParameter.setIn(true);
    StringBuilder doc = new StringBuilder("Indicates which inner links should be `followed`;").append(" i.e their actual contents fetched and returned along with the entity.").append(" Links are separated by commas, and levels of depth are denoted by periods.").append(" Example value for fetching vms: `cluster,nics,disk_attachments.disk`");
    followParameter.setDoc(doc.toString());
    followParameter.setType(new PrimitiveType());
    followParameter.setDeclaringMethod(method);
    method.addParameter(followParameter);
}
#method_after
private void addFollowParameter(Method method) {
    Parameter followParameter = new Parameter();
    followParameter.setName(FOLLOW_PARAMETER_NAME);
    followParameter.setIn(true);
    StringBuilder doc = new StringBuilder("Indicates which inner links should be `followed`;").append(" i.e their actual contents fetched and returned along with the object.").append(" Links are separated by commas, and levels of depth are denoted by periods.").append(" Example value for fetching vms: `cluster,nics,disk_attachments.disk`");
    followParameter.setDoc(doc.toString());
    followParameter.setType(method.getDeclaringService().getModel().getStringType());
    followParameter.setDeclaringMethod(method);
    method.addParameter(followParameter);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    switch(getDisk().getDiskStorageType()) {
        case IMAGE:
            if (getDisk().getContentType() == DiskContentType.MEMORY_DUMP_VOLUME || getDisk().getContentType() == DiskContentType.MEMORY_METADATA_VOLUME) {
                removeMemoryDiskFromSnapshotIfNeeded();
            }
            ActionReturnValue actionReturnValue = runInternalActionWithTasksContext(ActionType.RemoveImage, buildRemoveImageParameters(getDiskImage()));
            if (actionReturnValue.getSucceeded()) {
                incrementVmsGeneration();
                getReturnValue().getVdsmTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
                setSucceeded(true);
            }
            break;
        case LUN:
            removeLunDisk();
            break;
        case CINDER:
            RemoveCinderDiskParameters params = new RemoveCinderDiskParameters(getParameters().getDiskId());
            params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            Future<ActionReturnValue> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.RemoveCinderDisk, params, cloneContextAndDetachFromParent());
            try {
                setReturnValue(future.get());
                setSucceeded(getReturnValue().getSucceeded());
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error removing Cinder disk '{}': {}", getDiskImage().getDiskAlias(), e.getMessage());
                log.debug("Exception", e);
            }
            break;
    }
}
#method_after
@Override
protected void executeCommand() {
    switch(getDisk().getDiskStorageType()) {
        case IMAGE:
            ActionReturnValue actionReturnValue = runInternalActionWithTasksContext(ActionType.RemoveImage, buildRemoveImageParameters(getDiskImage()));
            if (actionReturnValue.getSucceeded()) {
                if (getDisk().getContentType() == DiskContentType.MEMORY_DUMP_VOLUME || getDisk().getContentType() == DiskContentType.MEMORY_METADATA_VOLUME) {
                    removeMemoryDiskFromSnapshotIfNeeded();
                }
                incrementVmsGeneration();
                getReturnValue().getVdsmTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
                setSucceeded(true);
            }
            break;
        case LUN:
            removeLunDisk();
            break;
        case CINDER:
            RemoveCinderDiskParameters params = new RemoveCinderDiskParameters(getParameters().getDiskId());
            params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            Future<ActionReturnValue> future = CommandCoordinatorUtil.executeAsyncCommand(ActionType.RemoveCinderDisk, params, cloneContextAndDetachFromParent());
            try {
                setReturnValue(future.get());
                setSucceeded(getReturnValue().getSucceeded());
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error removing Cinder disk '{}': {}", getDiskImage().getDiskAlias(), e.getMessage());
                log.debug("Exception", e);
            }
            break;
    }
}
#end_block

#method_before
private List<VdsNetworkInterface> getAllInterfacesByDataCenterId(Guid dataCenterId) {
    return getCallsHandler().executeReadList("GetInterfacesByDataCenterId", vdsNetworkInterfaceRowMapper, getCustomMapSqlParameterSource().addValue("data_center_id", dataCenterId));
}
#method_after
@Override
public List<VdsNetworkInterface> getAllInterfacesByDataCenterId(Guid dataCenterId) {
    return getCallsHandler().executeReadList("GetInterfacesByDataCenterId", vdsNetworkInterfaceRowMapper, getCustomMapSqlParameterSource().addValue("data_center_id", dataCenterId));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (updateStorageDomainsInDb()) {
        // setting storage pool status to maintenance
        StoragePool storagePool = getStoragePool();
        getCompensationContext().snapshotEntity(storagePool);
        TransactionSupport.executeInNewTransaction(() -> {
            getStoragePool().setStatus(StoragePoolStatus.Maintenance);
            getStoragePool().setStoragePoolFormatType(masterStorageDomain.getStorageFormat());
            storagePoolDao.update(getStoragePool());
            getCompensationContext().stateChanged();
            StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
            return null;
        });
        // Following code performs only read operations, therefore no need for new transaction
        boolean result = false;
        // Once we create a storage pool with multiple hosts, the engine should connect all
        // the hosts in the storage pool,
        // since the engine picks a random host to fetch all the unregistered disks.
        boolean isStoragePoolCreated = false;
        retVal = null;
        for (VDS vds : getAllRunningVdssInPool()) {
            setVds(vds);
            for (Guid storageDomainId : getParameters().getStorages()) {
                // now the domain should have the mapping
                // with the pool in db
                StorageDomain storageDomain = storageDomainDao.getForStoragePool(storageDomainId, getStoragePool().getId());
                storageHelperDirector.getItem(storageDomain.getStorageType()).connectStorageToDomainByVdsId(storageDomain, getVds().getId());
            }
            if (!isStoragePoolCreated) {
                cleanDirtyMetaDataIfNeeded();
                retVal = addStoragePoolInIrs();
                if (!retVal.getSucceeded() && retVal.getVdsError().getCode() == EngineError.StorageDomainAccessError) {
                    log.warn("Error creating storage pool on vds '{}' - continuing", vds.getName());
                    continue;
                }
                // storage pool creation succeeded or failed
                // but didn't throw exception
                result = retVal.getSucceeded();
                isStoragePoolCreated = true;
            }
        }
        setSucceeded(result);
        if (!result) {
            if (retVal != null && retVal.getVdsError().getCode() != null) {
                throw new EngineException(retVal.getVdsError().getCode(), retVal.getVdsError().getMessage());
            } else {
                // command
                throw new EngineException(EngineError.ENGINE_ERROR_CREATING_STORAGE_POOL);
            }
        }
        registerOvfStoreDisks();
    }
    // Create pool phase completed, no rollback is needed here, so compensation information needs to be cleared!
    TransactionSupport.executeInNewTransaction(() -> {
        // TODO MMUCHA: Dear code reviewer! I think CommandBase would(should) handle that. Please advise.
        getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
        return null;
    });
    freeLock();
    // if create succeeded activate
    if (getSucceeded()) {
        activateStorageDomains();
    }
}
#method_after
@Override
protected void executeCommand() {
    if (updateStorageDomainsInDb()) {
        // setting storage pool status to maintenance
        StoragePool storagePool = getStoragePool();
        getCompensationContext().snapshotEntity(storagePool);
        TransactionSupport.executeInNewTransaction(() -> {
            getStoragePool().setStatus(StoragePoolStatus.Maintenance);
            getStoragePool().setStoragePoolFormatType(masterStorageDomain.getStorageFormat());
            storagePoolDao.update(getStoragePool());
            getCompensationContext().stateChanged();
            StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
            return null;
        });
        // Following code performs only read operations, therefore no need for new transaction
        boolean result = false;
        // Once we create a storage pool with multiple hosts, the engine should connect all
        // the hosts in the storage pool,
        // since the engine picks a random host to fetch all the unregistered disks.
        boolean isStoragePoolCreated = false;
        retVal = null;
        for (VDS vds : getAllRunningVdssInPool()) {
            setVds(vds);
            for (Guid storageDomainId : getParameters().getStorages()) {
                // now the domain should have the mapping
                // with the pool in db
                StorageDomain storageDomain = storageDomainDao.getForStoragePool(storageDomainId, getStoragePool().getId());
                storageHelperDirector.getItem(storageDomain.getStorageType()).connectStorageToDomainByVdsId(storageDomain, getVds().getId());
            }
            if (!isStoragePoolCreated) {
                // but didn't throw exception
                if (!cleanDirtyMetaDataIfNeeded()) {
                    result = false;
                } else {
                    retVal = addStoragePoolInIrs();
                    if (!retVal.getSucceeded() && retVal.getVdsError().getCode() == EngineError.StorageDomainAccessError) {
                        log.warn("Error creating storage pool on vds '{}' - continuing", vds.getName());
                        continue;
                    }
                    result = retVal.getSucceeded();
                }
                isStoragePoolCreated = true;
            }
        }
        setSucceeded(result);
        if (!result) {
            if (retVal != null && retVal.getVdsError().getCode() != null) {
                throw new EngineException(retVal.getVdsError().getCode(), retVal.getVdsError().getMessage());
            } else {
                // command
                throw new EngineException(EngineError.ENGINE_ERROR_CREATING_STORAGE_POOL);
            }
        }
        registerOvfStoreDisks();
    }
    // Create pool phase completed, no rollback is needed here, so compensation information needs to be cleared!
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
        return null;
    });
    freeLock();
    // if create succeeded activate
    if (getSucceeded()) {
        activateStorageDomains();
    }
}
#end_block

#method_before
private void cleanDirtyMetaDataIfNeeded() {
    if (getStoragePool().getStatus() == StoragePoolStatus.Maintenance) {
        for (Guid storageDomainId : getParameters().getStorages()) {
            StorageDomain domain = storageDomainDao.get(storageDomainId);
            if (domain.getStorageDomainType().isDataDomain() && isStorageDomainAttachedToStoragePool(domain)) {
                detachStorageDomain(storageDomainId);
            }
        }
    }
}
#method_after
private boolean cleanDirtyMetaDataIfNeeded() {
    if (getStoragePool().getStatus() == StoragePoolStatus.Maintenance) {
        for (Guid storageDomainId : getParameters().getStorages()) {
            StorageDomain domain = storageDomainDao.get(storageDomainId);
            if (domain.getStorageDomainType().isDataDomain() && isStorageDomainAttachedToStoragePool(domain) && !detachStorageDomainSucceeded(storageDomainId)) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
public StatusOnlyReturn add_image_ticket(String ticketId, String[] ops, long timeout, long size, String url) {
    HashMap<String, Object> ticketDict = new HashMap<>();
    ticketDict.put("uuid", ticketId);
    ticketDict.put("timeout", timeout);
    ticketDict.put("ops", ops);
    ticketDict.put("size", size);
    ticketDict.put("url", url);
    JsonRpcRequest request = new RequestBuilder("Host.add_image_ticket").withParameter("ticket", ticketDict).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#method_after
@Override
public StatusOnlyReturn add_image_ticket(String ticketId, String[] ops, long timeout, long size, String url, String filename) {
    HashMap<String, Object> ticketDict = new HashMap<>();
    ticketDict.put("uuid", ticketId);
    ticketDict.put("timeout", timeout);
    ticketDict.put("ops", ops);
    ticketDict.put("size", size);
    ticketDict.put("url", url);
    // filename is null by default, and only specified by the UI
    if (filename != null) {
        ticketDict.put("filename", filename);
    }
    JsonRpcRequest request = new RequestBuilder("Host.add_image_ticket").withParameter("ticket", ticketDict).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (isAttachedStorageDomain() && checkForActiveVds() != null && !getParameters().isForceRemoveLastMaster()) {
        try {
            // if master try to reconstruct
            if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
                ReconstructMasterParameters tempVar = new ReconstructMasterParameters(getStoragePool().getId(), getStorageDomain().getId(), false);
                tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
                runInternalAction(ActionType.ReconstructMasterDomain, tempVar);
            }
            // try to force detach first
            DetachStorageDomainVDSCommandParameters tempVar2 = new DetachStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), Guid.Empty, -1);
            tempVar2.setForce(true);
            runVdsCommand(VDSCommandType.DetachStorageDomain, tempVar2);
        } catch (RuntimeException ex) {
            log.error("Could not force detach storage domain '{}': {}", getStorageDomain().getStorageName(), ex.getMessage());
            log.debug("Exception", ex);
        }
    }
    releaseStorageDomainMacPool(getVmsOnlyOnStorageDomain());
    storageHelperDirector.getItem(getStorageDomain().getStorageType()).storageDomainRemoved(getStorageDomain().getStorageStaticData());
    storageDomainDao.remove(getStorageDomain().getId());
    if (isAttachedStorageDomain()) {
        // if iso reset path for pool
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
            // todo: when iso in multiple pools will be implemented, we
            // should reset iso path for all related pools
            runVdsCommand(VDSCommandType.ResetISOPath, new IrsBaseVDSCommandParameters(getStoragePool().getId()));
        }
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
            calcStoragePoolStatusByDomainsStatus();
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (isAttachedStorageDomain() && hasRunningHostsInPool()) {
        try {
            // If master and there are more storage domains in the DC try to reconstruct.
            if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && !isLastStorageInPool()) {
                ReconstructMasterParameters tempVar = new ReconstructMasterParameters(getStoragePool().getId(), getStorageDomain().getId(), false);
                tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
                runInternalAction(ActionType.ReconstructMasterDomain, tempVar);
            }
            // try to force detach first
            DetachStorageDomainVDSCommandParameters tempVar2 = new DetachStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), Guid.Empty, -1);
            tempVar2.setForce(true);
            runVdsCommand(VDSCommandType.DetachStorageDomain, tempVar2);
        } catch (RuntimeException ex) {
            log.error("Could not force detach storage domain '{}': {}", getStorageDomain().getStorageName(), ex.getMessage());
            log.debug("Exception", ex);
        }
    } else {
        log.info("Avoid running host operations like reconstruct/detach on force remove for storage domain '{}'." + "Storage domain attached to pool: '{}'" + "Active Hosts exists in DC: '{}'", getStorageDomain().getStorageName(), isAttachedStorageDomain(), hasRunningHostsInPool());
    }
    releaseStorageDomainMacPool(getVmsOnlyOnStorageDomain());
    storageHelperDirector.getItem(getStorageDomain().getStorageType()).storageDomainRemoved(getStorageDomain().getStorageStaticData());
    storageDomainDao.remove(getStorageDomain().getId());
    if (isAttachedStorageDomain()) {
        // if iso reset path for pool
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
            // todo: when iso in multiple pools will be implemented, we
            // should reset iso path for all related pools
            runVdsCommand(VDSCommandType.ResetISOPath, new IrsBaseVDSCommandParameters(getStoragePool().getId()));
        }
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
            calcStoragePoolStatusByDomainsStatus();
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean returnValue = super.validate() && checkStorageDomain() && (getStorageDomain().getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached || checkStorageDomainStatusNotEqual(StorageDomainStatus.Active));
    if (returnValue && getStorageDomain().getStorageDomainType() == StorageDomainType.Master && isAttachedStorageDomain()) {
        if (electNewMaster() == null && !getParameters().isForceRemoveLastMaster()) {
            returnValue = false;
            addValidationMessage(EngineMessage.ERROR_CANNOT_DESTROY_LAST_STORAGE_DOMAIN);
        } else if (!initializeVds() && !getParameters().isForceRemoveLastMaster()) {
            returnValue = false;
            addValidationMessage(EngineMessage.ERROR_CANNOT_DESTROY_LAST_STORAGE_DOMAIN_HOST_NOT_ACTIVE);
        }
    }
    if (returnValue && getStorageDomain().getStorageType() == StorageType.GLANCE) {
        addValidationMessage(EngineMessage.ERROR_CANNOT_MANAGE_STORAGE_DOMAIN);
        returnValue = false;
    }
    return returnValue;
}
#method_after
@Override
protected boolean validate() {
    boolean returnValue = super.validate() && checkStorageDomain() && checkStorageDomainStatusNotEqual(StorageDomainStatus.Active);
    if (returnValue && getStorageDomain().getStorageDomainType() == StorageDomainType.Master && isAttachedStorageDomain() && !isLastStorageInPool()) {
        if (electNewMaster() == null) {
            returnValue = false;
            addValidationMessage(EngineMessage.ERROR_CANNOT_DESTROY_LAST_STORAGE_DOMAIN);
        } else if (!initializeVds()) {
            returnValue = false;
            addValidationMessage(EngineMessage.ERROR_CANNOT_DESTROY_LAST_STORAGE_DOMAIN_HOST_NOT_ACTIVE);
        }
    }
    if (returnValue && getStorageDomain().getStorageType() == StorageType.GLANCE) {
        addValidationMessage(EngineMessage.ERROR_CANNOT_MANAGE_STORAGE_DOMAIN);
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
protected void updateCpuPinningVisibility() {
    if (getModel().getSelectedCluster() != null) {
        boolean isLocalSD = getModel().getSelectedDataCenter() != null && getModel().getSelectedDataCenter().isLocal();
        // cpu pinning is available on Local SD with no consideration for auto assign value
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity()) || isLocalSD;
        if (Boolean.FALSE.equals(AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.CpuPinMigrationEnabled, AsyncDataProvider.getInstance().getDefaultConfigurationVersion())) && isVmMigratable() && !isLocalSD) {
            hasCpuPinning = false;
        }
        if (!hasCpuPinning) {
            getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailable());
        }
        getModel().getCpuPinning().setIsChangeable(hasCpuPinning);
    }
}
#method_after
protected void updateCpuPinningVisibility() {
    if (getModel().getIsAutoAssign().getEntity() == null) {
        return;
    }
    if (getModel().getSelectedCluster() != null) {
        boolean isLocalSD = getModel().getSelectedDataCenter() != null && getModel().getSelectedDataCenter().isLocal();
        // cpu pinning is available on Local SD with no consideration for auto assign value
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity()) || isLocalSD;
        if (Boolean.FALSE.equals(AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.CpuPinMigrationEnabled, AsyncDataProvider.getInstance().getDefaultConfigurationVersion())) && isVmMigratable() && !isLocalSD) {
            hasCpuPinning = false;
        }
        if (!hasCpuPinning) {
            getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailable());
        }
        getModel().getCpuPinning().setIsChangeable(hasCpuPinning);
    }
}
#end_block

#method_before
public void updateHaAvailability() {
    boolean automaticMigrationAllowed = getModel().getMigrationMode().getSelectedItem() == MigrationSupport.MIGRATABLE;
    final Collection<VDS> allowedHosts = getModel().getDefaultHost().getSelectedItems();
    Collection<VDS> presentHosts = getModel().getDefaultHost().getItems();
    int pinToHostSize = allowedHosts == null ? 0 : allowedHosts.size();
    boolean isHighlyAvailable = getModel().getIsHighlyAvailable().getEntity();
    Boolean isAutoAssign = getModel().getIsAutoAssign().getEntity();
    // This is needed for the unittests to not crash..
    if (presentHosts == null) {
        presentHosts = new ArrayList<>();
    }
    if (!automaticMigrationAllowed && (pinToHostSize == 1 || (pinToHostSize == 0 && presentHosts.size() < 2)) && (!isAutoAssign || presentHosts.size() < 2) && !isHighlyAvailable) {
        getModel().getIsHighlyAvailable().setChangeProhibitionReason(constants.hostNonMigratable());
        getModel().getIsHighlyAvailable().setEntity(false);
        isHighlyAvailable = false;
    }
    getModel().getIsHighlyAvailable().setIsChangeable(isHighlyAvailable || automaticMigrationAllowed || (isAutoAssign && presentHosts.size() >= 2) || pinToHostSize >= 2 || (pinToHostSize == 0 && presentHosts.size() >= 2));
}
#method_after
public void updateHaAvailability() {
    boolean automaticMigrationAllowed = getModel().getMigrationMode().getSelectedItem() == MigrationSupport.MIGRATABLE;
    final Collection<VDS> allowedHosts = getModel().getDefaultHost().getSelectedItems();
    Collection<VDS> presentHosts = getModel().getDefaultHost().getItems();
    int pinToHostSize = allowedHosts == null ? 0 : allowedHosts.size();
    boolean isHighlyAvailable = getModel().getIsHighlyAvailable().getEntity();
    Boolean isAutoAssign = getModel().getIsAutoAssign().getEntity();
    if (isAutoAssign == null) {
        return;
    }
    // This is needed for the unittests to not crash..
    if (presentHosts == null) {
        presentHosts = new ArrayList<>();
    }
    if (!automaticMigrationAllowed && (pinToHostSize == 1 || (pinToHostSize == 0 && presentHosts.size() < 2)) && (!isAutoAssign || presentHosts.size() < 2) && !isHighlyAvailable) {
        getModel().getIsHighlyAvailable().setChangeProhibitionReason(constants.hostNonMigratable());
        getModel().getIsHighlyAvailable().setEntity(false);
        isHighlyAvailable = false;
    }
    getModel().getIsHighlyAvailable().setIsChangeable(isHighlyAvailable || automaticMigrationAllowed || (isAutoAssign && presentHosts.size() >= 2) || pinToHostSize >= 2 || (pinToHostSize == 0 && presentHosts.size() >= 2));
}
#end_block

#method_before
public void vmTypeChanged(VmType vmType) {
    if (basedOnCustomInstanceType()) {
        // this field is normally taken from instance type. If the "custom" is selected, then it is supposed to use the default
        // determined by vm type
        getModel().getIsSoundcardEnabled().setEntity(vmType == VmType.Desktop);
    }
    getModel().getAllowConsoleReconnect().setEntity(vmType == VmType.Server);
    // High Performance
    if (vmType == VmType.HighPerformance) {
        // Conosole tab
        getModel().getIsHeadlessModeEnabled().setEntity(true);
        getModel().getIsConsoleDeviceEnabled().setEntity(true);
        getModel().getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
        // High Availability tab
        getModel().getWatchdogModel().setSelectedItem(null);
        getModel().getWatchdogAction().setSelectedItem(getModel().getWatchdogAction().getItems().iterator().next());
        getModel().getIsHighlyAvailable().setEntity(false);
    }
}
#method_after
public void vmTypeChanged(VmType vmType) {
    if (basedOnCustomInstanceType()) {
        // this field is normally taken from instance type. If the "custom" is selected, then it is supposed to use the default
        // determined by vm type
        getModel().getIsSoundcardEnabled().setEntity(vmType == VmType.Desktop);
    }
    getModel().getAllowConsoleReconnect().setEntity(vmType == VmType.Server);
    // High Performance
    if (vmType == VmType.HighPerformance) {
        // Conosole tab
        getModel().getIsHeadlessModeEnabled().setEntity(true);
        getModel().getIsConsoleDeviceEnabled().setEntity(true);
        getModel().getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
        // High Availability tab
        getModel().getWatchdogModel().setSelectedItem(null);
        getModel().getWatchdogAction().setSelectedItem(getModel().getWatchdogAction().getItems().iterator().next());
        getModel().getIsHighlyAvailable().setEntity(false);
        // Random Generator tab
        getModel().getIsRngEnabled().setEntity(true);
        // Host tab
        getModel().getMigrationMode().setSelectedItem(MigrationSupport.PINNED_TO_HOST);
        getModel().getHostCpu().setEntity(true);
        // Resouce allocation tab
        getModel().getMemoryBalloonDeviceEnabled().setEntity(false);
    }
}
#end_block

#method_before
protected final void updateNumaEnabledHelper() {
    boolean enabled = true;
    if (getModel().getMigrationMode().getSelectedItem() != MigrationSupport.PINNED_TO_HOST || getModel().getIsAutoAssign().getEntity() || getModel().getDefaultHost().getSelectedItem() == null || !getModel().getDefaultHost().getSelectedItem().isNumaSupport()) {
        enabled = false;
    }
    if (enabled) {
        getModel().getNumaEnabled().setMessage(constants.numaInfoMessage());
    } else {
        getModel().getNumaEnabled().setMessage(constants.numaDisabledInfoMessage());
        getModel().getNumaNodeCount().setEntity(0);
    }
    getModel().getNumaEnabled().setEntity(enabled);
}
#method_after
protected final void updateNumaEnabledHelper() {
    boolean enabled = true;
    if (getModel().getIsAutoAssign().getEntity() == null) {
        return;
    }
    if (getModel().getMigrationMode().getSelectedItem() != MigrationSupport.PINNED_TO_HOST || getModel().getIsAutoAssign().getEntity() || getModel().getDefaultHost().getSelectedItem() == null || !getModel().getDefaultHost().getSelectedItem().isNumaSupport()) {
        enabled = false;
    }
    if (enabled) {
        getModel().getNumaEnabled().setMessage(constants.numaInfoMessage());
    } else {
        getModel().getNumaEnabled().setMessage(constants.numaDisabledInfoMessage());
        getModel().getNumaNodeCount().setEntity(0);
    }
    getModel().getNumaEnabled().setEntity(enabled);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (isAttachedStorageDomain() && checkForActiveVds() != null) {
        try {
            // if master try to reconstruct
            if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
                ReconstructMasterParameters tempVar = new ReconstructMasterParameters(getStoragePool().getId(), getStorageDomain().getId(), false);
                tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
                runInternalAction(ActionType.ReconstructMasterDomain, tempVar);
            }
            // try to force detach first
            DetachStorageDomainVDSCommandParameters tempVar2 = new DetachStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), Guid.Empty, -1);
            tempVar2.setForce(true);
            runVdsCommand(VDSCommandType.DetachStorageDomain, tempVar2);
        } catch (RuntimeException ex) {
            log.error("Could not force detach storage domain '{}': {}", getStorageDomain().getStorageName(), ex.getMessage());
            log.debug("Exception", ex);
        }
    }
    releaseStorageDomainMacPool(getVmsOnlyOnStorageDomain());
    storageHelperDirector.getItem(getStorageDomain().getStorageType()).storageDomainRemoved(getStorageDomain().getStorageStaticData());
    storageDomainDao.remove(getStorageDomain().getId());
    if (isAttachedStorageDomain()) {
        // if iso reset path for pool
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
            // todo: when iso in multiple pools will be implemented, we
            // should reset iso path for all related pools
            runVdsCommand(VDSCommandType.ResetISOPath, new IrsBaseVDSCommandParameters(getStoragePool().getId()));
        }
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
            calcStoragePoolStatusByDomainsStatus();
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (isAttachedStorageDomain() && hasRunningHostsInPool()) {
        try {
            // if master try to reconstruct
            if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
                ReconstructMasterParameters tempVar = new ReconstructMasterParameters(getStoragePool().getId(), getStorageDomain().getId(), false);
                tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
                runInternalAction(ActionType.ReconstructMasterDomain, tempVar);
            }
            // try to force detach first
            DetachStorageDomainVDSCommandParameters tempVar2 = new DetachStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), Guid.Empty, -1);
            tempVar2.setForce(true);
            runVdsCommand(VDSCommandType.DetachStorageDomain, tempVar2);
        } catch (RuntimeException ex) {
            log.error("Could not force detach storage domain '{}': {}", getStorageDomain().getStorageName(), ex.getMessage());
            log.debug("Exception", ex);
        }
    } else {
        log.info("Avoid running host operations like reconstruct/detach on force remove for storage domain '{}'." + "Storage domain attached to pool: '{}'" + "Active Hosts exists in DC: '{}'", getStorageDomain().getStorageName(), isAttachedStorageDomain(), hasRunningHostsInPool());
    }
    releaseStorageDomainMacPool(getVmsOnlyOnStorageDomain());
    storageHelperDirector.getItem(getStorageDomain().getStorageType()).storageDomainRemoved(getStorageDomain().getStorageStaticData());
    storageDomainDao.remove(getStorageDomain().getId());
    if (isAttachedStorageDomain()) {
        // if iso reset path for pool
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
            // todo: when iso in multiple pools will be implemented, we
            // should reset iso path for all related pools
            runVdsCommand(VDSCommandType.ResetISOPath, new IrsBaseVDSCommandParameters(getStoragePool().getId()));
        }
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
            calcStoragePoolStatusByDomainsStatus();
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean returnValue = super.validate() && checkStorageDomain() && (getStorageDomain().getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached || checkStorageDomainStatusNotEqual(StorageDomainStatus.Active));
    if (returnValue && getStorageDomain().getStorageDomainType() == StorageDomainType.Master && isAttachedStorageDomain()) {
        if (electNewMaster() == null) {
            returnValue = false;
            addValidationMessage(EngineMessage.ERROR_CANNOT_DESTROY_LAST_STORAGE_DOMAIN);
        } else if (!initializeVds()) {
            returnValue = false;
            addValidationMessage(EngineMessage.ERROR_CANNOT_DESTROY_LAST_STORAGE_DOMAIN_HOST_NOT_ACTIVE);
        }
    }
    if (returnValue && getStorageDomain().getStorageType() == StorageType.GLANCE) {
        addValidationMessage(EngineMessage.ERROR_CANNOT_MANAGE_STORAGE_DOMAIN);
        returnValue = false;
    }
    return returnValue;
}
#method_after
@Override
protected boolean validate() {
    boolean returnValue = super.validate() && checkStorageDomain() && checkStorageDomainStatusNotEqual(StorageDomainStatus.Active);
    if (returnValue && getStorageDomain().getStorageDomainType() == StorageDomainType.Master && isAttachedStorageDomain()) {
        if (electNewMaster() == null) {
            returnValue = false;
            addValidationMessage(EngineMessage.ERROR_CANNOT_DESTROY_LAST_STORAGE_DOMAIN);
        } else if (!initializeVds()) {
            returnValue = false;
            addValidationMessage(EngineMessage.ERROR_CANNOT_DESTROY_LAST_STORAGE_DOMAIN_HOST_NOT_ACTIVE);
        }
    }
    if (returnValue && getStorageDomain().getStorageType() == StorageType.GLANCE) {
        addValidationMessage(EngineMessage.ERROR_CANNOT_MANAGE_STORAGE_DOMAIN);
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
private void copyAllMemoryImages(Guid containerId) {
    for (String memoryVolumes : MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots())) {
        List<Guid> guids = GuidUtils.getGuidListFromString(memoryVolumes);
        // copy the memory dump image
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy memory image");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy metadata image");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
private void copyAllMemoryImages(Guid containerId) {
    for (String memoryVolumes : MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots())) {
        List<Guid> guids = Guid.createGuidListFromString(memoryVolumes);
        // copy the memory dump image
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy memory image");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy metadata image");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
private void updateMemoryDisks(Snapshot snapshot) {
    List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
    snapshot.setMemoryDiskId(guids.get(2));
    snapshot.setMetadataDiskId(guids.get(4));
}
#method_after
private void updateMemoryDisks(Snapshot snapshot) {
    List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
    snapshot.setMemoryDiskId(guids.get(2));
    snapshot.setMetadataDiskId(guids.get(4));
}
#end_block

#method_before
private void addMemoryImages() {
    getVm().getSnapshots().stream().filter(snapshot -> !StringUtils.isEmpty(snapshot.getMemoryVolume())).forEach(snapshot -> {
        addDisk(createMemoryDisk(snapshot));
        addDisk(createMetadaaDisk(snapshot));
    });
}
#method_after
private void addMemoryImages() {
    getVm().getSnapshots().stream().filter(snapshot -> !StringUtils.isEmpty(snapshot.getMemoryVolume())).forEach(snapshot -> {
        addDisk(createMemoryDisk(snapshot));
        addDisk(createMetadataDisk(getVm(), snapshot));
    });
}
#end_block

#method_before
private DiskImage createMemoryDisk(Snapshot snapshot) {
    List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
    StorageDomainStatic sd = storageDomainStaticDao.get(guids.get(0));
    if (sd == null) {
        log.error("Memory disk '{}' of snapshot '{}' could not be added since storage domain id '{}' does not exists", guids.get(2), snapshot.getId(), guids.get(0));
        return null;
    }
    VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
    DiskImage memoryDisk = MemoryUtils.createMemoryDisk(vm, sd.getStorageType(), vmOverheadCalculator);
    memoryDisk.setId(guids.get(2));
    memoryDisk.setImageId(guids.get(3));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    return memoryDisk;
}
#method_after
private DiskImage createMemoryDisk(Snapshot snapshot) {
    List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
    StorageDomainStatic sd = validateStorageDomainExistsInDb(snapshot, guids.get(0), guids.get(2), guids.get(3));
    if (sd == null) {
        return null;
    }
    VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
    DiskImage memoryDisk = MemoryUtils.createMemoryDisk(vm, sd.getStorageType(), vmOverheadCalculator, MemoryUtils.generateMemoryDiskDescription(vm, snapshot.getDescription()));
    memoryDisk.setId(guids.get(2));
    memoryDisk.setImageId(guids.get(3));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    return memoryDisk;
}
#end_block

#method_before
private void addDisk(DiskImage disk) {
    if (disk != null) {
        saveImage(disk);
        saveBaseDisk(disk);
        saveDiskImageDynamic(disk);
    } else {
        log.error("Memory/Metadata disk could not be added");
    }
}
#method_after
private void addDisk(DiskImage disk) {
    if (disk != null) {
        saveImage(disk);
        saveBaseDisk(disk);
        saveDiskImageDynamic(disk);
    } else {
        log.error("Memory metadata/dump disk could not be added");
    }
}
#end_block

#method_before
@Override
public Response toResponse(MalformedIdException exception) {
    log.error("Malformed id detected while processing \"{}\" request for path \"{}\"", request.getMethod(), uriInfo.getPath());
    log.error("Exception", exception);
    final Fault fault = new Fault();
    fault.setReason("Operation Failed");
    fault.setDetail(exception.getCause().getMessage());
    return Response.status(Status.BAD_REQUEST).entity(fault).build();
}
#method_after
@Override
public Response toResponse(MalformedIdException exception) {
    log.error("Malformed id detected while processing \"{}\" request for path \"{}\"", request.getMethod(), uriInfo.getPath());
    log.error("Exception", exception);
    final Fault fault = new Fault();
    fault.setReason("Operation failed");
    fault.setDetail(exception.getCause().getMessage());
    return Response.status(Status.BAD_REQUEST).entity(fault).build();
}
#end_block

#method_before
private void disconnectStorageByType(StorageType storageType, List<StorageServerConnections> connections) {
    /*
         * HE SD should only be connected/disconnected by the HE tools, not
         * by the engine.
         */
    Optional<StorageDomain> heDomain = storageDomainDao.getAllForStoragePool(getStoragePool().getId()).stream().filter(StorageDomain::isHostedEngineStorage).findAny();
    if (heDomain.isPresent()) {
        String heID = heDomain.get().getStorageStaticData().getStorage();
        connections = connections.stream().filter(c -> !c.getId().equals(heID)).collect(Collectors.toList());
    }
    storageHelperDirector.getItem(storageType).prepareDisconnectHostFromStoragePoolServers(getParameters(), connections);
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.DisconnectStorageServer, new StorageServerConnectionManagementVDSParameters(getVds().getId(), getStoragePool().getId(), storageType, connections));
    setSucceeded(vdsReturnValue.getSucceeded());
    if (!vdsReturnValue.getSucceeded()) {
        storageHelperDirector.getItem(storageType).isConnectSucceeded((HashMap<String, String>) vdsReturnValue.getReturnValue(), connections);
    }
}
#method_after
private void disconnectStorageByType(StorageType storageType, List<StorageServerConnections> connections) {
    /*
         * HE SD should only be connected/disconnected by the HE tools, not
         * by the engine.
         */
    Set<String> heIds = storageDomainDao.getHostedEngineStorageDomainIds().stream().map(storageDomainDao::get).map(StorageDomain::getStorageStaticData).map(StorageDomainStatic::getStorage).collect(Collectors.toSet());
    connections = connections.stream().filter(c -> !heIds.contains(c.getId())).collect(Collectors.toList());
    storageHelperDirector.getItem(storageType).prepareDisconnectHostFromStoragePoolServers(getParameters(), connections);
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.DisconnectStorageServer, new StorageServerConnectionManagementVDSParameters(getVds().getId(), getStoragePool().getId(), storageType, connections));
    setSucceeded(vdsReturnValue.getSucceeded());
    if (!vdsReturnValue.getSucceeded()) {
        storageHelperDirector.getItem(storageType).isConnectSucceeded((HashMap<String, String>) vdsReturnValue.getReturnValue(), connections);
    }
}
#end_block

#method_before
@Override
public void edit(UnitVmModel model) {
    super.edit(model);
    unitVmModel = model;
    super.initializeModeSwitching(generalTab);
    driver.edit(model);
    profilesInstanceTypeEditor.edit(model.getNicsWithLogicalNetworks());
    instanceImagesEditor.edit(model.getInstanceImages());
    customPropertiesSheetEditor.edit(model.getCustomPropertySheet());
    vmInitEditor.edit(model.getVmInitModel());
    serialNumberPolicyEditor.edit(model.getSerialNumberPolicy());
    affinityLabelSelectionWidget.getListWidget().init(model.getLabelList());
    quotaEditor.setEnabled(!model.isVmBehaviorHostedEngine());
    initTabAvailabilityListeners(model);
    initListeners(model);
    hideAlwaysHiddenFields();
    decorateDetachableFields();
    enableNumaSupport(model);
}
#method_after
@Override
public void edit(UnitVmModel model) {
    super.edit(model);
    unitVmModel = model;
    super.initializeModeSwitching(generalTab);
    driver.edit(model);
    profilesInstanceTypeEditor.edit(model.getNicsWithLogicalNetworks());
    instanceImagesEditor.edit(model.getInstanceImages());
    customPropertiesSheetEditor.edit(model.getCustomPropertySheet());
    vmInitEditor.edit(model.getVmInitModel());
    serialNumberPolicyEditor.edit(model.getSerialNumberPolicy());
    affinityLabelSelectionWidget.getListWidget().init(model.getLabelList());
    quotaEditor.setEnabled(!model.isHostedEngine());
    initTabAvailabilityListeners(model);
    initListeners(model);
    hideAlwaysHiddenFields();
    decorateDetachableFields();
    enableNumaSupport(model);
}
#end_block

#method_before
private void showNetwork(LogicalNetworkModel networkModel) {
    boolean descriptionSectionHasValues = false;
    contents.removeAllRows();
    Network entity = networkModel.getNetwork();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName(), BACKGROUND_COLOR));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageWithText(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
        descriptionSectionHasValues = true;
    } else {
        if (networkModel.getErrorMessage() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, templates.maxWidthNteworkItemPopup(networkModel.getErrorMessage())));
            descriptionSectionHasValues = true;
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
            descriptionSectionHasValues = true;
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addSyncDiff(networkModel);
            descriptionSectionHasValues = true;
        }
    }
    if (descriptionSectionHasValues) {
        insertHorizontalLine();
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    boolean isGluster = false;
    boolean isDefaultRoute = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
        isGluster = entity.getCluster().isGluster();
        isDefaultRoute = entity.getCluster().isDefaultRoute();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration || isGluster || isDefaultRoute) {
        // $NON-NLS-1$
        addRow(templates.strongTextWithColor(constants.usageItemInfo() + ":", WHITE_TEXT_COLOR));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo(), TEXT_COLOR));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo(), TEXT_COLOR));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo(), TEXT_COLOR));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo(), TEXT_COLOR));
        }
        if (isGluster) {
            addRow(templates.imageTextSetupNetworkUsage(glusterNwImage, constants.glusterNwItemInfo(), TEXT_COLOR));
        }
        if (isDefaultRoute) {
            addRow(templates.imageTextSetupNetworkUsage(defaultRouteImage, constants.defaultRouteItemInfo(), TEXT_COLOR));
        }
        insertHorizontalLine();
    }
    // Mtu
    if (!entity.isExternal()) {
        final String mtuValue = entity.getMtu() == 0 ? messages.defaultMtu(defaultMtu) : String.valueOf(entity.getMtu());
        // $NON-NLS-1$
        final String mtu = templates.strongTextWithColor(constants.mtuItemInfo(), WHITE_TEXT_COLOR).asString() + ": " + templates.coloredText(mtuValue, TEXT_COLOR).asString();
        addRow(SafeHtmlUtils.fromTrustedString(mtu));
    }
    // Boot protocol and IP info
    if (networkModel.isAttached()) {
        insertHorizontalLine();
        VdsNetworkInterface iface = networkModel.getAttachedToNic().getOriginalIface();
        Ipv4BootProtocol bootProtocol = iface.getIpv4BootProtocol();
        addRow(constants.bootProtocolItemInfo(), RENDERER.render(bootProtocol));
        if (bootProtocol == Ipv4BootProtocol.STATIC_IP) {
            addRow(constants.addressItemInfo(), iface.getIpv4Address());
            addRow(constants.subnetItemInfo(), iface.getIpv4Subnet());
            addRow(constants.gatewayItemInfo(), iface.getIpv4Gateway());
        }
    }
}
#method_after
private void showNetwork(LogicalNetworkModel networkModel) {
    boolean descriptionSectionHasValues = false;
    contents.removeAllRows();
    Network entity = networkModel.getNetwork();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName(), BACKGROUND_COLOR));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageWithText(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
        descriptionSectionHasValues = true;
    } else {
        if (networkModel.getErrorMessage() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, templates.maxWidthNteworkItemPopup(networkModel.getErrorMessage())));
            descriptionSectionHasValues = true;
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
            descriptionSectionHasValues = true;
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addSyncDiff(networkModel);
            descriptionSectionHasValues = true;
        }
    }
    if (descriptionSectionHasValues) {
        insertHorizontalLine();
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    boolean isGluster = false;
    boolean isDefaultRoute = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
        isGluster = entity.getCluster().isGluster();
        isDefaultRoute = entity.getCluster().isDefaultRoute();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration || isGluster || isDefaultRoute) {
        // $NON-NLS-1$
        addRow(templates.strongTextWithColor(constants.usageItemInfo() + ":", WHITE_TEXT_COLOR));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo(), TEXT_COLOR));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo(), TEXT_COLOR));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo(), TEXT_COLOR));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo(), TEXT_COLOR));
        }
        if (isGluster) {
            addRow(templates.imageTextSetupNetworkUsage(glusterNwImage, constants.glusterNwItemInfo(), TEXT_COLOR));
        }
        if (isDefaultRoute) {
            addRow(templates.imageTextSetupNetworkUsage(defaultRouteImage, constants.defaultRouteItemInfo(), TEXT_COLOR));
        }
        insertHorizontalLine();
    }
    // Mtu
    if (!entity.isExternal()) {
        final String mtuValue = entity.getMtu() == 0 ? messages.defaultMtu(defaultMtu) : String.valueOf(entity.getMtu());
        // $NON-NLS-1$
        final String mtu = templates.strongTextWithColor(constants.mtuItemInfo(), WHITE_TEXT_COLOR).asString() + ": " + templates.coloredText(mtuValue, TEXT_COLOR).asString();
        addRow(SafeHtmlUtils.fromTrustedString(mtu));
    }
    // Boot protocol and IP info
    if (networkModel.isAttached()) {
        insertHorizontalLine();
        addBootProtoAndIpInfo(networkModel.getAttachedToNic().getOriginalIface());
    }
}
#end_block

#method_before
private void showNic(NetworkInterfaceModel nic) {
    contents.removeAllRows();
    VdsNetworkInterface entity = nic.getOriginalIface();
    addRow(templates.titleSetupNetworkTooltip(nic.getName(), BACKGROUND_COLOR));
    if (nic.getItems().isEmpty()) {
        Ipv4BootProtocol bootProtocol = entity.getIpv4BootProtocol();
        addRow(constants.bootProtocolItemInfo(), RENDERER.render(bootProtocol));
        if (bootProtocol == Ipv4BootProtocol.STATIC_IP) {
            addRow(constants.addressItemInfo(), entity.getIpv4Address());
            addRow(constants.subnetItemInfo(), entity.getIpv4Subnet());
            addRow(constants.gatewayItemInfo(), entity.getIpv4Gateway());
        }
    }
    if (nic instanceof BondNetworkInterfaceModel) {
        addRow(constants.bondOptionsItemInfo(), entity.getBondOptions());
    }
    if (nic.isVf()) {
        addRow(constants.physicalFunction(), nic.getPhysicalFunction());
    }
}
#method_after
private void showNic(NetworkInterfaceModel nic) {
    contents.removeAllRows();
    VdsNetworkInterface entity = nic.getOriginalIface();
    addRow(templates.titleSetupNetworkTooltip(nic.getName(), BACKGROUND_COLOR));
    if (nic.getItems().isEmpty()) {
        addBootProtoAndIpInfo(entity);
    }
    if (nic instanceof BondNetworkInterfaceModel) {
        addRow(constants.bondOptionsItemInfo(), entity.getBondOptions());
    }
    if (nic.isVf()) {
        addRow(constants.physicalFunction(), nic.getPhysicalFunction());
    }
}
#end_block

#method_before
@Override
protected boolean validateImageTransfer() {
    DiskImage diskImage = getDiskImage();
    DiskValidator diskValidator = getDiskValidator(diskImage);
    DiskImagesValidator diskImagesValidator = getDiskImagesValidator(diskImage);
    StorageDomainValidator storageDomainValidator = getStorageDomainValidator(storageDomainDao.getForStoragePool(diskImage.getStorageIds().get(0), diskImage.getStoragePoolId()));
    return validate(diskValidator.isDiskExists()) && validate(diskValidator.isDiskPluggedToAnyNonDownVm(false)) && validate(diskImagesValidator.diskImagesNotIllegal()) && validate(diskImagesValidator.diskImagesNotLocked()) && validate(storageDomainValidator.isDomainExistAndActive());
}
#method_after
@Override
protected boolean validateImageTransfer() {
    DiskImage diskImage = getDiskImage();
    DiskValidator diskValidator = getDiskValidator(diskImage);
    DiskImagesValidator diskImagesValidator = getDiskImagesValidator(diskImage);
    StorageDomainValidator storageDomainValidator = getStorageDomainValidator(storageDomainDao.getForStoragePool(diskImage.getStorageIds().get(0), diskImage.getStoragePoolId()));
    return validate(diskValidator.isDiskExists()) && validateActiveDiskPluggedToAnyNonDownVm(diskImage, diskValidator) && validate(diskImagesValidator.diskImagesNotIllegal()) && validate(diskImagesValidator.diskImagesNotLocked()) && validate(storageDomainValidator.isDomainExistAndActive());
}
#end_block

#method_before
private PrepareImageVDSCommandParameters getPrepareParameters(Guid vdsId) {
    return new PrepareImageVDSCommandParameters(vdsId, getStoragePool().getId(), getStorageDomainId(), getImage().getImage().getDiskId(), getImage().getImageId(), true);
}
#method_after
private PrepareImageVDSCommandParameters getPrepareParameters(Guid vdsId) {
    return new PrepareImageVDSCommandParameters(vdsId, getStoragePool().getId(), getStorageDomainId(), getDiskImage().getId(), getDiskImage().getImageId(), true);
}
#end_block

#method_before
protected ImageActionsVDSCommandParameters getImageActionsParameters(Guid vdsId) {
    return new ImageActionsVDSCommandParameters(vdsId, getStoragePool().getId(), getStorageDomainId(), getImage().getImage().getDiskId(), getImage().getImageId());
}
#method_after
protected ImageActionsVDSCommandParameters getImageActionsParameters(Guid vdsId) {
    return new ImageActionsVDSCommandParameters(vdsId, getStoragePool().getId(), getStorageDomainId(), getDiskImage().getId(), getDiskImage().getImageId());
}
#end_block

#method_before
protected DiskImage getDiskImage() {
    if (!Guid.isNullOrEmpty(getParameters().getImageId())) {
        return super.getDiskImage();
    }
    return (DiskImage) diskDao.get(getParameters().getImageGroupID());
}
#method_after
protected DiskImage getDiskImage() {
    if (!Guid.isNullOrEmpty(getParameters().getImageId())) {
        setImageId(getParameters().getImageId());
        return super.getDiskImage();
    }
    return (DiskImage) diskDao.get(getParameters().getImageGroupID());
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> listPermissionSubjects = new ArrayList<>();
    if (isImageProvided()) {
        listPermissionSubjects.add(new PermissionSubject(getImageGroupId(), VdcObjectType.Disk, ActionGroup.EDIT_DISK_PROPERTIES));
    } else {
        listPermissionSubjects.add(new PermissionSubject(getParameters().getStorageDomainId(), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
    }
    return listPermissionSubjects;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> listPermissionSubjects = new ArrayList<>();
    if (isImageProvided()) {
        listPermissionSubjects.add(new PermissionSubject(getParameters().getImageGroupID(), VdcObjectType.Disk, ActionGroup.EDIT_DISK_PROPERTIES));
    } else {
        listPermissionSubjects.add(new PermissionSubject(getParameters().getStorageDomainId(), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
    }
    return listPermissionSubjects;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    locks.put(getImageGroupId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.DISK, EngineMessage.ACTION_TYPE_FAILED_DISK_IS_LOCKED));
    if (!Guid.isNullOrEmpty(getParameters().getImageId())) {
        List<VM> vms = vmDao.getVmsListForDisk(getImageGroupId(), true);
        vms.forEach(vm -> locks.put(vm.getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_VM_IS_LOCKED)));
    }
    return locks;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    if (getParameters().getTransferType() == TransferType.Download) {
        locks.put(getParameters().getImageGroupID().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.DISK, EngineMessage.ACTION_TYPE_FAILED_DISK_IS_LOCKED));
        if (!Guid.isNullOrEmpty(getParameters().getImageId())) {
            List<VM> vms = vmDao.getVmsListForDisk(getParameters().getImageGroupID(), true);
            vms.forEach(vm -> locks.put(vm.getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_VM_IS_LOCKED)));
        }
    }
    return locks;
}
#end_block

#method_before
public void proceedCommandExecution(Guid childCmdId) {
    ImageTransfer entity = imageTransferDao.get(getCommandId());
    if (entity == null || entity.getPhase() == null) {
        log.error("Image transfer status entity corrupt or missing from database" + " for image transfer command '{}'", getCommandId());
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (entity.getDiskId() != null) {
        // Make the disk id available for all states below.  If the transfer is still
        // initializing, this may be set below in the INITIALIZING block instead.
        setImageId(entity.getDiskId());
    }
    // Check conditions for pausing the transfer (ie UI is MIA)
    long ts = System.currentTimeMillis() / 1000;
    if (pauseTransferIfNecessary(entity, ts)) {
        return;
    }
    executeStateHandler(entity, ts, childCmdId);
}
#method_after
public void proceedCommandExecution(Guid childCmdId) {
    ImageTransfer entity = imageTransferDao.get(getCommandId());
    if (entity == null || entity.getPhase() == null) {
        log.error("Image transfer status entity corrupt or missing from database" + " for image transfer command '{}'", getCommandId());
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (entity.getDiskId() != null) {
        // Make the disk id available for all states below.  If the transfer is still
        // initializing, this may be set below in the INITIALIZING block instead.
        setImageGroupId(entity.getDiskId());
    }
    // Check conditions for pausing the transfer (ie UI is MIA)
    long ts = System.currentTimeMillis() / 1000;
    if (pauseTransferIfNecessary(entity, ts)) {
        return;
    }
    executeStateHandler(entity, ts, childCmdId);
}
#end_block

#method_before
private void handleInitializing(final StateContext context) {
    if (context.childCmdId == null) {
        // Guard against callback invocation before executeCommand() is complete
        return;
    }
    switch(CommandCoordinatorUtil.getCommandStatus(context.childCmdId)) {
        case NOT_STARTED:
        case ACTIVE:
            log.info("Waiting for {} to be added for image transfer command '{}'", getImageType(), getCommandId());
            return;
        case SUCCEEDED:
            break;
        default:
            log.error("Failed to add {} for image transfer command '{}'", getImageType(), getCommandId());
            setCommandStatus(CommandStatus.FAILED);
            return;
    }
    ActionReturnValue addDiskRetVal = CommandCoordinatorUtil.getCommandReturnValue(context.childCmdId);
    if (addDiskRetVal == null || !addDiskRetVal.getSucceeded()) {
        log.error("Failed to add {} (command status was success, but return value was failed)" + " for image transfer command '{}'", getImageType(), getCommandId());
        setReturnValue(addDiskRetVal);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    Guid createdId = addDiskRetVal.getActionReturnValue();
    getParameters().setImageGroupID(createdId);
    handleImageIsReadyForTransfer();
}
#method_after
private void handleInitializing(final StateContext context) {
    if (context.childCmdId == null) {
        // Guard against callback invocation before executeCommand() is complete
        return;
    }
    switch(CommandCoordinatorUtil.getCommandStatus(context.childCmdId)) {
        case NOT_STARTED:
        case ACTIVE:
            log.info("Waiting for {} to be added for image transfer command '{}'", getImageType(), getCommandId());
            return;
        case SUCCEEDED:
            break;
        default:
            log.error("Failed to add {} for image transfer command '{}'", getImageType(), getCommandId());
            setCommandStatus(CommandStatus.FAILED);
            return;
    }
    ActionReturnValue addDiskRetVal = CommandCoordinatorUtil.getCommandReturnValue(context.childCmdId);
    if (addDiskRetVal == null || !addDiskRetVal.getSucceeded()) {
        log.error("Failed to add {} (command status was success, but return value was failed)" + " for image transfer command '{}'", getImageType(), getCommandId());
        setReturnValue(addDiskRetVal);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    Guid createdId = addDiskRetVal.getActionReturnValue();
    // Saving disk id in the parameters in order to persist it in command_entities table
    getParameters().setImageGroupID(createdId);
    handleImageIsReadyForTransfer();
}
#end_block

#method_before
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful transfer for {}", getTransferDescription());
    // If stopping the session did not succeed, don't change the transfer state.
    if (stopImageTransferSession(context.entity)) {
        Guid transferingVdsId = context.entity.getVdsId();
        // Verify image is relevant only on upload
        if (getParameters().getTransferType() == TransferType.Download) {
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
            setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else // We want to use the transferring vds for image actions for having a coherent log when transferring.
        if (verifyImage(transferingVdsId)) {
            setVolumeLegalityInStorage(LEGAL_IMAGE);
            if (getImage().getVolumeFormat().equals(VolumeFormat.COW)) {
                setQcowCompat(getImage().getImage(), getStoragePool().getId(), getImage().getImage().getDiskId(), getImage().getImageId(), getStorageDomainId(), transferingVdsId);
                imageDao.update(getImage().getImage());
            }
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
            setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else {
            setImageStatus(ImageStatus.ILLEGAL);
            updateEntityPhase(ImageTransferPhase.FINALIZING_FAILURE);
        }
        // Finished using the image, tear it down.
        tearDownImage(context.entity.getVdsId());
    }
}
#method_after
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful transfer for {}", getTransferDescription());
    // If stopping the session did not succeed, don't change the transfer state.
    if (stopImageTransferSession(context.entity)) {
        Guid transferingVdsId = context.entity.getVdsId();
        // Verify image is relevant only on upload
        if (getParameters().getTransferType() == TransferType.Download) {
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
            setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else // We want to use the transferring vds for image actions for having a coherent log when transferring.
        if (verifyImage(transferingVdsId)) {
            setVolumeLegalityInStorage(LEGAL_IMAGE);
            if (getDiskImage().getVolumeFormat().equals(VolumeFormat.COW)) {
                setQcowCompat(getImage().getImage(), getStoragePool().getId(), getDiskImage().getId(), getDiskImage().getImageId(), getStorageDomainId(), transferingVdsId);
                imageDao.update(getImage().getImage());
            }
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
            setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else {
            setImageStatus(ImageStatus.ILLEGAL);
            updateEntityPhase(ImageTransferPhase.FINALIZING_FAILURE);
        }
        // Finished using the image, tear it down.
        tearDownImage(context.entity.getVdsId());
    }
}
#end_block

#method_before
private boolean verifyImage(Guid transferingVdsId) {
    ImageActionsVDSCommandParameters parameters = new ImageActionsVDSCommandParameters(transferingVdsId, getStoragePool().getId(), getStorageDomainId(), getImage().getImage().getDiskId(), getImage().getImageId());
    try {
        // As we currently support a single volume image, we only need to verify that volume.
        getBackend().getResourceManager().runVdsCommand(VDSCommandType.VerifyUntrustedVolume, parameters);
    } catch (RuntimeException e) {
        log.error("Failed to verify transferred image: {}", e);
        return false;
    }
    return true;
}
#method_after
private boolean verifyImage(Guid transferingVdsId) {
    ImageActionsVDSCommandParameters parameters = new ImageActionsVDSCommandParameters(transferingVdsId, getStoragePool().getId(), getStorageDomainId(), getDiskImage().getId(), getDiskImage().getImageId());
    try {
        // As we currently support a single volume image, we only need to verify that volume.
        getBackend().getResourceManager().runVdsCommand(VDSCommandType.VerifyUntrustedVolume, parameters);
    } catch (RuntimeException e) {
        log.error("Failed to verify transferred image: {}", e);
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (!setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    String[] transferOps = new String[] { getParameters().getTransferType().getOp() };
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, transferOps, timeout, getParameters().getTransferSize(), imagePath, getParameters().getDownloadFilename());
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransfer updates = new ImageTransfer();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#method_after
protected boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (getParameters().getTransferType() == TransferType.Upload && !setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    String[] transferOps = new String[] { getParameters().getTransferType().getOp() };
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, transferOps, timeout, getParameters().getTransferSize(), imagePath, getParameters().getDownloadFilename());
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransfer updates = new ImageTransfer();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#end_block

#method_before
private boolean setVolumeLegalityInStorage(boolean legal) {
    SetVolumeLegalityVDSCommandParameters parameters = new SetVolumeLegalityVDSCommandParameters(getStoragePool().getId(), getStorageDomainId(), getImage().getImage().getDiskId(), getImage().getImageId(), legal);
    try {
        runVdsCommand(VDSCommandType.SetVolumeLegality, parameters);
    } catch (EngineException e) {
        log.error("Failed to set image's volume's legality to {} for image {} and volume {}: {}", legal, getImage().getImage().getDiskId(), getImage().getImageId(), e);
        return false;
    }
    return true;
}
#method_after
private boolean setVolumeLegalityInStorage(boolean legal) {
    SetVolumeLegalityVDSCommandParameters parameters = new SetVolumeLegalityVDSCommandParameters(getStoragePool().getId(), getStorageDomainId(), getDiskImage().getId(), getDiskImage().getImageId(), legal);
    try {
        runVdsCommand(VDSCommandType.SetVolumeLegality, parameters);
    } catch (EngineException e) {
        log.error("Failed to set image's volume's legality to {} for image {} and volume {}: {}", legal, getImage().getImage().getDiskId(), getImage().getImageId(), e);
        return false;
    }
    return true;
}
#end_block

#method_before
public ArrayList<Guid> getStorageIds() {
    return storageIds;
}
#method_after
public List<Guid> getStorageIds() {
    return storageIds;
}
#end_block

#method_before
public void setStorageIds(ArrayList<Guid> storageIds) {
    this.storageIds = storageIds;
}
#method_after
public void setStorageIds(List<Guid> storageIds) {
    this.storageIds = storageIds;
}
#end_block

#method_before
public ArrayList<StorageType> getStorageTypes() {
    return storageTypes;
}
#method_after
public List<StorageType> getStorageTypes() {
    return storageTypes;
}
#end_block

#method_before
public void setStorageTypes(ArrayList<StorageType> storageTypes) {
    this.storageTypes = storageTypes;
}
#method_after
public void setStorageTypes(List<StorageType> storageTypes) {
    this.storageTypes = storageTypes;
}
#end_block

#method_before
public ArrayList<String> getStoragesNames() {
    return storagesNames;
}
#method_after
public List<String> getStoragesNames() {
    return storagesNames;
}
#end_block

#method_before
public void setStoragesNames(ArrayList<String> storagesNames) {
    this.storagesNames = storagesNames;
}
#method_after
public void setStoragesNames(List<String> storagesNames) {
    this.storagesNames = storagesNames;
}
#end_block

#method_before
public ArrayList<DiskImage> getSnapshots() {
    return snapshots;
}
#method_after
public List<DiskImage> getSnapshots() {
    return snapshots;
}
#end_block

#method_before
public ArrayList<Guid> getQuotaIds() {
    return quotaIds;
}
#method_after
public List<Guid> getQuotaIds() {
    return quotaIds;
}
#end_block

#method_before
public void setQuotaIds(ArrayList<Guid> quotaIds) {
    this.quotaIds = quotaIds;
}
#method_after
public void setQuotaIds(List<Guid> quotaIds) {
    this.quotaIds = quotaIds;
}
#end_block

#method_before
public ArrayList<String> getQuotaNames() {
    return quotaNames;
}
#method_after
public List<String> getQuotaNames() {
    return quotaNames;
}
#end_block

#method_before
public void setQuotaNames(ArrayList<String> quotaNames) {
    this.quotaNames = quotaNames;
}
#method_after
public void setQuotaNames(List<String> quotaNames) {
    this.quotaNames = quotaNames;
}
#end_block

#method_before
public ArrayList<Guid> getDiskProfileIds() {
    return diskProfileIds;
}
#method_after
public List<Guid> getDiskProfileIds() {
    return diskProfileIds;
}
#end_block

#method_before
public void setDiskProfileIds(ArrayList<Guid> diskProfileIds) {
    this.diskProfileIds = diskProfileIds;
}
#method_after
public void setDiskProfileIds(List<Guid> diskProfileIds) {
    this.diskProfileIds = diskProfileIds;
}
#end_block

#method_before
public ArrayList<String> getDiskProfileNames() {
    return diskProfileNames;
}
#method_after
public List<String> getDiskProfileNames() {
    return diskProfileNames;
}
#end_block

#method_before
public void setDiskProfileNames(ArrayList<String> diskProfileNames) {
    this.diskProfileNames = diskProfileNames;
}
#method_after
public void setDiskProfileNames(List<String> diskProfileNames) {
    this.diskProfileNames = diskProfileNames;
}
#end_block

#method_before
@Mapping(from = RepoImage.class, to = Image.class)
public static Image map(RepoImage entity, Image template) {
    Image model = template != null ? template : new Image();
    model.setId(entity.getRepoImageId());
    model.setName(entity.getRepoImageName());
    if (entity.getSize() != null) {
        model.setSize(entity.getSize().intValue());
    }
    if (entity.getFileType() != null) {
        model.setFileType(map(entity.getFileType(), null));
    }
    return model;
}
#method_after
@Mapping(from = RepoImage.class, to = Image.class)
public static Image map(RepoImage entity, Image template) {
    Image model = template != null ? template : new Image();
    model.setId(entity.getRepoImageId());
    model.setName(entity.getRepoImageName());
    model.setSize(entity.getSize());
    model.setType(mapImageType(entity.getFileType()));
    return model;
}
#end_block

#method_before
public void setEntity(VDS value) {
    if (super.getEntity() != null && value != null) {
        VDS currentItem = super.getEntity();
        Guid currentItemId = currentItem.getId();
        Guid newItemId = value.getId();
        if (currentItemId.equals(newItemId)) {
            setEntity(value, false);
            updateActionAvailability();
            return;
        }
    }
    super.setEntity(value);
}
#method_after
public void setEntity(VDS value) {
    if (super.getEntity() != null && value != null) {
        VDS currentItem = super.getEntity();
        Guid currentItemId = currentItem.getId();
        Guid newItemId = value.getId();
        if (currentItemId.equals(newItemId)) {
            setEntity(value, false);
            updateNetworkAttachments();
            updateActionAvailability();
            return;
        }
    }
    super.setEntity(value);
    updateNetworkAttachments();
}
#end_block

#method_before
private void updateActionAvailability() {
    VDS host = getEntity();
    getSaveNetworkConfigCommand().setIsExecutionAllowed(host != null && (host.getNetConfigDirty() == null ? false : host.getNetConfigDirty()));
    getSyncAllHostNetworksCommand().setIsExecutionAllowed(host != null && (host.getNetConfigDirty() == null ? false : host.getNetConfigDirty()));
}
#method_after
private void updateActionAvailability() {
    VDS host = getEntity();
    getSaveNetworkConfigCommand().setIsExecutionAllowed(host != null && (host.getNetConfigDirty() == null ? false : host.getNetConfigDirty()));
}
#end_block

#method_before
@Override
public ClusterFeatures list() {
    ClusterFeatures features = new ClusterFeatures();
    Set<SupportedAdditionalClusterFeature> addlFeatures = getOptionalEntity(Set.class, QueryType.GetClusterFeaturesByClusterId, new IdQueryParameters(asGuid(clusterId)), clusterId, false);
    if (addlFeatures != null && !addlFeatures.isEmpty()) {
        for (SupportedAdditionalClusterFeature entity : addlFeatures) {
            if (entity.isEnabled()) {
                features.getClusterFeatures().add(ClusterFeaturesMapper.map(entity.getFeature(), null));
            }
        }
    }
    return features;
}
#method_after
@Override
public ClusterFeatures list() {
    ClusterFeatures features = new ClusterFeatures();
    Set<SupportedAdditionalClusterFeature> addlFeatures = getOptionalEntity(Set.class, QueryType.GetClusterFeaturesByClusterId, new IdQueryParameters(clusterId), clusterId.toString(), false);
    if (addlFeatures != null) {
        for (SupportedAdditionalClusterFeature entity : addlFeatures) {
            if (entity.isEnabled()) {
                features.getClusterFeatures().add(addLinks(map(entity.getFeature(), null)));
            }
        }
    }
    return features;
}
#end_block

#method_before
@Override
public Response add(ClusterFeature feature) {
    validateParameters(feature);
    org.ovirt.engine.core.common.businessentities.AdditionalFeature featureEntity = ClusterFeaturesMapper.map(feature, null);
    org.ovirt.engine.core.common.businessentities.Cluster cluster = getClusterEntity();
    SupportedAdditionalClusterFeature supportedFeature = new SupportedAdditionalClusterFeature();
    supportedFeature.setFeature(featureEntity);
    supportedFeature.setEnabled(true);
    supportedFeature.setClusterId(asGuid(clusterId));
    cluster.getAddtionalFeaturesSupported().add(supportedFeature);
    return updateClusterEntity(cluster);
}
#method_after
@Override
public Response add(ClusterFeature feature) {
    validateParameters(feature);
    org.ovirt.engine.core.common.businessentities.AdditionalFeature featureEntity = map(feature, null);
    org.ovirt.engine.core.common.businessentities.Cluster cluster = BackendClusterFeatureHelper.getClusterEntity(this, clusterId);
    SupportedAdditionalClusterFeature supportedFeature = new SupportedAdditionalClusterFeature();
    supportedFeature.setFeature(featureEntity);
    supportedFeature.setEnabled(true);
    supportedFeature.setClusterId(clusterId);
    cluster.getAddtionalFeaturesSupported().add(supportedFeature);
    ManagementNetworkOnClusterOperationParameters param = new ManagementNetworkOnClusterOperationParameters(cluster);
    return performCreate(ActionType.UpdateCluster, param, new ClusterFeatureIdResolver(clusterId, featureEntity.getId()));
}
#end_block

#method_before
@Override
public ClusterEnabledFeatureResource getFeatureResource(String id) {
    return new BackendClusterEnabledFeatureResource(id, this);
}
#method_after
@Override
public ClusterEnabledFeatureResource getFeatureResource(String id) {
    return inject(new BackendClusterEnabledFeatureResource(clusterId, id));
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.api.model.ClusterFeature.class, to = AdditionalFeature.class)
public static AdditionalFeature map(org.ovirt.engine.api.model.ClusterFeature model, AdditionalFeature template) {
    AdditionalFeature entity = new AdditionalFeature();
    entity.setName(model.getName());
    entity.setId(Guid.createGuidFromString(model.getId()));
    return entity;
}
#method_after
@Mapping(from = org.ovirt.engine.api.model.ClusterFeature.class, to = AdditionalFeature.class)
public static AdditionalFeature map(org.ovirt.engine.api.model.ClusterFeature model, AdditionalFeature template) {
    AdditionalFeature entity = template != null ? template : new AdditionalFeature();
    entity.setName(model.getName());
    entity.setId(Guid.createGuidFromString(model.getId()));
    return entity;
}
#end_block

#method_before
@Mapping(from = AdditionalFeature.class, to = org.ovirt.engine.api.model.ClusterFeature.class)
public static org.ovirt.engine.api.model.ClusterFeature map(AdditionalFeature entity, org.ovirt.engine.api.model.ClusterFeature template) {
    org.ovirt.engine.api.model.ClusterFeature model = new org.ovirt.engine.api.model.ClusterFeature();
    model.setName(entity.getName());
    model.setId(entity.getId().toString());
    return model;
}
#method_after
@Mapping(from = AdditionalFeature.class, to = org.ovirt.engine.api.model.ClusterFeature.class)
public static org.ovirt.engine.api.model.ClusterFeature map(AdditionalFeature entity, org.ovirt.engine.api.model.ClusterFeature template) {
    org.ovirt.engine.api.model.ClusterFeature model = template != null ? template : new org.ovirt.engine.api.model.ClusterFeature();
    model.setName(entity.getName());
    model.setId(entity.getId().toString());
    return model;
}
#end_block

#method_before
@Override
public ClusterEnabledFeaturesResource getEnabledFeaturesResource() {
    return inject(new BackendClusterEnabledFeaturesResource(this, id));
}
#method_after
@Override
public ClusterEnabledFeaturesResource getEnabledFeaturesResource() {
    return inject(new BackendClusterEnabledFeaturesResource(guid));
}
#end_block

#method_before
@Override
public ClusterFeature get() {
    Cluster cluster = parent.getClusterEntity();
    for (SupportedAdditionalClusterFeature feature : cluster.getAddtionalFeaturesSupported()) {
        if (feature.getFeature().getId().equals(asGuid(id))) {
            return ClusterFeaturesMapper.map(feature.getFeature(), null);
        }
    }
    throw new WebApplicationException(Response.Status.NOT_FOUND);
}
#method_after
@Override
public ClusterFeature get() {
    SupportedAdditionalClusterFeature feature = BackendClusterFeatureHelper.getEnabledFeature(this, clusterId, guid);
    if (feature != null) {
        return addLinks(ClusterFeaturesMapper.map(feature.getFeature(), null));
    } else {
        throw new WebApplicationException(Response.Status.NOT_FOUND);
    }
}
#end_block

#method_before
@Override
public Response remove() {
    Cluster cluster = parent.getClusterEntity();
    for (SupportedAdditionalClusterFeature feature : cluster.getAddtionalFeaturesSupported()) {
        if (feature.getFeature().getId().equals(asGuid(id))) {
            feature.setEnabled(false);
        }
    }
    return parent.updateClusterEntity(cluster);
}
#method_after
@Override
public Response remove() {
    Cluster cluster = BackendClusterFeatureHelper.getClusterWithFeatureDisabled(this, clusterId, guid);
    ManagementNetworkOnClusterOperationParameters param = new ManagementNetworkOnClusterOperationParameters(cluster);
    return performAction(ActionType.UpdateCluster, param);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    getPlugged().setIsChangeable(false);
    setNetworkFilterParameterWidgetVisible(false);
}
#method_after
@Override
protected void init() {
    super.init();
    getPlugged().setIsChangeable(false);
    getNetworkFilterParameterListModel().setIsAvailable(false);
}
#end_block

#method_before
@Override
public boolean isEnabled() {
    return enabled;
}
#method_after
@Override
public boolean isEnabled() {
    return nameEditor.isEnabled();
}
#end_block

#method_before
@Override
public void setEnabled(boolean enabled) {
    this.enabled = enabled;
    nameEditor.setEnabled(enabled);
    valueEditor.setEnabled(enabled);
}
#method_after
@Override
public void setEnabled(boolean enabled) {
    nameEditor.setEnabled(enabled);
    valueEditor.setEnabled(enabled);
}
#end_block

#method_before
@Override
public void edit(final VmInterfaceModel iface) {
    driver.edit(iface);
    networkFilterParameterWidget.edit(iface.getNetworkFilterParameterListModel());
    networkFilterParameterWidget.setEnabled(iface.isNetworkFilterParameterWidgetVisible());
    networkFilterParameterWidget.setVisible(iface.isNetworkFilterParameterWidgetVisible());
    hideMacWhenNotEnabled(iface);
    iface.getMAC().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            hideMacWhenNotEnabled(iface);
        }
    });
}
#method_after
@Override
public void edit(final VmInterfaceModel iface) {
    driver.edit(iface);
    networkFilterParameterWidget.edit(iface.getNetworkFilterParameterListModel());
    networkFilterParameterWidget.setEnabled(iface.getNetworkFilterParameterListModel().getIsAvailable());
    networkFilterParameterWidget.setVisible(iface.getNetworkFilterParameterListModel().getIsAvailable());
    hideMacWhenNotEnabled(iface);
    iface.getMAC().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            hideMacWhenNotEnabled(iface);
        }
    });
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (sender == getMAC()) {
        mAC_PropertyChanged((PropertyChangedEventArgs) args);
    } else if (sender == getPlugged()) {
        PropertyChangedEventArgs propArgs = (PropertyChangedEventArgs) args;
        if (propArgs.propertyName.equals("Entity")) {
            // $NON-NLS-1$
            boolean plugged = getPlugged().getEntity();
            getPlugged_IsSelected().setEntity(plugged);
            getUnplugged_IsSelected().setEntity(!plugged);
        } else if (propArgs.propertyName.equals("IsChangable")) {
            // $NON-NLS-1$
            boolean isPlugChangeable = getPlugged().getIsChangable();
            getPlugged_IsSelected().setChangeProhibitionReason(getLinked().getChangeProhibitionReason());
            getPlugged_IsSelected().setIsChangeable(isPlugChangeable);
            getUnplugged_IsSelected().setChangeProhibitionReason(getLinked().getChangeProhibitionReason());
            getUnplugged_IsSelected().setIsChangeable(isPlugChangeable);
        } else if (propArgs.propertyName.equals("IsAvailable")) {
            // $NON-NLS-1$
            boolean isPlugAvailable = getPlugged().getIsAvailable();
            getPlugged_IsSelected().setIsAvailable(isPlugAvailable);
            getUnplugged_IsSelected().setIsAvailable(isPlugAvailable);
        }
    } else if (sender == getPlugged_IsSelected()) {
        if (getPlugged_IsSelected().getEntity()) {
            getPlugged().setEntity(true);
        }
    } else if (sender == getUnplugged_IsSelected()) {
        if (getUnplugged_IsSelected().getEntity()) {
            getPlugged().setEntity(false);
        }
    } else if (sender == getLinked()) {
        PropertyChangedEventArgs propArgs = (PropertyChangedEventArgs) args;
        if (propArgs.propertyName.equals("Entity")) {
            // $NON-NLS-1$
            boolean linked = getLinked().getEntity();
            getLinked_IsSelected().setEntity(linked);
            getUnlinked_IsSelected().setEntity(!linked);
        } else if (propArgs.propertyName.equals("IsChangable")) {
            // $NON-NLS-1$
            boolean isLinkedChangeable = getLinked().getIsChangable();
            getLinked_IsSelected().setChangeProhibitionReason(getLinked().getChangeProhibitionReason());
            getLinked_IsSelected().setIsChangeable(isLinkedChangeable);
            getUnlinked_IsSelected().setChangeProhibitionReason(getLinked().getChangeProhibitionReason());
            getUnlinked_IsSelected().setIsChangeable(isLinkedChangeable);
        } else if (propArgs.propertyName.equals("IsAvailable")) {
            // $NON-NLS-1$
            boolean isLinkedAvailable = getLinked().getIsAvailable();
            getLinked_IsSelected().setIsAvailable(isLinkedAvailable);
            getUnlinked_IsSelected().setIsAvailable(isLinkedAvailable);
        }
    } else if (sender == getLinked_IsSelected()) {
        if (getLinked_IsSelected().getEntity()) {
            getLinked().setEntity(true);
        }
    } else if (sender == getUnlinked_IsSelected()) {
        if (getUnlinked_IsSelected().getEntity()) {
            getLinked().setEntity(false);
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (sender == getMAC()) {
        mAC_PropertyChanged((PropertyChangedEventArgs) args);
    } else if (sender == getPlugged()) {
        PropertyChangedEventArgs propArgs = (PropertyChangedEventArgs) args;
        if (propArgs.propertyName.equals("Entity")) {
            // $NON-NLS-1$
            boolean plugged = getPlugged().getEntity();
            getPlugged_IsSelected().setEntity(plugged);
            getUnplugged_IsSelected().setEntity(!plugged);
        } else if (propArgs.propertyName.equals("IsChangable")) {
            // $NON-NLS-1$
            boolean isPlugChangeable = getPlugged().getIsChangable();
            getPlugged_IsSelected().setIsChangeable(isPlugChangeable);
            getPlugged_IsSelected().setChangeProhibitionReason(getLinked().getChangeProhibitionReason());
            getUnplugged_IsSelected().setIsChangeable(isPlugChangeable);
            getUnplugged_IsSelected().setChangeProhibitionReason(getLinked().getChangeProhibitionReason());
        } else if (propArgs.propertyName.equals("IsAvailable")) {
            // $NON-NLS-1$
            boolean isPlugAvailable = getPlugged().getIsAvailable();
            getPlugged_IsSelected().setIsAvailable(isPlugAvailable);
            getUnplugged_IsSelected().setIsAvailable(isPlugAvailable);
        }
    } else if (sender == getPlugged_IsSelected()) {
        if (getPlugged_IsSelected().getEntity()) {
            getPlugged().setEntity(true);
        }
    } else if (sender == getUnplugged_IsSelected()) {
        if (getUnplugged_IsSelected().getEntity()) {
            getPlugged().setEntity(false);
        }
    } else if (sender == getLinked()) {
        PropertyChangedEventArgs propArgs = (PropertyChangedEventArgs) args;
        if (propArgs.propertyName.equals("Entity")) {
            // $NON-NLS-1$
            boolean linked = getLinked().getEntity();
            getLinked_IsSelected().setEntity(linked);
            getUnlinked_IsSelected().setEntity(!linked);
        } else if (propArgs.propertyName.equals("IsChangable")) {
            // $NON-NLS-1$
            boolean isLinkedChangeable = getLinked().getIsChangable();
            getLinked_IsSelected().setIsChangeable(isLinkedChangeable);
            getLinked_IsSelected().setChangeProhibitionReason(getLinked().getChangeProhibitionReason());
            getUnlinked_IsSelected().setIsChangeable(isLinkedChangeable);
            getUnlinked_IsSelected().setChangeProhibitionReason(getLinked().getChangeProhibitionReason());
        } else if (propArgs.propertyName.equals("IsAvailable")) {
            // $NON-NLS-1$
            boolean isLinkedAvailable = getLinked().getIsAvailable();
            getLinked_IsSelected().setIsAvailable(isLinkedAvailable);
            getUnlinked_IsSelected().setIsAvailable(isLinkedAvailable);
        }
    } else if (sender == getLinked_IsSelected()) {
        if (getLinked_IsSelected().getEntity()) {
            getLinked().setEntity(true);
        }
    } else if (sender == getUnlinked_IsSelected()) {
        if (getUnlinked_IsSelected().getEntity()) {
            getLinked().setEntity(false);
        }
    }
}
#end_block

#method_before
protected void onSave() {
    VmNetworkInterface nic = createBaseNic();
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    nic.setName(getName().getEntity());
    VnicProfileView profile = getProfile().getSelectedItem();
    nic.setVnicProfileId(profile.getId());
    nic.setNetworkName(profile.getNetworkName());
    nic.setLinked(getLinked().getEntity());
    if (getNicType().getSelectedItem() == null) {
        nic.setType(null);
    } else {
        nic.setType(getNicType().getSelectedItem().getValue());
    }
    onSaveMAC(nic);
    nic.setPlugged(getPlugged().getEntity());
    startProgress();
    saveSuceeded = false;
    Frontend.getInstance().runAction(getActionType(), createVdcActionParameters(nic), result -> {
        VdcReturnValueBase returnValue = result.getReturnValue();
        if (returnValue != null && returnValue.getSucceeded()) {
            Object actionReturnValue = returnValue.getActionReturnValue();
            saveSuceeded = true;
            if (actionReturnValue != null && actionReturnValue instanceof Guid) {
                saveNicFilterParameters((Guid) actionReturnValue);
            } else {
                postOnSave();
            }
        }
    }, this);
}
#method_after
protected void onSave() {
    VmNetworkInterface nic = createBaseNic();
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    nic.setName(getName().getEntity());
    VnicProfileView profile = getProfile().getSelectedItem();
    nic.setVnicProfileId(profile.getId());
    nic.setNetworkName(profile.getNetworkName());
    nic.setLinked(getLinked().getEntity());
    if (getNicType().getSelectedItem() == null) {
        nic.setType(null);
    } else {
        nic.setType(getNicType().getSelectedItem().getValue());
    }
    onSaveMAC(nic);
    nic.setPlugged(getPlugged().getEntity());
    startProgress();
    Frontend.getInstance().runAction(getActionType(), createVdcActionParameters(nic), result -> {
        ActionReturnValue returnValue = result.getReturnValue();
        stopProgress();
        if (returnValue != null && returnValue.getSucceeded()) {
            cancel();
            postOnSave();
        }
    }, this);
}
#end_block

#method_before
protected void postOnSave() {
    stopProgress();
    if (saveSuceeded) {
        cancel();
    }
}
#method_after
protected void postOnSave() {
// Do nothing
}
#end_block

#method_before
private void postNicInit() {
    getName().setEntity(getNic().getName());
    initMAC();
    initLinked();
    initNetworkFilterParameters(new AsyncQuery<>(returnValue -> {
        if (returnValue != null) {
            getNetworkFilterParameterListModel().setItems(returnValue);
        }
    }));
    initProfiles();
    // Plug should be the last one updated, cause it controls the changeability of the other editor
    getPlugged().setEntity(getNic().isPlugged());
    if (!allowPlug()) {
        getPlugged().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().nicHotPlugNotSupported(getClusterCompatibilityVersion().toString()));
    }
    getPlugged().setIsChangeable(allowPlug());
    initCommands();
}
#method_after
private void postNicInit() {
    getName().setEntity(getNic().getName());
    initMAC();
    initLinked();
    initNetworkFilterParameters(new AsyncQuery<>(returnValue -> {
        getNetworkFilterParameterListModel().setItems(returnValue);
    }));
    initProfiles();
    // Plug should be the last one updated, cause it controls the changeability of the other editor
    getPlugged().setEntity(getNic().isPlugged());
    if (!allowPlug()) {
        getPlugged().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().nicHotPlugNotSupported(getClusterCompatibilityVersion().toString()));
    }
    getPlugged().setIsChangeable(allowPlug());
    initCommands();
}
#end_block

#method_before
@Override
protected ActionParametersBase createVdcActionParameters(VmNetworkInterface nicToSave) {
    return new AddVmInterfaceParameters(getVm().getId(), nicToSave);
}
#method_after
@Override
protected ActionParametersBase createVdcActionParameters(VmNetworkInterface nicToSave) {
    AddVmInterfaceParameters parameters = new AddVmInterfaceParameters(getVm().getId(), nicToSave);
    parameters.setFilterParameters(getNetworkFilterParameterListModel().getItems().stream().map(x -> x.flush()).collect(Collectors.toList()));
    return parameters;
}
#end_block

#method_before
public VmNicFilterParameter flush() {
    getEntity().setName(name.getEntity());
    getEntity().setValue(value.getEntity());
    return getEntity();
}
#method_after
public VmNicFilterParameter flush() {
    getEntity().setName(name.getEntity());
    getEntity().setValue(value.getEntity());
    if (getEntity().getVmInterfaceId() == null) {
        getEntity().setVmInterfaceId(Guid.Empty);
    }
    return getEntity();
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    getPlugged().setIsChangeable(false);
    setNetworkFilterParameterWidgetVisible(false);
}
#method_after
@Override
protected void init() {
    super.init();
    getPlugged().setIsChangeable(false);
    getNetworkFilterParameterListModel().setIsAvailable(false);
}
#end_block

#method_before
@Override
protected void init() {
    setNetworkFilterParameterWidgetVisible(true);
    super.init();
}
#method_after
@Override
protected void init() {
    getNetworkFilterParameterListModel().setIsAvailable(true);
    super.init();
}
#end_block

#method_before
@Override
protected void init() {
    setNetworkFilterParameterWidgetVisible(true);
    AsyncDataProvider.getInstance().getNicTypeList(getVm().getOsId(), getClusterCompatibilityVersion(), new AsyncQuery<>(returnValue -> {
        setSupportedVnicTypes(returnValue);
        postNicInit();
    }));
}
#method_after
@Override
protected void init() {
    getNetworkFilterParameterListModel().setIsAvailable(true);
    AsyncDataProvider.getInstance().getNicTypeList(getVm().getOsId(), getClusterCompatibilityVersion(), new AsyncQuery<>(returnValue -> {
        setSupportedVnicTypes(returnValue);
        postNicInit();
    }));
}
#end_block

#method_before
@Override
protected ActionParametersBase createVdcActionParameters(VmNetworkInterface nicToSave) {
    return new AddVmInterfaceParameters(getVm().getId(), nicToSave);
}
#method_after
@Override
protected ActionParametersBase createVdcActionParameters(VmNetworkInterface nicToSave) {
    AddVmInterfaceParameters parameters = new AddVmInterfaceParameters(getVm().getId(), nicToSave);
    parameters.setFilterParameters(getNetworkFilterParameterListModel().getItems().stream().map(x -> x.flush()).collect(Collectors.toList()));
    return parameters;
}
#end_block

#method_before
private String renderPortMirroring(boolean portMirroring) {
    if (portMirroring) {
        return constants.yes();
    } else {
        return constants.no();
    }
}
#method_after
private String renderPortMirroring(boolean portMirroring) {
    if (portMirroring) {
        return constants.portMirroringEnabled();
    } else {
        return constants.portMirroringDisabled();
    }
}
#end_block

#method_before
private Container createStatisticsItemContainerPanel(VmNetworkInterface networkInterface) {
    Row content = new Row();
    Column column = new Column(ColumnSize.MD_12);
    content.add(column);
    RxTxRateRenderer rateRenderer = new RxTxRateRenderer();
    DListElement dl = Document.get().createDLElement();
    dl.addClassName(DL_HORIZONTAL);
    addDetailItem(templates.sub(constants.rxRate(), constants.mbps()), rateRenderer.render(new Double[] { networkInterface.getStatistics().getReceiveRate(), networkInterface.getSpeed().doubleValue() }), dl);
    addDetailItem(templates.sub(constants.txRate(), constants.mbps()), rateRenderer.render(new Double[] { networkInterface.getStatistics().getTransmitRate(), networkInterface.getSpeed().doubleValue() }), dl);
    addDetailItem(templates.sub(constants.rxTotal(), constants.mbps()), networkInterface.getStatistics().getReceivedBytes() != null ? String.valueOf(networkInterface.getStatistics().getReceivedBytes()) : constants.notAvailableLabel(), dl);
    addDetailItem(templates.sub(constants.txTotal(), constants.mbps()), networkInterface.getStatistics().getTransmittedBytes() != null ? String.valueOf(networkInterface.getStatistics().getTransmittedBytes()) : constants.notAvailableLabel(), dl);
    addDetailItem(templates.sub(constants.dropsInterface(), constants.pkts()), String.valueOf(networkInterface.getStatistics().getReceiveDropRate() + networkInterface.getStatistics().getTransmitDropRate()), dl);
    column.getElement().appendChild(dl);
    return createItemContainerPanel(content);
}
#method_after
private Container createStatisticsItemContainerPanel(VmNetworkInterface networkInterface) {
    Row content = new Row();
    Column column = new Column(ColumnSize.MD_12);
    content.add(column);
    RxTxRateRenderer rateRenderer = new RxTxRateRenderer();
    DListElement dl = Document.get().createDLElement();
    dl.addClassName(DL_HORIZONTAL);
    addDetailItem(templates.sub(constants.rxRate(), constants.mbps()), rateRenderer.render(new Double[] { networkInterface.getStatistics().getReceiveRate(), networkInterface.hasSpeed() ? networkInterface.getSpeed().doubleValue() : 0 }), dl);
    addDetailItem(templates.sub(constants.txRate(), constants.mbps()), rateRenderer.render(new Double[] { networkInterface.getStatistics().getTransmitRate(), networkInterface.hasSpeed() ? networkInterface.getSpeed().doubleValue() : 0 }), dl);
    addDetailItem(templates.sub(constants.rxTotal(), constants.mbps()), networkInterface.getStatistics().getReceivedBytes() != null ? String.valueOf(networkInterface.getStatistics().getReceivedBytes()) : constants.notAvailableLabel(), dl);
    addDetailItem(templates.sub(constants.txTotal(), constants.mbps()), networkInterface.getStatistics().getTransmittedBytes() != null ? String.valueOf(networkInterface.getStatistics().getTransmittedBytes()) : constants.notAvailableLabel(), dl);
    addDetailItem(templates.sub(constants.dropsInterface(), constants.pkts()), String.valueOf(networkInterface.getStatistics().getReceiveDropRate() + networkInterface.getStatistics().getTransmitDropRate()), dl);
    column.getElement().appendChild(dl);
    return createItemContainerPanel(content);
}
#end_block

#method_before
private IsWidget createLinkStatusPanel(boolean isLinked) {
    IconStatusPanel iconStatusPanel = new IconStatusPanel(isLinked ? IconType.ARROW_CIRCLE_O_UP : IconType.ARROW_CIRCLE_O_DOWN);
    iconStatusPanel.addStyleName(DOUBLE_SIZE);
    iconStatusPanel.getElement().getStyle().setColor(isLinked ? GREEN : RED);
    return iconStatusPanel;
}
#method_after
private IsWidget createLinkStatusPanel(boolean isLinked) {
    IconStatusPanel iconStatusPanel = new IconStatusPanel(isLinked ? IconType.ARROW_CIRCLE_O_UP : IconType.ARROW_CIRCLE_O_DOWN);
    iconStatusPanel.addStyleName(DOUBLE_SIZE);
    iconStatusPanel.getElement().getStyle().setColor(isLinked ? GREEN : RED);
    String tooltipText = isLinked ? constants.linkedNetworkInterface() : constants.unlinkedNetworkInterface();
    WidgetTooltip tooltip = new WidgetTooltip(iconStatusPanel);
    tooltip.setHtml(SafeHtmlUtils.fromString(tooltipText));
    return tooltip;
}
#end_block

#method_before
private IsWidget createCardPluggedStatusPanel(boolean isPlugged) {
    Span linkStatusPanel = new Span();
    Span icon = new Span();
    icon.addStyleName(Styles.ICON_STACK);
    Italic plugItalic = new Italic();
    plugItalic.addStyleName(Styles.FONT_AWESOME_BASE);
    plugItalic.addStyleName(Styles.ICON_STACK_TOP);
    plugItalic.addStyleName(ROTATE_270);
    plugItalic.addStyleName(IconType.PLUG.getCssName());
    icon.add(plugItalic);
    if (!isPlugged) {
        Italic unplugged = new Italic();
        unplugged.addStyleName(Styles.FONT_AWESOME_BASE);
        unplugged.addStyleName(Styles.ICON_STACK_TOP);
        unplugged.addStyleName(DANGER);
        unplugged.addStyleName(IconType.BAN.getCssName());
        icon.add(unplugged);
    }
    linkStatusPanel.add(icon);
    linkStatusPanel.addStyleName(DOUBLE_SIZE);
    return linkStatusPanel;
}
#method_after
private IsWidget createCardPluggedStatusPanel(boolean isPlugged) {
    Span linkStatusPanel = new Span();
    Span icon = new Span();
    icon.addStyleName(Styles.ICON_STACK);
    Italic plugItalic = new Italic();
    plugItalic.addStyleName(Styles.FONT_AWESOME_BASE);
    plugItalic.addStyleName(Styles.ICON_STACK_TOP);
    plugItalic.addStyleName(ROTATE_270);
    plugItalic.addStyleName(IconType.PLUG.getCssName());
    icon.add(plugItalic);
    if (!isPlugged) {
        Italic unplugged = new Italic();
        unplugged.addStyleName(Styles.FONT_AWESOME_BASE);
        unplugged.addStyleName(Styles.ICON_STACK_TOP);
        unplugged.addStyleName(DANGER);
        unplugged.addStyleName(IconType.BAN.getCssName());
        icon.add(unplugged);
    }
    linkStatusPanel.add(icon);
    linkStatusPanel.addStyleName(DOUBLE_SIZE);
    String tooltipText = isPlugged ? constants.pluggedNetworkInterface() : constants.unpluggedNetworkInterface();
    WidgetTooltip tooltip = new WidgetTooltip(linkStatusPanel);
    tooltip.setHtml(SafeHtmlUtils.fromString(tooltipText));
    return tooltip;
}
#end_block

#method_before
public void addMainContentView(String label, String historyToken, String contentUrl, int priority) {
    menuPresenterWidget.addMenuItem(priority, label, historyToken);
    // Not interested in the actual proxy, it will register itself.
    new DynamicUrlContentProxy(historyToken, contentUrl, gatekeeper, placeManager, eventBus, MainContentPresenter.TYPE_SetContent);
}
#method_after
public void addMainContentView(String label, String historyToken, String contentUrl, int priority) {
    menuPresenterWidget.addMenuItem(priority, label, historyToken);
    // Not interested in the actual proxy, it will register itself.
    dynamicUrlContentProxyFactory.create(historyToken, contentUrl);
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Menu
    bindSingletonPresenterWidget(MenuPresenterWidget.class, MenuPresenterWidget.ViewDef.class, MenuView.class);
    bind(MenuDetailsProvider.class).to(MenuView.class).in(Singleton.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    bindPresenterWidget(AffinityLabelPopupPresenterWidget.class, AffinityLabelPopupPresenterWidget.ViewDef.class, AffinityLabelPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQosPresenter.class, SubTabDataCenterQosPresenter.ViewDef.class, SubTabDataCenterQosView.class, SubTabDataCenterQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelView<DataCenterListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StoragePool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StoragePool, DataCenterListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StoragePool>>() {
    }, new TypeLiteral<ActionPanelView<StoragePool>>() {
    });
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDRPresenter.class, SubTabStorageDRPresenter.ViewDef.class, SubTabStorageDRView.class, SubTabStorageDRPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageLeasePresenter.class, SubTabStorageLeasePresenter.ViewDef.class, SubTabStorageLeaseView.class, SubTabStorageLeasePresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<StorageListModel>>() {
    }, new TypeLiteral<SearchPanelView<StorageListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StorageDomain>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StorageDomain, StorageListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDomain>>() {
    }, new TypeLiteral<ActionPanelView<StorageDomain>>() {
    });
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    bindPresenter(SubTabClusterAffinityLabelPresenter.class, SubTabClusterAffinityLabelPresenter.ViewDef.class, SubTabClusterAffinityLabelView.class, SubTabClusterAffinityLabelPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<ClusterListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Cluster>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Cluster, ClusterListModel<Void>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Cluster>>() {
    }, new TypeLiteral<ActionPanelView<Cluster>>() {
    });
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPresenter.class, HostGeneralSubTabPresenter.ViewDef.class, HostGeneralSubTabView.class, HostGeneralSubTabPresenter.ProxyDef.class);
    bindPresenter(SubTabHostErrataPresenter.class, SubTabHostErrataPresenter.ViewDef.class, SubTabHostErrataView.class, SubTabHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<HostListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VDS>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VDS, HostListModel<Void>>>() {
    });
    bindPresenter(SubTabHostAffinityLabelPresenter.class, SubTabHostAffinityLabelPresenter.ViewDef.class, SubTabHostAffinityLabelView.class, SubTabHostAffinityLabelPresenter.ProxyDef.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VDS>>() {
    }, new TypeLiteral<ActionPanelView<VDS>>() {
    });
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<VmListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VM>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VM, VmListModel<Void>>>() {
    });
    bindPresenter(SubTabVirtualMachineAffinityLabelPresenter.class, SubTabVirtualMachineAffinityLabelPresenter.ViewDef.class, SubTabVirtualMachineAffinityLabelView.class, SubTabVirtualMachineAffinityLabelPresenter.ProxyDef.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VM>>() {
    }, new TypeLiteral<ActionPanelView<VM>>() {
    });
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<PoolListModel>>() {
    }, new TypeLiteral<SearchPanelView<PoolListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VmPool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VmPool, PoolListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmPool>>() {
    }, new TypeLiteral<ActionPanelView<VmPool>>() {
    });
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmTemplate, TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelView<TemplateListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VmTemplate, TemplateListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VmTemplate>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VmTemplate, TemplateListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmTemplate>>() {
    }, new TypeLiteral<ActionPanelView<VmTemplate>>() {
    });
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<UserListModel>>() {
    }, new TypeLiteral<SearchPanelView<UserListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<DbUser>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<DbUser, UserListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DbUser>>() {
    }, new TypeLiteral<ActionPanelView<DbUser>>() {
    });
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Quota, QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelView<QuotaListModel>>() {
    });
    bindPresenterWidget(QuotaBreadCrumbsPresenterWidget.class, QuotaBreadCrumbsPresenterWidget.QuotaBreadCrumbsViewDef.class, QuotaBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Quota>>() {
    }, new TypeLiteral<ActionPanelView<Quota>>() {
    });
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DiskListModel>>() {
    }, new TypeLiteral<SearchPanelView<DiskListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Disk>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Disk, DiskListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Disk>>() {
    }, new TypeLiteral<ActionPanelView<Disk>>() {
    });
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<NetworkView, NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelView<NetworkListModel>>() {
    });
    bindPresenterWidget(NetworkBreadCrumbsPresenterWidget.class, NetworkBreadCrumbsPresenterWidget.NetworkBreadCrumbsViewDef.class, NetworkBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkView>>() {
    }, new TypeLiteral<ActionPanelView<NetworkView>>() {
    });
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelView<ProviderListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Provider>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Provider, ProviderListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Provider>>() {
    }, new TypeLiteral<ActionPanelView<Provider>>() {
    });
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Erratum, EngineErrataListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Erratum>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Erratum, EngineErrataListModel>>() {
    });
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    bindPresenterWidget(VnicProfileBreadCrumbsPresenterWidget.class, VnicProfileBreadCrumbsPresenterWidget.VnicProfileBreadCrumbsViewDef.class, VnicProfileBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VnicProfileView>>() {
    }, new TypeLiteral<ActionPanelView<VnicProfileView>>() {
    });
    // User Sessions
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<SessionListModel>>() {
    }, new TypeLiteral<SearchPanelView<SessionListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<UserSession>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<UserSession, SessionListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<UserSession>>() {
    }, new TypeLiteral<ActionPanelView<UserSession>>() {
    });
    // Volume
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelView<VolumeListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<GlusterVolumeEntity>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<GlusterVolumeEntity, VolumeListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeEntity>>() {
    });
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    bindPresenterWidget(HostMaintenanceConfirmationPopupPresenterWidget.class, HostMaintenanceConfirmationPopupPresenterWidget.ViewDef.class, HostMaintenanceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(VnicProfileMappingPopupPresenterWidget.class, VnicProfileMappingPopupPresenterWidget.ViewDef.class, VnicProfileMappingPopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    bindPresenterWidget(StorageDRPopupPresenterWidget.class, StorageDRPopupPresenterWidget.ViewDef.class, StorageDRPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // VM Sparsify Disk
    bindPresenterWidget(VmDiskSparsifyPopupPresenterWidget.class, VmDiskSparsifyPopupPresenterWidget.ViewDef.class, VmDiskSparsifyPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(StorageQosRemovePopupPresenterWidget.class, StorageQosRemovePopupPresenterWidget.ViewDef.class, StorageQosRemovePopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<EventListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<AuditLog>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<AuditLog, EventListModel<Void>>>() {
    });
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
    bindPresenterWidget(ExpandAllButtonPresenterWidget.class, ExpandAllButtonPresenterWidget.ViewDef.class, ExpandAllButtonView.class);
    // Overlays
    // Tasks
    bindPresenter(TasksPresenter.class, TasksPresenter.ViewDef.class, TasksView.class, TasksPresenter.ProxyDef.class);
    // Bookmarks
    bindPresenter(BookmarkPresenter.class, BookmarkPresenter.ViewDef.class, BookmarkView.class, BookmarkPresenter.ProxyDef.class);
    // Tags
    bindPresenter(TagsPresenter.class, TagsPresenter.ViewDef.class, TagsView.class, TagsPresenter.ProxyDef.class);
    // Popup/detail Action panels
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Label>>() {
    }, new TypeLiteral<ActionPanelView<Label>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterHookEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterHookEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Network>>() {
    }, new TypeLiteral<ActionPanelView<Network>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<IscsiBond>>() {
    }, new TypeLiteral<ActionPanelView<IscsiBond>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterBrickEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterBrickEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeOptionEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeOptionEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDevice>>() {
    }, new TypeLiteral<ActionPanelView<StorageDevice>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeSnapshotEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeSnapshotEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterServerService>>() {
    }, new TypeLiteral<ActionPanelView<GlusterServerService>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkCluster>>() {
    }, new TypeLiteral<ActionPanelView<NetworkCluster>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<ExternalSubnet>>() {
    }, new TypeLiteral<ActionPanelView<ExternalSubnet>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<LibvirtSecret>>() {
    }, new TypeLiteral<ActionPanelView<LibvirtSecret>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Permission>>() {
    }, new TypeLiteral<ActionPanelView<Permission>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterGeoRepSession>>() {
    }, new TypeLiteral<ActionPanelView<GlusterGeoRepSession>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<Cluster, NetworkCluster>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<Cluster, NetworkCluster>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<VdsNetworkInterface, VDS>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<VdsNetworkInterface, VDS>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<VmNetworkInterface, VM>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<VmNetworkInterface, VM>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<VmNetworkInterface, VmTemplate>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<VmNetworkInterface, VmTemplate>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDomainDR>>() {
    }, new TypeLiteral<ActionPanelView<StorageDomainDR>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<RepoImage>>() {
    }, new TypeLiteral<ActionPanelView<RepoImage>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DiskModel>>() {
    }, new TypeLiteral<ActionPanelView<DiskModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<EventSubscriber>>() {
    }, new TypeLiteral<ActionPanelView<EventSubscriber>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<AffinityGroup>>() {
    }, new TypeLiteral<ActionPanelView<AffinityGroup>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<MacPool>>() {
    }, new TypeLiteral<ActionPanelView<MacPool>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Role>>() {
    }, new TypeLiteral<ActionPanelView<Role>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<ClusterPolicy>>() {
    }, new TypeLiteral<ActionPanelView<ClusterPolicy>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<InstanceType>>() {
    }, new TypeLiteral<ActionPanelView<InstanceType>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<CpuQos>>() {
    }, new TypeLiteral<ActionPanelView<CpuQos>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkQoS>>() {
    }, new TypeLiteral<ActionPanelView<NetworkQoS>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostNetworkQos>>() {
    }, new TypeLiteral<ActionPanelView<HostNetworkQos>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DiskProfile>>() {
    }, new TypeLiteral<ActionPanelView<DiskProfile>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<CpuProfile>>() {
    }, new TypeLiteral<ActionPanelView<CpuProfile>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmNetworkInterface>>() {
    }, new TypeLiteral<ActionPanelView<VmNetworkInterface>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Snapshot>>() {
    }, new TypeLiteral<ActionPanelView<Snapshot>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostDeviceView>>() {
    }, new TypeLiteral<ActionPanelView<HostDeviceView>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostInterfaceLineModel>>() {
    }, new TypeLiteral<ActionPanelView<HostInterfaceLineModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageQos>>() {
    }, new TypeLiteral<ActionPanelView<StorageQos>>() {
    });
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Menu
    bindSingletonPresenterWidget(MenuPresenterWidget.class, MenuPresenterWidget.ViewDef.class, MenuView.class);
    bind(MenuDetailsProvider.class).to(MenuPresenterWidget.class).in(Singleton.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    bindPresenterWidget(AffinityLabelPopupPresenterWidget.class, AffinityLabelPopupPresenterWidget.ViewDef.class, AffinityLabelPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQosPresenter.class, SubTabDataCenterQosPresenter.ViewDef.class, SubTabDataCenterQosView.class, SubTabDataCenterQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DataCenterListModel>>() {
    }, new TypeLiteral<SearchPanelView<DataCenterListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StoragePool, DataCenterListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StoragePool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StoragePool, DataCenterListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StoragePool>>() {
    }, new TypeLiteral<ActionPanelView<StoragePool>>() {
    });
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDRPresenter.class, SubTabStorageDRPresenter.ViewDef.class, SubTabStorageDRView.class, SubTabStorageDRPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageLeasePresenter.class, SubTabStorageLeasePresenter.ViewDef.class, SubTabStorageLeaseView.class, SubTabStorageLeasePresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<StorageListModel>>() {
    }, new TypeLiteral<SearchPanelView<StorageListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<StorageDomain, StorageListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<StorageDomain>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<StorageDomain, StorageListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDomain>>() {
    }, new TypeLiteral<ActionPanelView<StorageDomain>>() {
    });
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    bindPresenter(SubTabClusterAffinityLabelPresenter.class, SubTabClusterAffinityLabelPresenter.ViewDef.class, SubTabClusterAffinityLabelView.class, SubTabClusterAffinityLabelPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ClusterListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<ClusterListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Cluster, ClusterListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Cluster>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Cluster, ClusterListModel<Void>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Cluster>>() {
    }, new TypeLiteral<ActionPanelView<Cluster>>() {
    });
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPresenter.class, HostGeneralSubTabPresenter.ViewDef.class, HostGeneralSubTabView.class, HostGeneralSubTabPresenter.ProxyDef.class);
    bindPresenter(SubTabHostErrataPresenter.class, SubTabHostErrataPresenter.ViewDef.class, SubTabHostErrataView.class, SubTabHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<HostListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<HostListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VDS, HostListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VDS>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VDS, HostListModel<Void>>>() {
    });
    bindPresenter(SubTabHostAffinityLabelPresenter.class, SubTabHostAffinityLabelPresenter.ViewDef.class, SubTabHostAffinityLabelView.class, SubTabHostAffinityLabelPresenter.ProxyDef.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VDS>>() {
    }, new TypeLiteral<ActionPanelView<VDS>>() {
    });
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VmListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<VmListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VM, VmListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VM>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VM, VmListModel<Void>>>() {
    });
    bindPresenter(SubTabVirtualMachineAffinityLabelPresenter.class, SubTabVirtualMachineAffinityLabelPresenter.ViewDef.class, SubTabVirtualMachineAffinityLabelView.class, SubTabVirtualMachineAffinityLabelPresenter.ProxyDef.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VM>>() {
    }, new TypeLiteral<ActionPanelView<VM>>() {
    });
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<PoolListModel>>() {
    }, new TypeLiteral<SearchPanelView<PoolListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VmPool, PoolListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VmPool>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VmPool, PoolListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmPool>>() {
    }, new TypeLiteral<ActionPanelView<VmPool>>() {
    });
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<VmTemplate, TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<TemplateListModel>>() {
    }, new TypeLiteral<SearchPanelView<TemplateListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<VmTemplate, TemplateListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<VmTemplate>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<VmTemplate, TemplateListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmTemplate>>() {
    }, new TypeLiteral<ActionPanelView<VmTemplate>>() {
    });
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<UserListModel>>() {
    }, new TypeLiteral<SearchPanelView<UserListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<DbUser, UserListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<DbUser>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<DbUser, UserListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DbUser>>() {
    }, new TypeLiteral<ActionPanelView<DbUser>>() {
    });
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Quota, QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<QuotaListModel>>() {
    }, new TypeLiteral<SearchPanelView<QuotaListModel>>() {
    });
    bindPresenterWidget(QuotaBreadCrumbsPresenterWidget.class, QuotaBreadCrumbsPresenterWidget.QuotaBreadCrumbsViewDef.class, QuotaBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Quota>>() {
    }, new TypeLiteral<ActionPanelView<Quota>>() {
    });
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<DiskListModel>>() {
    }, new TypeLiteral<SearchPanelView<DiskListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Disk, DiskListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Disk>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Disk, DiskListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Disk>>() {
    }, new TypeLiteral<ActionPanelView<Disk>>() {
    });
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<NetworkView, NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<NetworkListModel>>() {
    }, new TypeLiteral<SearchPanelView<NetworkListModel>>() {
    });
    bindPresenterWidget(NetworkBreadCrumbsPresenterWidget.class, NetworkBreadCrumbsPresenterWidget.NetworkBreadCrumbsViewDef.class, NetworkBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkView>>() {
    }, new TypeLiteral<ActionPanelView<NetworkView>>() {
    });
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<ProviderListModel>>() {
    }, new TypeLiteral<SearchPanelView<ProviderListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Provider, ProviderListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Provider>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Provider, ProviderListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Provider>>() {
    }, new TypeLiteral<ActionPanelView<Provider>>() {
    });
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<Erratum, EngineErrataListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<Erratum>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<Erratum, EngineErrataListModel>>() {
    });
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    bindPresenterWidget(VnicProfileBreadCrumbsPresenterWidget.class, VnicProfileBreadCrumbsPresenterWidget.VnicProfileBreadCrumbsViewDef.class, VnicProfileBreadCrumbsView.class);
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VnicProfileView>>() {
    }, new TypeLiteral<ActionPanelView<VnicProfileView>>() {
    });
    // User Sessions
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<SessionListModel>>() {
    }, new TypeLiteral<SearchPanelView<SessionListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<UserSession, SessionListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<UserSession>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<UserSession, SessionListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<UserSession>>() {
    }, new TypeLiteral<ActionPanelView<UserSession>>() {
    });
    // Volume
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<VolumeListModel>>() {
    }, new TypeLiteral<SearchPanelView<VolumeListModel>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<GlusterVolumeEntity, VolumeListModel>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<GlusterVolumeEntity>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<GlusterVolumeEntity, VolumeListModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeEntity>>() {
    });
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    bindPresenterWidget(HostMaintenanceConfirmationPopupPresenterWidget.class, HostMaintenanceConfirmationPopupPresenterWidget.ViewDef.class, HostMaintenanceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(VnicProfileMappingPopupPresenterWidget.class, VnicProfileMappingPopupPresenterWidget.ViewDef.class, VnicProfileMappingPopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    bindPresenterWidget(StorageDRPopupPresenterWidget.class, StorageDRPopupPresenterWidget.ViewDef.class, StorageDRPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // VM Sparsify Disk
    bindPresenterWidget(VmDiskSparsifyPopupPresenterWidget.class, VmDiskSparsifyPopupPresenterWidget.ViewDef.class, VmDiskSparsifyPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(StorageQosRemovePopupPresenterWidget.class, StorageQosRemovePopupPresenterWidget.ViewDef.class, StorageQosRemovePopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    bindSingletonPresenterWidget(new TypeLiteral<SearchPanelPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelPresenterWidget.ViewDef<EventListModel<Void>>>() {
    }, new TypeLiteral<SearchPanelView<EventListModel<Void>>>() {
    });
    bindPresenterWidget(new TypeLiteral<OvirtBreadCrumbsPresenterWidget<AuditLog, EventListModel<Void>>>() {
    }, new TypeLiteral<OvirtBreadCrumbsPresenterWidget.ViewDef<AuditLog>>() {
    }, new TypeLiteral<OvirtBreadCrumbsView<AuditLog, EventListModel<Void>>>() {
    });
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
    bindPresenterWidget(ExpandAllButtonPresenterWidget.class, ExpandAllButtonPresenterWidget.ViewDef.class, ExpandAllButtonView.class);
    // Overlays
    // Tasks
    bindPresenter(TasksPresenter.class, TasksPresenter.ViewDef.class, TasksView.class, TasksPresenter.ProxyDef.class);
    // Bookmarks
    bindPresenter(BookmarkPresenter.class, BookmarkPresenter.ViewDef.class, BookmarkView.class, BookmarkPresenter.ProxyDef.class);
    // Tags
    bindPresenter(TagsPresenter.class, TagsPresenter.ViewDef.class, TagsView.class, TagsPresenter.ProxyDef.class);
    // Popup/detail Action panels
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Label>>() {
    }, new TypeLiteral<ActionPanelView<Label>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterHookEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterHookEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Network>>() {
    }, new TypeLiteral<ActionPanelView<Network>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<IscsiBond>>() {
    }, new TypeLiteral<ActionPanelView<IscsiBond>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterBrickEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterBrickEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeOptionEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeOptionEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDevice>>() {
    }, new TypeLiteral<ActionPanelView<StorageDevice>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterVolumeSnapshotEntity>>() {
    }, new TypeLiteral<ActionPanelView<GlusterVolumeSnapshotEntity>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterServerService>>() {
    }, new TypeLiteral<ActionPanelView<GlusterServerService>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkCluster>>() {
    }, new TypeLiteral<ActionPanelView<NetworkCluster>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<ExternalSubnet>>() {
    }, new TypeLiteral<ActionPanelView<ExternalSubnet>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<LibvirtSecret>>() {
    }, new TypeLiteral<ActionPanelView<LibvirtSecret>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Permission>>() {
    }, new TypeLiteral<ActionPanelView<Permission>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<GlusterGeoRepSession>>() {
    }, new TypeLiteral<ActionPanelView<GlusterGeoRepSession>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<Cluster, NetworkCluster>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<Cluster, NetworkCluster>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<VdsNetworkInterface, VDS>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<VdsNetworkInterface, VDS>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<VmNetworkInterface, VM>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<VmNetworkInterface, VM>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<PairQueryable<VmNetworkInterface, VmTemplate>>>() {
    }, new TypeLiteral<ActionPanelView<PairQueryable<VmNetworkInterface, VmTemplate>>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageDomainDR>>() {
    }, new TypeLiteral<ActionPanelView<StorageDomainDR>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<RepoImage>>() {
    }, new TypeLiteral<ActionPanelView<RepoImage>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DiskModel>>() {
    }, new TypeLiteral<ActionPanelView<DiskModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<EventSubscriber>>() {
    }, new TypeLiteral<ActionPanelView<EventSubscriber>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<AffinityGroup>>() {
    }, new TypeLiteral<ActionPanelView<AffinityGroup>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<MacPool>>() {
    }, new TypeLiteral<ActionPanelView<MacPool>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Role>>() {
    }, new TypeLiteral<ActionPanelView<Role>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<ClusterPolicy>>() {
    }, new TypeLiteral<ActionPanelView<ClusterPolicy>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<InstanceType>>() {
    }, new TypeLiteral<ActionPanelView<InstanceType>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<CpuQos>>() {
    }, new TypeLiteral<ActionPanelView<CpuQos>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<NetworkQoS>>() {
    }, new TypeLiteral<ActionPanelView<NetworkQoS>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostNetworkQos>>() {
    }, new TypeLiteral<ActionPanelView<HostNetworkQos>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<DiskProfile>>() {
    }, new TypeLiteral<ActionPanelView<DiskProfile>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<CpuProfile>>() {
    }, new TypeLiteral<ActionPanelView<CpuProfile>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<VmNetworkInterface>>() {
    }, new TypeLiteral<ActionPanelView<VmNetworkInterface>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<Snapshot>>() {
    }, new TypeLiteral<ActionPanelView<Snapshot>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostDeviceView>>() {
    }, new TypeLiteral<ActionPanelView<HostDeviceView>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<HostInterfaceLineModel>>() {
    }, new TypeLiteral<ActionPanelView<HostInterfaceLineModel>>() {
    });
    bindActionPanel(new TypeLiteral<ActionPanelPresenterWidget.ViewDef<StorageQos>>() {
    }, new TypeLiteral<ActionPanelView<StorageQos>>() {
    });
}
#end_block

#method_before
@Override
public void itemChanged(T item) {
    if (item != null && getView().asWidget().isVisible()) {
        getView().setMainTabSelectedItem(item);
    } else if (item == null && getView().asWidget().isVisible() && modelProvider.getMainModel().getItems().isEmpty()) {
        // No selection so we can't positively show anything, switch to grid.
        placeManager.revealPlace(getMainTabRequest());
    }
}
#method_after
@Override
public void itemChanged(T item) {
    boolean widgetVisible = getView().asWidget().isVisible();
    if (item != null && widgetVisible) {
        getView().setMainTabSelectedItem(item);
    } else if (item == null && widgetVisible && modelProvider.getMainModel().getItems().isEmpty()) {
        // No selection so we can't positively show anything, switch to grid.
        placeManager.revealPlace(getMainTabRequest());
    }
}
#end_block

#method_before
@Override
public void onBind() {
    super.onBind();
    registerHandler(getView().getConfigure().addClickHandler(event -> RevealRootPopupContentEvent.fire(MenuPresenterWidget.this, configurePopupProvider.get())));
}
#method_after
@Override
public void onBind() {
    super.onBind();
    registerHandler(getView().getConfigureItem().addClickHandler(event -> RevealRootPopupContentEvent.fire(MenuPresenterWidget.this, configurePopupProvider.get())));
}
#end_block

#method_before
@Override
public DynamicUrlContentPresenter get() {
    if (presenter == null) {
        presenter = new DynamicUrlContentPresenter(getEventBus(), new DynamicUrlContentView(), this, slot);
        presenter.bind();
    }
    presenter.setContentUrl(contentUrl);
    return presenter;
}
#method_after
@Override
public DynamicUrlContentPresenter get() {
    if (presenter == null) {
        presenter = new DynamicUrlContentPresenter(contentUrl, getEventBus(), viewProvider.get(), this, slot);
        presenter.bind();
    }
    return presenter;
}
#end_block

#method_before
protected Resources getTableHeaderlessResources() {
    return GWT.<Resources>create(SubTableHeaderlessResources.class);
}
#method_after
protected Resources getTableHeaderlessResources() {
    return GWT.create(SubTableHeaderlessResources.class);
}
#end_block

#method_before
protected Resources getTableResources() {
    return GWT.<Resources>create(SubTableResources.class);
}
#method_after
protected Resources getTableResources() {
    return GWT.create(SubTableResources.class);
}
#end_block

#method_before
@Override
public void onBind() {
    super.onBind();
    registerHandler(((ViewDef) getView()).getCloseButton().addClickHandler(e -> {
        AbstractOverlayPresenter.this.removeFromParentSlot();
    }));
}
#method_after
@Override
public void onBind() {
    super.onBind();
    registerHandler(((ViewDef) getView()).getCloseButton().addClickHandler(e -> AbstractOverlayPresenter.this.removeFromParentSlot()));
}
#end_block

#method_before
@Override
public void removeFromSlot(Object slot, IsWidget content) {
    super.removeFromSlot(slot, content);
    if (content instanceof AbstractOverlayPresenter && previousWidget != null) {
        setPanelContent(contentContainer, previousWidget);
    }
}
#method_after
@Override
public void removeFromSlot(Object slot, IsWidget content) {
    super.removeFromSlot(slot, content);
    if (content instanceof AbstractOverlayPresenter && nonOverlayContent != null) {
        // restore non-overlay content
        setPanelContent(contentContainer, nonOverlayContent);
    }
}
#end_block

#method_before
@Override
public void setInSlot(Object slot, IsWidget content) {
    if (slot == MainContentPresenter.TYPE_SetContent) {
        if (content instanceof AbstractOverlayPresenter && !(currentWidget instanceof AbstractOverlayPresenter)) {
            previousWidget = currentWidget;
        }
        currentWidget = content;
        setPanelContent(contentContainer, content);
    } else {
        super.setInSlot(slot, content);
    }
}
#method_after
@Override
public void setInSlot(Object slot, IsWidget content) {
    if (slot == MainContentPresenter.TYPE_SetContent) {
        if (content instanceof AbstractOverlayPresenter) {
            IsWidget currentContent = getCurrentContent();
            // prevent overlay content stacking
            if (!(currentContent instanceof AbstractOverlayPresenter)) {
                // remember non-overlay content
                nonOverlayContent = currentContent;
            }
        }
        setPanelContent(contentContainer, content);
    } else {
        super.setInSlot(slot, content);
    }
}
#end_block

#method_before
private List<Map<String, Object>> parseMemories(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.MEMORY);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.MEMORY)) {
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.MEMORY.getValue());
        dev.put(VdsProperties.Device, VmDeviceGeneralType.MEMORY.getValue());
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        XmlNode target = node.selectSingleNode("target");
        if (target == null) {
            continue;
        }
        String devNode = target.selectSingleNode(NODE).innerText;
        String devSize = kiloBytesToMegaBytes(target.selectSingleNode(SIZE).innerText);
        VmDevice dbDev = dbDevices.stream().sorted(// try to match managed devices first
        Comparator.comparing(VmDevice::isManaged).reversed()).filter(d -> d.getDevice().equals(dev.get(VdsProperties.Device))).filter(d -> Objects.equals(d.getSpecParams().get(VmDeviceCommonUtils.SPEC_PARAM_NODE).toString(), devNode)).filter(d -> Objects.equals(d.getSpecParams().get(VmDeviceCommonUtils.SPEC_PARAM_SIZE).toString(), devSize)).findFirst().orElse(null);
        if (dbDev != null) {
            dbDevices.remove(dbDev);
            dev.put(VdsProperties.DeviceId, dbDev.getId().getDeviceId().toString());
            dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        } else {
            dev.put(VdsProperties.DeviceId, Guid.newGuid().toString());
            Map<String, Object> specParams = new HashMap<>();
            specParams.put(VmDeviceCommonUtils.SPEC_PARAM_NODE, devNode);
            specParams.put(VmDeviceCommonUtils.SPEC_PARAM_SIZE, devSize);
            dev.put(VdsProperties.SpecParams, specParams);
        }
        result.add(dev);
    }
    return result;
}
#method_after
private List<Map<String, Object>> parseMemories(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.MEMORY);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.MEMORY)) {
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.MEMORY.getValue());
        dev.put(VdsProperties.Device, VmDeviceGeneralType.MEMORY.getValue());
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        XmlNode target = node.selectSingleNode("target");
        if (target == null) {
            continue;
        }
        String devNode = target.selectSingleNode(NODE).innerText;
        String devSize = kiloBytesToMegaBytes(target.selectSingleNode(SIZE).innerText);
        VmDevice dbDev = dbDevices.stream().sorted(// try to match managed devices first
        Comparator.comparing(VmDevice::isManaged).reversed()).filter(d -> d.getDevice().equals(dev.get(VdsProperties.Device))).filter(d -> Objects.equals(d.getSpecParams().get(SPEC_PARAM_NODE).toString(), devNode)).filter(d -> Objects.equals(d.getSpecParams().get(SPEC_PARAM_SIZE).toString(), devSize)).findFirst().orElse(null);
        if (dbDev != null) {
            dbDevices.remove(dbDev);
            dev.put(VdsProperties.DeviceId, dbDev.getId().getDeviceId().toString());
            dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        } else {
            dev.put(VdsProperties.DeviceId, Guid.newGuid().toString());
            Map<String, Object> specParams = new HashMap<>();
            specParams.put(SPEC_PARAM_NODE, devNode);
            specParams.put(SPEC_PARAM_SIZE, devSize);
            dev.put(VdsProperties.SpecParams, specParams);
        }
        result.add(dev);
    }
    return result;
}
#end_block

#method_before
@Override
public void setUp() {
    super.setUp();
    generateStorageToDisksMap();
    initDestSDs();
    mcr.mockConfigValue(ConfigValues.MaxIoThreadsPerVm, 127);
    mcr.mockConfigValue(ConfigValues.MaxVmNameLength, 64);
    mcr.mockConfigValue(ConfigValues.SupportedClusterLevels, new HashSet<>(Arrays.asList(new Version(2, 2), new Version(3, 0))));
    mcr.mockConfigValue(ConfigValues.ValidNumOfMonitors, Arrays.asList("1", "2", "4"));
}
#method_after
@Override
public void setUp() {
    super.setUp();
    generateStorageToDisksMap();
    initDestSDs();
}
#end_block

#method_before
@Test
public void testBlockUseHostCpuWithPPCArch() {
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    doNothing().when(cmd).initTemplateDisks();
    setupCanAddPpcTest();
    cmd.setEffectiveCompatibilityVersion(Version.v4_0);
    doReturn(Collections.emptyList()).when(cmd).getImagesToCheckDestinationStorageDomains();
    initPpcCluster();
    doReturn(true).when(cmd).validateAddVmCommand();
    doReturn(true).when(cmd).isVmNameValidLength(any(VM.class));
    when(osRepository.getArchitectureFromOS(anyInt())).thenReturn(ArchitectureType.ppc64);
    cmd.getParameters().getVm().setClusterArch(ArchitectureType.ppc64);
    cmd.getParameters().getVm().setUseHostCpuFlags(true);
    cmd.getParameters().getVm().setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    cmd.getParameters().getVm().setClusterId(cluster.getId());
    cmd.getParameters().getVm().setVmOs(OsType.Other.ordinal());
    cmd.init();
    Map<String, String> migrationMap = new HashMap<String, String>() {

        {
            put("undefined", "true");
            put("x86", "true");
            put("ppc", "true");
        }
    };
    mcr.mockConfigValue(ConfigValues.IsMigrationSupported, cmd.getEffectiveCompatibilityVersion(), migrationMap);
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
}
#method_after
@Test
public void testBlockUseHostCpuWithPPCArch() {
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    doNothing().when(cmd).initTemplateDisks();
    setupCanAddPpcTest();
    cmd.setEffectiveCompatibilityVersion(Version.v4_0);
    doReturn(Collections.emptyList()).when(cmd).getImagesToCheckDestinationStorageDomains();
    initPpcCluster();
    doReturn(true).when(cmd).validateAddVmCommand();
    doReturn(true).when(cmd).isVmNameValidLength(any(VM.class));
    when(osRepository.getArchitectureFromOS(anyInt())).thenReturn(ArchitectureType.ppc64);
    cmd.getParameters().getVm().setClusterArch(ArchitectureType.ppc64);
    cmd.getParameters().getVm().setUseHostCpuFlags(true);
    cmd.getParameters().getVm().setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    cmd.getParameters().getVm().setClusterId(cluster.getId());
    cmd.getParameters().getVm().setVmOs(OsType.Other.ordinal());
    cmd.init();
    Map<String, String> migrationMap = new HashMap<>();
    migrationMap.put("undefined", "true");
    migrationMap.put("x86", "true");
    migrationMap.put("ppc", "true");
    mcr.mockConfigValue(ConfigValues.IsMigrationSupported, cmd.getEffectiveCompatibilityVersion(), migrationMap);
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
}
#end_block

#method_before
@Before
public void setUp() {
    when(vmDao.get(vm.getId())).thenReturn(vm);
    // The cluster to use
    Cluster cluster = new Cluster();
    cluster.setCpuName("Intel Conroe Family");
    cluster.setArchitecture(ArchitectureType.x86_64);
    cluster.setId(vm.getClusterId());
    cluster.setStoragePoolId(vm.getStoragePoolId());
    cluster.setCompatibilityVersion(Version.getLast());
    when(clusterDao.get(vm.getClusterId())).thenReturn(cluster);
    mockOsRepository();
    doNothing().when(cmd).separateCustomProperties(any(VmStatic.class));
    doReturn(getDisksList(vm.getStoragePoolId())).when(cmd).getVmDisksFromDB();
    doReturn(vmDeviceUtils).when(cmd).getVmDeviceUtils();
    mcr.mockConfigValue(ConfigValues.VmPriorityMaxValue, 100);
    cmd.init();
}
#method_after
@Before
public void setUp() {
    when(vmDao.get(vm.getId())).thenReturn(vm);
    // The cluster to use
    Cluster cluster = new Cluster();
    cluster.setCpuName("Intel Conroe Family");
    cluster.setArchitecture(ArchitectureType.x86_64);
    cluster.setId(vm.getClusterId());
    cluster.setStoragePoolId(vm.getStoragePoolId());
    cluster.setCompatibilityVersion(Version.getLast());
    when(clusterDao.get(vm.getClusterId())).thenReturn(cluster);
    mockOsRepository();
    doNothing().when(cmd).separateCustomProperties(any(VmStatic.class));
    doReturn(getDisksList(vm.getStoragePoolId())).when(cmd).getVmDisksFromDB();
    doReturn(vmDeviceUtils).when(cmd).getVmDeviceUtils();
    cmd.init();
}
#end_block

#method_before
@Before
public void setUp() {
    final int osId = 0;
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    when(cpuFlagsManagerHandler.getCpuId(any(), any())).thenReturn(CPU_ID);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(), any())).thenReturn(true);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<>());
    displayTypeMap.get(osId).put(version, Collections.singletonList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    vmHandler.init();
    vm = new VM();
    vmStatic = command.getParameters().getVmStaticData();
    group = new Cluster();
    group.setCpuName("Intel Conroe Family");
    group.setId(clusterId);
    group.setCompatibilityVersion(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setClusterId(clusterId);
    vm.setClusterArch(ArchitectureType.x86_64);
    doReturn(group).when(command).getCluster();
    doReturn(vm).when(command).getVm();
    doReturn(ActionType.UpdateVm).when(command).getActionType();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getCompatibilityVersion());
    doReturn(vmDeviceUtils).when(command).getVmDeviceUtils();
    doReturn(numaValidator).when(command).getNumaValidator();
    mcr.mockConfigValue(ConfigValues.MaxVmNameLength, 64);
    mcr.mockConfigValue(ConfigValues.ValidNumOfMonitors, Arrays.asList("1", "2", "4"));
    mcr.mockConfigValue(ConfigValues.VmPriorityMaxValue, 100);
    mcr.mockConfigValue(ConfigValues.MaxIoThreadsPerVm, 127);
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    when(cpuFlagsManagerHandler.getCpuId(any(), any())).thenReturn(CPU_ID);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(), any())).thenReturn(true);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<>());
    displayTypeMap.get(osId).put(version, Collections.singletonList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    vmHandler.init();
    vm = new VM();
    vmStatic = command.getParameters().getVmStaticData();
    group = new Cluster();
    group.setCpuName("Intel Conroe Family");
    group.setId(clusterId);
    group.setCompatibilityVersion(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setClusterId(clusterId);
    vm.setClusterArch(ArchitectureType.x86_64);
    doReturn(group).when(command).getCluster();
    doReturn(vm).when(command).getVm();
    doReturn(ActionType.UpdateVm).when(command).getActionType();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getCompatibilityVersion());
    doReturn(vmDeviceUtils).when(command).getVmDeviceUtils();
    doReturn(numaValidator).when(command).getNumaValidator();
}
#end_block

#method_before
@Test
public void testNameNotChanged() {
    prepareVmToPassValidate();
    vm.setName("vm1");
    mockSameNameQuery(true);
    mockVmValidator();
    command.initEffectiveCompatibilityVersion();
    Map<String, String> migrationMap = new HashMap<String, String>() {

        {
            put("undefined", "true");
            put("x86", "true");
            put("ppc", "true");
        }
    };
    mcr.mockConfigValue(ConfigValues.IsMigrationSupported, command.getEffectiveCompatibilityVersion(), migrationMap);
    mcr.mockConfigValue(ConfigValues.MaxNumOfCpuPerSocket, command.getEffectiveCompatibilityVersion(), 16);
    mcr.mockConfigValue(ConfigValues.MaxNumOfThreadsPerCpu, command.getEffectiveCompatibilityVersion(), 8);
    mcr.mockConfigValue(ConfigValues.MaxNumOfVmCpus, command.getEffectiveCompatibilityVersion(), 16);
    mcr.mockConfigValue(ConfigValues.MaxNumOfVmSockets, command.getEffectiveCompatibilityVersion(), 16);
    mcr.mockConfigValue(ConfigValues.VM32BitMaxMemorySizeInMB, command.getEffectiveCompatibilityVersion(), 20480);
    mcr.mockConfigValue(ConfigValues.VM64BitMaxMemorySizeInMB, command.getEffectiveCompatibilityVersion(), 4194304);
    mcr.mockConfigValue(ConfigValues.VMPpc64BitMaxMemorySizeInMB, command.getEffectiveCompatibilityVersion(), 1048576);
    assertTrue("validate should have passed.", command.validate());
}
#method_after
@Test
public void testNameNotChanged() {
    prepareVmToPassValidate();
    vm.setName("vm1");
    mockSameNameQuery(true);
    mockVmValidator();
    command.initEffectiveCompatibilityVersion();
    Map<String, String> migrationMap = new HashMap<>();
    migrationMap.put("undefined", "true");
    migrationMap.put("x86", "true");
    migrationMap.put("ppc", "true");
    mcr.mockConfigValue(ConfigValues.IsMigrationSupported, command.getEffectiveCompatibilityVersion(), migrationMap);
    mcr.mockConfigValue(ConfigValues.MaxNumOfCpuPerSocket, command.getEffectiveCompatibilityVersion(), 16);
    mcr.mockConfigValue(ConfigValues.MaxNumOfThreadsPerCpu, command.getEffectiveCompatibilityVersion(), 8);
    mcr.mockConfigValue(ConfigValues.MaxNumOfVmCpus, command.getEffectiveCompatibilityVersion(), 16);
    mcr.mockConfigValue(ConfigValues.MaxNumOfVmSockets, command.getEffectiveCompatibilityVersion(), 16);
    mcr.mockConfigValue(ConfigValues.VM32BitMaxMemorySizeInMB, command.getEffectiveCompatibilityVersion(), 20480);
    mcr.mockConfigValue(ConfigValues.VM64BitMaxMemorySizeInMB, command.getEffectiveCompatibilityVersion(), 4194304);
    mcr.mockConfigValue(ConfigValues.VMPpc64BitMaxMemorySizeInMB, command.getEffectiveCompatibilityVersion(), 1048576);
    assertTrue("validate should have passed.", command.validate());
}
#end_block

#method_before
private void createCommand(final Cluster group) {
    cmd.getParameters().setManagementNetworkId(managementNetworkId);
    cmd.getParameters().setCluster(group);
    cmd.setClusterId(group.getId());
    doReturn(dbFacadeMock).when(cmd).getDbFacade();
    doReturn(clusterDao).when(dbFacadeMock).getClusterDao();
    doReturn(storagePoolDao).when(dbFacadeMock).getStoragePoolDao();
    doReturn(true).when(cmd).isSupportedEmulatedMachinesMatchClusterLevel(any());
    // cluster upgrade
    doReturn(new ClusterPolicy()).when(schedulingManager).getClusterPolicy(any(Guid.class));
    final ClusterPolicy clusterPolicy = new ClusterPolicy();
    clusterPolicy.setId(ClusterPolicy.UPGRADE_POLICY_GUID);
    doReturn(clusterPolicy).when(schedulingManager).getClusterPolicy(eq(ClusterPolicy.UPGRADE_POLICY_GUID));
    if (StringUtils.isEmpty(group.getCpuName())) {
        doReturn(ArchitectureType.undefined).when(cmd).getArchitecture();
    } else {
        doReturn(ArchitectureType.x86_64).when(cmd).getArchitecture();
    }
    when(clusterDao.get(any())).thenReturn(createDefaultCluster());
    when(clusterDao.getByName(any())).thenReturn(createDefaultCluster());
    List<Cluster> clusterList = new ArrayList<>();
    clusterList.add(createDefaultCluster());
    when(clusterDao.getByName(any(), anyBoolean())).thenReturn(clusterList);
    Map<String, String> migrationMap = new HashMap<String, String>() {

        {
            put("undefined", "true");
            put("x86", "true");
            put("ppc", "true");
        }
    };
    mcr.mockConfigValue(ConfigValues.IsMigrationSupported, cmd.getCluster().getCompatibilityVersion(), migrationMap);
}
#method_after
private void createCommand(final Cluster group) {
    cmd.getParameters().setManagementNetworkId(managementNetworkId);
    cmd.getParameters().setCluster(group);
    cmd.setClusterId(group.getId());
    doReturn(dbFacadeMock).when(cmd).getDbFacade();
    doReturn(clusterDao).when(dbFacadeMock).getClusterDao();
    doReturn(storagePoolDao).when(dbFacadeMock).getStoragePoolDao();
    doReturn(true).when(cmd).isSupportedEmulatedMachinesMatchClusterLevel(any());
    // cluster upgrade
    doReturn(new ClusterPolicy()).when(schedulingManager).getClusterPolicy(any(Guid.class));
    final ClusterPolicy clusterPolicy = new ClusterPolicy();
    clusterPolicy.setId(ClusterPolicy.UPGRADE_POLICY_GUID);
    doReturn(clusterPolicy).when(schedulingManager).getClusterPolicy(eq(ClusterPolicy.UPGRADE_POLICY_GUID));
    if (StringUtils.isEmpty(group.getCpuName())) {
        doReturn(ArchitectureType.undefined).when(cmd).getArchitecture();
    } else {
        doReturn(ArchitectureType.x86_64).when(cmd).getArchitecture();
    }
    when(clusterDao.get(any())).thenReturn(createDefaultCluster());
    when(clusterDao.getByName(any())).thenReturn(createDefaultCluster());
    List<Cluster> clusterList = new ArrayList<>();
    clusterList.add(createDefaultCluster());
    when(clusterDao.getByName(any(), anyBoolean())).thenReturn(clusterList);
    Map<String, String> migrationMap = new HashMap<>();
    migrationMap.put("undefined", "true");
    migrationMap.put("x86", "true");
    migrationMap.put("ppc", "true");
    mcr.mockConfigValue(ConfigValues.IsMigrationSupported, cmd.getCluster().getCompatibilityVersion(), migrationMap);
}
#end_block

#method_before
@Override
public void starting(Description description) {
    origConfUtils = Config.getConfigUtils();
    Config.setConfigUtils(MOCK_CONFIG_UTILS);
    for (MockConfigDescriptor<?> config : configs) {
        mockConfigValue(config.getValue(), config.getVersion(), config.getReturnValue());
    }
}
#method_after
@Override
public void starting(Description description) {
    origConfUtils = Config.getConfigUtils();
    Config.setConfigUtils(mockConfigUtils);
    for (MockConfigDescriptor<?> config : configs) {
        mockConfigValue(config.getValue(), config.getVersion(), config.getReturnValue());
    }
}
#end_block

#method_before
@Override
public void finished(Description description) {
    Mockito.reset(MOCK_CONFIG_UTILS);
    Config.setConfigUtils(origConfUtils);
}
#method_after
@Override
public void finished(Description description) {
    Mockito.reset(mockConfigUtils);
    Config.setConfigUtils(origConfUtils);
}
#end_block

#method_before
@Test
public void canAddVmWithVirtioScsiControllerNotSupportedOs() {
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    doReturn(true).when(cmd).areParametersLegal(anyList());
    doReturn(Collections.emptyList()).when(cmd).getVmInterfaces();
    doReturn(Collections.emptyList()).when(cmd).getDiskVmElements();
    mockStorageDomainDaoGetAllForStoragePool();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllForStoragePool();
    cmd.getParameters().setVirtioScsiEnabled(true);
    when(osRepository.isSoundDeviceEnabled(anyInt(), any(Version.class))).thenReturn(true);
    when(osRepository.getArchitectureFromOS(anyInt())).thenReturn(ArchitectureType.x86_64);
    when(osRepository.getDiskInterfaces(anyInt(), any(Version.class))).thenReturn(new ArrayList<>(Collections.singletonList("VirtIO")));
    mockGetAllSnapshots();
    cmd.initEffectiveCompatibilityVersion();
    Map<String, String> migrationMap = new HashMap<String, String>() {

        {
            put("undefined", "true");
            put("x86", "true");
            put("ppc", "true");
        }
    };
    mcr.mockConfigValue(ConfigValues.IsMigrationSupported, cmd.getEffectiveCompatibilityVersion(), migrationMap);
    mcr.mockConfigValue(ConfigValues.MaxNumOfVmCpus, cmd.getEffectiveCompatibilityVersion(), 16);
    mcr.mockConfigValue(ConfigValues.MaxNumOfVmSockets, cmd.getEffectiveCompatibilityVersion(), 16);
    mcr.mockConfigValue(ConfigValues.MaxNumOfCpuPerSocket, cmd.getEffectiveCompatibilityVersion(), 16);
    mcr.mockConfigValue(ConfigValues.MaxNumOfThreadsPerCpu, cmd.getEffectiveCompatibilityVersion(), 8);
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#method_after
@Test
public void canAddVmWithVirtioScsiControllerNotSupportedOs() {
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    doReturn(true).when(cmd).areParametersLegal(anyList());
    doReturn(Collections.emptyList()).when(cmd).getVmInterfaces();
    doReturn(Collections.emptyList()).when(cmd).getDiskVmElements();
    mockStorageDomainDaoGetAllForStoragePool();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllForStoragePool();
    cmd.getParameters().setVirtioScsiEnabled(true);
    when(osRepository.isSoundDeviceEnabled(anyInt(), any(Version.class))).thenReturn(true);
    when(osRepository.getArchitectureFromOS(anyInt())).thenReturn(ArchitectureType.x86_64);
    when(osRepository.getDiskInterfaces(anyInt(), any(Version.class))).thenReturn(new ArrayList<>(Collections.singletonList("VirtIO")));
    mockGetAllSnapshots();
    cmd.initEffectiveCompatibilityVersion();
    Map<String, String> migrationMap = new HashMap<>();
    migrationMap.put("undefined", "true");
    migrationMap.put("x86", "true");
    migrationMap.put("ppc", "true");
    mcr.mockConfigValue(ConfigValues.IsMigrationSupported, cmd.getEffectiveCompatibilityVersion(), migrationMap);
    mcr.mockConfigValue(ConfigValues.MaxNumOfVmCpus, cmd.getEffectiveCompatibilityVersion(), 16);
    mcr.mockConfigValue(ConfigValues.MaxNumOfVmSockets, cmd.getEffectiveCompatibilityVersion(), 16);
    mcr.mockConfigValue(ConfigValues.MaxNumOfCpuPerSocket, cmd.getEffectiveCompatibilityVersion(), 16);
    mcr.mockConfigValue(ConfigValues.MaxNumOfThreadsPerCpu, cmd.getEffectiveCompatibilityVersion(), 8);
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#end_block

#method_before
protected <T> Set<MockConfigDescriptor<T>> getExtraConfigDescriptors() {
    return Collections.emptySet();
}
#method_after
protected Set<MockConfigDescriptor<Object>> getExtraConfigDescriptors() {
    return Collections.emptySet();
}
#end_block

#method_before
@Before
public void setupEnvironment() {
    CorrelationIdTracker.clean();
    DbUser user = mock(DbUser.class);
    when(engineSessionDao.remove(anyLong())).thenReturn(1);
    mcr.mockConfigValue(ConfigValues.UserSessionTimeOutInterval, 30);
    sessionDataContainer.setUser(session, user);
}
#method_after
@Before
public void setupEnvironment() {
    CorrelationIdTracker.clean();
    DbUser user = mock(DbUser.class);
    when(engineSessionDao.remove(anyLong())).thenReturn(1);
    sessionDataContainer.setUser(session, user);
}
#end_block

#method_before
private void getImageChildren(Guid snapshot, List<DiskImage> children) {
    List<DiskImage> snapshots = diskImageDao.getAllSnapshotsForParent(snapshot).stream().collect(Collectors.toList());
    children.addAll(snapshots);
    snapshots.forEach(s -> getImageChildren(s.getId(), children));
}
#method_after
private void getImageChildren(Guid snapshot, List<DiskImage> children) {
    List<DiskImage> snapshots = diskImageDao.getAllSnapshotsForParent(snapshot);
    children.addAll(snapshots);
    snapshots.forEach(s -> getImageChildren(s.getId(), children));
}
#end_block

#method_before
private void removeChildren(Guid snapshot) {
    List<DiskImage> children = new ArrayList<>();
    getImageChildren(snapshot, children);
    children.stream().sorted(Collections.reverseOrder()).forEach(this::removeSnapshot);
}
#method_after
private void removeChildren(Guid snapshot) {
    List<DiskImage> children = new ArrayList<>();
    getImageChildren(snapshot, children);
    Collections.reverse(children);
    children.forEach(this::removeSnapshot);
}
#end_block

#method_before
protected VDSReturnValue performDeleteImageVdsmOperation() {
    if (getParameters().isShouldLockImage()) {
        // the image status should be set to ILLEGAL, so that in case compensation runs the image status will
        // be revert to be ILLEGAL, as we can't tell whether the task started on vdsm side or not.
        imagesHandler.updateAllDiskImageSnapshotsStatusWithCompensation(getRelevantDiskImage().getId(), ImageStatus.LOCKED, ImageStatus.ILLEGAL, getCompensationContext());
    }
    return runVdsCommand(VDSCommandType.DeleteImageGroup, postDeleteActionHandler.fixParameters(new DeleteImageGroupVDSCommandParameters(getDiskImage().getStoragePoolId(), getStorageDomainId(), getDiskImage().getId(), getDiskImage().isWipeAfterDelete(), getStorageDomain().getDiscardAfterDelete(), getParameters().getForceDelete())));
}
#method_after
protected VDSReturnValue performDeleteImageVdsmOperation() {
    if (getParameters().isShouldLockImage()) {
        // the image status should be set to ILLEGAL, so that in case compensation runs the image status will
        // be revert to be ILLEGAL, as we can't tell whether the task started on vdsm side or not.
        imagesHandler.updateAllDiskImageSnapshotsStatusWithCompensation(getRelevantDiskImage().getId(), ImageStatus.LOCKED, ImageStatus.ILLEGAL, getCompensationContext());
    }
    return runVdsCommand(VDSCommandType.DeleteImageGroup, postDeleteActionHandler.fixParameters(new DeleteImageGroupVDSCommandParameters(getDiskImage().getStoragePoolId(), getStorageDomainId(), getDiskImage().getId(), getDiskImage().isWipeAfterDelete(), getStorageDomain().getDiscardAfterDelete(), getParameters().isForceDelete())));
}
#end_block

#method_before
private void removeImageFromDB() {
    final DiskImage diskImage = getDiskImage();
    final List<Snapshot> updatedSnapshots;
    try {
        VM vm = getVmForNonShareableDiskImage(diskImage);
        // so no lock is required.
        if (getParameters().isRemoveFromSnapshots() && vm != null) {
            lockVmSnapshotsWithWait(vm);
            updatedSnapshots = prepareSnapshotConfigWithoutImage(diskImage.getId());
        } else {
            updatedSnapshots = Collections.emptyList();
        }
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            diskImageDynamicDao.remove(diskImage.getImageId());
            Guid imageTemplate = diskImage.getImageTemplateId();
            Guid currentGuid = diskImage.getImageId();
            // the storage).
            while (!currentGuid.equals(imageTemplate) && !currentGuid.equals(Guid.Empty)) {
                removeChildren(currentGuid);
                DiskImage image = diskImageDao.getSnapshotById(currentGuid);
                if (image != null) {
                    removeSnapshot(image);
                    currentGuid = image.getParentId();
                } else {
                    currentGuid = Guid.Empty;
                    log.warn("'image' (snapshot of image '{}') is null, cannot remove it.", diskImage.getImageId());
                }
            }
            baseDiskDao.remove(diskImage.getId());
            vmDeviceDao.remove(new VmDeviceId(diskImage.getId(), null));
            updatedSnapshots.forEach(s -> snapshotDao.update(s));
            return null;
        });
    } finally {
        if (getSnapshotsEngineLock() != null) {
            lockManager.releaseLock(getSnapshotsEngineLock());
        }
    }
}
#method_after
private void removeImageFromDB() {
    final DiskImage diskImage = getDiskImage();
    final List<Snapshot> updatedSnapshots;
    try {
        VM vm = getVmForNonShareableDiskImage(diskImage);
        // so no lock is required.
        if (getParameters().isRemoveFromSnapshots() && vm != null) {
            lockVmSnapshotsWithWait(vm);
            updatedSnapshots = prepareSnapshotConfigWithoutImage(diskImage.getId());
        } else {
            updatedSnapshots = Collections.emptyList();
        }
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            diskImageDynamicDao.remove(diskImage.getImageId());
            Guid imageTemplate = diskImage.getImageTemplateId();
            Guid currentGuid = diskImage.getImageId();
            // the storage).
            while (!currentGuid.equals(imageTemplate) && !currentGuid.equals(Guid.Empty)) {
                removeChildren(currentGuid);
                DiskImage image = diskImageDao.getSnapshotById(currentGuid);
                if (image != null) {
                    removeSnapshot(image);
                    currentGuid = image.getParentId();
                } else {
                    currentGuid = Guid.Empty;
                    log.warn("'image' (snapshot of image '{}') is null, cannot remove it.", diskImage.getImageId());
                }
            }
            baseDiskDao.remove(diskImage.getId());
            vmDeviceDao.remove(new VmDeviceId(diskImage.getId(), null));
            updatedSnapshots.forEach(snapshotDao::update);
            return null;
        });
    } finally {
        if (getSnapshotsEngineLock() != null) {
            lockManager.releaseLock(getSnapshotsEngineLock());
        }
    }
}
#end_block

#method_before
private void getImageChildren(Guid snapshot, List<Guid> children) {
    List<Guid> snapshotIds = diskImageDao.getAllSnapshotsForParent(snapshot).stream().map(s -> s.getImageId()).collect(Collectors.toList());
    children.addAll(snapshotIds);
    snapshotIds.stream().forEach(id -> getImageChildren(id, children));
}
#method_after
private void getImageChildren(Guid snapshot, List<Guid> children) {
    List<Guid> snapshotIds = diskImageDao.getAllSnapshotsForParent(snapshot).stream().map(DiskImage::getImageId).collect(Collectors.toList());
    children.addAll(snapshotIds);
    snapshotIds.forEach(id -> getImageChildren(id, children));
}
#end_block

#method_before
private void removeChildren(Guid snapshot) {
    List<Guid> children = new ArrayList<>();
    getImageChildren(snapshot, children);
    children.stream().sorted(Collections.reverseOrder()).forEach(child -> diskImageDao.getSnapshotById(child));
}
#method_after
private void removeChildren(Guid snapshot) {
    List<Guid> children = new ArrayList<>();
    getImageChildren(snapshot, children);
    Collections.reverse(children);
    children.forEach(child -> removeSnapshot(diskImageDao.getSnapshotById(child)));
}
#end_block

#method_before
protected VDSReturnValue performDeleteImageVdsmOperation() {
    if (getParameters().isShouldLockImage()) {
        // the image status should be set to ILLEGAL, so that in case compensation runs the image status will
        // be revert to be ILLEGAL, as we can't tell whether the task started on vdsm side or not.
        imagesHandler.updateAllDiskImageSnapshotsStatusWithCompensation(getRelevantDiskImage().getId(), ImageStatus.LOCKED, ImageStatus.ILLEGAL, getCompensationContext());
    }
    return runVdsCommand(VDSCommandType.DeleteImageGroup, postDeleteActionHandler.fixParameters(new DeleteImageGroupVDSCommandParameters(getDiskImage().getStoragePoolId(), getStorageDomainId(), getDiskImage().getId(), getDiskImage().isWipeAfterDelete(), getStorageDomain().getDiscardAfterDelete(), getParameters().getForceDelete())));
}
#method_after
protected VDSReturnValue performDeleteImageVdsmOperation() {
    if (getParameters().isShouldLockImage()) {
        // the image status should be set to ILLEGAL, so that in case compensation runs the image status will
        // be revert to be ILLEGAL, as we can't tell whether the task started on vdsm side or not.
        imagesHandler.updateAllDiskImageSnapshotsStatusWithCompensation(getRelevantDiskImage().getId(), ImageStatus.LOCKED, ImageStatus.ILLEGAL, getCompensationContext());
    }
    return runVdsCommand(VDSCommandType.DeleteImageGroup, postDeleteActionHandler.fixParameters(new DeleteImageGroupVDSCommandParameters(getDiskImage().getStoragePoolId(), getStorageDomainId(), getDiskImage().getId(), getDiskImage().isWipeAfterDelete(), getStorageDomain().getDiscardAfterDelete(), getParameters().isForceDelete())));
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof AuditLog)) {
        return false;
    }
    AuditLog other = (AuditLog) obj;
    return auditLogId == other.auditLogId && Objects.equals(logTime, other.logTime) && logType == other.logType && Objects.equals(message, other.message) && Objects.equals(storageDomainId, other.storageDomainId) && Objects.equals(storagePoolId, other.storagePoolId) && severity == other.severity && Objects.equals(userId, other.userId) && Objects.equals(vdsId, other.vdsId) && Objects.equals(quotaId, other.quotaId) && Objects.equals(vmId, other.vmId) && Objects.equals(vmTemplateId, other.vmTemplateId) && processed == other.processed && Objects.equals(correlationId, other.correlationId) && Objects.equals(jobId, other.jobId) && Objects.equals(origin, other.origin) && customId == other.customId && customEventId == other.customEventId && eventFloodInSec == other.eventFloodInSec && Objects.equals(customData, other.customData) && external == other.external && deleted == other.deleted && Objects.equals(callStack, other.callStack);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof AuditLog)) {
        return false;
    }
    AuditLog other = (AuditLog) obj;
    return auditLogId == other.auditLogId && Objects.equals(logTime, other.logTime) && logType == other.logType && Objects.equals(message, other.message) && Objects.equals(storageDomainId, other.storageDomainId) && Objects.equals(storagePoolId, other.storagePoolId) && severity == other.severity && Objects.equals(userId, other.userId) && Objects.equals(vdsId, other.vdsId) && Objects.equals(quotaId, other.quotaId) && Objects.equals(vmId, other.vmId) && Objects.equals(vmTemplateId, other.vmTemplateId) && processed == other.processed && Objects.equals(correlationId, other.correlationId) && Objects.equals(jobId, other.jobId) && Objects.equals(origin, other.origin) && Objects.equals(customId, other.customId) && customEventId == other.customEventId && eventFloodInSec == other.eventFloodInSec && Objects.equals(customData, other.customData) && external == other.external && deleted == other.deleted && Objects.equals(callStack, other.callStack);
}
#end_block

#method_before
private void createStatelessSnapshot() {
    warnIfNotAllDisksPermitSnapshots();
    log.info("Creating stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
    CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, createContextForStatelessSnapshotCreation());
    // setting lock to null in order not to release lock twice
    setLock(null);
    setSucceeded(vdcReturnValue.getSucceeded());
    if (!vdcReturnValue.getSucceeded()) {
        if (areDisksLocked(vdcReturnValue)) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        getReturnValue().setFault(vdcReturnValue.getFault());
        log.error("Failed to create stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
    }
}
#method_after
private void createStatelessSnapshot() {
    warnIfNotAllDisksPermitSnapshots();
    log.info("Creating stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
    CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
    ActionReturnValue actionReturnValue = runInternalAction(ActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, createContextForStatelessSnapshotCreation());
    // setting lock to null in order not to release lock twice
    setLock(null);
    setSucceeded(actionReturnValue.getSucceeded());
    if (!actionReturnValue.getSucceeded()) {
        if (areDisksLocked(actionReturnValue)) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        getReturnValue().setFault(actionReturnValue.getFault());
        log.error("Failed to create stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
    }
}
#end_block

#method_before
private boolean areDisksLocked(VdcReturnValueBase vdcReturnValue) {
    return vdcReturnValue.getValidationMessages().contains(EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED.name());
}
#method_after
private boolean areDisksLocked(ActionReturnValue actionReturnValue) {
    return actionReturnValue.getValidationMessages().contains(EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED.name());
}
#end_block

#method_before
private void removeStatlessSnapshot() {
    runInternalAction(VdcActionType.ProcessDownVm, new ProcessDownVmParameters(getVm().getId(), true), ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
    // setting lock to null in order not to release lock twice
    setLock(null);
    setSucceeded(true);
}
#method_after
private void removeStatlessSnapshot() {
    runInternalAction(ActionType.ProcessDownVm, new ProcessDownVmParameters(getVm().getId(), true), ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
    // setting lock to null in order not to release lock twice
    setLock(null);
    setSucceeded(true);
}
#end_block

#method_before
protected CreateVDSCommandParameters buildCreateVmParameters() {
    CreateVDSCommandParameters parameters = new CreateVDSCommandParameters(getVdsId(), getVm());
    parameters.setRunInUnknownStatus(getParameters().isRunInUnknownStatus());
    parameters.setVmPayload(vmPayload);
    parameters.setHibernationVolHandle(getMemoryFromActiveSnapshot());
    parameters.setPassthroughVnicToVfMap(flushPassthroughVnicToVfMap());
    if (initializationType == InitializationType.Sysprep && osRepository.isWindows(getVm().getVmOsId()) && (getVm().getFloppyPath() == null || "".equals(getVm().getFloppyPath()))) {
        parameters.setInitializationType(InitializationType.Sysprep);
    }
    if (initializationType == InitializationType.CloudInit && !osRepository.isWindows(getVm().getVmOsId())) {
        parameters.setInitializationType(InitializationType.CloudInit);
    }
    return parameters;
}
#method_after
protected CreateVDSCommandParameters buildCreateVmParameters() {
    CreateVDSCommandParameters parameters = new CreateVDSCommandParameters(getVdsId(), getVm());
    parameters.setRunInUnknownStatus(getParameters().isRunInUnknownStatus());
    parameters.setVmPayload(vmPayload);
    String memoryFromActiveSnapshot = getMemoryFromActiveSnapshot();
    if (StringUtils.isNotEmpty(memoryFromActiveSnapshot)) {
        parameters.setHibernationVolHandle(memoryFromActiveSnapshot);
        parameters.setDownSince(getVm().getStatus() == VMStatus.Suspended ? getVm().getLastStopTime() : getActiveSnapshot().getCreationDate());
    }
    parameters.setPassthroughVnicToVfMap(flushPassthroughVnicToVfMap());
    if (initializationType == InitializationType.Sysprep && osRepository.isWindows(getVm().getVmOsId()) && (getVm().getFloppyPath() == null || "".equals(getVm().getFloppyPath()))) {
        parameters.setInitializationType(InitializationType.Sysprep);
    }
    if (initializationType == InitializationType.CloudInit && !osRepository.isWindows(getVm().getVmOsId())) {
        parameters.setInitializationType(InitializationType.CloudInit);
    }
    return parameters;
}
#end_block

#method_before
protected void initParametersForExternalNetworks() {
    if (getVm().getInterfaces().isEmpty()) {
        return;
    }
    Map<VmDeviceId, VmDevice> nicDevices = Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.INTERFACE));
    for (VmNic iface : getVm().getInterfaces()) {
        VnicProfile vnicProfile = vnicProfileDao.get(iface.getVnicProfileId());
        Network network = NetworkHelper.getNetworkByVnicProfile(vnicProfile);
        VmDevice vmDevice = nicDevices.get(new VmDeviceId(iface.getId(), getVmId()));
        if (network != null && network.isExternal() && vmDevice.isPlugged()) {
            Provider<?> provider = providerDao.get(network.getProvidedBy().getProviderId());
            NetworkProviderProxy providerProxy = providerProxyFactory.create(provider);
            Map<String, String> deviceProperties = providerProxy.allocate(network, vnicProfile, iface, getVds());
            getVm().getRuntimeDeviceCustomProperties().put(vmDevice.getId(), deviceProperties);
        }
    }
}
#method_after
protected void initParametersForExternalNetworks() {
    if (getVm().getInterfaces().isEmpty()) {
        return;
    }
    Map<VmDeviceId, VmDevice> nicDevices = Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.INTERFACE));
    for (VmNic iface : getVm().getInterfaces()) {
        VnicProfile vnicProfile = vnicProfileDao.get(iface.getVnicProfileId());
        Network network = networkHelper.getNetworkByVnicProfile(vnicProfile);
        VmDevice vmDevice = nicDevices.get(new VmDeviceId(iface.getId(), getVmId()));
        if (network != null && network.isExternal() && vmDevice.isPlugged()) {
            Provider<?> provider = providerDao.get(network.getProvidedBy().getProviderId());
            NetworkProviderProxy providerProxy = providerProxyFactory.create(provider);
            Map<String, String> deviceProperties = providerProxy.allocate(network, vnicProfile, iface, getVds());
            getVm().getRuntimeDeviceCustomProperties().put(vmDevice.getId(), deviceProperties);
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().getCustomCompatibilityVersion() != null && vm.getCustomCompatibilityVersion().less(getStoragePool().getCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_COMATIBILITY_VERSION_NOT_SUPPORTED, String.format("$VmName %1$s", getVm().getName()), String.format("$VmVersion %1$s", getVm().getCustomCompatibilityVersion().toString()), String.format("$DcVersion %1$s", getStoragePool().getCompatibilityVersion()));
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getValidationMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getCluster(), getParameters().isRunInUnknownStatus())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    if (!checkDisksNotInBackupStorage()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_DISKS_ON_BACKUP_STORAGE);
    }
    boolean isWindowsOs = osRepository.isWindows(getVm().getVmOsId());
    boolean isCloudInitEnabled = (!getVm().isInitialized() && getVm().getVmInit() != null && !isWindowsOs) || (getParameters().getInitializationType() == InitializationType.CloudInit);
    if (isCloudInitEnabled && hasMaximumNumberOfDisks()) {
        return failValidation(EngineMessage.VMPAYLOAD_CDROM_OR_CLOUD_INIT_MAXIMUM_DEVICES);
    }
    if (!vmHandler.isCpuSupported(getVm().getVmOsId(), getVm().getCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    try {
        acquireHostDevicesLock();
        if (!checkRequiredHostDevicesAvailability()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_DEVICE_NOT_AVAILABLE);
        }
    } finally {
        releaseHostDevicesLock();
    }
    if (!validate(runVmValidator.validateUsbDevices(getVm().getStaticData()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().getCustomCompatibilityVersion() != null && vm.getCustomCompatibilityVersion().less(getStoragePool().getCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_COMATIBILITY_VERSION_NOT_SUPPORTED, String.format("$VmName %1$s", getVm().getName()), String.format("$VmVersion %1$s", getVm().getCustomCompatibilityVersion().toString()), String.format("$DcVersion %1$s", getStoragePool().getCompatibilityVersion()));
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getValidationMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getCluster(), getParameters().isRunInUnknownStatus())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    if (!validate(runVmValidator.validateVmLease())) {
        return false;
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    if (checkDisksInBackupStorage()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_DISKS_ON_BACKUP_STORAGE);
    }
    boolean isWindowsOs = osRepository.isWindows(getVm().getVmOsId());
    boolean isCloudInitEnabled = (!getVm().isInitialized() && getVm().getVmInit() != null && !isWindowsOs) || (getParameters().getInitializationType() == InitializationType.CloudInit);
    if (isCloudInitEnabled && hasMaximumNumberOfDisks()) {
        return failValidation(EngineMessage.VMPAYLOAD_CDROM_OR_CLOUD_INIT_MAXIMUM_DEVICES);
    }
    if (!vmHandler.isCpuSupported(getVm().getVmOsId(), getVm().getCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    try {
        acquireHostDevicesLock();
        if (!checkRequiredHostDevicesAvailability()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_DEVICE_NOT_AVAILABLE);
        }
    } finally {
        releaseHostDevicesLock();
    }
    if (!validate(runVmValidator.validateUsbDevices(getVm().getStaticData()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (shouldEndSnapshotCreation()) {
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        getParameters().setCachedFlow(null);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.error("Could not run VM '{}' ({}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#method_after
@Override
protected void endSuccessfully() {
    if (shouldEndSnapshotCreation()) {
        getBackend().endAction(ActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        getParameters().setCachedFlow(null);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.error("Could not run VM '{}' ({}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    if (shouldEndSnapshotCreation()) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), cloneContext().withoutExecutionContext().withoutLock());
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
}
#method_after
@Override
protected void endWithFailure() {
    if (shouldEndSnapshotCreation()) {
        ActionReturnValue actionReturnValue = getBackend().endAction(ActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), cloneContext().withoutExecutionContext().withoutLock());
        setSucceeded(actionReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
}
#end_block

#method_before
protected boolean isCinderStorageHasNoDisks() {
    if (getStorageDomain().getStorageType() == StorageType.CINDER) {
        return validate(CINDERStorageHelper.isCinderHasNoImages(getStorageDomainId()));
    }
    return true;
}
#method_after
protected boolean isCinderStorageHasNoDisks() {
    if (getStorageDomain().getStorageType() == StorageType.CINDER) {
        return validate(OpenStackVolumeProviderProxy.getFromStorageDomainId(getStorageDomainId(), providerProxyFactory).getProviderValidator().isCinderHasNoImages());
    }
    return true;
}
#end_block

#method_before
protected boolean isLunsAlreadyInUse(List<String> lunIds) {
    // Get LUNs from DB
    List<LUNs> lunsFromDb = lunDao.getAll();
    Set<LUNs> lunsUsedBySDs = new HashSet<>();
    Set<LUNs> lunsUsedByDisks = new HashSet<>();
    for (LUNs lun : lunsFromDb) {
        if (lunIds.contains(lun.getLUNId())) {
            if (lun.getStorageDomainId() != null) {
                // LUN is already part of a storage domain
                lunsUsedBySDs.add(lun);
            }
            if (lun.getDiskId() != null) {
                // LUN is already used by a disk
                lunsUsedByDisks.add(lun);
            }
        }
    }
    if (!lunsUsedBySDs.isEmpty()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_LUNS_ALREADY_PART_OF_STORAGE_DOMAINS);
        Set<String> formattedIds = lunsUsedBySDs.stream().map(lun -> getFormattedLunId(lun, lun.getStorageDomainName())).collect(toSet());
        addValidationMessageVariable("lunIds", StringUtils.join(formattedIds, ", "));
    }
    if (!lunsUsedByDisks.isEmpty()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_LUNS_ALREADY_USED_BY_DISKS);
        Set<String> formattedIds = lunsUsedByDisks.stream().map(lun -> getFormattedLunId(lun, lun.getDiskAlias())).collect(toSet());
        addValidationMessageVariable("lunIds", StringUtils.join(formattedIds, ", "));
    }
    return !lunsUsedBySDs.isEmpty() || !lunsUsedByDisks.isEmpty();
}
#method_after
protected boolean isLunsAlreadyInUse(Set<String> lunIds) {
    // Get LUNs from DB
    List<LUNs> lunsFromDb = lunDao.getAll();
    Set<LUNs> lunsUsedBySDs = new HashSet<>();
    Set<LUNs> lunsUsedByDisks = new HashSet<>();
    for (LUNs lun : lunsFromDb) {
        if (lunIds.contains(lun.getLUNId())) {
            if (lun.getStorageDomainId() != null) {
                // LUN is already part of a storage domain
                lunsUsedBySDs.add(lun);
            }
            if (lun.getDiskId() != null) {
                // LUN is already used by a disk
                lunsUsedByDisks.add(lun);
            }
        }
    }
    if (!lunsUsedBySDs.isEmpty()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_LUNS_ALREADY_PART_OF_STORAGE_DOMAINS);
        Set<String> formattedIds = lunsUsedBySDs.stream().map(lun -> getFormattedLunId(lun, lun.getStorageDomainName())).collect(toSet());
        addValidationMessageVariable("lunIds", StringUtils.join(formattedIds, ", "));
    }
    if (!lunsUsedByDisks.isEmpty()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_LUNS_ALREADY_USED_BY_DISKS);
        Set<String> formattedIds = lunsUsedByDisks.stream().map(lun -> getFormattedLunId(lun, lun.getDiskAlias())).collect(toSet());
        addValidationMessageVariable("lunIds", StringUtils.join(formattedIds, ", "));
    }
    return !lunsUsedBySDs.isEmpty() || !lunsUsedByDisks.isEmpty();
}
#end_block

#method_before
protected List<Pair<Guid, Boolean>> connectHostsInUpToDomainStorageServer() {
    return performConnectionOpOnAllUpHosts(vds -> StorageHelperDirector.getInstance().getItem(getStorageDomain().getStorageType()).connectStorageToDomainByVdsId(getStorageDomain(), vds.getId()));
}
#method_after
protected List<Pair<Guid, Boolean>> connectHostsInUpToDomainStorageServer() {
    return performConnectionOpOnAllUpHosts(vds -> storageHelperDirector.getItem(getStorageDomain().getStorageType()).connectStorageToDomainByVdsId(getStorageDomain(), vds.getId()));
}
#end_block

#method_before
protected List<Pair<Guid, Boolean>> disconnectHostsInUpToDomainStorageServer() {
    return performConnectionOpOnAllUpHosts(vds -> StorageHelperDirector.getInstance().getItem(getStorageDomain().getStorageType()).disconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId()));
}
#method_after
protected List<Pair<Guid, Boolean>> disconnectHostsInUpToDomainStorageServer() {
    return performConnectionOpOnAllUpHosts(vds -> storageHelperDirector.getItem(getStorageDomain().getStorageType()).disconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId()));
}
#end_block

#method_before
protected StorageDomain electNewMaster(boolean duringReconstruct, boolean selectInactiveWhenNoActiveUnknownDomains, boolean canChooseCurrentMasterAsNewMaster) {
    if (getStoragePool() == null) {
        log.warn("Cannot elect new master: storage pool not found");
        return null;
    }
    List<StorageDomain> storageDomains = storageDomainDao.getAllForStoragePool(getStoragePool().getId());
    if (storageDomains.isEmpty()) {
        log.warn("Cannot elect new master, no storage domains found for pool {}", getStoragePool().getName());
        return null;
    }
    Collections.sort(storageDomains, Comparator.comparing(StorageDomain::getLastTimeUsedAsMaster).thenComparing(Comparator.comparing(StorageDomain::isLocal)));
    StorageDomain newMaster = null;
    StorageDomain storageDomain = getStorageDomain();
    for (StorageDomain dbStorageDomain : storageDomains) {
        if (dbStorageDomain.isHostedEngineStorage()) {
            continue;
        }
        if ((storageDomain == null || (duringReconstruct || !dbStorageDomain.getId().equals(storageDomain.getId()))) && ((dbStorageDomain.getStorageDomainType() == StorageDomainType.Data) && (!dbStorageDomain.isBackup()) || (canChooseCurrentMasterAsNewMaster && dbStorageDomain.getStorageDomainType() == StorageDomainType.Master))) {
            if (dbStorageDomain.getStatus() == StorageDomainStatus.Active || dbStorageDomain.getStatus() == StorageDomainStatus.Unknown) {
                newMaster = dbStorageDomain;
                break;
            } else if (selectInactiveWhenNoActiveUnknownDomains && newMaster == null && dbStorageDomain.getStatus() == StorageDomainStatus.Inactive) {
                // if the found domain is inactive, we don't break to continue and look for
                // active/unknown domain.
                newMaster = dbStorageDomain;
            }
        }
    }
    return newMaster;
}
#method_after
protected StorageDomain electNewMaster(boolean duringReconstruct, boolean selectInactiveWhenNoActiveUnknownDomains, boolean canChooseCurrentMasterAsNewMaster) {
    if (getStoragePool() == null) {
        log.warn("Cannot elect new master: storage pool not found");
        return null;
    }
    List<StorageDomain> storageDomains = storageDomainDao.getAllForStoragePool(getStoragePool().getId());
    if (storageDomains.isEmpty()) {
        log.warn("Cannot elect new master, no storage domains found for pool {}", getStoragePool().getName());
        return null;
    }
    Collections.sort(storageDomains, Comparator.comparing(StorageDomain::getLastTimeUsedAsMaster).thenComparing(Comparator.comparing(StorageDomain::isLocal)));
    StorageDomain newMaster = null;
    StorageDomain storageDomain = getStorageDomain();
    for (StorageDomain dbStorageDomain : storageDomains) {
        if (dbStorageDomain.isHostedEngineStorage()) {
            continue;
        }
        if ((storageDomain == null || (duringReconstruct || !dbStorageDomain.getId().equals(storageDomain.getId()))) && ((dbStorageDomain.getStorageDomainType() == StorageDomainType.Data && !dbStorageDomain.isBackup()) || (canChooseCurrentMasterAsNewMaster && dbStorageDomain.getStorageDomainType() == StorageDomainType.Master))) {
            if (dbStorageDomain.getStatus() == StorageDomainStatus.Active || dbStorageDomain.getStatus() == StorageDomainStatus.Unknown) {
                newMaster = dbStorageDomain;
                break;
            } else if (selectInactiveWhenNoActiveUnknownDomains && newMaster == null && dbStorageDomain.getStatus() == StorageDomainStatus.Inactive) {
                // if the found domain is inactive, we don't break to continue and look for
                // active/unknown domain.
                newMaster = dbStorageDomain;
            }
        }
    }
    return newMaster;
}
#end_block

#method_before
protected IStorageHelper getStorageHelper(StorageDomain storageDomain) {
    return StorageHelperDirector.getInstance().getItem(storageDomain.getStorageType());
}
#method_after
protected IStorageHelper getStorageHelper(StorageDomain storageDomain) {
    return storageHelperDirector.getItem(storageDomain.getStorageType());
}
#end_block

#method_before
protected void createDefaultDiskProfile() {
    executeInNewTransaction(() -> {
        final DiskProfile diskProfile = diskProfileHelper.createDiskProfile(getStorageDomain().getId(), getStorageDomainName());
        DiskProfileParameters diskProfileParameters = new DiskProfileParameters(diskProfile, true);
        runInternalActionWithTasksContext(VdcActionType.AddDiskProfile, diskProfileParameters);
        getCompensationContext().snapshotNewEntity(diskProfile);
        getCompensationContext().stateChanged();
        return null;
    });
}
#method_after
protected void createDefaultDiskProfile() {
    executeInNewTransaction(() -> {
        final DiskProfile diskProfile = diskProfileHelper.createDiskProfile(getStorageDomain().getId(), getStorageDomainName());
        DiskProfileParameters diskProfileParameters = new DiskProfileParameters(diskProfile, true);
        runInternalActionWithTasksContext(ActionType.AddDiskProfile, diskProfileParameters);
        getCompensationContext().snapshotNewEntity(diskProfile);
        getCompensationContext().stateChanged();
        return null;
    });
}
#end_block

#method_before
protected void updateStaticDataDefaults() {
    updateStorageDomainWipeAfterDelete();
    updateSpaceThresholds();
    updateStorageDomainBackup();
}
#method_after
protected void updateStaticDataDefaults() {
    updateStorageDomainWipeAfterDelete();
    updateSpaceThresholds();
}
#end_block

#method_before
protected Pair<Boolean, Integer> connectStorage() {
    String connectionId = getStorageDomain().getStorage();
    StorageServerConnections connection = storageServerConnectionDao.get(connectionId);
    Map<String, String> result = (Map<String, String>) runVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(getParameters().getVdsId(), Guid.Empty, connection.getStorageType(), new ArrayList<>(Collections.singletonList(connection)))).getReturnValue();
    return new Pair<>(StorageHelperDirector.getInstance().getItem(connection.getStorageType()).isConnectSucceeded(result, Collections.singletonList(connection)), Integer.parseInt(result.values().iterator().next()));
}
#method_after
protected Pair<Boolean, Integer> connectStorage() {
    String connectionId = getStorageDomain().getStorage();
    StorageServerConnections connection = storageServerConnectionDao.get(connectionId);
    Map<String, String> result = (Map<String, String>) runVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(getParameters().getVdsId(), Guid.Empty, connection.getStorageType(), new ArrayList<>(Collections.singletonList(connection)))).getReturnValue();
    return new Pair<>(storageHelperDirector.getItem(connection.getStorageType()).isConnectSucceeded(result, Collections.singletonList(connection)), Integer.parseInt(result.values().iterator().next()));
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate() || !initializeVds() || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    if (isStorageWithSameNameExists()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.ISO);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.EXPORT);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && getStorageDomain().getStorageStaticData().isBackup()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_DOES_NOT_SUPPORT_BACKUP);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageStaticData().isBackup()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_DOES_NOT_SUPPORT_BACKUP);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!Guid.isNullOrEmpty(getParameters().getStoragePoolId()) && getTargetStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    ensureStorageFormatInitialized();
    StorageDomainToPoolRelationValidator storageDomainToPoolRelationValidator = getAttachDomainValidator();
    StorageDomainValidator sdValidator = getStorageDomainValidator();
    if (!validate(storageDomainToPoolRelationValidator.isStorageDomainFormatCorrectForDC()) || !validate(sdValidator.isStorageFormatCompatibleWithDomain()) || !validateDiscardAfterDeleteLegal(sdValidator, getTargetStoragePool().getCompatibilityVersion())) {
        return false;
    }
    return canAddDomain();
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate() || !initializeVds() || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    if (isStorageWithSameNameExists()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.ISO);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.EXPORT);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    StorageDomainValidator sdValidator = getStorageDomainValidator();
    if (!validate(sdValidator.isNotIsoOrExportForBackup())) {
        return false;
    }
    ensureStorageFormatInitialized();
    if (!validate(sdValidator.isStorageFormatCompatibleWithDomain())) {
        return false;
    }
    initStorageDomainDiscardAfterDeleteIfNeeded();
    if (!validateDiscardAfterDeleteLegal(sdValidator)) {
        return false;
    }
    return canAddDomain();
}
#end_block

#method_before
private void ensureStorageFormatInitialized() {
    StorageDomain sd = getStorageDomain();
    if (sd.getStorageFormat() == null) {
        if (sd.getStorageDomainType().isDataDomain()) {
            StoragePool sp = getTargetStoragePool();
            if (sp != null) {
                sd.setStorageFormat(VersionStorageFormatUtil.getForVersion(sp.getCompatibilityVersion()));
            }
        } else {
            sd.setStorageFormat(StorageFormatType.V1);
        }
    }
}
#method_after
private void ensureStorageFormatInitialized() {
    StorageDomain sd = getStorageDomain();
    if (sd.getStorageFormat() == null) {
        if (sd.getStorageDomainType().isDataDomain()) {
            sd.setStorageFormat(StorageFormatType.getLatest());
        } else {
            sd.setStorageFormat(StorageFormatType.V1);
        }
    }
}
#end_block

#method_before
public static DiskImage createSnapshotMetadataDisk() {
    DiskImage image = createMetadataDisk();
    image.setDiskAlias(VM_SNAPSHOT_METADATA_DISK_ALIAS);
    image.setDescription(VM_SNAPSHOT_METADATA_DISK_DESCRIPTION);
    return image;
}
#method_after
public static DiskImage createSnapshotMetadataDisk(String diskDescription) {
    DiskImage image = createMetadataDisk(diskDescription);
    image.setDiskAlias(VM_SNAPSHOT_METADATA_DISK_ALIAS);
    return image;
}
#end_block

#method_before
public static DiskImage createHibernationMetadataDisk(VM vm) {
    DiskImage image = createMetadataDisk();
    image.setDiskAlias(generateHibernationMetadataDiskAlias(vm.getName()));
    image.setDescription(VM_HIBERNATION_METADATA_DISK_DESCRIPTION);
    return image;
}
#method_after
public static DiskImage createHibernationMetadataDisk(VM vm) {
    DiskImage image = createMetadataDisk(null);
    image.setDiskAlias(generateHibernationMetadataDiskAlias(vm.getName()));
    image.setDescription(VM_HIBERNATION_METADATA_DISK_DESCRIPTION);
    return image;
}
#end_block

#method_before
public static DiskImage createMetadataDisk() {
    DiskImage image = new DiskImage();
    image.setSize(MemoryUtils.METADATA_SIZE_IN_BYTES);
    image.setVolumeType(VolumeType.Preallocated);
    image.setVolumeFormat(VolumeFormat.RAW);
    image.setContentType(DiskContentType.MEMORY_METADATA_VOLUME);
    return image;
}
#method_after
public static DiskImage createMetadataDisk(String diskDescription) {
    DiskImage image = new DiskImage();
    image.setSize(MemoryUtils.METADATA_SIZE_IN_BYTES);
    image.setVolumeType(VolumeType.Preallocated);
    image.setVolumeFormat(VolumeFormat.RAW);
    image.setContentType(DiskContentType.MEMORY_METADATA_VOLUME);
    image.setDiskDescription(diskDescription);
    return image;
}
#end_block

#method_before
public static DiskImage createSnapshotMemoryDisk(VM vm, StorageType storageType, VmOverheadCalculator vmOverheadCalculator) {
    DiskImage image = createMemoryDisk(vm, storageType, vmOverheadCalculator);
    image.setDiskAlias(VM_SNAPSHOT_MEMORY_DISK_ALIAS);
    image.setDescription(VM_SNAPSHOT_MEMORY_DISK_DESCRIPTION);
    return image;
}
#method_after
public static DiskImage createSnapshotMemoryDisk(VM vm, StorageType storageType, VmOverheadCalculator vmOverheadCalculator, String diskDescription) {
    DiskImage image = createMemoryDisk(vm, storageType, vmOverheadCalculator, diskDescription);
    image.setDiskAlias(VM_SNAPSHOT_MEMORY_DISK_ALIAS);
    return image;
}
#end_block

#method_before
public static DiskImage createHibernationMemoryDisk(VM vm, StorageType storageType, VmOverheadCalculator vmOverheadCalculator) {
    DiskImage image = createMemoryDisk(vm, storageType, vmOverheadCalculator);
    image.setDiskAlias(generateHibernationMemoryDiskAlias(vm.getName()));
    image.setDescription(VM_HIBERNATION_MEMORY_DISK_DESCRIPTION);
    return image;
}
#method_after
public static DiskImage createHibernationMemoryDisk(VM vm, StorageType storageType, VmOverheadCalculator vmOverheadCalculator) {
    DiskImage image = createMemoryDisk(vm, storageType, vmOverheadCalculator, null);
    image.setDiskAlias(generateHibernationMemoryDiskAlias(vm.getName()));
    image.setDescription(VM_HIBERNATION_MEMORY_DISK_DESCRIPTION);
    return image;
}
#end_block

#method_before
public static DiskImage createMemoryDisk(VM vm, StorageType storageType, VmOverheadCalculator vmOverheadCalculator) {
    DiskImage image = new DiskImage();
    image.setSize(vmOverheadCalculator.getSnapshotMemorySizeInBytes(vm));
    image.setVolumeType(storageTypeToMemoryVolumeType(storageType));
    image.setVolumeFormat(VolumeFormat.RAW);
    image.setContentType(DiskContentType.MEMORY_DUMP_VOLUME);
    return image;
}
#method_after
public static DiskImage createMemoryDisk(VM vm, StorageType storageType, VmOverheadCalculator vmOverheadCalculator, String diskDescription) {
    DiskImage image = new DiskImage();
    image.setSize(vmOverheadCalculator.getSnapshotMemorySizeInBytes(vm));
    image.setVolumeType(storageTypeToMemoryVolumeType(storageType));
    image.setVolumeFormat(VolumeFormat.RAW);
    image.setContentType(DiskContentType.MEMORY_DUMP_VOLUME);
    image.setDiskDescription(diskDescription);
    return image;
}
#end_block

#method_before
private void addMemoryImages() {
    getVm().getSnapshots().stream().filter(snapshot -> !StringUtils.isEmpty(snapshot.getMemoryVolume())).forEach(snapshot -> {
        addDisk(createMemoryDisk(snapshot));
        addDisk(createMetadataDisk(snapshot));
    });
}
#method_after
private void addMemoryImages() {
    getVm().getSnapshots().stream().filter(snapshot -> !StringUtils.isEmpty(snapshot.getMemoryVolume())).forEach(snapshot -> {
        addDisk(createMemoryDisk(snapshot));
        addDisk(createMetadataDisk(getVm(), snapshot));
    });
}
#end_block

#method_before
private DiskImage createMemoryDisk(Snapshot snapshot) {
    List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
    VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
    DiskImage memoryDisk = MemoryUtils.createMemoryDisk(vm, storageDomainStaticDao.get(guids.get(0)).getStorageType(), vmOverheadCalculator);
    memoryDisk.setId(guids.get(2));
    memoryDisk.setImageId(guids.get(3));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    return memoryDisk;
}
#method_after
private DiskImage createMemoryDisk(Snapshot snapshot) {
    List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
    VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
    DiskImage memoryDisk = MemoryUtils.createMemoryDisk(vm, storageDomainStaticDao.get(guids.get(0)).getStorageType(), vmOverheadCalculator, MemoryUtils.generateMemoryDiskDescription(vm, snapshot.getDescription()));
    memoryDisk.setId(guids.get(2));
    memoryDisk.setImageId(guids.get(3));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    return memoryDisk;
}
#end_block

#method_before
private DiskImage createMetadataDisk(Snapshot snapshot) {
    List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
    DiskImage memoryDisk = MemoryUtils.createMetadataDisk();
    memoryDisk.setId(guids.get(4));
    memoryDisk.setImageId(guids.get(5));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    return memoryDisk;
}
#method_after
private DiskImage createMetadataDisk(VM vm, Snapshot snapshot) {
    List<Guid> guids = Guid.createGuidListFromString(snapshot.getMemoryVolume());
    DiskImage memoryDisk = MemoryUtils.createMetadataDisk(MemoryUtils.generateMemoryDiskDescription(vm, snapshot.getDescription()));
    memoryDisk.setId(guids.get(4));
    memoryDisk.setImageId(guids.get(5));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    return memoryDisk;
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    mandatory(imageTransfer().diskSnapshot().id());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(imageTransfer().snapshot().id());
}
#end_block

#method_before
private void writeCpuTune() {
    @SuppressWarnings("unchecked")
    Map<String, Object> cpuPinning = (Map<String, Object>) createInfo.get(VdsProperties.cpuPinning);
    if (cpuPinning == null) {
        return;
    }
    writer.writeStartElement("cputune");
    cpuPinning.forEach((vcpu, cpuset) -> {
        writer.writeStartElement("vcpupin");
        writer.writeAttributeString("vcpu", vcpu);
        writer.writeAttributeString("cpuset", (String) cpuset);
        writer.writeEndElement();
    });
    writer.writeEndElement();
}
#method_after
private void writeCpuTune() {
    writer.writeStartElement("cputune");
    @SuppressWarnings("unchecked")
    Map<String, Object> cpuPinning = (Map<String, Object>) createInfo.get(VdsProperties.cpuPinning);
    if (cpuPinning != null) {
        cpuPinning.forEach((vcpu, cpuset) -> {
            writer.writeStartElement("vcpupin");
            writer.writeAttributeString("vcpu", vcpu);
            writer.writeAttributeString("cpuset", (String) cpuset);
            writer.writeEndElement();
        });
    }
    if (vm.getCpuShares() > 0) {
        writer.writeElement("shares", String.valueOf(vm.getCpuShares()));
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeMetadata() {
    // <domain>
    // ...
    // <metadata>
    // <ovirt-tune:qos/>
    // <ovirt-vm:vm/>
    // </metadata>
    // ...
    // </domain>
    writer.writeStartElement("metadata");
    writeQosMetadata();
    writeVmMetadata();
    writeNetworkInterfaceMetadata();
    writer.writeEndElement();
}
#method_after
private void writeMetadata() {
    // <domain>
    // ...
    // <metadata>
    // <ovirt-tune:qos/>
    // <ovirt-vm:vm/>
    // </metadata>
    // ...
    // </domain>
    writer.writeStartElement("metadata");
    writeQosMetadata();
    writeVmMetadata();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeNetworkInterfaceMetadata() {
    vnicMetadata.forEach((mac, data) -> {
        writer.writeStartElement(OVIRT_VM_URI, "device");
        writer.writeAttributeString("mac_address", mac);
        data.forEach((key, value) -> writer.writeElement(OVIRT_VM_URI, key, value));
        writer.writeEndElement();
    });
}
#method_after
private void writeNetworkInterfaceMetadata() {
    vnicMetadata.forEach((mac, data) -> {
        writer.writeStartElement("device");
        writer.writeAttributeString("mac_address", mac);
        List<String> portMirroring = (List<String>) data.get("portMirroring");
        if (portMirroring != null) {
            writer.writeStartElement("portMirroring");
            portMirroring.forEach(network -> writer.writeElement("network", network));
            writer.writeEndElement();
        }
        writer.writeEndElement();
    });
}
#end_block

#method_before
private void writeVmMetadata() {
    writer.writeStartElement(OVIRT_VM_URI, "vm");
    writeMinGuaranteedMemoryMetadata();
    writeClusterVersionMetadata();
    writeVmCustomMetadata();
    writer.writeEndElement();
}
#method_after
private void writeVmMetadata() {
    writer.writeStartElement(OVIRT_VM_URI, "vm");
    writeMinGuaranteedMemoryMetadata();
    writeClusterVersionMetadata();
    writeVmCustomMetadata();
    writeNetworkInterfaceMetadata();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeCdRom(List<VmDevice> devices) {
    // <disk type='file' device='cdrom' snapshot='no'>
    // <driver name='qemu' type='raw'/>
    // <source file='<path>' startupPolicy='optional'/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    devices.stream().filter(d -> VmPayload.isPayload(d.getSpecParams())).forEach(device -> {
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("source");
        writer.writeAttributeString("file", "PAYLOAD:");
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        payloadIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, payloadIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if ("scsi".equals(cdInterface)) {
            int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
            writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
        writer.writeEndElement();
    });
    VmDevice nonPayload = devices.stream().filter(d -> !VmPayload.isPayload(d.getSpecParams())).findAny().orElse(null);
    if (nonPayload != null || (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath()))) {
        // add a device that points to vm.getCdPath()
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("source");
        writer.writeAttributeString("file", vm.getCdPath());
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if (nonPayload != null) {
            writeAddress(nonPayload);
            writeBootOrder(nonPayload.getBootOrder());
        }
        writer.writeEndElement();
    }
}
#method_after
private void writeCdRom(List<VmDevice> devices) {
    // <disk type='file' device='cdrom' snapshot='no'>
    // <driver name='qemu' type='raw' error_policy='report' />
    // <source file='<path>' startupPolicy='optional'/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    devices.stream().filter(d -> VmPayload.isPayload(d.getSpecParams())).forEach(device -> {
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", "PAYLOAD:");
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        payloadIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, payloadIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if ("scsi".equals(cdInterface)) {
            int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
            writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
        writer.writeEndElement();
    });
    VmDevice nonPayload = devices.stream().filter(d -> !VmPayload.isPayload(d.getSpecParams())).findAny().orElse(null);
    if (nonPayload != null || (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath()))) {
        // add a device that points to vm.getCdPath()
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", vm.getCdPath());
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if (nonPayload != null) {
            writeAddress(nonPayload);
            writeBootOrder(nonPayload.getBootOrder());
        }
        writer.writeEndElement();
    }
}
#end_block

#method_before
private void writeInterface(VmDevice device, VmNetworkInterface nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    Map<String, String> properties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    VnicProfile vnicProfile = vnicProfileDao.get(nic.getVnicProfileId());
    Network network = networkDao.get(vnicProfile.getNetworkId());
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            writer.writeAttributeString("type", ifaceType == VmInterfaceType.pv ? "virtio" : ifaceType.getInternalName());
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", network.getVdsmName());
            writer.writeEndElement();
            String queues = vnicProfile.getCustomProperties().get("queues");
            String driverName = getDriverNameForNetwork(nic.getNetworkName(), properties);
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.entrySet().forEach(e -> writer.writeAttributeString(e.getKey(), e.getValue()));
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmNicFilterParameterDao.getAllForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    if (properties.containsKey("sndbuf")) {
        writer.writeStartElement("tune");
        writer.writeStartElement("sndbuf");
        writer.writeRaw(properties.get("sndbuf"));
        writer.writeEndElement();
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring.stream().collect(Collectors.joining(",")));
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNetworkInterface nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    Map<String, String> properties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    VnicProfile vnicProfile = vnicProfileDao.get(nic.getVnicProfileId());
    Network network = networkDao.get(vnicProfile.getNetworkId());
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            writer.writeAttributeString("type", ifaceType == VmInterfaceType.pv ? "virtio" : ifaceType.getInternalName());
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", network.getVdsmName());
            writer.writeEndElement();
            String queues = vnicProfile.getCustomProperties().get("queues");
            String driverName = getDriverNameForNetwork(nic.getNetworkName(), properties);
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.entrySet().forEach(e -> writer.writeAttributeString(e.getKey(), e.getValue()));
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmNicFilterParameterDao.getAllForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    if (properties.containsKey("sndbuf")) {
        writer.writeStartElement("tune");
        writer.writeStartElement("sndbuf");
        writer.writeRaw(properties.get("sndbuf"));
        writer.writeEndElement();
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void initFirewallType() {
    ListModel<FirewallType> firewallType = getFirewallType();
    firewallType.setItems(Arrays.asList(FirewallType.values()));
    firewallType.setIsChangeable(false);
    firewallType.setSelectedItem(FirewallType.FIREWALLD);
}
#method_after
private void initFirewallType() {
    ListModel<FirewallType> firewallType = getFirewallType();
    firewallType.setItems(Arrays.asList(FirewallType.values()));
    firewallType.setIsChangeable(true);
    firewallType.setSelectedItem(FirewallType.FIREWALLD);
}
#end_block

#method_before
private void updateFirewallTypeUponVersionChange(Version version) {
    ListModel<FirewallType> firewallType = getFirewallType();
    firewallType.setIsChangeable(version.equals(Version.v4_2));
    if (version.greater(Version.v4_2)) {
        firewallType.setSelectedItem(FirewallType.FIREWALLD);
    } else if (version.less(Version.v4_2)) {
        firewallType.setSelectedItem(FirewallType.IPTABLES);
    }
}
#method_after
private void updateFirewallTypeUponVersionChange(Version version) {
    ListModel<FirewallType> firewallType = getFirewallType();
    if (version.less(AsyncDataProvider.getInstance().multiFirewallSupportSince())) {
        firewallType.setIsChangeable(false);
        firewallType.setSelectedItem(FirewallType.IPTABLES);
    } else {
        firewallType.setIsChangeable(true);
    }
}
#end_block

#method_before
private void setDetailList(final ClusterGeneralModel clusterGeneralModel, final ClusterNetworkListModel clusterNetworkListModel, final ClusterHostListModel clusterHostListModel, final PermissionListModel<Cluster> permissionListModel) {
    List<HasEntity<Cluster>> list = new ArrayList<>();
    list.add(clusterGeneralModel);
    list.add(clusterNetworkListModel);
    list.add(clusterHostListModel);
    list.add(clusterVmListModel);
    list.add(clusterServiceModel);
    list.add(clusterGlusterHookListModel);
    list.add(cpuProfileListModel);
    list.add(permissionListModel);
    list.add(affinityGroupListModel);
    list.add(affinityLabelListModel);
    setDetailModels(list);
}
#method_after
private void setDetailList() {
    List<HasEntity<Cluster>> list = new ArrayList<>();
    list.add(generalModel);
    list.add(networkListModel);
    list.add(hostListModel);
    list.add(vmListModel);
    list.add(serviceModel);
    list.add(glusterHookListModel);
    list.add(cpuProfileListModel);
    list.add(permissionListModel);
    list.add(affinityGroupListModel);
    list.add(affinityLabelListModel);
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    Cluster cluster = getSelectedItem();
    boolean clusterSupportsVirtService = cluster != null && cluster.supportsVirtService();
    boolean clusterSupportsGlusterService = cluster != null && cluster.supportsGlusterService();
    getClusterVmListModel().setIsAvailable(clusterSupportsVirtService);
    getClusterServiceModel().setIsAvailable(clusterSupportsGlusterService);
    getClusterGlusterHookListModel().setIsAvailable(clusterSupportsGlusterService);
    getAffinityGroupListModel().setIsAvailable(clusterSupportsVirtService);
    getCpuProfileListModel().setIsAvailable(clusterSupportsVirtService);
    getAffinityLabelListModel().setIsAvailable(clusterSupportsVirtService);
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    Cluster cluster = getSelectedItem();
    boolean clusterSupportsVirtService = cluster != null && cluster.supportsVirtService();
    boolean clusterSupportsGlusterService = cluster != null && cluster.supportsGlusterService();
    getVmListModel().setIsAvailable(clusterSupportsVirtService);
    getServiceModel().setIsAvailable(clusterSupportsGlusterService);
    getGlusterHookListModel().setIsAvailable(clusterSupportsGlusterService);
    getAffinityGroupListModel().setIsAvailable(clusterSupportsVirtService);
    getCpuProfileListModel().setIsAvailable(clusterSupportsVirtService);
    getAffinityLabelListModel().setIsAvailable(clusterSupportsVirtService);
}
#end_block

#method_before
public void onRemove() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<ActionParametersBase> prms = new ArrayList<>();
    for (Object a : getSelectedItems()) {
        prms.add(new ClusterParametersBase(((Cluster) a).getId()));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.RemoveCluster, prms, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#method_after
public void onRemove() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<ActionParametersBase> prms = new ArrayList<>();
    for (Object a : getSelectedItems()) {
        prms.add(new ClusterParametersBase(((Cluster) a).getId()));
    }
    selectNextItem();
    model.startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.RemoveCluster, prms, result -> {
        ConfirmationModel localModel = (ConfirmationModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, model);
}
#end_block

#method_before
public static FirewallType getDefaultFirewallType(Version clusterCompatibilityVersion) {
    return clusterCompatibilityVersion.less(Version.v4_2) ? FirewallType.IPTABLES : FirewallType.FIREWALLD;
}
#method_after
public static FirewallType getDefaultFirewallType(Version clusterCompatibilityVersion) {
    return clusterCompatibilityVersion.greater(Version.v3_6) ? FirewallType.FIREWALLD : FirewallType.IPTABLES;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid newMacPoolId = getNewMacPoolId();
    moveMacs.moveMacsOfUpdatedCluster(oldCluster, newMacPoolId, getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    setDefaultFirewallTypeIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    clusterDao.update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
        // update gluster parameters on all hosts
        updateGlusterHosts();
    }
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        final NetworkCluster managementNetworkCluster = createManagementNetworkCluster();
        networkClusterDao.save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    updateVms();
    updateTemplates();
    if (!failedUpgradeEntities.isEmpty()) {
        logFailedUpgrades();
        failValidation(Arrays.asList(EngineMessage.CLUSTER_CANNOT_UPDATE_CLUSTER_FAILED_TO_UPDATE_VMS), "$VmList " + StringUtils.join(failedUpgradeEntities.keySet(), ", "));
        getReturnValue().setValid(false);
        setSucceeded(false);
        return;
    }
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid newMacPoolId = getNewMacPoolId();
    moveMacs.migrateMacsToAnotherMacPool(oldCluster, newMacPoolId, getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    setDefaultFirewallTypeIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    clusterDao.update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
        // update gluster parameters on all hosts
        updateGlusterHosts();
    }
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        final NetworkCluster managementNetworkCluster = createManagementNetworkCluster();
        networkClusterDao.save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    updateVms();
    updateTemplates();
    if (!failedUpgradeEntities.isEmpty()) {
        logFailedUpgrades();
        failValidation(Arrays.asList(EngineMessage.CLUSTER_CANNOT_UPDATE_CLUSTER_FAILED_TO_UPDATE_VMS), "$VmList " + StringUtils.join(failedUpgradeEntities.keySet(), ", "));
        getReturnValue().setValid(false);
        setSucceeded(false);
        return;
    }
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = vdsDao.getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = vmDao.getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result && !oldCluster.getCompatibilityVersion().equals(getCluster().getCompatibilityVersion())) {
        for (VM vm : vmList) {
            if (vm.isPreviewSnapshot()) {
                // can't change cluster version when a VM is in preview
                if (result) {
                    addValidationMessage(EngineMessage.CLUSTER_VERSION_CHANGE_VM_PREVIEW);
                    // and continue with adding validation messages
                    result = false;
                }
                addValidationMessage(vm.getName());
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetwork()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(this, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = storagePoolDao.get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!clusterDao.getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = glusterVolumeDao.getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    ClusterValidator clusterValidator = new ClusterValidator(getDbFacade(), getCluster(), cpuFlagsManagerHandler);
    result = result && validate(clusterValidator.rngSourcesAllowed()) && validate(clusterValidator.memoryOptimizationConfiguration());
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = vdsDao.getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = vmDao.getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result && !oldCluster.getCompatibilityVersion().equals(getCluster().getCompatibilityVersion())) {
        for (VM vm : vmList) {
            if (vm.isPreviewSnapshot()) {
                // can't change cluster version when a VM is in preview
                if (result) {
                    addValidationMessage(EngineMessage.CLUSTER_VERSION_CHANGE_VM_PREVIEW);
                    // and continue with adding validation messages
                    result = false;
                }
                addValidationMessage(vm.getName());
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetwork()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(this, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = storagePoolDao.get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!clusterDao.getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = glusterVolumeDao.getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    ClusterValidator clusterValidator = new ClusterValidator(getDbFacade(), getCluster(), cpuFlagsManagerHandler);
    result = result && validate(clusterValidator.rngSourcesAllowed()) && validate(clusterValidator.memoryOptimizationConfiguration()) && validate(moveMacs.canMigrateMacsToAnotherMacPool(oldCluster, getNewMacPoolId()));
    return result;
}
#end_block

#method_before
public String build() {
    writeHeader();
    writeName();
    writeId();
    writeMemory();
    writeIoThreads();
    writeMaxMemory();
    writevCpu();
    writeSystemInfo();
    writeClock();
    writePowerEvents();
    writeFeatures();
    writeCpu();
    writeCpuTune();
    writeNumaTune();
    writeDevices();
    // note that this must be called after writeDevices to get the serial console, if exists
    writeOs();
    writeMetadata();
    return writer.getStringXML();
}
#method_after
public String build() {
    writeHeader();
    writeName();
    writeId();
    writeMemory();
    writeIoThreads();
    writeMaxMemory();
    writevCpu();
    writeMetadata();
    writeSystemInfo();
    writeClock();
    writePowerEvents();
    writeFeatures();
    writeCpu();
    writeCpuTune();
    writeNumaTune();
    writeDevices();
    // note that this must be called after writeDevices to get the serial console, if exists
    writeOs();
    return writer.getStringXML();
}
#end_block

#method_before
private void writeMetadata() {
    // <domain>
    // ...
    // <metadata>
    // <ovirt-tune:qos/>
    // <ovirt-vm:vm/>
    // </metadata>
    // ...
    // </domain>
    writer.writeStartElement("metadata");
    writeQosMetadata();
    writeVmMetadata();
    writeNetworkInterfaceMetadata();
    writer.writeEndElement();
}
#method_after
private void writeMetadata() {
    // <domain>
    // ...
    // <metadata>
    // <ovirt-tune:qos/>
    // <ovirt-vm:vm/>
    // </metadata>
    // ...
    // </domain>
    writer.writeStartElement("metadata");
    writeQosMetadata();
    writeVmMetadata();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    writer.writeStartElement("devices");
    writeInput();
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if (device.getSpecParams() != null && "serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                writeHostDevice(new VmHostDevice(device), hostDevicesSupplier.get().get(device.getDevice()));
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    writer.writeStartElement("devices");
    writeInput();
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    MemoizingSupplier<Map<String, HostDevice>> hostDevicesSupplier = new MemoizingSupplier<>(() -> {
        return hostDeviceDao.getHostDevicesByHostId(hostId).stream().collect(Collectors.toMap(HostDevice::getDeviceName, device -> device));
    });
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if (device.getSpecParams() != null && "serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                writeHostDevice(new VmHostDevice(device), hostDevicesSupplier.get().get(device.getDevice()));
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeLease() {
    if (vm.getLeaseStorageDomainId() == null) {
        return;
    }
    writer.writeStartElement("lease");
    writer.writeElement("key", vm.getId().toString());
    writer.writeElement("lockspace", vm.getLeaseStorageDomainId().toString());
    writer.writeStartElement("target");
    Map<String, String> leaseInfo = vm.getStaticData().getLeaseInfo();
    writer.writeAttributeString("offset", leaseInfo.get(VdsProperties.VmLeaseOffset));
    writer.writeAttributeString("path", leaseInfo.get(VdsProperties.VmLeasePath));
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeLease() {
    if (vm.getLeaseStorageDomainId() == null) {
        return;
    }
    writer.writeStartElement("lease");
    writer.writeElement("key", vm.getId().toString());
    writer.writeElement("lockspace", vm.getLeaseStorageDomainId().toString());
    writer.writeStartElement("target");
    Map<String, String> leaseInfo = vm.getStaticData().getLeaseInfo();
    writer.writeAttributeString("offset", String.valueOf(leaseInfo.get(VdsProperties.VmLeaseOffset)));
    writer.writeAttributeString("path", leaseInfo.get(VdsProperties.VmLeasePath));
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeInterface(VmDevice device, VmNetworkInterface nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    Map<String, String> properties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    VnicProfile vnicProfile = vnicProfileDao.get(nic.getVnicProfileId());
    Network network = networkDao.get(vnicProfile.getNetworkId());
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            writer.writeAttributeString("type", ifaceType == VmInterfaceType.pv ? "virtio" : ifaceType.getInternalName());
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", network.getVdsmName());
            writer.writeEndElement();
            String queues = vnicProfile.getCustomProperties().get("queues");
            String driverName = getDriverNameForNetwork(nic.getNetworkName(), properties);
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.entrySet().forEach(e -> writer.writeAttributeString(e.getKey(), e.getValue()));
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmNicFilterParameterDao.getAllForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    if (properties.containsKey("sndbuf")) {
        writer.writeStartElement("tune");
        writer.writeStartElement("sndbuf");
        writer.writeRaw(properties.get("sndbuf"));
        writer.writeEndElement();
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring.stream().collect(Collectors.joining(",")));
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNetworkInterface nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    Map<String, String> properties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    VnicProfile vnicProfile = vnicProfileDao.get(nic.getVnicProfileId());
    Network network = networkDao.get(vnicProfile.getNetworkId());
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            writer.writeAttributeString("type", ifaceType == VmInterfaceType.pv ? "virtio" : ifaceType.getInternalName());
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", network.getVdsmName());
            writer.writeEndElement();
            String queues = vnicProfile.getCustomProperties().get("queues");
            String driverName = getDriverNameForNetwork(nic.getNetworkName(), properties);
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            // writer.writeEndElement();
            break;
    }
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmNicFilterParameterDao.getAllForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    if (properties.containsKey("sndbuf")) {
        writer.writeStartElement("tune");
        writer.writeStartElement("sndbuf");
        writer.writeRaw(properties.get("sndbuf"));
        writer.writeEndElement();
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private Set<Guid> findNonResponsiveHosts(List<VDS> hosts) {
    final Set<Guid> nonResponsiveHosts = new HashSet<>();
    for (VDS host : hosts) {
        if (host.getStatus() == VDSStatus.NonResponsive) {
            nonResponsiveHosts.add(host.getId());
        }
        if ((host.getStatus() == VDSStatus.Down || host.getStatus() == VDSStatus.Reboot) && host.isInFenceFlow()) {
            host.setStatus(VDSStatus.NonResponsive);
            nonResponsiveHosts.add(host.getId());
        }
    }
    return nonResponsiveHosts;
}
#method_after
private Set<Guid> findNonResponsiveHosts(List<VDS> hosts) {
    final Set<Guid> nonResponsiveHosts = new HashSet<>();
    for (VDS host : hosts) {
        if (host.getStatus() == VDSStatus.NonResponsive) {
            nonResponsiveHosts.add(host.getId());
        }
        if (host.isInFenceFlow() && (host.getStatus() == VDSStatus.Down || host.getStatus() == VDSStatus.Reboot)) {
            host.setStatus(VDSStatus.NonResponsive);
            nonResponsiveHosts.add(host.getId());
        }
    }
    return nonResponsiveHosts;
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VdsDynamic vds) {
    return getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getCpuCores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getCpuModel()).addValue("online_cpus", vds.getOnlineCpus()).addValue("cpu_speed_mh", vds.getCpuSpeedMh()).addValue("if_total_speed", vds.getIfTotalSpeed()).addValue("kvm_enabled", vds.getKvmEnabled()).addValue("mem_commited", vds.getMemCommited()).addValue("physical_mem_mb", vds.getPhysicalMemMb()).addValue("status", vds.getStatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getVmActive()).addValue("vm_count", vds.getVmCount()).addValue("vms_cores_count", vds.getVmsCoresCount()).addValue("vm_migrating", vds.getVmMigrating()).addValue("incoming_migrations", vds.getIncomingMigrations()).addValue("outgoing_migrations", vds.getOutgoingMigrations()).addValue("reserved_mem", vds.getReservedMem()).addValue("guest_overhead", vds.getGuestOverhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getSoftwareVersion()).addValue("version_name", vds.getVersionName()).addValue("build_name", vds.getBuildName()).addValue("previous_status", vds.getPreviousStatus()).addValue("cpu_flags", vds.getCpuFlags()).addValue("pending_vcpus_count", vds.getPendingVcpusCount()).addValue("pending_vmem_size", vds.getPendingVmemSize()).addValue("cpu_sockets", vds.getCpuSockets()).addValue("net_config_dirty", vds.getNetConfigDirty()).addValue("supported_cluster_levels", vds.getSupportedClusterLevels()).addValue("supported_engines", vds.getSupportedEngines()).addValue("host_os", vds.getHostOs()).addValue("kvm_version", vds.getKvmVersion()).addValue("libvirt_version", vds.getLibvirtVersion().getRpmName()).addValue("spice_version", vds.getSpiceVersion()).addValue("gluster_version", vds.getGlusterVersion().getRpmName()).addValue("librbd1_version", vds.getLibrbdVersion().getRpmName()).addValue("glusterfs_cli_version", vds.getGlusterfsCliVersion().getRpmName()).addValue("kernel_version", vds.getKernelVersion()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily()).addValue("hbas", new JsonObjectSerializer().serialize(vds.getHBAs())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines()).addValue("kdump_status", vds.getKdumpStatus().getAsNumber()).addValue("selinux_enforce_mode", (vds.getSELinuxEnforceMode() != null) ? vds.getSELinuxEnforceMode().toInt() : null).addValue("auto_numa_balancing", vds.getAutoNumaBalancing().getValue()).addValue("is_numa_supported", vds.isNumaSupport()).addValue("supported_rng_sources", VmRngDevice.sourcesToCsv(vds.getSupportedRngSources())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines()).addValue("maintenance_reason", vds.getMaintenanceReason()).addValue("is_update_available", vds.isUpdateAvailable()).addValue("kernel_args", vds.getKernelArgs()).addValue("is_hostdev_enabled", vds.isHostDevicePassthroughEnabled()).addValue("pretty_name", vds.getPrettyName()).addValue("hosted_engine_configured", vds.isHostedEngineConfigured()).addValue("dns_resolver_configuration_id", getReportedDnsResolverConfigurationId(vds)).addValue("is_in_fence_flow", vds.isInFenceFlow());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VdsDynamic vds) {
    return getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getCpuCores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getCpuModel()).addValue("online_cpus", vds.getOnlineCpus()).addValue("cpu_speed_mh", vds.getCpuSpeedMh()).addValue("if_total_speed", vds.getIfTotalSpeed()).addValue("kvm_enabled", vds.getKvmEnabled()).addValue("mem_commited", vds.getMemCommited()).addValue("physical_mem_mb", vds.getPhysicalMemMb()).addValue("status", vds.getStatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getVmActive()).addValue("vm_count", vds.getVmCount()).addValue("vms_cores_count", vds.getVmsCoresCount()).addValue("vm_migrating", vds.getVmMigrating()).addValue("incoming_migrations", vds.getIncomingMigrations()).addValue("outgoing_migrations", vds.getOutgoingMigrations()).addValue("reserved_mem", vds.getReservedMem()).addValue("guest_overhead", vds.getGuestOverhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getSoftwareVersion()).addValue("version_name", vds.getVersionName()).addValue("build_name", vds.getBuildName()).addValue("previous_status", vds.getPreviousStatus()).addValue("cpu_flags", vds.getCpuFlags()).addValue("pending_vcpus_count", vds.getPendingVcpusCount()).addValue("pending_vmem_size", vds.getPendingVmemSize()).addValue("cpu_sockets", vds.getCpuSockets()).addValue("net_config_dirty", vds.getNetConfigDirty()).addValue("supported_cluster_levels", vds.getSupportedClusterLevels()).addValue("supported_engines", vds.getSupportedEngines()).addValue("host_os", vds.getHostOs()).addValue("kvm_version", vds.getKvmVersion()).addValue("libvirt_version", vds.getLibvirtVersion().getRpmName()).addValue("spice_version", vds.getSpiceVersion()).addValue("gluster_version", vds.getGlusterVersion().getRpmName()).addValue("librbd1_version", vds.getLibrbdVersion().getRpmName()).addValue("glusterfs_cli_version", vds.getGlusterfsCliVersion().getRpmName()).addValue("kernel_version", vds.getKernelVersion()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily()).addValue("hbas", new JsonObjectSerializer().serialize(vds.getHBAs())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines()).addValue("kdump_status", vds.getKdumpStatus().getAsNumber()).addValue("selinux_enforce_mode", (vds.getSELinuxEnforceMode() != null) ? vds.getSELinuxEnforceMode().toInt() : null).addValue("auto_numa_balancing", vds.getAutoNumaBalancing().getValue()).addValue("is_numa_supported", vds.isNumaSupport()).addValue("supported_rng_sources", VmRngDevice.sourcesToCsv(vds.getSupportedRngSources())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines()).addValue("maintenance_reason", vds.getMaintenanceReason()).addValue("is_update_available", vds.isUpdateAvailable()).addValue("kernel_args", vds.getKernelArgs()).addValue("is_hostdev_enabled", vds.isHostDevicePassthroughEnabled()).addValue("pretty_name", vds.getPrettyName()).addValue("hosted_engine_configured", vds.isHostedEngineConfigured()).addValue("dns_resolver_configuration_id", getReportedDnsResolverConfigurationId(vds)).addValue("in_fence_flow", vds.isInFenceFlow());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDS host = getVds();
    if (!previousHostedEngineHost.isPreviousHostId(host.getId()) && !new FenceValidator().isStartupTimeoutPassed() && !host.isInFenceFlow()) {
        log.error("Failed to run Fence script on vds '{}'.", getVdsName());
        alertIfPowerManagementOperationSkipped();
        // If fencing can't be done and the host is the SPM, set storage-pool to non-operational
        if (host.getSpmStatus() != VdsSpmStatus.None) {
            setStoragePoolNonOperational();
        }
        return;
    }
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (shouldFencingBeSkipped(getVds())) {
        setSucceeded(false);
        setCommandShouldBeLogged(false);
        return;
    }
    boolean shouldBeFenced = getVds().shouldVdsBeFenced();
    ActionReturnValue restartVdsResult = null;
    if (shouldBeFenced) {
        getParameters().setParentCommand(ActionType.VdsNotRespondingTreatment);
        ActionReturnValue retVal;
        retVal = runInternalAction(ActionType.SshSoftFencing, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // SSH Soft Fencing was successful and host is Up, stop non responding treatment
            getReturnValue().setSucceeded(true);
            return;
        }
        // proceed with non responding treatment only if PM action are allowed and PM enabled for host
        if (!monitoringStrategyFactory.getMonitoringStrategyForVds(getVds()).isPowerManagementSupported() || !getVds().isPmEnabled()) {
            setSucceeded(false);
            setCommandShouldBeLogged(false);
            return;
        }
        retVal = runInternalAction(ActionType.VdsKdumpDetection, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = clusterDao.get(getVds().getClusterId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        waitUntilSkipFencingIfSDActiveAllowed(fencingPolicy.isSkipFencingIfSDActive());
        restartVdsResult = runInternalAction(ActionType.RestartVds, getParameters(), cloneContext().withoutExecutionContext());
    } else {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (restartVdsResult != null && restartVdsResult.getActionReturnValue() != null && restartVdsResult.<RestartVdsResult>getActionReturnValue().isSkippedDueToFencingPolicy()) {
        // fencing was skipped, fire an alert and suppress standard command logging
        AuditLogable alb = createAuditLogableForHost(getVds());
        auditLogDirector.log(alb, AuditLogType.VDS_ALERT_NOT_RESTARTED_DUE_TO_POLICY);
        setSucceeded(false);
        setCommandShouldBeLogged(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#method_after
@Override
protected void executeCommand() {
    VDS host = getVds();
    if (!previousHostedEngineHost.isPreviousHostId(host.getId()) && !new FenceValidator().isStartupTimeoutPassed() && !host.isInFenceFlow()) {
        log.error("Failed to run Fence script on vds '{}'.", getVdsName());
        alertIfPowerManagementOperationSkipped();
        // If fencing can't be done and the host is the SPM, set storage-pool to non-operational
        if (host.getSpmStatus() != VdsSpmStatus.None) {
            setStoragePoolNonOperational();
        }
        return;
    }
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (shouldFencingBeSkipped(getVds())) {
        setSucceeded(false);
        setCommandShouldBeLogged(false);
        return;
    }
    boolean shouldBeFenced = getVds().shouldVdsBeFenced();
    ActionReturnValue restartVdsResult = null;
    if (shouldBeFenced) {
        getParameters().setParentCommand(ActionType.VdsNotRespondingTreatment);
        ActionReturnValue retVal;
        retVal = runInternalAction(ActionType.SshSoftFencing, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // SSH Soft Fencing was successful and host is Up, stop non responding treatment
            getReturnValue().setSucceeded(true);
            return;
        }
        // proceed with non responding treatment only if PM action are allowed and PM enabled for host
        if (!monitoringStrategyFactory.getMonitoringStrategyForVds(getVds()).isPowerManagementSupported() || !getVds().isPmEnabled()) {
            setSucceeded(false);
            setCommandShouldBeLogged(false);
            return;
        }
        retVal = runInternalAction(ActionType.VdsKdumpDetection, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = clusterDao.get(getVds().getClusterId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        waitUntilSkipFencingIfSDActiveAllowed(fencingPolicy.isSkipFencingIfSDActive());
        restartVdsResult = runInternalAction(ActionType.RestartVds, getParameters(), cloneContext().withoutExecutionContext());
    } else {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (restartVdsResult != null && restartVdsResult.<RestartVdsResult>getActionReturnValue() != null && restartVdsResult.<RestartVdsResult>getActionReturnValue().isSkippedDueToFencingPolicy()) {
        // fencing was skipped, fire an alert and suppress standard command logging
        AuditLogable alb = createAuditLogableForHost(getVds());
        auditLogDirector.log(alb, AuditLogType.VDS_ALERT_NOT_RESTARTED_DUE_TO_POLICY);
        setSucceeded(false);
        setCommandShouldBeLogged(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#end_block

#method_before
public boolean isInFenceFlow() {
    return isInFenceFlow;
}
#method_after
public boolean isInFenceFlow() {
    return inFenceFlow;
}
#end_block

#method_before
public void setInFenceFlow(boolean isInFenceFlow) {
    this.isInFenceFlow = isInFenceFlow;
}
#method_after
public void setInFenceFlow(boolean isInFenceFlow) {
    this.inFenceFlow = isInFenceFlow;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, supportedClusterVersionsSet, supportedEngineVersionsSet, buildName, cpuCores, cpuThreads, cpuFlags, cpuModel, cpuSockets, cpuSpeedMh, onlineCpus, guestOverhead, hooksStr, hostOs, iScsiInitiatorName, ifTotalSpeed, kernelVersion, kvmEnabled, kvmVersion, libvirtVersion, rpmVersion, memCommited, netConfigDirty, nonOperationalReason, pendingVcpusCount, pendingVmemSize, physicalMemMb, previousStatus, reservedMem, softwareVersion, spiceVersion, glusterVersion, status, supportedClusterLevels, supportedEngines, transparentHugePagesState, versionName, vmActive, vmCount, supportedRngSources, vmMigrating, incomingMigrations, outgoingMigrations, vmsCoresCount, hwManufacturer, hwProductName, hwVersion, hwSerialNumber, hwUUID, hwFamily, HBAs, powerManagementControlledByPolicy, kdumpStatus, selinuxEnforceMode, autoNumaBalancing, numaSupport, additionalFeatures, maintenanceReason, updateAvailable, hostDevicePassthroughEnabled, kernelArgs, prettyName, hostedEngineConfigured, reportedDnsResolverConfiguration, isInFenceFlow);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, supportedClusterVersionsSet, supportedEngineVersionsSet, buildName, cpuCores, cpuThreads, cpuFlags, cpuModel, cpuSockets, cpuSpeedMh, onlineCpus, guestOverhead, hooksStr, hostOs, iScsiInitiatorName, ifTotalSpeed, kernelVersion, kvmEnabled, kvmVersion, libvirtVersion, rpmVersion, memCommited, netConfigDirty, nonOperationalReason, pendingVcpusCount, pendingVmemSize, physicalMemMb, previousStatus, reservedMem, softwareVersion, spiceVersion, glusterVersion, status, supportedClusterLevels, supportedEngines, transparentHugePagesState, versionName, vmActive, vmCount, supportedRngSources, vmMigrating, incomingMigrations, outgoingMigrations, vmsCoresCount, hwManufacturer, hwProductName, hwVersion, hwSerialNumber, hwUUID, hwFamily, HBAs, powerManagementControlledByPolicy, kdumpStatus, selinuxEnforceMode, autoNumaBalancing, numaSupport, additionalFeatures, maintenanceReason, updateAvailable, hostDevicePassthroughEnabled, kernelArgs, prettyName, hostedEngineConfigured, reportedDnsResolverConfiguration, inFenceFlow);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VdsDynamic)) {
        return false;
    }
    VdsDynamic other = (VdsDynamic) obj;
    return Objects.equals(id, other.id) && Objects.equals(getSupportedClusterVersionsSet(), other.getSupportedClusterVersionsSet()) && Objects.equals(supportedEngineVersionsSet, other.supportedEngineVersionsSet) && Objects.equals(buildName, other.buildName) && Objects.equals(cpuCores, other.cpuCores) && Objects.equals(cpuThreads, other.cpuThreads) && Objects.equals(cpuFlags, other.cpuFlags) && Objects.equals(cpuModel, other.cpuModel) && Objects.equals(cpuSockets, other.cpuSockets) && Objects.equals(cpuSpeedMh, other.cpuSpeedMh) && Objects.equals(onlineCpus, other.onlineCpus) && Objects.equals(guestOverhead, other.guestOverhead) && Objects.equals(hooksStr, other.hooksStr) && Objects.equals(hostOs, other.hostOs) && Objects.equals(iScsiInitiatorName, other.iScsiInitiatorName) && Objects.equals(ifTotalSpeed, other.ifTotalSpeed) && Objects.equals(kernelVersion, other.kernelVersion) && Objects.equals(kvmEnabled, other.kvmEnabled) && Objects.equals(kvmVersion, other.kvmVersion) && Objects.equals(libvirtVersion, other.libvirtVersion) && Objects.equals(rpmVersion, other.rpmVersion) && Objects.equals(memCommited, other.memCommited) && Objects.equals(netConfigDirty, other.netConfigDirty) && nonOperationalReason == other.nonOperationalReason && Objects.equals(pendingVcpusCount, other.pendingVcpusCount) && Objects.equals(pendingVmemSize, other.pendingVmemSize) && Objects.equals(physicalMemMb, other.physicalMemMb) && previousStatus == other.previousStatus && Objects.equals(reservedMem, other.reservedMem) && Objects.equals(getSoftwareVersion(), other.getSoftwareVersion()) && Objects.equals(spiceVersion, other.spiceVersion) && Objects.equals(glusterVersion, other.glusterVersion) && status == other.status && Objects.equals(supportedClusterLevels, other.supportedClusterLevels) && Objects.equals(supportedEngines, other.supportedEngines) && transparentHugePagesState == other.transparentHugePagesState && Objects.equals(versionName, other.versionName) && Objects.equals(vmActive, other.vmActive) && vmCount == other.vmCount && Objects.equals(vmMigrating, other.vmMigrating) && incomingMigrations == other.incomingMigrations && outgoingMigrations == other.outgoingMigrations && Objects.equals(vmsCoresCount, other.vmsCoresCount) && Objects.equals(hwManufacturer, other.hwManufacturer) && Objects.equals(hwProductName, other.hwProductName) && Objects.equals(hwVersion, other.hwVersion) && Objects.equals(hwSerialNumber, other.hwSerialNumber) && Objects.equals(hwUUID, other.hwUUID) && Objects.equals(hwFamily, other.hwFamily) && Objects.equals(HBAs, other.HBAs) && powerManagementControlledByPolicy == other.powerManagementControlledByPolicy && kdumpStatus == other.kdumpStatus && Objects.equals(selinuxEnforceMode, other.selinuxEnforceMode) && autoNumaBalancing.getValue() == other.autoNumaBalancing.getValue() && numaSupport == other.numaSupport && Objects.equals(supportedEmulatedMachines, other.supportedEmulatedMachines) && powerManagementControlledByPolicy == other.powerManagementControlledByPolicy && Objects.equals(supportedRngSources, other.supportedRngSources) && Objects.equals(maintenanceReason, other.maintenanceReason) && updateAvailable == other.updateAvailable && Objects.equals(additionalFeatures, other.additionalFeatures) && Objects.equals(kernelArgs, other.kernelArgs) && Objects.equals(hostDevicePassthroughEnabled, other.hostDevicePassthroughEnabled) && Objects.equals(prettyName, other.prettyName) && Objects.equals(hostedEngineConfigured, other.hostedEngineConfigured) && Objects.equals(reportedDnsResolverConfiguration, other.reportedDnsResolverConfiguration) && isInFenceFlow == other.isInFenceFlow;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VdsDynamic)) {
        return false;
    }
    VdsDynamic other = (VdsDynamic) obj;
    return Objects.equals(id, other.id) && Objects.equals(getSupportedClusterVersionsSet(), other.getSupportedClusterVersionsSet()) && Objects.equals(supportedEngineVersionsSet, other.supportedEngineVersionsSet) && Objects.equals(buildName, other.buildName) && Objects.equals(cpuCores, other.cpuCores) && Objects.equals(cpuThreads, other.cpuThreads) && Objects.equals(cpuFlags, other.cpuFlags) && Objects.equals(cpuModel, other.cpuModel) && Objects.equals(cpuSockets, other.cpuSockets) && Objects.equals(cpuSpeedMh, other.cpuSpeedMh) && Objects.equals(onlineCpus, other.onlineCpus) && Objects.equals(guestOverhead, other.guestOverhead) && Objects.equals(hooksStr, other.hooksStr) && Objects.equals(hostOs, other.hostOs) && Objects.equals(iScsiInitiatorName, other.iScsiInitiatorName) && Objects.equals(ifTotalSpeed, other.ifTotalSpeed) && Objects.equals(kernelVersion, other.kernelVersion) && Objects.equals(kvmEnabled, other.kvmEnabled) && Objects.equals(kvmVersion, other.kvmVersion) && Objects.equals(libvirtVersion, other.libvirtVersion) && Objects.equals(rpmVersion, other.rpmVersion) && Objects.equals(memCommited, other.memCommited) && Objects.equals(netConfigDirty, other.netConfigDirty) && nonOperationalReason == other.nonOperationalReason && Objects.equals(pendingVcpusCount, other.pendingVcpusCount) && Objects.equals(pendingVmemSize, other.pendingVmemSize) && Objects.equals(physicalMemMb, other.physicalMemMb) && previousStatus == other.previousStatus && Objects.equals(reservedMem, other.reservedMem) && Objects.equals(getSoftwareVersion(), other.getSoftwareVersion()) && Objects.equals(spiceVersion, other.spiceVersion) && Objects.equals(glusterVersion, other.glusterVersion) && status == other.status && Objects.equals(supportedClusterLevels, other.supportedClusterLevels) && Objects.equals(supportedEngines, other.supportedEngines) && transparentHugePagesState == other.transparentHugePagesState && Objects.equals(versionName, other.versionName) && Objects.equals(vmActive, other.vmActive) && vmCount == other.vmCount && Objects.equals(vmMigrating, other.vmMigrating) && incomingMigrations == other.incomingMigrations && outgoingMigrations == other.outgoingMigrations && Objects.equals(vmsCoresCount, other.vmsCoresCount) && Objects.equals(hwManufacturer, other.hwManufacturer) && Objects.equals(hwProductName, other.hwProductName) && Objects.equals(hwVersion, other.hwVersion) && Objects.equals(hwSerialNumber, other.hwSerialNumber) && Objects.equals(hwUUID, other.hwUUID) && Objects.equals(hwFamily, other.hwFamily) && Objects.equals(HBAs, other.HBAs) && powerManagementControlledByPolicy == other.powerManagementControlledByPolicy && kdumpStatus == other.kdumpStatus && Objects.equals(selinuxEnforceMode, other.selinuxEnforceMode) && autoNumaBalancing.getValue() == other.autoNumaBalancing.getValue() && numaSupport == other.numaSupport && Objects.equals(supportedEmulatedMachines, other.supportedEmulatedMachines) && powerManagementControlledByPolicy == other.powerManagementControlledByPolicy && Objects.equals(supportedRngSources, other.supportedRngSources) && Objects.equals(maintenanceReason, other.maintenanceReason) && updateAvailable == other.updateAvailable && Objects.equals(additionalFeatures, other.additionalFeatures) && Objects.equals(kernelArgs, other.kernelArgs) && Objects.equals(hostDevicePassthroughEnabled, other.hostDevicePassthroughEnabled) && Objects.equals(prettyName, other.prettyName) && Objects.equals(hostedEngineConfigured, other.hostedEngineConfigured) && Objects.equals(reportedDnsResolverConfiguration, other.reportedDnsResolverConfiguration) && inFenceFlow == other.inFenceFlow;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    ActionReturnValue returnValue = new ActionReturnValue();
    final Guid vdsId = getVdsId();
    final String sessionId = getParameters().getSessionId();
    // do not try to stop Host if Host is reported as Down via PM
    if (new HostFenceActionExecutor(getVds()).isHostPoweredOff()) {
        returnValue.setSucceeded(true);
    } else {
        // execute StopVds action
        returnValue = executeVdsFenceAction(vdsId, sessionId, ActionType.StopVds);
        if (getParameters().getParentCommand() == ActionType.VdsNotRespondingTreatment) {
            setInFenceFlow(vdsId, true);
        }
    }
    if (wasSkippedDueToPolicy(returnValue)) {
        // fence execution was skipped due to fencing policy, host should be alive
        RestartVdsResult restartVdsResult = new RestartVdsResult();
        restartVdsResult.setSkippedDueToFencingPolicy(true);
        setActionReturnValue(restartVdsResult);
        setSucceeded(false);
        setVdsStatus(VDSStatus.NonResponsive);
        return;
    } else if (returnValue.getSucceeded()) {
        executeFenceVdsManuallyAction(vdsId, sessionId);
        // execute StartVds action
        returnValue = executeVdsFenceAction(vdsId, sessionId, ActionType.StartVds);
        setSucceeded(returnValue.getSucceeded());
    } else {
        handleError();
        setSucceeded(false);
    }
    if (!getSucceeded()) {
        log.warn("Restart host action failed, updating host '{}' to '{}'", vdsId, VDSStatus.NonResponsive.name());
        setVdsStatus(VDSStatus.NonResponsive);
    }
    // reset the flag since we have completed the restart action, not matter if it succeeded or not
    setInFenceFlow(vdsId, false);
}
#method_after
@Override
protected void executeCommand() {
    ActionReturnValue returnValue = new ActionReturnValue();
    final Guid vdsId = getVdsId();
    final String sessionId = getParameters().getSessionId();
    // do not try to stop Host if Host is reported as Down via PM
    if (new HostFenceActionExecutor(getVds()).isHostPoweredOff()) {
        returnValue.setSucceeded(true);
    } else {
        // execute StopVds action
        returnValue = executeVdsFenceAction(vdsId, sessionId, ActionType.StopVds);
        if (getParameters().getParentCommand() == ActionType.VdsNotRespondingTreatment) {
            updateHostInFenceFlow(vdsId, true);
        }
    }
    if (wasSkippedDueToPolicy(returnValue)) {
        // fence execution was skipped due to fencing policy, host should be alive
        RestartVdsResult restartVdsResult = new RestartVdsResult();
        restartVdsResult.setSkippedDueToFencingPolicy(true);
        setActionReturnValue(restartVdsResult);
        setSucceeded(false);
        setVdsStatus(VDSStatus.NonResponsive);
        return;
    } else if (returnValue.getSucceeded()) {
        executeFenceVdsManuallyAction(vdsId, sessionId);
        // execute StartVds action
        returnValue = executeVdsFenceAction(vdsId, sessionId, ActionType.StartVds);
        setSucceeded(returnValue.getSucceeded());
    } else {
        handleError();
        setSucceeded(false);
    }
    if (!getSucceeded()) {
        log.warn("Restart host action failed, updating host '{}' to '{}'", vdsId, VDSStatus.NonResponsive.name());
        setVdsStatus(VDSStatus.NonResponsive);
    }
    // reset the flag since we have completed the restart action, not matter if it succeeded or not
    updateHostInFenceFlow(vdsId, false);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    AuditLog auditLog = getAuditLog();
    auditLogDao.remove(getParameters().getAuditLogId());
    setAuditLogDetails(auditLog);
    // clear the id so the auditLog will be considered as a system-level auditLog
    auditLog.setUserId(Guid.Empty);
    AuditLogableBase logableToClear = Injector.injectMembers(new AuditLogableBase(auditLog));
    // clean cache manager entry (if exists)
    EventFloodRegulator eventFloodRegulator = new EventFloodRegulator(logableToClear, auditLog.getLogType());
    eventFloodRegulator.evict();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    AuditLog auditLog = getAuditLog();
    auditLogDao.remove(getParameters().getAuditLogId());
    setAuditLogDetails(auditLog);
    // clear the id so the auditLog will be considered as a system-level auditLog
    auditLog.setUserId(Guid.Empty);
    AuditLogable logableToClear = createAuditLogableImpl(auditLog);
    // clean cache manager entry (if exists)
    EventFloodRegulator eventFloodRegulator = new EventFloodRegulator(logableToClear, auditLog.getLogType());
    eventFloodRegulator.evict();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setStoragePoolId(getNetwork().getDataCenterId());
    TransactionSupport.executeInNewTransaction(() -> {
        removeVnicProfiles();
        removeFromClusters();
        setVdsmNamesInVdsInterfaces();
        getCompensationContext().snapshotEntity(getNetwork());
        networkDao.remove(getNetwork().getId());
        getCompensationContext().stateChanged();
        return null;
    });
    if (getNetwork().isExternal()) {
        if (getParameters().isRemoveFromNetworkProvider()) {
            removeExternalNetwork();
        }
    }
    if (NetworkHelper.shouldRemoveNetworkFromHostUponNetworkRemoval(getNetwork())) {
        removeNetworkFromHosts();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    setStoragePoolId(getNetwork().getDataCenterId());
    TransactionSupport.executeInNewTransaction(() -> {
        removeVnicProfiles();
        removeFromClusters();
        networkHelper.setVdsmNamesInVdsInterfaces(getNetwork());
        getCompensationContext().snapshotEntity(getNetwork());
        networkDao.remove(getNetwork().getId());
        getCompensationContext().stateChanged();
        return null;
    });
    if (getNetwork().isExternal()) {
        if (getParameters().isRemoveFromNetworkProvider()) {
            removeExternalNetwork();
        }
    }
    if (NetworkHelper.shouldRemoveNetworkFromHostUponNetworkRemoval(getNetwork())) {
        removeNetworkFromHosts();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public StatusOnlyReturn add_image_ticket(String ticketId, String[] ops, long timeout, long size, String url, String filename) {
    HashMap<String, Object> ticketDict = new HashMap<>();
    ticketDict.put("uuid", ticketId);
    ticketDict.put("timeout", timeout);
    ticketDict.put("ops", ops);
    ticketDict.put("size", size);
    ticketDict.put("url", url);
    if (filename != null) {
        ticketDict.put("filename", filename);
    }
    JsonRpcRequest request = new RequestBuilder("Host.add_image_ticket").withParameter("ticket", ticketDict).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#method_after
@Override
public StatusOnlyReturn add_image_ticket(String ticketId, String[] ops, long timeout, long size, String url, String filename) {
    HashMap<String, Object> ticketDict = new HashMap<>();
    ticketDict.put("uuid", ticketId);
    ticketDict.put("timeout", timeout);
    ticketDict.put("ops", ops);
    ticketDict.put("size", size);
    ticketDict.put("url", url);
    // filename is null by default, and only specified by the UI
    if (filename != null) {
        ticketDict.put("filename", filename);
    }
    JsonRpcRequest request = new RequestBuilder("Host.add_image_ticket").withParameter("ticket", ticketDict).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

