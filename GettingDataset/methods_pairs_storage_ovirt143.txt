361
#method_before
private void initInternalDiskTable(final CommonApplicationConstants constants, final CommonApplicationResources resources, final CommonApplicationTemplates templates) {
    internalDiskTable.enableColumnResizing();
    TextColumnWithTooltip<EntityModel> aliasColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) (((DiskModel) (object.getEntity())).getDisk());
            return diskImage.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    internalDiskTable.addColumn(aliasColumn, constants.aliasVmDiskTable(), "85px");
    TextColumnWithTooltip<EntityModel> descriptionColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) (((DiskModel) (object.getEntity())).getDisk());
            return diskImage.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    internalDiskTable.addColumn(descriptionColumn, constants.descriptionVmDiskTable(), "85px");
    TextColumnWithTooltip<EntityModel> idColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) (((DiskModel) (object.getEntity())).getDisk());
            return diskImage.getId().toString();
        }
    };
    // $NON-NLS-1$
    internalDiskTable.addColumn(idColumn, constants.idVmDiskTable(), "85px");
    DiskSizeColumn<EntityModel> sizeColumn = new DiskSizeColumn<EntityModel>() {

        @Override
        protected Long getRawValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) (((DiskModel) (object.getEntity())).getDisk());
            return diskImage.getSize();
        }
    };
    // $NON-NLS-1$
    internalDiskTable.addColumn(sizeColumn, constants.provisionedSizeVmDiskTable(), "105px");
    DiskSizeColumn<EntityModel> actualSizeColumn = new DiskSizeColumn<EntityModel>() {

        @Override
        protected Long getRawValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) (((DiskModel) (object.getEntity())).getDisk());
            return diskImage.getActualSizeInBytes();
        }
    };
    // $NON-NLS-1$
    internalDiskTable.addColumn(actualSizeColumn, constants.sizeVmDiskTable(), "105px");
    TextColumnWithTooltip<EntityModel> storageDomainColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) (((DiskModel) (object.getEntity())).getDisk());
            return diskImage.getStoragesNames().get(0);
        }
    };
    // $NON-NLS-1$
    internalDiskTable.addColumn(storageDomainColumn, constants.storageDomainVmDiskTable(), "115px");
    TextColumnWithTooltip<EntityModel> interfaceColumn = new EnumColumn<EntityModel, DiskInterface>() {

        @Override
        protected DiskInterface getRawValue(EntityModel object) {
            Disk disk = (((DiskModel) (object.getEntity())).getDisk());
            return disk.getDiskInterface();
        }
    };
    // $NON-NLS-1$
    internalDiskTable.addColumn(interfaceColumn, constants.interfaceVmDiskPopup(), "95px");
    SafeHtml readOnlyColumnHeader = templates.imageWithTitle(SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(resources.readOnlyDiskIcon()).getHTML()), constants.readOnly());
    // $NON-NLS-1$
    internalDiskTable.addColumn(DisksViewColumns.readOnlyCheckboxColumn, readOnlyColumnHeader, "30px");
    SafeHtml bootableColumnHeader = templates.imageWithTitle(SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(resources.bootableDiskIcon()).getHTML()), constants.bootable());
    internalDiskTable.addColumn(new ImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = (((DiskModel) (object.getEntity())).getDisk());
            setTitle(disk.isBoot() ? constants.bootableDisk() : null);
            return disk.isBoot() ? resources.bootableDiskIcon() : null;
        }
    }, bootableColumnHeader, // $NON-NLS-1$ //$NON-NLS-2$
    "30px");
    SafeHtml shareableColumnHeader = templates.imageWithTitle(SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(resources.shareableDiskIcon()).getHTML()), constants.shareable());
    internalDiskTable.addColumn(new ImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = (((DiskModel) (object.getEntity())).getDisk());
            setTitle(disk.isShareable() ? constants.shareable() : null);
            return disk.isShareable() ? resources.shareableDiskIcon() : null;
        }
    }, shareableColumnHeader, // $NON-NLS-1$ //$NON-NLS-2$
    "30px");
    // $NON-NLS-1$
    internalDiskTable.setWidth("100%", true);
    // $NON-NLS-1$
    internalDiskTable.setHeight("100%");
}
#method_after
private void initInternalDiskTable(final CommonApplicationConstants constants, final CommonApplicationResources resources, final CommonApplicationTemplates templates) {
    internalDiskTable.enableColumnResizing();
    TextColumnWithTooltip<EntityModel> aliasColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) (((DiskModel) (object.getEntity())).getDisk());
            return diskImage.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    internalDiskTable.addColumn(aliasColumn, constants.aliasVmDiskTable(), "85px");
    TextColumnWithTooltip<EntityModel> descriptionColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) (((DiskModel) (object.getEntity())).getDisk());
            return diskImage.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    internalDiskTable.addColumn(descriptionColumn, constants.descriptionVmDiskTable(), "85px");
    TextColumnWithTooltip<EntityModel> idColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) (((DiskModel) (object.getEntity())).getDisk());
            return diskImage.getId().toString();
        }
    };
    // $NON-NLS-1$
    internalDiskTable.addColumn(idColumn, constants.idVmDiskTable(), "85px");
    DiskSizeColumn<EntityModel> sizeColumn = new DiskSizeColumn<EntityModel>() {

        @Override
        protected Long getRawValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) (((DiskModel) (object.getEntity())).getDisk());
            return diskImage.getSize();
        }
    };
    // $NON-NLS-1$
    internalDiskTable.addColumn(sizeColumn, constants.provisionedSizeVmDiskTable(), "105px");
    DiskSizeColumn<EntityModel> actualSizeColumn = new DiskSizeColumn<EntityModel>() {

        @Override
        protected Long getRawValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) (((DiskModel) (object.getEntity())).getDisk());
            return diskImage.getActualSizeInBytes();
        }
    };
    // $NON-NLS-1$
    internalDiskTable.addColumn(actualSizeColumn, constants.sizeVmDiskTable(), "105px");
    TextColumnWithTooltip<EntityModel> storageDomainColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) (((DiskModel) (object.getEntity())).getDisk());
            return diskImage.getStoragesNames().get(0);
        }
    };
    // $NON-NLS-1$
    internalDiskTable.addColumn(storageDomainColumn, constants.storageDomainVmDiskTable(), "115px");
    TextColumnWithTooltip<EntityModel> interfaceColumn = new EnumColumn<EntityModel, DiskInterface>() {

        @Override
        protected DiskInterface getRawValue(EntityModel object) {
            Disk disk = (((DiskModel) (object.getEntity())).getDisk());
            return disk.getDiskInterface();
        }
    };
    // $NON-NLS-1$
    internalDiskTable.addColumn(interfaceColumn, constants.interfaceVmDiskPopup(), "95px");
    SafeHtml readOnlyColumnHeader = templates.imageWithTitle(SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(resources.readOnlyDiskIcon()).getHTML()), constants.readOnly());
    // $NON-NLS-1$
    internalDiskTable.addColumn(DisksViewColumns.readOnlyCheckboxColumn, readOnlyColumnHeader, "30px");
    SafeHtml bootableColumnHeader = templates.imageWithTitle(SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(resources.bootableDiskIcon()).getHTML()), constants.bootable());
    internalDiskTable.addColumn(new ImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = (((DiskModel) (object.getEntity())).getDisk());
            setTitle(disk.isBoot() ? constants.bootableDisk() : null);
            return disk.isBoot() ? resources.bootableDiskIcon() : null;
        }
    }, bootableColumnHeader, // $NON-NLS-1$
    "30px");
    SafeHtml shareableColumnHeader = templates.imageWithTitle(SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(resources.shareableDiskIcon()).getHTML()), constants.shareable());
    internalDiskTable.addColumn(new ImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = (((DiskModel) (object.getEntity())).getDisk());
            setTitle(disk.isShareable() ? constants.shareable() : null);
            return disk.isShareable() ? resources.shareableDiskIcon() : null;
        }
    }, shareableColumnHeader, // $NON-NLS-1$
    "30px");
    // $NON-NLS-1$
    internalDiskTable.setWidth("100%", true);
    // $NON-NLS-1$
    internalDiskTable.setHeight("100%");
}
#end_block

#method_before
private void initExternalDiskTable(final CommonApplicationConstants constants, final CommonApplicationResources resources, final CommonApplicationTemplates templates) {
    externalDiskTable.enableColumnResizing();
    TextColumnWithTooltip<EntityModel> aliasColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return disk.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(aliasColumn, constants.aliasVmDiskTable(), "60px");
    TextColumnWithTooltip<EntityModel> descriptionColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return disk.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(descriptionColumn, constants.descriptionVmDiskTable(), "85px");
    TextColumnWithTooltip<EntityModel> lunIdColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return disk.getLun().getLUN_id();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(lunIdColumn, constants.lunIdSanStorage(), "60px");
    TextColumnWithTooltip<EntityModel> idColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return disk.getId().toString();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(idColumn, constants.idVmDiskTable(), "60px");
    DiskSizeColumn<EntityModel> sizeColumn = new DiskSizeColumn<EntityModel>(SizeConverter.SizeUnit.GB) {

        @Override
        protected Long getRawValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return (long) disk.getLun().getDeviceSize();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(sizeColumn, constants.devSizeSanStorage(), "70px");
    TextColumnWithTooltip<EntityModel> pathColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return String.valueOf(disk.getLun().getPathCount());
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(pathColumn, constants.pathSanStorage(), "40px");
    TextColumnWithTooltip<EntityModel> vendorIdColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return disk.getLun().getVendorId();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "70px");
    TextColumnWithTooltip<EntityModel> productIdColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return disk.getLun().getProductId();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(productIdColumn, constants.productIdSanStorage(), "70px");
    TextColumnWithTooltip<EntityModel> serialColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return disk.getLun().getSerial();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(serialColumn, constants.serialSanStorage(), "70px");
    TextColumnWithTooltip<EntityModel> interfaceColumn = new EnumColumn<EntityModel, DiskInterface>() {

        @Override
        protected DiskInterface getRawValue(EntityModel object) {
            Disk disk = (((DiskModel) (object.getEntity())).getDisk());
            return disk.getDiskInterface();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(interfaceColumn, constants.interfaceVmDiskPopup(), "90px");
    SafeHtml readOnlyColumnHeader = templates.imageWithTitle(SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(resources.readOnlyDiskIcon()).getHTML()), constants.readOnly());
    // $NON-NLS-1$
    externalDiskTable.addColumn(DisksViewColumns.readOnlyCheckboxColumn, readOnlyColumnHeader, "30px");
    externalDiskTable.addColumn(new ImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = (((DiskModel) (object.getEntity())).getDisk());
            setTitle(disk.isBoot() ? constants.bootableDisk() : null);
            return disk.isBoot() ? resources.bootableDiskIcon() : null;
        }
    }, "", // $NON-NLS-1$ //$NON-NLS-2$
    "30px");
    externalDiskTable.addColumn(new ImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = (((DiskModel) (object.getEntity())).getDisk());
            setTitle(disk.isShareable() ? constants.shareable() : null);
            return disk.isShareable() ? resources.shareableDiskIcon() : null;
        }
    }, "", // $NON-NLS-1$ //$NON-NLS-2$
    "30px");
    // $NON-NLS-1$
    externalDiskTable.setWidth("100%", true);
    // $NON-NLS-1$
    externalDiskTable.setHeight("100%");
}
#method_after
private void initExternalDiskTable(final CommonApplicationConstants constants, final CommonApplicationResources resources, final CommonApplicationTemplates templates) {
    externalDiskTable.enableColumnResizing();
    TextColumnWithTooltip<EntityModel> aliasColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return disk.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(aliasColumn, constants.aliasVmDiskTable(), "60px");
    TextColumnWithTooltip<EntityModel> descriptionColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return disk.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(descriptionColumn, constants.descriptionVmDiskTable(), "85px");
    TextColumnWithTooltip<EntityModel> lunIdColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return disk.getLun().getLUN_id();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(lunIdColumn, constants.lunIdSanStorage(), "60px");
    TextColumnWithTooltip<EntityModel> idColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return disk.getId().toString();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(idColumn, constants.idVmDiskTable(), "60px");
    DiskSizeColumn<EntityModel> sizeColumn = new DiskSizeColumn<EntityModel>(SizeConverter.SizeUnit.GB) {

        @Override
        protected Long getRawValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return (long) disk.getLun().getDeviceSize();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(sizeColumn, constants.devSizeSanStorage(), "70px");
    TextColumnWithTooltip<EntityModel> pathColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return String.valueOf(disk.getLun().getPathCount());
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(pathColumn, constants.pathSanStorage(), "40px");
    TextColumnWithTooltip<EntityModel> vendorIdColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return disk.getLun().getVendorId();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "70px");
    TextColumnWithTooltip<EntityModel> productIdColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return disk.getLun().getProductId();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(productIdColumn, constants.productIdSanStorage(), "70px");
    TextColumnWithTooltip<EntityModel> serialColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            LunDisk disk = (LunDisk) (((DiskModel) (object.getEntity())).getDisk());
            return disk.getLun().getSerial();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(serialColumn, constants.serialSanStorage(), "70px");
    TextColumnWithTooltip<EntityModel> interfaceColumn = new EnumColumn<EntityModel, DiskInterface>() {

        @Override
        protected DiskInterface getRawValue(EntityModel object) {
            Disk disk = (((DiskModel) (object.getEntity())).getDisk());
            return disk.getDiskInterface();
        }
    };
    // $NON-NLS-1$
    externalDiskTable.addColumn(interfaceColumn, constants.interfaceVmDiskPopup(), "90px");
    SafeHtml readOnlyColumnHeader = templates.imageWithTitle(SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(resources.readOnlyDiskIcon()).getHTML()), constants.readOnly());
    // $NON-NLS-1$
    externalDiskTable.addColumn(DisksViewColumns.readOnlyCheckboxColumn, readOnlyColumnHeader, "30px");
    SafeHtml bootableColumnHeader = templates.imageWithTitle(SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(resources.bootableDiskIcon()).getHTML()), constants.bootable());
    externalDiskTable.addColumn(new ImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = (((DiskModel) (object.getEntity())).getDisk());
            setTitle(disk.isBoot() ? constants.bootableDisk() : null);
            return disk.isBoot() ? resources.bootableDiskIcon() : null;
        }
    }, bootableColumnHeader, // $NON-NLS-1$
    "30px");
    SafeHtml shareableColumnHeader = templates.imageWithTitle(SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(resources.shareableDiskIcon()).getHTML()), constants.shareable());
    externalDiskTable.addColumn(new ImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = (((DiskModel) (object.getEntity())).getDisk());
            setTitle(disk.isShareable() ? constants.shareable() : null);
            return disk.isShareable() ? resources.shareableDiskIcon() : null;
        }
    }, shareableColumnHeader, // $NON-NLS-1$
    "30px");
    // $NON-NLS-1$
    externalDiskTable.setWidth("100%", true);
    // $NON-NLS-1$
    externalDiskTable.setHeight("100%");
}
#end_block

#method_before
public static Pair<SizeUnit, Double> autoConvert(long size, SizeUnit inUnit) {
    for (Pair<Long, SizeUnit> currentUnitPair : SizeUnit.weightToUnit) {
        if (size / Math.pow(CONVERT_FACTOR, currentUnitPair.getFirst() - inUnit.getUnitWeight()) >= 1) {
            return new Pair<SizeConverter.SizeUnit, Double>(currentUnitPair.getSecond(), Double.valueOf(SizeConverter.convert(size, inUnit, currentUnitPair.getSecond()).doubleValue()));
        }
    }
    return new Pair<SizeConverter.SizeUnit, Double>(SizeUnit.BYTES, new Double(Long.valueOf(size)));
}
#method_after
public static Pair<SizeUnit, Double> autoConvert(long size, SizeUnit inUnit) {
    for (Pair<Long, SizeUnit> currentUnitPair : SizeUnit.weightToUnit) {
        if (size / Math.pow(CONVERT_FACTOR, currentUnitPair.getFirst() - inUnit.getUnitWeight()) >= 1) {
            return new Pair<SizeConverter.SizeUnit, Double>(currentUnitPair.getSecond(), SizeConverter.convert(size, inUnit, currentUnitPair.getSecond()).doubleValue());
        }
    }
    return new Pair<SizeConverter.SizeUnit, Double>(SizeUnit.BYTES, (double) size);
}
#end_block

#method_before
@Before
public void init() {
    MockitoAnnotations.initMocks(this);
    tasksSyncJob = Mockito.spy(GlusterTasksSyncJob.getInstance());
    logUtil = Mockito.spy(GlusterAuditLogUtil.getInstance());
    tasksSyncJob.setLogUtil(logUtil);
    doReturn(clusterDao).when(tasksSyncJob).getClusterDao();
    doReturn(getClusters()).when(clusterDao).getAll();
    doReturn(provider).when(tasksSyncJob).getProvider();
    doReturn(stepDao).when(tasksSyncJob).getStepDao();
    doReturn(volumeDao).when(tasksSyncJob).getVolumeDao();
    doReturn(jobRepository).when(tasksSyncJob).getJobRepository();
    doReturn(backend).when(tasksSyncJob).getBackend();
    doNothing().when(tasksSyncJob).releaseLock(any(Guid.class));
    doNothing().when(tasksSyncJob).endStepJob(any(Step.class));
    doNothing().when(tasksSyncJob).logMessage(any(Guid.class), any(GlusterVolumeEntity.class), any(String.class), any(String.class), any(AuditLogType.class));
    doNothing().when(logUtil).logAuditMessage(any(Guid.class), any(GlusterVolumeEntity.class), any(VDS.class), any(AuditLogType.class), any(Map.class));
}
#method_after
@Before
public void init() {
    MockitoAnnotations.initMocks(this);
    tasksSyncJob = Mockito.spy(GlusterTasksSyncJob.getInstance());
    logUtil = Mockito.spy(GlusterAuditLogUtil.getInstance());
    taskUtils = Mockito.spy(GlusterTaskUtils.getInstance());
    doNothing().when(logUtil).logClusterMessage(any(Guid.class), any(AuditLogType.class));
    doReturn(clusterDao).when(tasksSyncJob).getClusterDao();
    doReturn(getClusters()).when(clusterDao).getAll();
    doReturn(provider).when(tasksSyncJob).getProvider();
    doReturn(stepDao).when(tasksSyncJob).getStepDao();
    doReturn(volumeDao).when(tasksSyncJob).getVolumeDao();
    doReturn(volumeDao).when(taskUtils).getVolumeDao();
    doReturn(jobRepository).when(tasksSyncJob).getJobRepository();
    doReturn(jobRepository).when(taskUtils).getJobRepository();
    doReturn(backend).when(tasksSyncJob).getBackend();
    doReturn(taskUtils).when(tasksSyncJob).getGlusterTaskUtils();
    doNothing().when(taskUtils).releaseLock(any(Guid.class));
    doNothing().when(taskUtils).endStepJob(any(Step.class));
    doReturn(null).when(provider).getMonitoredTaskIDsInDB();
    doNothing().when(taskUtils).eventMessageLogger(any(GlusterAsyncTask.class), any(JobExecutionStatus.class), any(VDSGroup.class));
}
#end_block

#method_before
@Test
public void updateTasksInCluster() {
    doReturn(getTasks()).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(1)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(1)).endStepJob(any(Step.class));
}
#method_after
@Test
public void updateTasksInCluster() {
    doReturn(getTasks()).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(1)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(1)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void testUpdateWhenNoTasks() {
    doReturn(null).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(volumeDao, times(0)).updateVolumeTask(VOL_GUIDS[0], null);
    Mockito.verify(volumeDao, times(0)).updateVolumeTask(VOL_GUIDS[1], null);
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(0)).endStepJob(any(Step.class));
}
#method_after
@Test
public void testUpdateWhenNoTasks() {
    doReturn(null).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(volumeDao, times(0)).updateVolumeTask(VOL_GUIDS[0], null);
    Mockito.verify(volumeDao, times(0)).updateVolumeTask(VOL_GUIDS[1], null);
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(0)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void testCreateTasksStartedFromCLI() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(mockVdcReturn(true, Guid.newGuid())).when(backend).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
    prepareMocksForTasksFromCLI();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(0)).endStepJob(any(Step.class));
    Mockito.verify(backend, times(6)).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
}
#method_after
@Test
public void testCreateTasksStartedFromCLI() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(mockVdcReturn(true, Guid.newGuid())).when(backend).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
    prepareMocksForTasksFromCLI();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(0)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void testCreateTasksStartedFromCLIWithErrors() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(mockVdcReturn(false, null)).when(backend).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
    prepareMocksForTasksFromCLI();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(0)).endStepJob(any(Step.class));
    Mockito.verify(backend, times(2)).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
}
#method_after
@Test
public void testCreateTasksStartedFromCLIWithErrors() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(mockVdcReturn(false, null)).when(backend).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
    prepareMocksForTasksFromCLI();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(0)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void testUpdateWhenNoCompletedTasks() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(2)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(0)).endStepJob(any(Step.class));
}
#method_after
@Test
public void testUpdateWhenNoCompletedTasks() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(2)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(0)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void testUpdateWhenAbortedTasks() {
    doReturn(getTasks(JobExecutionStatus.ABORTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(2)).endStepJob(any(Step.class));
}
#method_after
@Test
public void testUpdateWhenAbortedTasks() {
    doReturn(getTasks(JobExecutionStatus.ABORTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(2)).endStepJob(any(Step.class));
}
#end_block

#method_before
private void prepareMocks() {
    doReturn(getVolume(0)).when(volumeDao).getVolumeByGlusterTask(TASK_GUIDS[0]);
    doReturn(getVolume(1)).when(volumeDao).getVolumeByGlusterTask(TASK_GUIDS[1]);
    doReturn(getSteps()).when(stepDao).getStepsByExternalId(TASK_GUIDS[0]);
    doReturn(getSteps()).when(stepDao).getStepsByExternalId(TASK_GUIDS[1]);
}
#method_after
private void prepareMocks() {
    doReturn(getVolume(0)).when(volumeDao).getVolumeByGlusterTask(TASK_GUIDS[0]);
    doReturn(getVolume(1)).when(volumeDao).getVolumeByGlusterTask(TASK_GUIDS[1]);
    doReturn(getVolume(1)).when(volumeDao).getVolumeByGlusterTask(TASK_GUIDS[2]);
    doReturn(getSteps()).when(stepDao).getStepsByExternalId(TASK_GUIDS[0]);
    doReturn(getSteps()).when(stepDao).getStepsByExternalId(TASK_GUIDS[1]);
    doReturn(getSteps()).when(stepDao).getStepsByExternalId(TASK_GUIDS[2]);
}
#end_block

#method_before
private GlusterVolumeEntity getVolume(int i) {
    GlusterVolumeEntity vol = new GlusterVolumeEntity();
    vol.setId(VOL_GUIDS[i]);
    return vol;
}
#method_after
private GlusterVolumeEntity getVolume(int i) {
    GlusterVolumeEntity vol = new GlusterVolumeEntity();
    vol.setStatus(GlusterStatus.UP);
    vol.setId(VOL_GUIDS[i]);
    return vol;
}
#end_block

#method_before
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICK_DATA_MIGRATION_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_NEW, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICES_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_TYPE_ADDED_TO_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOPPED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, AuditLogSeverity.WARNING);
}
#method_after
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_MIGRATE_BRICK_DATA_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_NEW, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICES_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_TYPE_ADDED_TO_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOPPED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@Override
public List<permissions> getAllForEntity(Guid id, Guid userID, boolean isFiltered) {
    Integer appMode = Config.<Integer>GetValue(ConfigValues.ApplicationMode);
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id).addValue("user_id", userID).addValue("is_filtered", isFiltered).addValue("app_mode", appMode.intValue());
    return getCallsHandler().executeReadList("GetPermissionsByEntityId", PermissionRowMapper.instance, parameterSource);
}
#method_after
@Override
public List<permissions> getAllForEntity(Guid id, Guid userID, boolean isFiltered) {
    return getAllForEntity(id, userID, isFiltered, false);
}
#end_block

#method_before
@Override
public List<permissions> getAllForEntity(Guid id, Guid userID, boolean isFiltered) {
    Integer appMode = Config.<Integer>GetValue(ConfigValues.ApplicationMode);
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id).addValue("user_id", userID).addValue("is_filtered", isFiltered).addValue("app_mode", appMode.intValue());
    return getCallsHandler().executeReadList("GetPermissionsByEntityId", PermissionRowMapper.instance, parameterSource);
}
#method_after
@Override
public List<permissions> getAllForEntity(Guid id, Guid userID, boolean isFiltered, boolean allUsersWithPermission) {
    int appMode = Config.<Integer>GetValue(ConfigValues.ApplicationMode);
    return getAllForEntity(id, userID, isFiltered, allUsersWithPermission, appMode);
}
#end_block

#method_before
@Override
public List<permissions> getTreeForEntity(Guid id, VdcObjectType type, Guid userID, boolean isFiltered) {
    Integer appMode = Config.<Integer>GetValue(ConfigValues.ApplicationMode);
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id).addValue("object_type_id", type.getValue()).addValue("user_id", userID).addValue("is_filtered", isFiltered).addValue("app_mode", appMode.intValue());
    return getCallsHandler().executeReadList("GetPermissionsTreeByEntityId", PermissionRowMapper.instance, parameterSource);
}
#method_after
@Override
public List<permissions> getTreeForEntity(Guid id, VdcObjectType type, Guid userID, boolean isFiltered) {
    int appMode = Config.<Integer>GetValue(ConfigValues.ApplicationMode);
    return getTreeForEntity(id, type, userID, isFiltered, appMode);
}
#end_block

#method_before
@Override
public List<permissions> getTreeForEntity(Guid id, VdcObjectType type, Guid userID, boolean isFiltered) {
    Integer appMode = Config.<Integer>GetValue(ConfigValues.ApplicationMode);
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id).addValue("object_type_id", type.getValue()).addValue("user_id", userID).addValue("is_filtered", isFiltered).addValue("app_mode", appMode.intValue());
    return getCallsHandler().executeReadList("GetPermissionsTreeByEntityId", PermissionRowMapper.instance, parameterSource);
}
#method_after
@Override
public List<permissions> getTreeForEntity(Guid id, VdcObjectType type, Guid userID, boolean isFiltered, int appMode) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id).addValue("object_type_id", type.getValue()).addValue("user_id", userID).addValue("is_filtered", isFiltered).addValue("app_mode", appMode);
    return getCallsHandler().executeReadList("GetPermissionsTreeByEntityId", PermissionRowMapper.instance, parameterSource);
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(list), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
}
#end_block

#method_before
private Set<String> getInterfaceNetworkNames() {
    if (cachedInterfaceNetworkNames == null) {
        return Entities.vmInterfacesByNetworkName(vm.getInterfaces()).keySet();
    }
    return cachedInterfaceNetworkNames;
}
#method_after
private Set<String> getInterfaceNetworkNames() {
    if (cachedInterfaceNetworkNames == null) {
        cachedInterfaceNetworkNames = Entities.vmInterfacesByNetworkName(vm.getInterfaces()).keySet();
    }
    return cachedInterfaceNetworkNames;
}
#end_block

#method_before
private void initHandlers() {
    mTagsHandler = HandlersFactory.createTagsHandler();
    BaseConditionFieldAutoCompleter.TagsHandler = mTagsHandler;
    VmHandler.init();
    VdsHandler.Init();
    VmTemplateHandler.Init();
    log.info("Completed initializing handlers");
}
#method_after
private void initHandlers() {
    mTagsHandler = HandlersFactory.createTagsHandler();
    BaseConditionFieldAutoCompleter.tagsHandler = mTagsHandler;
    VmHandler.init();
    VdsHandler.Init();
    VmTemplateHandler.Init();
    log.info("Completed initializing handlers");
}
#end_block

#method_before
private void initHandlers() {
    mTagsHandler = HandlersFactory.createTagsHandler();
    BaseConditionFieldAutoCompleter.TagsHandler = mTagsHandler;
    VmHandler.init();
    VdsHandler.Init();
    VmTemplateHandler.Init();
    log.info("Completed initializing handlers");
}
#method_after
private void initHandlers() {
    mTagsHandler = HandlersFactory.createTagsHandler();
    BaseConditionFieldAutoCompleter.tagsHandler = mTagsHandler;
    VmHandler.init();
    VdsHandler.Init();
    VmTemplateHandler.Init();
    log.info("Completed initializing handlers");
}
#end_block

#method_before
private void initHandlers() {
    mTagsHandler = HandlersFactory.createTagsHandler();
    BaseConditionFieldAutoCompleter.TagsHandler = mTagsHandler;
    VmHandler.init();
    VdsHandler.Init();
    VmTemplateHandler.Init();
    log.info("Completed initializing handlers");
}
#method_after
private void initHandlers() {
    mTagsHandler = HandlersFactory.createTagsHandler();
    BaseConditionFieldAutoCompleter.tagsHandler = mTagsHandler;
    VmHandler.init();
    VdsHandler.Init();
    VmTemplateHandler.Init();
    log.info("Completed initializing handlers");
}
#end_block

#method_before
@Override
public VdcQueryReturnValue RunPublicQuery(VdcQueryType queryType, VdcQueryParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: RunPublicQuery invoked! " + queryType);
    debugQuery(queryType, params);
    return getBackend().runPublicQuery(queryType, params);
}
#method_after
@Override
public VdcQueryReturnValue RunPublicQuery(VdcQueryType queryType, VdcQueryParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: runPublicQuery invoked! " + queryType);
    debugQuery(queryType, params);
    return getBackend().runPublicQuery(queryType, params);
}
#end_block

#method_before
private void initHandlers() {
    mTagsHandler = HandlersFactory.createTagsHandler();
    BaseConditionFieldAutoCompleter.TagsHandler = mTagsHandler;
    VmHandler.init();
    VdsHandler.Init();
    VmTemplateHandler.Init();
    log.info("Completed initializing handlers");
}
#method_after
private void initHandlers() {
    mTagsHandler = HandlersFactory.createTagsHandler();
    BaseConditionFieldAutoCompleter.tagsHandler = mTagsHandler;
    VmHandler.init();
    VdsHandler.Init();
    VmTemplateHandler.Init();
    log.info("Completed initializing handlers");
}
#end_block

#method_before
private void initHandlers() {
    mTagsHandler = HandlersFactory.createTagsHandler();
    BaseConditionFieldAutoCompleter.TagsHandler = mTagsHandler;
    VmHandler.init();
    VdsHandler.Init();
    VmTemplateHandler.Init();
    log.info("Completed initializing handlers");
}
#method_after
private void initHandlers() {
    mTagsHandler = HandlersFactory.createTagsHandler();
    BaseConditionFieldAutoCompleter.tagsHandler = mTagsHandler;
    VmHandler.init();
    VdsHandler.Init();
    VmTemplateHandler.Init();
    log.info("Completed initializing handlers");
}
#end_block

#method_before
@OnTimerMethodAnnotation("gluster_async_task_poll_event")
public void updateGlusterAsyncTasks() {
    log.debug("Refreshing gluster tasks list");
    List<VDSGroup> clusters = getClusterDao().getAll();
    List<Guid> tasksFromClusters = new ArrayList<>();
    boolean cleanOrphanTasks = true;
    for (VDSGroup cluster : clusters) {
        if (!getGlusterTaskUtils().supportsGlusterAsyncTasksFeature(cluster)) {
            continue;
        }
        try {
            Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
            if (runningTasks != null) {
                updateTasksInCluster(cluster, runningTasks);
                tasksFromClusters.addAll(runningTasks.keySet());
            }
        } catch (VdcBLLException e) {
            cleanOrphanTasks = false;
        }
    }
    if (cleanOrphanTasks) {
        cleanUpOrphanTasks(tasksFromClusters);
    }
}
#method_after
@OnTimerMethodAnnotation("gluster_async_task_poll_event")
public void updateGlusterAsyncTasks() {
    log.debug("Refreshing gluster tasks list");
    List<VDSGroup> clusters = getClusterDao().getAll();
    Map<Guid, Set<Guid>> tasksFromClustersMap = new HashMap<>();
    for (VDSGroup cluster : clusters) {
        if (!getGlusterTaskUtils().supportsGlusterAsyncTasksFeature(cluster)) {
            continue;
        }
        try {
            Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
            if (runningTasks != null) {
                updateTasksInCluster(cluster, runningTasks);
            }
            tasksFromClustersMap.put(cluster.getId(), runningTasks == null ? null : runningTasks.keySet());
        } catch (VdcBLLException e) {
            log.error("Error updating tasks from CLI", e);
        }
    }
    cleanUpOrphanTasks(tasksFromClustersMap);
}
#end_block

#method_before
private void updateTasksInCluster(final VDSGroup cluster, final Map<Guid, GlusterAsyncTask> runningTasks) {
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        getGlusterTaskUtils().updateSteps(cluster, task, steps);
    }
}
#method_after
private void updateTasksInCluster(final VDSGroup cluster, final Map<Guid, GlusterAsyncTask> runningTasks) {
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            createJobForTaskFromCLI(cluster, task);
        }
        getGlusterTaskUtils().updateSteps(cluster, task, steps);
    }
}
#end_block

#method_before
private void updateVolumeBricksAndLock(VDSGroup cluster, GlusterAsyncTask task) {
    // get volume associated with task
    String volumeName = task.getTaskParameters().getVolumeName();
    GlusterVolumeEntity vol = getVolumeDao().getByName(cluster.getId(), volumeName);
    if (vol != null) {
        // update volume with task id
        getVolumeDao().updateVolumeTask(vol.getId(), task.getTaskId());
        // acquire lock on volume
        acquireLock(vol.getId());
        if (GlusterTaskType.REMOVE_BRICK == task.getType()) {
            // update bricks associated with task id
            String[] bricks = task.getTaskParameters().getBricks();
            if (bricks == null) {
                return;
            }
            List<GlusterBrickEntity> brickEntities = new ArrayList<>();
            for (String brick : bricks) {
                String[] brickParts = brick.split(":", -1);
                String hostnameOrIp = brickParts[0];
                String brickDir = brickParts[1];
                GlusterBrickEntity brickEntity = new GlusterBrickEntity();
                VdsStatic server = GlusterDBUtils.getInstance().getServer(cluster.getId(), hostnameOrIp);
                if (server == null) {
                    log.warnFormat("Could not find server {0} in cluster {1}", hostnameOrIp, cluster.getId());
                } else {
                    brickEntity.setServerId(server.getId());
                    brickEntity.setBrickDirectory(brickDir);
                    brickEntity.setAsyncTask(new GlusterAsyncTask());
                    brickEntity.getAsyncTask().setTaskId(task.getTaskId());
                    brickEntities.add(brickEntity);
                }
            }
            getBrickDao().updateAllBrickTasksByHostIdBrickDirInBatch(brickEntities);
        }
    } else {
        log.debugFormat("Did not find a volume associated with volumeName {0} and task {1} ", volumeName, task.getTaskId());
    }
}
#method_after
private void updateVolumeBricksAndLock(VDSGroup cluster, GlusterAsyncTask task) {
    // get volume associated with task
    String volumeName = task.getTaskParameters().getVolumeName();
    GlusterVolumeEntity vol = getVolumeDao().getByName(cluster.getId(), volumeName);
    if (vol != null) {
        try {
            // acquire lock on volume
            acquireLock(vol.getId());
            // update volume with task id
            getVolumeDao().updateVolumeTask(vol.getId(), task.getTaskId());
            if (GlusterTaskType.REMOVE_BRICK == task.getType()) {
                // update bricks associated with task id
                String[] bricks = task.getTaskParameters().getBricks();
                if (bricks == null) {
                    return;
                }
                List<GlusterBrickEntity> brickEntities = new ArrayList<>();
                for (String brick : bricks) {
                    String[] brickParts = brick.split(":", -1);
                    String hostnameOrIp = brickParts[0];
                    String brickDir = brickParts[1];
                    GlusterBrickEntity brickEntity = new GlusterBrickEntity();
                    VdsStatic server = GlusterDBUtils.getInstance().getServer(cluster.getId(), hostnameOrIp);
                    if (server == null) {
                        log.warnFormat("Could not find server {0} in cluster {1}", hostnameOrIp, cluster.getId());
                    } else {
                        brickEntity.setServerId(server.getId());
                        brickEntity.setBrickDirectory(brickDir);
                        brickEntity.setAsyncTask(new GlusterAsyncTask());
                        brickEntity.getAsyncTask().setTaskId(task.getTaskId());
                        brickEntities.add(brickEntity);
                    }
                }
                getBrickDao().updateAllBrickTasksByHostIdBrickDirInBatch(brickEntities);
            }
        } catch (Exception e) {
            log.error(e);
            throw new VdcBLLException(VdcBllErrors.GeneralException, e.getMessage());
        } finally {
            releaseLock(vol.getId());
        }
    } else {
        log.debugFormat("Did not find a volume associated with volumeName {0} and task {1} ", volumeName, task.getTaskId());
    }
}
#end_block

#method_before
private void cleanUpOrphanTasks(List<Guid> runningTasksinCluster) {
    // Populate the list of tasks that need to be monitored from database
    List<Guid> taskListInDB = getProvider().getMonitoredTaskIDsInDB();
    if (taskListInDB == null || taskListInDB.isEmpty()) {
        return;
    }
    // if task is in DB but not in running task list
    final Set<Guid> tasksNotRunning = new HashSet<Guid>(taskListInDB);
    tasksNotRunning.removeAll(runningTasksinCluster);
    for (Guid taskId : tasksNotRunning) {
        GlusterVolumeEntity vol = getVolumeDao().getVolumeByGlusterTask(taskId);
        if (vol != null && vol.getStatus() != GlusterStatus.UP) {
            // the volume is not UP. Hence gluster may not have been able to return tasks for the volume
            continue;
        }
        // Volume is up, but gluster does not know of task
        // will mark job ended with status unknown.
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        for (Step step : steps) {
            step.markStepEnded(JobExecutionStatus.UNKNOWN);
            step.setStatus(JobExecutionStatus.UNKNOWN);
            getGlusterTaskUtils().endStepJob(step);
        }
        getGlusterTaskUtils().releaseVolumeLock(taskId);
    }
}
#method_after
private void cleanUpOrphanTasks(Map<Guid, Set<Guid>> runningTasksInClusterMap) {
    // if map is empty, no tasks from clusters fetched. so return
    if (runningTasksInClusterMap.isEmpty()) {
        log.debug("Clean up of tasks has been skipped");
        return;
    }
    // Populate the list of tasks that need to be monitored from database
    List<Guid> taskListInDB = getProvider().getMonitoredTaskIDsInDB();
    if (taskListInDB == null || taskListInDB.isEmpty()) {
        return;
    }
    Set<Guid> allRunningTasksInCluster = new HashSet<>();
    for (Set<Guid> taskSet : runningTasksInClusterMap.values()) {
        if (taskSet != null) {
            allRunningTasksInCluster.addAll(taskSet);
        }
    }
    // if task is in DB but not in running task list
    final Set<Guid> tasksNotRunning = new HashSet<Guid>(taskListInDB);
    tasksNotRunning.removeAll(allRunningTasksInCluster);
    log.debugFormat("tasks to be cleaned up in db {0}", tasksNotRunning);
    for (Guid taskId : tasksNotRunning) {
        GlusterVolumeEntity vol = getVolumeDao().getVolumeByGlusterTask(taskId);
        if (vol != null && vol.getStatus() != GlusterStatus.UP && !runningTasksInClusterMap.keySet().contains((vol.getClusterId()))) {
            // contain the cluster id in such case
            continue;
        }
        // Volume is up, but gluster does not know of task
        // will mark job ended with status unknown.
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        for (Step step : steps) {
            step.markStepEnded(JobExecutionStatus.UNKNOWN);
            step.setStatus(JobExecutionStatus.UNKNOWN);
            getGlusterTaskUtils().endStepJob(step);
        }
        getGlusterTaskUtils().releaseVolumeLock(taskId);
    }
}
#end_block

#method_before
private void cleanUpOrphanTasks(Map<Guid, Set<Guid>> runningTasksinClusterMap) {
    // Populate the list of tasks that need to be monitored from database
    List<Guid> taskListInDB = getProvider().getMonitoredTaskIDsInDB();
    if (taskListInDB == null || taskListInDB.isEmpty()) {
        return;
    }
    Set<Guid> allRunningTasksInCluster = new HashSet<>();
    for (Set<Guid> taskSet : runningTasksinClusterMap.values()) {
        if (taskSet != null) {
            allRunningTasksInCluster.addAll(taskSet);
        }
    }
    // if task is in DB but not in running task list
    final Set<Guid> tasksNotRunning = new HashSet<Guid>(taskListInDB);
    tasksNotRunning.removeAll(allRunningTasksInCluster);
    for (Guid taskId : tasksNotRunning) {
        GlusterVolumeEntity vol = getVolumeDao().getVolumeByGlusterTask(taskId);
        if (vol != null && vol.getStatus() != GlusterStatus.UP && !runningTasksinClusterMap.keySet().contains((vol.getClusterId()))) {
            // contain the cluster id in such case
            continue;
        }
        // Volume is up, but gluster does not know of task
        // will mark job ended with status unknown.
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        for (Step step : steps) {
            step.markStepEnded(JobExecutionStatus.UNKNOWN);
            getGlusterTaskUtils().endStepJob(step);
        }
        getGlusterTaskUtils().releaseVolumeLock(taskId);
    }
}
#method_after
private void cleanUpOrphanTasks(Map<Guid, Set<Guid>> runningTasksInClusterMap) {
    // if map is empty, no tasks from clusters fetched. so return
    if (runningTasksInClusterMap.isEmpty()) {
        log.debug("Clean up of tasks has been skipped");
        return;
    }
    // Populate the list of tasks that need to be monitored from database
    List<Guid> taskListInDB = getProvider().getMonitoredTaskIDsInDB();
    if (taskListInDB == null || taskListInDB.isEmpty()) {
        return;
    }
    Set<Guid> allRunningTasksInCluster = new HashSet<>();
    for (Set<Guid> taskSet : runningTasksInClusterMap.values()) {
        if (taskSet != null) {
            allRunningTasksInCluster.addAll(taskSet);
        }
    }
    // if task is in DB but not in running task list
    final Set<Guid> tasksNotRunning = new HashSet<Guid>(taskListInDB);
    tasksNotRunning.removeAll(allRunningTasksInCluster);
    log.debugFormat("tasks to be cleaned up in db {0}", tasksNotRunning);
    for (Guid taskId : tasksNotRunning) {
        GlusterVolumeEntity vol = getVolumeDao().getVolumeByGlusterTask(taskId);
        if (vol != null && vol.getStatus() != GlusterStatus.UP && !runningTasksInClusterMap.keySet().contains((vol.getClusterId()))) {
            // contain the cluster id in such case
            continue;
        }
        // Volume is up, but gluster does not know of task
        // will mark job ended with status unknown.
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        for (Step step : steps) {
            step.markStepEnded(JobExecutionStatus.UNKNOWN);
            getGlusterTaskUtils().endStepJob(step);
        }
        getGlusterTaskUtils().releaseVolumeLock(taskId);
    }
}
#end_block

#method_before
private void configureFeedbackUrl() {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String version = (String) result;
            feedbackUrl = dynamicMessages.feedbackUrl(version);
            if (feedbackUrl != null && feedbackUrl.length() > 0) {
                getView().setFeedbackText(feedbackLinkLabel);
                registerHandler(getView().getFeedbackLink().addClickHandler(new ClickHandler() {

                    @Override
                    public void onClick(ClickEvent event) {
                        WebUtils.openUrlInNewWindow(feedbackLinkLabel, feedbackUrl);
                    }
                }));
            }
        }
    };
    AsyncDataProvider.getRpmVersionViaPublic(_asyncQuery);
}
#method_after
private void configureFeedbackUrl() {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String version = (String) result;
            feedbackUrl = dynamicMessages.feedbackUrl(version);
            if (feedbackUrl != null && feedbackUrl.length() > 0) {
                getView().setFeedbackText(feedbackLinkLabel);
                registerHandler(getView().getFeedbackLink().addClickHandler(new ClickHandler() {

                    @Override
                    public void onClick(ClickEvent event) {
                        WebUtils.openUrlInNewWindow(feedbackLinkLabel, feedbackUrl);
                    }
                }));
            }
        }
    };
    AsyncDataProvider.getRpmVersion(_asyncQuery);
}
#end_block

#method_before
@Test
public void testUpdateAsyncTaskId() {
    assertNull(existingDistVol.getAsyncTask().getTaskId());
    dao.updateVolumeTask(existingDistVol.getId(), REBALANCING_VOLUME_TASKID);
    GlusterVolumeEntity volume = dao.getAllWithQuery("select * from gluster_volumes_view where id = '" + existingDistVol.getId() + "'").get(0);
    assertNotNull("Volume : " + existingDistVol.getId() + " doesn't exists", volume);
    assertTrue("Task ID is not getting updated", volume.getAsyncTask().getTaskId().equals(REBALANCING_VOLUME_TASKID));
    assertTrue("Invalid Task status", JobExecutionStatus.STARTED == volume.getAsyncTask().getStatus());
    assertTrue("Invalid Task type", GlusterTaskType.REBALANCE == volume.getAsyncTask().getType());
}
#method_after
@Test
public void testUpdateAsyncTaskId() {
    assertNotNull(existingDistVol.getAsyncTask());
    assertNull(existingDistVol.getAsyncTask().getTaskId());
    dao.updateVolumeTask(existingDistVol.getId(), REBALANCING_VOLUME_TASKID);
    GlusterVolumeEntity volume = dao.getAllWithQuery("select * from gluster_volumes_view where id = '" + existingDistVol.getId() + "'").get(0);
    assertNotNull("Volume : " + existingDistVol.getId() + " doesn't exists", volume);
    assertTrue("Task ID is not getting updated", volume.getAsyncTask().getTaskId().equals(REBALANCING_VOLUME_TASKID));
    assertTrue("Invalid Task status", JobExecutionStatus.STARTED == volume.getAsyncTask().getStatus());
    assertTrue("Invalid Task type", GlusterTaskType.REBALANCE == volume.getAsyncTask().getType());
}
#end_block

#method_before
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
        volume.setAsyncTask(getAsyncTaskOfVolume(volume.getId()));
        List<GlusterBrickEntity> bricks = dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId());
        if (volume.getAsyncTask() != null && volume.getAsyncTask().getTaskId() != null) {
            for (GlusterBrickEntity brick : bricks) {
                if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volume.getAsyncTask().getTaskId())) {
                    brick.setAsyncTask(volume.getAsyncTask());
                }
            }
        }
        volume.setBricks(bricks);
    }
}
#method_after
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
        GlusterAsyncTask asyncTask = getAsyncTaskOfVolume(volume.getId());
        if (asyncTask != null) {
            volume.setAsyncTask(asyncTask);
        }
        List<GlusterBrickEntity> bricks = dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId());
        if (volume.getAsyncTask() != null && volume.getAsyncTask().getTaskId() != null) {
            for (GlusterBrickEntity brick : bricks) {
                if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volume.getAsyncTask().getTaskId())) {
                    brick.setAsyncTask(volume.getAsyncTask());
                }
            }
        }
        volume.setBricks(bricks);
    }
}
#end_block

#method_before
@Override
public void render(Context context, T value, SafeHtmlBuilder sb) {
    // Waiting icon need to be rendered only if job is started and task ref is emptu
    if (value.getAsyncTask() == null || value.getAsyncTask().getJobId() == null || value.getAsyncTask().getType() != null || value.getAsyncTask().getJobStatus() != JobExecutionStatus.STARTED) {
        return;
    }
    ImageResource taskImage = resources.waitImage();
    String tooltip = constants.waitForGlusterTask();
    // Generate the HTML for the image:
    SafeHtml activityImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(taskImage).getHTML());
    sb.append(applicationTemplates.image(activityImageHtml, tooltip));
}
#method_after
@Override
public void render(Context context, T value, SafeHtmlBuilder sb) {
    // Waiting icon need to be rendered only if job is started and task ref is empty
    if (value.getAsyncTask() == null || value.getAsyncTask().getJobId() == null || value.getAsyncTask().getType() != null || value.getAsyncTask().getJobStatus() != JobExecutionStatus.STARTED) {
        return;
    }
    ImageResource taskImage = resources.waitImage();
    String tooltip = constants.waitForGlusterTask();
    // Generate the HTML for the image:
    SafeHtml activityImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(taskImage).getHTML());
    sb.append(applicationTemplates.image(activityImageHtml, tooltip));
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> numOfBricksColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return Integer.toString(object.getBricks().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfBricksColumn, constants.numberOfBricksVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(compositeList), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> numOfBricksColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return Integer.toString(object.getBricks().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfBricksColumn, constants.numberOfBricksVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
}
#end_block

#method_before
private MenuCell<GlusterTaskSupport> getRebalanceActivityMenu(ApplicationConstants constants) {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REBALANCE;
        }
    };
    menuCell.addMenuItem(constants.statusRebalance(), getMainModel().getStatusRebalanceCommand());
    menuCell.addMenuItem(constants.stopRebalance(), getMainModel().getStopRebalanceCommand());
    return menuCell;
}
#method_after
private MenuCell<GlusterTaskSupport> getRebalanceActivityMenu(ApplicationConstants constants) {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REBALANCE;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.statusRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStatusRebalanceCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.stopRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopRebalanceCommand();
        }
    });
    return menuCell;
}
#end_block

#method_before
private MenuCell<GlusterTaskSupport> getRemoveBrickActivityMenu(ApplicationConstants constants) {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK;
        }
    };
    menuCell.addMenuItem(constants.removeBricksStatus(), getMainModel().getBrickListModel().getStatusRemoveBricksCommand());
    menuCell.addMenuItem(constants.removeBricksStop(), getMainModel().getBrickListModel().getStopRemoveBricksCommand());
    menuCell.addMenuItem(constants.removeBricksCommit(), getMainModel().getBrickListModel().getCommitRemoveBricksCommand());
    menuCell.addMenuItem(constants.retainBricks(), getMainModel().getBrickListModel().getRetainBricksCommand());
    return menuCell;
}
#method_after
private MenuCell<GlusterTaskSupport> getRemoveBrickActivityMenu(ApplicationConstants constants) {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStatus()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getStatusRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStop()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getStopRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksCommit()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getCommitRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.retainBricks()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getRetainBricksCommand();
        }
    });
    return menuCell;
}
#end_block

#method_before
public boolean load() {
    // $NON-NLS-1$
    final String propertiesFileName = filePath + "/" + BRANDING_PROPERTIES_NAME;
    available = false;
    try (FileInputStream propertiesFile = new FileInputStream(propertiesFileName)) {
        brandingProperties.load(propertiesFile);
        available = supportedBrandingVersion == getVersion(brandingProperties);
        if (!available) {
            log.warn(// $NON-NLS-1$
            "Unable to load branding theme, mismatched version: " + getVersion(brandingProperties) + " wanted version: " + // $NON-NLS-1$
            supportedBrandingVersion);
        }
    } catch (IOException e) {
        // Unable to load properties file, disable theme.
        log.warn(// $NON-NLS-1$
        "Unable to load properties file for " + // $NON-NLS-1$
        "theme located here:" + propertiesFileName, e);
    }
    return available;
}
#method_after
public boolean load() {
    // $NON-NLS-1$
    final String propertiesFileName = filePath + "/" + BRANDING_PROPERTIES_NAME;
    available = false;
    try (FileInputStream propertiesFile = new FileInputStream(propertiesFileName)) {
        brandingProperties.load(propertiesFile);
        available = supportedBrandingVersion == getVersion(brandingProperties);
        if (!available) {
            log.warn(// $NON-NLS-1$
            "Unable to load branding theme, mismatched version: " + getVersion(brandingProperties) + " wanted version: " + // $NON-NLS-1$
            supportedBrandingVersion);
        } else {
            available = verifyPropertyValues(brandingProperties);
            if (!available) {
                // $NON-NLS-1$
                log.warn("Unable to load branding theme, property value verification failed");
            }
        }
    } catch (IOException e) {
        // Unable to load properties file, disable theme.
        log.warn(// $NON-NLS-1$
        "Unable to load properties file for " + // $NON-NLS-1$
        "theme located here:" + propertiesFileName, e);
    }
    return available;
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    QueryIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class);
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    QueryIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class);
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#end_block

#method_before
@Override
public Disk get() {
    return performGet(VdcQueryType.GetDiskByDiskId, new GetDiskByDiskIdParameters(guid));
}
#method_after
@Override
public Disk get() {
    return performGet(VdcQueryType.GetDiskByDiskId, new IdQueryParameters(guid));
}
#end_block

#method_before
@Test
public void testGet() {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class, new String[] { "DiskId" }, new Object[] { DISK_ID }, getEntity(1));
    control.replay();
    Disk disk = resource.get();
    verifyModelSpecific(disk, 1);
    verifyLinks(disk);
}
#method_after
@Test
public void testGet() {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { DISK_ID }, getEntity(1));
    control.replay();
    Disk disk = resource.get();
    verifyModelSpecific(disk, 1);
    verifyLinks(disk);
}
#end_block

#method_before
@Test
public void testMoveById() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class, new String[] { "DiskId" }, new Object[] { DISK_ID }, getEntity(1));
    setUriInfo(setUpActionExpectations(VdcActionType.MoveDisks, MoveDisksParameters.class, new String[] { "ParametersList" }, new Object[] { Collections.singletonList(new MoveDiskParameters(GUIDS[1], Guid.Empty, GUIDS[3])) }));
    Response response = ((BackendDiskResource) resource).move(setUpParams(false));
    verifyActionResponse(response, "disks/" + DISK_ID, false);
}
#method_after
@Test
public void testMoveById() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { DISK_ID }, getEntity(1));
    setUriInfo(setUpActionExpectations(VdcActionType.MoveDisks, MoveDisksParameters.class, new String[] { "ParametersList" }, new Object[] { Collections.singletonList(new MoveDiskParameters(GUIDS[1], Guid.Empty, GUIDS[3])) }, true, true, null, null, true));
    verifyActionResponse(resource.move(setUpParams(false)), "disks/" + DISK_ID, false);
}
#end_block

#method_before
@Test
public void testCopyById() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class, new String[] { "DiskId" }, new Object[] { DISK_ID }, getEntity(1));
    setUriInfo(setUpActionExpectations(VdcActionType.MoveOrCopyDisk, MoveOrCopyImageGroupParameters.class, new String[] { "ImageId", "SourceDomainId", "StorageDomainId", "Operation" }, new Object[] { GUIDS[1], Guid.Empty, GUIDS[3], ImageOperation.Copy }));
    Response response = (((BackendDiskResource) resource).copy(setUpParams(false)));
    verifyActionResponse(response, "disks/" + DISK_ID, false);
}
#method_after
@Test
public void testCopyById() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { DISK_ID }, getEntity(1));
    setUriInfo(setUpActionExpectations(VdcActionType.MoveOrCopyDisk, MoveOrCopyImageGroupParameters.class, new String[] { "ImageId", "SourceDomainId", "StorageDomainId", "Operation" }, new Object[] { GUIDS[1], Guid.Empty, GUIDS[3], ImageOperation.Copy }, true, true, null, null, true));
    verifyActionResponse(resource.copy(setUpParams(false)), "disks/" + DISK_ID, false);
}
#end_block

#method_before
@Override
protected org.ovirt.engine.core.common.businessentities.Disk getEntity(int index) {
    return setUpEntityExpectations(control.createMock(DiskImage.class), index);
}
#method_after
@Override
protected org.ovirt.engine.core.common.businessentities.Disk getEntity(int index) {
    DiskImage entity = new DiskImage();
    entity.setId(GUIDS[index]);
    entity.setImageId(GUIDS[1]);
    entity.setvolumeFormat(VolumeFormat.RAW);
    entity.setDiskInterface(DiskInterface.VirtIO);
    entity.setImageStatus(ImageStatus.OK);
    entity.setVolumeType(VolumeType.Sparse);
    entity.setBoot(false);
    entity.setShareable(false);
    entity.setPropagateErrors(PropagateErrors.On);
    return setUpStatisticalEntityExpectations(entity);
}
#end_block

#method_before
@Override
public ValidationResult validate(ConfigKey key, String value) {
    if (getTimeZoneType().getTimeZoneList().containsKey(value)) {
        return new ValidationResult(true);
    }
    return new ValidationResult(false, value + " is not a valid " + getHelpNoteType());
}
#method_after
@Override
public ValidationResult validate(ConfigKey key, String value) {
    if (getTimeZoneType().getTimeZoneList().containsKey(value)) {
        return new ValidationResult(true);
    }
    return new ValidationResult(false, String.format("%s is not a valid %s. %s", value, getHelpNoteType(), getExample()));
}
#end_block

#method_before
private void noIllegalStatusMessage() {
    assertFalse(cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString()));
}
#method_after
private void noIllegalStatusMessage() {
    assertFalse(cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2.toString()));
}
#end_block

#method_before
private void hasIllegalStatusMessage() {
    assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString()));
}
#method_after
private void hasIllegalStatusMessage() {
    assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2.toString()));
}
#end_block

#method_before
protected boolean checkStorageDomainStatusNotEqual(StorageDomainStatus status) {
    boolean returnValue = false;
    if (getStorageDomain() != null && getStorageDomain().getStatus() != null) {
        returnValue = (getStorageDomain().getStatus() != status);
        if (!returnValue) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2.toString());
            addCanDoActionMessage(String.format("$status %1$s", getStorageDomain().getStatus()));
        }
    }
    return returnValue;
}
#method_after
protected boolean checkStorageDomainStatusNotEqual(StorageDomainStatus status) {
    boolean returnValue = false;
    if (getStorageDomainStatus() != null) {
        returnValue = (getStorageDomainStatus() != status);
        if (!returnValue) {
            addStorageDomainStatusIllegalMessage();
        }
    }
    return returnValue;
}
#end_block

#method_before
protected StorageDomainStatus getStorageDomainStatus() {
    StorageDomainStatus status = null;
    if (getStorageDomain() != null) {
        status = getStorageDomain().getStatus();
    }
    return status;
}
#method_after
private StorageDomainStatus getStorageDomainStatus() {
    StorageDomainStatus status = null;
    if (getStorageDomain() != null) {
        status = getStorageDomain().getStatus();
    }
    return status;
}
#end_block

#method_before
private void addStorageDomainStatusIllegalMessage() {
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
}
#method_after
protected void addStorageDomainStatusIllegalMessage() {
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
    addCanDoActionMessage(String.format("$status %1$s", getStorageDomainStatus()));
}
#end_block

#method_before
public LinkedHashSet<Guid> getDiskIdsToIgnoreInChecks() {
    return diskIdsToIgnoreInChecks;
}
#method_after
public Set<Guid> getDiskIdsToIgnoreInChecks() {
    return diskIdsToIgnoreInChecks;
}
#end_block

#method_before
public void setDiskIdsToIgnoreInChecks(LinkedHashSet<Guid> diskIdsToIgnoreInChecks) {
    this.diskIdsToIgnoreInChecks = diskIdsToIgnoreInChecks;
}
#method_after
public void setDiskIdsToIgnoreInChecks(Set<Guid> diskIdsToIgnoreInChecks) {
    this.diskIdsToIgnoreInChecks = diskIdsToIgnoreInChecks;
}
#end_block

#method_before
private LiveMigrateDiskParameters createLiveMigrateDiskParameters(MoveDiskParameters moveDiskParameters, Guid vmId) {
    LiveMigrateDiskParameters toReturn = new LiveMigrateDiskParameters(moveDiskParameters.getImageId(), moveDiskParameters.getSourceDomainId(), moveDiskParameters.getStorageDomainId(), vmId, moveDiskParameters.getQuotaId());
    toReturn.setImageGroupID(diskMap.get(moveDiskParameters.getImageId()).getId());
    return toReturn;
}
#method_after
private LiveMigrateDiskParameters createLiveMigrateDiskParameters(MoveDiskParameters moveDiskParameters, Guid vmId) {
    return new LiveMigrateDiskParameters(moveDiskParameters.getImageId(), moveDiskParameters.getSourceDomainId(), moveDiskParameters.getStorageDomainId(), vmId, moveDiskParameters.getQuotaId(), diskMap.get(moveDiskParameters.getImageId()).getId());
}
#end_block

#method_before
protected void setImageStatus(ImageStatus imageStatus) {
    DiskImage diskImage = getRelevantDiskImage();
    if (diskImage != null) {
        diskImage.setImageStatus(imageStatus);
        ImagesHandler.updateImageStatus(diskImage.getImage().getId(), imageStatus);
    }
}
#method_after
protected void setImageStatus(ImageStatus imageStatus) {
    DiskImage diskImage = getRelevantDiskImage();
    if (diskImage != null && diskImage.getImageStatus() != imageStatus) {
        diskImage.setImageStatus(imageStatus);
        ImagesHandler.updateImageStatus(diskImage.getImage().getId(), imageStatus);
    }
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (getDestinationDiskImage() != null) {
        Guid storagePoolId = getDestinationDiskImage().getStoragePoolId() != null ? getDestinationDiskImage().getStoragePoolId() : Guid.Empty;
        Guid newImageGroupId = getDestinationDiskImage().getId() != null ? getDestinationDiskImage().getId() : Guid.Empty;
        Guid newImageId = getDestinationDiskImage().getImageId();
        Guid newStorageDomainID = getDestinationDiskImage().getStorageIds().get(0);
        // complete IRS data to DB disk image:
        DiskImage newImageIRS = (DiskImage) runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
        if (newImageIRS != null) {
            completeImageData(newImageIRS);
        }
        // Unlock destination image:
        if (!getParameters().isShouldLeaveLocked()) {
            getDestinationDiskImage().setImageStatus(ImageStatus.OK);
            getImageDao().update(getDestinationDiskImage().getImage());
        }
    }
    if (!getParameters().isShouldLeaveLocked()) {
        unLockImage();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    if (getDestinationDiskImage() != null) {
        Guid storagePoolId = getDestinationDiskImage().getStoragePoolId() != null ? getDestinationDiskImage().getStoragePoolId() : Guid.Empty;
        Guid newImageGroupId = getDestinationDiskImage().getId() != null ? getDestinationDiskImage().getId() : Guid.Empty;
        Guid newImageId = getDestinationDiskImage().getImageId();
        Guid newStorageDomainID = getDestinationDiskImage().getStorageIds().get(0);
        // complete IRS data to DB disk image:
        try {
            DiskImage newImageIRS = (DiskImage) runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
            if (newImageIRS != null) {
                completeImageData(newImageIRS);
            }
        } catch (VdcBLLException e) {
            // Logging only
            log.errorFormat("Unable to update the image info for image {0} (image group: {1}) on domain {2}", newImageId, newImageGroupId, newStorageDomainID);
        } finally {
            if (!getParameters().isLeaveLocked()) {
                getDestinationDiskImage().setImageStatus(ImageStatus.OK);
            }
            getImageDao().update(getDestinationDiskImage().getImage());
        }
    }
    if (!getParameters().isLeaveLocked()) {
        unLockImage();
    }
    setSucceeded(true);
}
#end_block

#method_before
protected List<DiskImage> getDisksListForChecks() {
    if (getParameters().getDiskIdsToIgnoreInChecks() == null) {
        return getDisksList();
    }
    List<DiskImage> toReturn = new LinkedList<>();
    for (DiskImage diskImage : getDisksList()) {
        if (!getParameters().getDiskIdsToIgnoreInChecks().contains(diskImage.getId())) {
            toReturn.add(diskImage);
        }
    }
    return toReturn;
}
#method_after
protected List<DiskImage> getDisksListForChecks() {
    if (getParameters().getDiskIdsToIgnoreInChecks().isEmpty()) {
        return getDisksList();
    }
    List<DiskImage> toReturn = new LinkedList<>();
    for (DiskImage diskImage : getDisksList()) {
        if (!getParameters().getDiskIdsToIgnoreInChecks().contains(diskImage.getId())) {
            toReturn.add(diskImage);
        }
    }
    return toReturn;
}
#end_block

#method_before
private ImagesActionsParametersBase buildCreateSnapshotParameters(DiskImage image) {
    VdcActionType parentCommand = getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.CreateAllSnapshotsFromVm;
    ImagesActionsParametersBase result = new ImagesActionsParametersBase(image.getImageId());
    result.setDescription(getParameters().getDescription());
    result.setSessionId(getParameters().getSessionId());
    result.setQuotaId(image.getQuotaId());
    result.setVmSnapshotId(newActiveSnapshotId);
    result.setEntityInfo(getParameters().getEntityInfo());
    result.setParentCommand(parentCommand);
    result.setParentParameters(getParametersForTask(parentCommand, getParameters()));
    if (getParameters().getDiskIdsToIgnoreInChecks().contains(image.getId())) {
        result.setShouldLeaveLocked(true);
    }
    return result;
}
#method_after
private ImagesActionsParametersBase buildCreateSnapshotParameters(DiskImage image) {
    VdcActionType parentCommand = getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.CreateAllSnapshotsFromVm;
    ImagesActionsParametersBase result = new ImagesActionsParametersBase(image.getImageId());
    result.setDescription(getParameters().getDescription());
    result.setSessionId(getParameters().getSessionId());
    result.setQuotaId(image.getQuotaId());
    result.setVmSnapshotId(newActiveSnapshotId);
    result.setEntityInfo(getParameters().getEntityInfo());
    result.setParentCommand(parentCommand);
    result.setParentParameters(getParametersForTask(parentCommand, getParameters()));
    if (getParameters().getDiskIdsToIgnoreInChecks().contains(image.getId())) {
        result.setLeaveLocked(true);
    }
    return result;
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (isLiveSnapshotApplicable()) {
            performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // If the removed snapshot contained memory, remove the memory volumes
            // Note that the memory volumes might not have been created
            removeMemoryVolumesOfSnapshot(createdSnapshot);
        } else {
            log.warnFormat("No snapshot was created for VM {0} which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded);
    getReturnValue().setEndActionTryAgain(false);
}
#method_after
@Override
protected void endVmCommand() {
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    boolean liveSnapshotRequired = isLiveSnapshotApplicable();
    boolean liveSnapshotSucceeded = false;
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (liveSnapshotRequired) {
            liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // Note that the memory volumes might not have been created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warnFormat("No snapshot was created for VM {0} which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded));
    getReturnValue().setEndActionTryAgain(false);
}
#end_block

#method_before
protected void performLiveSnapshot(final Snapshot snapshot) {
    try {
        TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                runVdsCommand(VDSCommandType.Snapshot, buildLiveSnapshotParameters(snapshot));
                return null;
            }
        });
    } catch (VdcBLLException e) {
        handleVdsLiveSnapshotFailure(e);
    }
}
#method_after
protected boolean performLiveSnapshot(final Snapshot snapshot) {
    try {
        TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                runVdsCommand(VDSCommandType.Snapshot, buildLiveSnapshotParameters(snapshot));
                return null;
            }
        });
    } catch (VdcBLLException e) {
        handleVdsLiveSnapshotFailure(e);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void execute() {
    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (LiveMigrateDiskParameters parameters : enclosingCommand.getParameters().getParametersList()) {
                CommandContext commandContext = ExecutionHandler.createInternalJobContext();
                ExecutionHandler.setAsyncJob(commandContext.getExecutionContext(), true);
                parameters.setSessionId(enclosingCommand.getParameters().getSessionId());
                VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.LiveMigrateDisk, parameters, commandContext);
                if (!vdcReturnValue.getSucceeded()) {
                    ImagesHandler.updateAllDiskImageSnapshotsStatus(parameters.getImageGroupID(), ImageStatus.OK);
                }
                enclosingCommand.getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                if (!parameters.getTaskGroupSuccess()) {
                    ExecutionHandler.endTaskJob(commandContext.getExecutionContext(), false);
                    log.errorFormat("Failed LiveMigrateDisk (Disk {0} , VM {1})", parameters.getImageGroupID(), parameters.getVmId());
                }
            }
            enclosingCommand.getReturnValue().setSucceeded(true);
            return null;
        }
    });
}
#method_after
@Override
public void execute() {
    if (!enclosingCommand.getReturnValue().getSucceeded()) {
        throw new VdcBLLException(VdcBllErrors.imageErr, "Auto-generated live snapshot for VM " + enclosingCommand.getParameters().getVmId() + " failed");
    }
    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (LiveMigrateDiskParameters parameters : enclosingCommand.getParameters().getParametersList()) {
                CommandContext commandContext = ExecutionHandler.createInternalJobContext();
                ExecutionHandler.setAsyncJob(commandContext.getExecutionContext(), true);
                parameters.setSessionId(enclosingCommand.getParameters().getSessionId());
                VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.LiveMigrateDisk, parameters, commandContext);
                if (!vdcReturnValue.getSucceeded()) {
                    ImagesHandler.updateAllDiskImageSnapshotsStatus(parameters.getImageGroupID(), ImageStatus.OK);
                }
                enclosingCommand.getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                if (!parameters.getTaskGroupSuccess()) {
                    ExecutionHandler.endTaskJob(commandContext.getExecutionContext(), false);
                    log.errorFormat("Failed LiveMigrateDisk (Disk {0} , VM {1})", parameters.getImageGroupID(), parameters.getVmId());
                }
            }
            enclosingCommand.getReturnValue().setSucceeded(true);
            return null;
        }
    });
}
#end_block

#method_before
private List<LiveMigrateDiskParameters> createLiveMigrateVmDisksParameters() {
    return Arrays.asList(new LiveMigrateDiskParameters(diskImageId, srcStorageId, dstStorageId, vmId, quotaId));
}
#method_after
private List<LiveMigrateDiskParameters> createLiveMigrateVmDisksParameters() {
    return Arrays.asList(new LiveMigrateDiskParameters(diskImageId, srcStorageId, dstStorageId, vmId, quotaId, diskImageId));
}
#end_block

#method_before
public SPMAsyncTask concreteCreateTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, getAsyncTask(taskId, asyncTaskCreationInfo, parentCommand));
    p.setEntityInfo(getParameters().getEntityInfo());
    return CreateTask(internalGetTaskType(), p);
}
#method_after
public SPMAsyncTask concreteCreateTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, getAsyncTask(taskId, asyncTaskCreationInfo, parentCommand));
    p.setEntityInfo(getParameters().getEntityInfo());
    return createTask(internalGetTaskType(), p);
}
#end_block

#method_before
protected Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        return createTaskImpl(taskId, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during createTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return Guid.Empty;
}
#method_after
public SPMAsyncTask createTask(AsyncTaskType taskType, AsyncTaskParameters taskParameters) {
    return AsyncTaskFactory.construct(taskType, taskParameters, false);
}
#end_block

#method_before
private void endCreateAllSnapshots() {
    Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), ExecutionHandler.createDefaultContexForTasks(enclosingCommand.getExecutionContext()));
}
#method_after
private void endCreateAllSnapshots() {
    VdcReturnValueBase returnValue = Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), ExecutionHandler.createDefaultContexForTasks(enclosingCommand.getExecutionContext()));
    enclosingCommand.getReturnValue().setSucceeded(returnValue.getSucceeded());
}
#end_block

#method_before
@Override
public void visitToken(DetailAST classDef) {
    if (!isClass(classDef) || !shouldCheckClass(classDef)) {
        return;
    }
    final DetailAST objBlock = classDef.findFirstToken(TokenTypes.OBJBLOCK);
    DetailAST child = objBlock.getFirstChild();
    boolean hasNoArgCtor = false;
    boolean hasExplicitCtor = false;
    while (child != null) {
        if (child.getType() == TokenTypes.CTOR_DEF) {
            hasExplicitCtor = true;
            DetailAST ctorParams = child.findFirstToken(TokenTypes.PARAMETERS);
            if (ctorParams.getChildCount() == 0) {
                hasNoArgCtor = true;
                break;
            }
        }
        child = child.getNextSibling();
    }
    if (!hasNoArgCtor && hasExplicitCtor) {
        log(classDef.getLineNo(), classDef.getColumnNo(), "Class must have a no-argument constructor (with any access modifier)," + " i.e. either explicit or default constructor without arguments.");
    }
}
#method_after
@Override
public void visitToken(DetailAST classDef) {
    if (!run) {
        return;
    }
    DetailAST objBlock = classDef.findFirstToken(TokenTypes.OBJBLOCK);
    DetailAST child = objBlock.getFirstChild();
    boolean hasExplicitCtor = false;
    while (child != null) {
        if (child.getType() == TokenTypes.CTOR_DEF) {
            hasExplicitCtor = true;
            DetailAST ctorParams = child.findFirstToken(TokenTypes.PARAMETERS);
            if (ctorParams.getChildCount() == 0) {
                // Found no-argument constructor
                return;
            }
        }
        child = child.getNextSibling();
    }
    if (hasExplicitCtor) {
        DetailAST classIdent = classDef.findFirstToken(TokenTypes.LITERAL_CLASS).getNextSibling();
        log(classIdent.getLineNo(), classIdent.getColumnNo(), "Class {0} must have a no-argument constructor (with any access modifier)", classIdent.getText());
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    if (getParameters().getDiskInfo().isShareable() && getStorageDomain().getStorageType() == StorageType.GLUSTERFS) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfImageDiskCanBeAdded(vm);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded();
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfImageDiskCanBeAdded(vm);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded();
    }
    return true;
}
#end_block

#method_before
private boolean checkIfImageDiskCanBeAdded(VM vm) {
    boolean returnValue;
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    // vm agnostic checks
    returnValue = validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive()) && checkImageConfiguration() && hasFreeSpace(getStorageDomain()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskValidator.isVirtIoScsiValid(vm));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).isUp()) && isStoragePoolMatching(vm) && isVmNotLocked() && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#method_after
private boolean checkIfImageDiskCanBeAdded(VM vm) {
    boolean returnValue;
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    // vm agnostic checks
    returnValue = validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive()) && !isShareableDiskOnGlusterDomain() && checkImageConfiguration() && hasFreeSpace(getStorageDomain()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskValidator.isVirtIoScsiValid(vm));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).isUp()) && isStoragePoolMatching(vm) && isVmNotLocked() && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#end_block

#method_before
private boolean validateCanUpdateShareable() {
    if (DiskStorageType.LUN == getOldDisk().getDiskStorageType()) {
        return true;
    }
    // Check if VM is not during snapshot.
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (isUpdatedToShareable(getOldDisk(), getNewDisk())) {
        StorageDomain storageDomain = getStorageDomainDAO().get(((DiskImage) getNewDisk()).getStorageIds().get(0));
        if (storageDomain.getStorageType() == StorageType.GLUSTERFS) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN);
        }
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(getOldDisk().getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) getOldDisk()).getImageTemplateId())) {
            return failCanDoAction(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
        }
        if (!isVersionSupportedForShareable(getOldDisk(), getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
            return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
        }
        if (!isVolumeFormatSupportedForShareable(((DiskImage) getNewDisk()).getVolumeFormat())) {
            return failCanDoAction(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
        }
    } else if (isUpdatedToNonShareable(getOldDisk(), getNewDisk())) {
        if (vmsDiskOrSnapshotAttachedTo.size() > 1) {
            return failCanDoAction(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
        }
    }
    return true;
}
#method_after
private boolean validateCanUpdateShareable() {
    if (DiskStorageType.LUN == getOldDisk().getDiskStorageType()) {
        return true;
    }
    // Check if VM is not during snapshot.
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (isUpdatedToShareable(getOldDisk(), getNewDisk())) {
        StorageDomainStatic sds = getStorageDomainStaticDAO().get(((DiskImage) getNewDisk()).getStorageIds().get(0));
        if (sds.getStorageType() == StorageType.GLUSTERFS) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN);
        }
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(getOldDisk().getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) getOldDisk()).getImageTemplateId())) {
            return failCanDoAction(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
        }
        if (!isVersionSupportedForShareable(getOldDisk(), getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
            return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
        }
        if (!isVolumeFormatSupportedForShareable(((DiskImage) getNewDisk()).getVolumeFormat())) {
            return failCanDoAction(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
        }
    } else if (isUpdatedToNonShareable(getOldDisk(), getNewDisk())) {
        if (vmsDiskOrSnapshotAttachedTo.size() > 1) {
            return failCanDoAction(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
        }
    }
    return true;
}
#end_block

#method_before
@Test
public void canDoActionFailedShareableDiskVolumeFormatUnsupported() throws Exception {
    UpdateVmDiskParameters parameters = createParameters();
    DiskImage disk = createShareableDisk(VolumeFormat.COW);
    StorageDomain storage = addNewStorageDomainToDisk(disk, StorageType.NFS);
    parameters.setDiskInfo(disk);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    when(storageDomainDao.get(storage.getId())).thenReturn(storage);
    initializeCommand(parameters);
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT.toString()));
}
#method_after
@Test
public void canDoActionFailedShareableDiskVolumeFormatUnsupported() throws Exception {
    UpdateVmDiskParameters parameters = createParameters();
    DiskImage disk = createShareableDisk(VolumeFormat.COW);
    StorageDomain storage = addNewStorageDomainToDisk(disk, StorageType.NFS);
    parameters.setDiskInfo(disk);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    when(storageDomainStaticDao.get(storage.getId())).thenReturn(storage.getStorageStaticData());
    initializeCommand(parameters);
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT.toString()));
}
#end_block

#method_before
@Test
public void canDoActionFailedShareableDiskOnGlusterDomain() throws Exception {
    UpdateVmDiskParameters parameters = createParameters();
    DiskImage disk = createShareableDisk(VolumeFormat.RAW);
    StorageDomain storage = addNewStorageDomainToDisk(disk, StorageType.GLUSTERFS);
    parameters.setDiskInfo(disk);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    when(storageDomainDao.get(storage.getId())).thenReturn(storage);
    initializeCommand(parameters);
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN.toString()));
}
#method_after
@Test
public void canDoActionFailedShareableDiskOnGlusterDomain() throws Exception {
    UpdateVmDiskParameters parameters = createParameters();
    DiskImage disk = createShareableDisk(VolumeFormat.RAW);
    StorageDomain storage = addNewStorageDomainToDisk(disk, StorageType.GLUSTERFS);
    parameters.setDiskInfo(disk);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    when(storageDomainStaticDao.get(storage.getId())).thenReturn(storage.getStorageStaticData());
    initializeCommand(parameters);
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN.toString()));
}
#end_block

#method_before
@Test
public void nullifiedSnapshotOnUpdateDiskToShareable() {
    UpdateVmDiskParameters parameters = createParameters();
    DiskImage disk = createShareableDisk(VolumeFormat.RAW);
    parameters.setDiskInfo(disk);
    StorageDomain storage = addNewStorageDomainToDisk(disk, StorageType.NFS);
    parameters.setDiskInfo(disk);
    DiskImage oldDisk = createDiskImage();
    oldDisk.setVmSnapshotId(Guid.newGuid());
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    when(storageDomainDao.get(storage.getId())).thenReturn(storage);
    initializeCommand(parameters);
    assertTrue(command.canDoAction());
    command.executeVmCommand();
    assertTrue(oldDisk.getVmSnapshotId() == null);
}
#method_after
@Test
public void nullifiedSnapshotOnUpdateDiskToShareable() {
    UpdateVmDiskParameters parameters = createParameters();
    DiskImage disk = createShareableDisk(VolumeFormat.RAW);
    parameters.setDiskInfo(disk);
    StorageDomain storage = addNewStorageDomainToDisk(disk, StorageType.NFS);
    parameters.setDiskInfo(disk);
    DiskImage oldDisk = createDiskImage();
    oldDisk.setVmSnapshotId(Guid.newGuid());
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    when(storageDomainStaticDao.get(storage.getId())).thenReturn(storage.getStorageStaticData());
    initializeCommand(parameters);
    assertTrue(command.canDoAction());
    command.executeVmCommand();
    assertTrue(oldDisk.getVmSnapshotId() == null);
}
#end_block

#method_before
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainDao).when(command).getStorageDomainDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    ejbRule.mockResource(ContainerManagedResourceType.TRANSACTION_MANAGER, new DummyTransactionManager());
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
}
#method_after
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    ejbRule.mockResource(ContainerManagedResourceType.TRANSACTION_MANAGER, new DummyTransactionManager());
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, List<String> messages) {
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        for (VDS host : hosts) {
            if (host.getId().equals(vm.getDedicatedVmForVds())) {
                return Arrays.asList(host);
            }
        }
        // if flow reaches here, the VM is pinned but there is no dedicated host.
        return new ArrayList<>();
    }
    return hosts;
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, List<String> messages) {
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        // host has been specified for pin to host.
        if (vm.getDedicatedVmForVds() != null) {
            for (VDS host : hosts) {
                if (host.getId().equals(vm.getDedicatedVmForVds())) {
                    return Arrays.asList(host);
                }
            }
        } else {
            // check pin to any (the VM should be down/ no migration allowed).
            if (vm.getRunOnVds() == null) {
                return hosts;
            }
        }
        // if flow reaches here, the VM is pinned but there is no dedicated host.
        return new ArrayList<>();
    }
    return hosts;
}
#end_block

#method_before
protected boolean initVm() {
    if (getVm() == null) {
        log.warnFormat("ResourceManager::{0}::No such vm (where id = '{1}' )in database", getClass().getName(), getVmId().toString());
        throw new VdcBLLException(VdcBllErrors.DB_NO_SUCH_VM);
    }
    if ((getVm().getStatus() == VMStatus.ImageIllegal) || (getVm().getStatus() == VMStatus.ImageLocked)) {
        log.warnFormat("ResourceManager::{0}::vm '{1}' has {2}", getClass().getName(), getVmId().toString(), (getVm().getStatus() == VMStatus.ImageLocked ? "a locked image" : "an illegal image"));
        setActionReturnValue(getVm().getStatus());
        return false;
    } else if (!getSnapshotsValidator().vmNotDuringSnapshot(getVmId()).isValid()) {
        log.warnFormat("ResourceManager::{0}::VM {1} is during snapshot", getClass().getName(), getVmId().toString());
        return false;
    } else {
        handleMemoryAdjustments();
        VmHandler.updateDisksFromDb(getVm());
        getVm().setKvmEnable(getParameters().getKvmEnable());
        getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
        getVm().setAcpiEnable(getParameters().getAcpiEnable());
        // Clear the first user:
        getVm().setConsoleUserId(null);
        getParameters().setRunAsStateless(getParameters().getRunAsStateless() != null ? getParameters().getRunAsStateless() : getVm().isStateless());
        getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
        (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
        if (getParameters().getInitializationType() == null) {
            // if vm not initialized, use sysprep/cloud-init
            if (!getVm().isInitialized()) {
                getVm().setInitializationType(osRepository.isWindows(getVm().getVmOsId()) ? InitializationType.Sysprep : InitializationType.CloudInit);
            }
        } else {
            getVm().setInitializationType(getParameters().getInitializationType());
        }
        // if we attach floppy we don't need the sysprep
        if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
            getVmStaticDAO().update(getVm().getStaticData());
        }
        // get what cpu flags should be passed to vdsm according to cluster
        // cpu name
        getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
        return true;
    }
}
#method_after
protected boolean initVm() {
    if (getVm() == null) {
        log.warnFormat("ResourceManager::{0}::No such vm (where id = '{1}' )in database", getClass().getName(), getVmId().toString());
        throw new VdcBLLException(VdcBllErrors.DB_NO_SUCH_VM);
    }
    if ((getVm().getStatus() == VMStatus.ImageIllegal) || (getVm().getStatus() == VMStatus.ImageLocked)) {
        log.warnFormat("ResourceManager::{0}::vm '{1}' has {2}", getClass().getName(), getVmId().toString(), (getVm().getStatus() == VMStatus.ImageLocked ? "a locked image" : "an illegal image"));
        setActionReturnValue(getVm().getStatus());
        return false;
    } else if (!getSnapshotsValidator().vmNotDuringSnapshot(getVmId()).isValid()) {
        log.warnFormat("ResourceManager::{0}::VM {1} is during snapshot", getClass().getName(), getVmId().toString());
        return false;
    } else {
        handleMemoryAdjustments();
        VmHandler.updateDisksFromDb(getVm());
        getVm().setKvmEnable(getParameters().getKvmEnable());
        getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
        getVm().setAcpiEnable(getParameters().getAcpiEnable());
        // Clear the first user:
        getVm().setConsoleUserId(null);
        getParameters().setRunAsStateless(getParameters().getRunAsStateless() != null ? getParameters().getRunAsStateless() : getVm().isStateless());
        getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
        (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
        if (getParameters().getInitializationType() == null) {
            // if vm not initialized, use sysprep/cloud-init
            if (!getVm().isInitialized()) {
                getVm().setInitializationType(osRepository.isWindows(getVm().getVmOsId()) ? InitializationType.Sysprep : // TODO: we should use cloud init automatically only when cloud init configuration will be available
                InitializationType.None);
            }
        } else {
            getVm().setInitializationType(getParameters().getInitializationType());
        }
        // if we attach floppy we don't need the sysprep
        if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
            getVmStaticDAO().update(getVm().getStaticData());
        }
        // get what cpu flags should be passed to vdsm according to cluster
        // cpu name
        getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
        return true;
    }
}
#end_block

#method_before
@Override
public Response activate(Action action) {
    validateParameters(action, "bricks");
    validateBrickNames(action);
    GlusterVolumeEntity volume = getEntity(GlusterVolumeEntity.class, VdcQueryType.GetGlusterVolumeById, new IdQueryParameters(asGuid(getVolumeId())), "");
    if (volume.getAsyncTask() != null && volume.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK && volume.getAsyncTask().getStatus() == JobExecutionStatus.FINISHED) {
        return stopMigrate(action);
    } else {
        Fault fault = new Fault();
        fault.setReason(localize(Messages.INVALID_ENUM_DETAIL));
        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(fault).build());
    }
}
#method_after
@Override
public Response activate(Action action) {
    validateParameters(action, "bricks");
    validateBrickNames(action);
    GlusterVolumeEntity volume = getEntity(GlusterVolumeEntity.class, VdcQueryType.GetGlusterVolumeById, new IdQueryParameters(asGuid(getVolumeId())), "");
    if (volume.getAsyncTask() != null && volume.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK && volume.getAsyncTask().getStatus() == JobExecutionStatus.FINISHED) {
        return stopMigrate(action);
    } else {
        Fault fault = new Fault();
        fault.setReason(localize(Messages.CANNOT_ACTIVATE_UNLESS_MIGRATION_COMPLETED));
        throw new WebApplicationException(Response.status(Response.Status.CONFLICT).entity(fault).build());
    }
}
#end_block

#method_before
private void initFailedQueriesEventSubscribers() {
    String emailRecipients = prop.getProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_RECIPIENTS, true);
    if (StringUtils.isEmpty(emailRecipients)) {
        return;
    }
    List<EventAuditLogSubscriber> failedQueriesEventSubscribers = new LinkedList<>();
    for (String email : emailRecipients.split(",")) {
        EventAuditLogSubscriber eals = new EventAuditLogSubscriber();
        eals.setevent_type(1);
        eals.setevent_up_name("DATABASE_UNREACHABLE");
        eals.setmethod_id(EventNotificationMethods.EMAIL.getValue());
        eals.setmethod_address(StringUtils.strip(email));
        eals.setmessage("Failed to query for notifications. Database Connection refused.");
        eals.setseverity(AuditLogSeverity.ERROR.getValue());
        failedQueriesEventSubscribers.add(eals);
    }
    this.failedQueriesEventSubscribers = failedQueriesEventSubscribers;
}
#method_after
private void initFailedQueriesEventSubscribers() {
    String emailRecipients = prop.getProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_RECIPIENTS, true);
    if (StringUtils.isEmpty(emailRecipients)) {
        return;
    }
    List<EventAuditLogSubscriber> failedQueriesEventSubscribers = new LinkedList<>();
    for (String email : emailRecipients.split(",")) {
        EventAuditLogSubscriber eals = new EventAuditLogSubscriber();
        eals.setevent_type(MessageHelper.MessageType.alertMessage.getEventType());
        eals.setevent_up_name("DATABASE_UNREACHABLE");
        eals.setmethod_id(EventNotificationMethods.EMAIL.getValue());
        eals.setmethod_address(StringUtils.strip(email));
        eals.setmessage("Failed to query for notifications. Database Connection refused.");
        eals.setseverity(AuditLogSeverity.ERROR.getValue());
        failedQueriesEventSubscribers.add(eals);
    }
    this.failedQueriesEventSubscribers = failedQueriesEventSubscribers;
}
#end_block

#method_before
private boolean deviceCanBeRemoved(VmDevice vmDevice) {
    if (!vmDevice.getDevice().equals(VmDeviceType.DISK.getName())) {
        return true;
    }
    return vmDevice.getSnapshotId() == null && getDiskDao().get(vmDevice.getDeviceId()).isAllowSnapshot();
}
#method_after
private boolean deviceCanBeRemoved(VmDevice vmDevice) {
    if (!vmDevice.getDevice().equals(VmDeviceType.DISK.getName())) {
        return true;
    }
    if (vmDevice.getSnapshotId() == null) {
        Disk disk = getDiskDao().get(vmDevice.getDeviceId());
        return disk != null && disk.isAllowSnapshot();
    }
    return false;
}
#end_block

#method_before
@Test
public void testRemoveNotFound() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetNetworksByStoragePoolId, StoragePoolQueryParametersBase.class, new String[] { "StoragePoolId" }, new Object[] { DATA_CENTER_ID }, new ArrayList<org.ovirt.engine.core.common.businessentities.network.Network>());
    control.replay();
    try {
        collection.remove(GUIDS[0].toString());
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyNotFoundException(wae);
    }
}
#method_after
@Test
public void testRemoveNotFound() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetNetworksByStoragePoolId, StorageDomainAndPoolQueryParameters.class, new String[] { "StoragePoolId" }, new Object[] { DATA_CENTER_ID }, new ArrayList<org.ovirt.engine.core.common.businessentities.network.Network>());
    control.replay();
    try {
        collection.remove(GUIDS[0].toString());
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyNotFoundException(wae);
    }
}
#end_block

#method_before
@Test
public void testRemoveNonExistant() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetNetworksByStoragePoolId, StoragePoolQueryParametersBase.class, new String[] { "StoragePoolId" }, new Object[] { DATA_CENTER_ID }, new LinkedList<org.ovirt.engine.core.common.businessentities.network.Network>(), null);
    control.replay();
    try {
        collection.remove(NON_EXISTANT_GUID.toString());
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        assertNotNull(wae.getResponse());
        assertEquals(404, wae.getResponse().getStatus());
    }
}
#method_after
@Test
public void testRemoveNonExistant() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetNetworksByStoragePoolId, StorageDomainAndPoolQueryParameters.class, new String[] { "StoragePoolId" }, new Object[] { DATA_CENTER_ID }, new LinkedList<org.ovirt.engine.core.common.businessentities.network.Network>(), null);
    control.replay();
    try {
        collection.remove(NON_EXISTANT_GUID.toString());
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        assertNotNull(wae.getResponse());
        assertEquals(404, wae.getResponse().getStatus());
    }
}
#end_block

#method_before
@Test
public void testAddNetwork() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpCreationExpectations(VdcActionType.AddNetwork, AddNetworkStoragePoolParameters.class, new String[] { "StoragePoolId" }, new Object[] { DATA_CENTER_ID }, true, true, // GUIDS[0],
    null, VdcQueryType.GetNetworksByStoragePoolId, StoragePoolQueryParametersBase.class, new String[] { "StoragePoolId" }, new Object[] { DATA_CENTER_ID }, asList(getEntity(0)));
    Network model = getModel(0);
    model.setDataCenter(new DataCenter());
    model.getDataCenter().setId(DATA_CENTER_ID.toString());
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Network);
    verifyModel((Network) response.getEntity(), 0);
}
#method_after
@Test
public void testAddNetwork() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpCreationExpectations(VdcActionType.AddNetwork, AddNetworkStoragePoolParameters.class, new String[] { "StoragePoolId" }, new Object[] { DATA_CENTER_ID }, true, true, // GUIDS[0],
    null, VdcQueryType.GetNetworksByStoragePoolId, StorageDomainAndPoolQueryParameters.class, new String[] { "StoragePoolId" }, new Object[] { DATA_CENTER_ID }, asList(getEntity(0)));
    Network model = getModel(0);
    model.setDataCenter(new DataCenter());
    model.getDataCenter().setId(DATA_CENTER_ID.toString());
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Network);
    verifyModel((Network) response.getEntity(), 0);
}
#end_block

#method_before
@Override
protected void setUpQueryExpectations(String query, Object failure) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetNetworksByStoragePoolId, StoragePoolQueryParametersBase.class, new String[] { "StoragePoolId" }, new Object[] { DATA_CENTER_ID }, getEntityList(), failure);
    control.replay();
}
#method_after
@Override
protected void setUpQueryExpectations(String query, Object failure) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetNetworksByStoragePoolId, StorageDomainAndPoolQueryParameters.class, new String[] { "StoragePoolId" }, new Object[] { DATA_CENTER_ID }, getEntityList(), failure);
    control.replay();
}
#end_block

#method_before
@Override
protected void setUpEntityQueryExpectations(int times, Object failure) throws Exception {
    while (times-- > 0) {
        setUpEntityQueryExpectations(VdcQueryType.GetNetworksByStoragePoolId, StoragePoolQueryParametersBase.class, new String[] { "StoragePoolId" }, new Object[] { DATA_CENTER_ID }, getEntityList(), failure);
    }
}
#method_after
@Override
protected void setUpEntityQueryExpectations(int times, Object failure) throws Exception {
    while (times-- > 0) {
        setUpEntityQueryExpectations(VdcQueryType.GetNetworksByStoragePoolId, StorageDomainAndPoolQueryParameters.class, new String[] { "StoragePoolId" }, new Object[] { DATA_CENTER_ID }, getEntityList(), failure);
    }
}
#end_block

#method_before
protected storage_pool setUpStoragePool(Guid id) {
    storage_pool pool = control.createMock(storage_pool.class);
    expect(pool.getId()).andReturn(id).anyTimes();
    return pool;
}
#method_after
protected StoragePool setUpStoragePool(Guid id) {
    StoragePool pool = control.createMock(StoragePool.class);
    expect(pool.getId()).andReturn(id).anyTimes();
    return pool;
}
#end_block

#method_before
@Override
public DataCenter get() {
    return performGet(VdcQueryType.GetStoragePoolById, new StoragePoolQueryParametersBase(guid));
}
#method_after
@Override
public DataCenter get() {
    return performGet(VdcQueryType.GetStoragePoolById, new IdQueryParameters(guid));
}
#end_block

#method_before
@Override
public DataCenter update(DataCenter incoming) {
    validateEnums(DataCenter.class, incoming);
    return performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetStoragePoolById, StoragePoolQueryParametersBase.class), VdcActionType.UpdateStoragePool, new UpdateParametersProvider());
}
#method_after
@Override
public DataCenter update(DataCenter incoming) {
    validateEnums(DataCenter.class, incoming);
    return performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetStoragePoolById, IdQueryParameters.class), VdcActionType.UpdateStoragePool, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
protected DataCenter doPopulate(DataCenter model, storage_pool entity) {
    return parent.doPopulate(model, entity);
}
#method_after
@Override
protected DataCenter doPopulate(DataCenter model, StoragePool entity) {
    return parent.doPopulate(model, entity);
}
#end_block

#method_before
@Override
protected DataCenter deprecatedPopulate(DataCenter model, storage_pool entity) {
    return parent.deprecatedPopulate(model, entity);
}
#method_after
@Override
protected DataCenter deprecatedPopulate(DataCenter model, StoragePool entity) {
    return parent.deprecatedPopulate(model, entity);
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(DataCenter incoming, storage_pool entity) {
    return new StoragePoolManagementParameter(map(incoming, entity));
}
#method_after
@Override
public VdcActionParametersBase getParameters(DataCenter incoming, StoragePool entity) {
    return new StoragePoolManagementParameter(map(incoming, entity));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static storage_pool getStoragePool(Cluster cluster, AbstractBackendResource parent) {
    storage_pool pool = null;
    if (cluster.getDataCenter().isSetId()) {
        String id = cluster.getDataCenter().getId();
        pool = (storage_pool) parent.getEntity(storage_pool.class, VdcQueryType.GetStoragePoolById, new StoragePoolQueryParametersBase(new Guid(id)), "Datacenter: id=" + id);
    } else {
        pool = (storage_pool) parent.getEntity(storage_pool.class, SearchType.StoragePool, "Datacenter: name=" + cluster.getDataCenter().getName());
        cluster.getDataCenter().setId(pool.getId().toString());
    }
    return pool;
}
#method_after
@SuppressWarnings("unchecked")
public static StoragePool getStoragePool(Cluster cluster, AbstractBackendResource parent) {
    StoragePool pool = null;
    if (cluster.getDataCenter().isSetId()) {
        String id = cluster.getDataCenter().getId();
        pool = parent.getEntity(StoragePool.class, VdcQueryType.GetStoragePoolById, new IdQueryParameters(new Guid(id)), "Datacenter: id=" + id);
    } else {
        pool = parent.getEntity(StoragePool.class, SearchType.StoragePool, "Datacenter: name=" + cluster.getDataCenter().getName());
        cluster.getDataCenter().setId(pool.getId().toString());
    }
    return pool;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static List<storage_pool> getStoragePools(Guid storageDomainId, AbstractBackendResource parent) {
    return (List<storage_pool>) parent.getEntity(List.class, VdcQueryType.GetStoragePoolsByStorageDomainId, new StorageDomainQueryParametersBase(storageDomainId), "Datacenters", true);
}
#method_after
@SuppressWarnings("unchecked")
public static List<StoragePool> getStoragePools(Guid storageDomainId, AbstractBackendResource parent) {
    return parent.getEntity(List.class, VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), "Datacenters", true);
}
#end_block

#method_before
@Override
public Response add(DataCenter dataCenter) {
    validateParameters(dataCenter, "name", "storageType");
    validateEnums(DataCenter.class, dataCenter);
    validateEnum(StorageType.class, dataCenter.getStorageType().toUpperCase());
    storage_pool entity = map(dataCenter);
    return performCreate(VdcActionType.AddEmptyStoragePool, new StoragePoolManagementParameter(entity), new QueryIdResolver<Guid>(VdcQueryType.GetStoragePoolById, StoragePoolQueryParametersBase.class));
}
#method_after
@Override
public Response add(DataCenter dataCenter) {
    validateParameters(dataCenter, "name", "storageType");
    validateEnums(DataCenter.class, dataCenter);
    validateEnum(StorageType.class, dataCenter.getStorageType().toUpperCase());
    StoragePool entity = map(dataCenter);
    return performCreate(VdcActionType.AddEmptyStoragePool, new StoragePoolManagementParameter(entity), new QueryIdResolver<Guid>(VdcQueryType.GetStoragePoolById, IdQueryParameters.class));
}
#end_block

#method_before
private DataCenters mapCollection(List<storage_pool> entities) {
    DataCenters collection = new DataCenters();
    for (storage_pool entity : entities) {
        collection.getDataCenters().add(addLinks(populate(map(entity), entity)));
    }
    return collection;
}
#method_after
private DataCenters mapCollection(List<StoragePool> entities) {
    DataCenters collection = new DataCenters();
    for (StoragePool entity : entities) {
        collection.getDataCenters().add(addLinks(populate(map(entity), entity)));
    }
    return collection;
}
#end_block

#method_before
@Override
protected DataCenter doPopulate(DataCenter model, storage_pool entity) {
    return model;
}
#method_after
@Override
protected DataCenter doPopulate(DataCenter model, StoragePool entity) {
    return model;
}
#end_block

#method_before
@Override
protected DataCenter deprecatedPopulate(DataCenter model, storage_pool entity) {
    GetAvailableStoragePoolVersionsParameters parameters = new GetAvailableStoragePoolVersionsParameters();
    parameters.setStoragePoolId(new Guid(model.getId()));
    model.setSupportedVersions(getMapper(List.class, SupportedVersions.class).map(getEntity(ArrayList.class, VdcQueryType.GetAvailableStoragePoolVersions, parameters, model.getId()), null));
    return model;
}
#method_after
@Override
protected DataCenter deprecatedPopulate(DataCenter model, StoragePool entity) {
    IdQueryParameters parameters = new IdQueryParameters(new Guid(model.getId()));
    model.setSupportedVersions(getMapper(List.class, SupportedVersions.class).map(getEntity(ArrayList.class, VdcQueryType.GetAvailableStoragePoolVersions, parameters, model.getId()), null));
    return model;
}
#end_block

#method_before
@Override
public Networks list() {
    Networks networks = mapCollection(getBackendCollection(VdcQueryType.GetNetworksByStoragePoolId, getQueryParameters()));
    for (Network network : networks.getNetworks()) {
        network.setDisplay(null);
    }
    return networks;
}
#method_after
@Override
public Networks list() {
    Networks networks = mapCollection(getNetworks());
    for (Network network : networks.getNetworks()) {
        network.setDisplay(null);
    }
    return networks;
}
#end_block

#method_before
@Override
protected VdcQueryParametersBase getQueryParameters() {
    return new StoragePoolQueryParametersBase(dataCenterId);
}
#method_after
@Override
protected VdcQueryParametersBase getQueryParameters() {
    return new StorageDomainAndPoolQueryParameters(Guid.Empty, dataCenterId);
}
#end_block

#method_before
@Override
protected AddNetworkStoragePoolParameters getActionParameters(Network network, org.ovirt.engine.core.common.businessentities.network.Network entity) {
    if (namedDataCenter(network)) {
        entity.setDataCenterId(getDataCenterId(network));
    }
    return new AddNetworkStoragePoolParameters(entity.getDataCenterId().getValue(), entity);
}
#method_after
@Override
protected AddNetworkStoragePoolParameters getActionParameters(Network network, org.ovirt.engine.core.common.businessentities.network.Network entity) {
    if (namedDataCenter(network)) {
        entity.setDataCenterId(getDataCenterId(network));
    }
    AddNetworkStoragePoolParameters parameters = new AddNetworkStoragePoolParameters(entity.getDataCenterId(), entity);
    if (network != null && network.isSetProfileRequired()) {
        parameters.setVnicProfileRequired(network.isProfileRequired());
    }
    return parameters;
}
#end_block

#method_before
protected Guid getDataCenterId(Network network) {
    return getEntity(storage_pool.class, SearchType.StoragePool, "Datacenter: name=" + network.getDataCenter().getName()).getId();
}
#method_after
protected Guid getDataCenterId(Network network) {
    return getEntity(StoragePool.class, SearchType.StoragePool, "Datacenter: name=" + network.getDataCenter().getName()).getId();
}
#end_block

#method_before
public String translateErrorTextSingle(String errorMsg, Boolean changeIfNotFound) {
    // $NON-NLS-1$
    String ret = "";
    try {
        if ((errorMsg != null) && (errorMsg.length() > 0)) {
            // Taking a copy of the error message
            String errMsgCopy = errorMsg;
            if (!isDynamicVariable(errorMsg)) {
                errorMsg = errorMsg.replace('.', '_');
            }
            if (errors.getString(errorMsg) != null) {
                // $NON-NLS-1$ //$NON-NLS-2$
                ret = errors.getString(errorMsg).replace("\n", "<br/>");
            } else {
                // The error message is not found in the errors map, revert to original one
                // without replacement of "." with "_"
                errorMsg = errMsgCopy;
                if ((isDynamicVariable(errorMsg)) || (!changeIfNotFound)) {
                    ret = errorMsg;
                } else {
                    // just a message that doesn't have a value in the resource:
                    // $NON-NLS-1$
                    String[] splitted = errorMsg.toLowerCase().split("_");
                    // $NON-NLS-1$
                    ret = StringHelper.join(" ", splitted);
                }
            }
        }
    } catch (MissingResourceException e) {
        ret = errorMsg;
    }
    return ret;
}
#method_after
public String translateErrorTextSingle(String errorMsg, Boolean changeIfNotFound) {
    // $NON-NLS-1$
    String ret = "";
    try {
        if ((errorMsg != null) && (errorMsg.length() > 0)) {
            // Taking a copy of the error message
            String errMsgCopy = errorMsg;
            if (!isDynamicVariable(errorMsg)) {
                errorMsg = errorMsg.replace('.', '_');
            }
            if (errors.getString(errorMsg) != null) {
                // $NON-NLS-1$ //$NON-NLS-2$
                ret = errors.getString(errorMsg).replace("\n", "<br/>");
            } else {
                if ((isDynamicVariable(errorMsg)) || (!changeIfNotFound)) {
                    ret = errorMsg;
                } else {
                    // The error message is not found in the errors map, revert to original one
                    // without replacement of "." with "_"
                    errorMsg = errMsgCopy;
                    // just a message that doesn't have a value in the resource:
                    // $NON-NLS-1$
                    String[] splitted = errorMsg.toLowerCase().split("_");
                    // $NON-NLS-1$
                    ret = StringHelper.join(" ", splitted);
                }
            }
        }
    } catch (MissingResourceException e) {
        ret = errorMsg;
    }
    return ret;
}
#end_block

#method_before
private void newVolume() {
    if (getWindow() != null) {
        return;
    }
    VolumeModel volumeModel = new VolumeModel();
    volumeModel.setTitle(ConstantsManager.getInstance().getConstants().newVolumeTitle());
    setWindow(volumeModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VolumeListModel volumeListModel = (VolumeListModel) model;
            VolumeModel innerVolumeModel = (VolumeModel) volumeListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (volumeListModel.getSystemTreeSelectedItem() != null) {
                switch(volumeListModel.getSystemTreeSelectedItem().getType()) {
                    case Volumes:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerVolumeModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerVolumeModel.getCluster().setItems(Arrays.asList(cluster));
                        innerVolumeModel.getCluster().setSelectedItem(cluster);
                        innerVolumeModel.getCluster().setIsChangable(false);
                        innerVolumeModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case Clusters:
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerVolumeModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerVolumeModel.getDataCenter().setItems(dataCenters);
                        innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerVolumeModel.getDataCenter().setItems(dataCenters);
                innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand command = new UICommand("onCreateVolume", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerVolumeModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerVolumeModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterByClusterServiceList(_asyncQuery, false, true);
}
#method_after
private void newVolume() {
    if (getWindow() != null) {
        return;
    }
    VolumeModel volumeModel = new VolumeModel();
    // $NON-NLS-1$
    volumeModel.setHashName("new_volume");
    volumeModel.setTitle(ConstantsManager.getInstance().getConstants().newVolumeTitle());
    setWindow(volumeModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VolumeListModel volumeListModel = (VolumeListModel) model;
            VolumeModel innerVolumeModel = (VolumeModel) volumeListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (volumeListModel.getSystemTreeSelectedItem() != null) {
                switch(volumeListModel.getSystemTreeSelectedItem().getType()) {
                    case Volumes:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerVolumeModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerVolumeModel.getCluster().setItems(Arrays.asList(cluster));
                        innerVolumeModel.getCluster().setSelectedItem(cluster);
                        innerVolumeModel.getCluster().setIsChangable(false);
                        innerVolumeModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case Clusters:
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerVolumeModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerVolumeModel.getDataCenter().setItems(dataCenters);
                        innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerVolumeModel.getDataCenter().setItems(dataCenters);
                innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand command = new UICommand("onCreateVolume", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerVolumeModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerVolumeModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterByClusterServiceList(_asyncQuery, false, true);
}
#end_block

#method_before
private void stopRebalance() {
    if (getSelectedItems() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterVolumeEntity item : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("onStopRebalance", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void stopRebalance() {
    if (getSelectedItem() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getMessages().confirmStopVolumeRebalance(volumeEntity.getName()));
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("onStopRebalance", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void showRebalanceStatus() {
    if (getSelectedItem() == null) {
        return;
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(cModel);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().rebalanceStatusTitle());
    // $NON-NLS-1$
    cModel.startProgress(ConstantsManager.getInstance().getConstants().rebalanceStatusFetchMessage());
    // $NON-NLS-1$
    final UICommand rebalanceStatusOk = new UICommand("rebalanceNotStarted", VolumeListModel.this);
    rebalanceStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    rebalanceStatusOk.setIsCancel(true);
    cModel.getCommands().add(rebalanceStatusOk);
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            cModel.stopProgress();
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = vdcValue.getReturnValue();
            if ((rebalanceStatusEntity == null) || !(vdcValue.getSucceeded())) {
                cModel.setMessage(ConstantsManager.getInstance().getMessages().rebalanceStatusFailed(volumeEntity.getName()));
            } else {
                setConfirmWindow(null);
                if (getWindow() == null) {
                    VolumeRebalanceStatusModel rebalanceStatusModel = new VolumeRebalanceStatusModel(volumeEntity);
                    rebalanceStatusModel.setTitle(ConstantsManager.getInstance().getConstants().volumeRebalanceStatusTitle());
                    setWindow(rebalanceStatusModel);
                    rebalanceStatusModel.getVolume().setEntity(volumeEntity.getName());
                    rebalanceStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
                    // $NON-NLS-1$
                    UICommand stopRebalanceFromStatus = new UICommand("stop_rebalance_from_status", VolumeListModel.this);
                    stopRebalanceFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRebalance());
                    rebalanceStatusModel.getCommands().add(stopRebalanceFromStatus);
                    rebalanceStatusModel.setStopReblanceFromStatus(stopRebalanceFromStatus);
                    // $NON-NLS-1$
                    UICommand cancelRebalance = new UICommand("CancelRebalanceStatus", VolumeListModel.this);
                    cancelRebalance.setTitle(ConstantsManager.getInstance().getConstants().close());
                    cancelRebalance.setIsCancel(true);
                    rebalanceStatusModel.getCommands().add(cancelRebalance);
                    rebalanceStatusModel.showStatus(rebalanceStatusEntity);
                } else {
                    VolumeRebalanceStatusModel statusModel = (VolumeRebalanceStatusModel) getWindow();
                    statusModel.getCommands().get(0).setIsExecutionAllowed(false);
                    statusModel.showStatus(rebalanceStatusEntity);
                }
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#method_after
private void showRebalanceStatus() {
    if (getSelectedItem() == null) {
        return;
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(cModel);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().rebalanceStatusTitle());
    // $NON-NLS-1$
    cModel.startProgress(ConstantsManager.getInstance().getConstants().rebalanceStatusFetchMessage());
    // $NON-NLS-1$
    cModel.setHashName("volume_rebalance_status");
    // $NON-NLS-1$
    final UICommand rebalanceStatusOk = new UICommand("rebalanceNotStarted", VolumeListModel.this);
    rebalanceStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    rebalanceStatusOk.setIsCancel(true);
    cModel.getCommands().add(rebalanceStatusOk);
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            cModel.stopProgress();
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = vdcValue.getReturnValue();
            if ((rebalanceStatusEntity == null) || !(vdcValue.getSucceeded())) {
                cModel.setMessage(ConstantsManager.getInstance().getMessages().rebalanceStatusFailed(volumeEntity.getName()));
            } else {
                setConfirmWindow(null);
                if (getWindow() == null) {
                    VolumeRebalanceStatusModel rebalanceStatusModel = new VolumeRebalanceStatusModel(volumeEntity);
                    rebalanceStatusModel.setTitle(ConstantsManager.getInstance().getConstants().volumeRebalanceStatusTitle());
                    setWindow(rebalanceStatusModel);
                    rebalanceStatusModel.getVolume().setEntity(volumeEntity.getName());
                    rebalanceStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
                    // $NON-NLS-1$
                    UICommand stopRebalanceFromStatus = new UICommand("stop_rebalance_from_status", VolumeListModel.this);
                    stopRebalanceFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRebalance());
                    rebalanceStatusModel.getCommands().add(stopRebalanceFromStatus);
                    rebalanceStatusModel.setStopReblanceFromStatus(stopRebalanceFromStatus);
                    // $NON-NLS-1$
                    UICommand cancelRebalance = new UICommand("CancelRebalanceStatus", VolumeListModel.this);
                    cancelRebalance.setTitle(ConstantsManager.getInstance().getConstants().close());
                    cancelRebalance.setIsCancel(true);
                    rebalanceStatusModel.getCommands().add(cancelRebalance);
                    rebalanceStatusModel.showStatus(rebalanceStatusEntity);
                } else {
                    VolumeRebalanceStatusModel statusModel = (VolumeRebalanceStatusModel) getWindow();
                    statusModel.getCommands().get(0).setIsExecutionAllowed(false);
                    statusModel.showStatus(rebalanceStatusEntity);
                }
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#end_block

#method_before
public void edit() {
    final VmPool pool = (VmPool) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final PoolListModel poolListModel = this;
    Frontend.RunQuery(VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(pool.getVmPoolId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object modell, Object result) {
            final VM vm = (VM) ((VdcQueryReturnValue) result).getReturnValue();
            final ExistingPoolModelBehavior behavior = new ExistingPoolModelBehavior(vm);
            behavior.getPoolModelBehaviorInitializedEvent().addListener(new IEventListener() {

                @Override
                public void eventRaised(Event ev, Object sender, EventArgs args) {
                    final PoolModel model = behavior.getModel();
                    for (Object item : model.getPoolType().getItems()) {
                        EntityModel a = (EntityModel) item;
                        if (a.getEntity() == pool.getVmPoolType()) {
                            model.getPoolType().setSelectedItem(a);
                            break;
                        }
                    }
                    String cdImage = null;
                    if (vm != null) {
                        model.getDataCenterWithClustersList().setSelectedItem(null);
                        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(model.getDataCenterWithClustersList().getItems(), new Linq.DataCenterWithClusterPredicate(vm.getStoragePoolId(), vm.getVdsGroupId())));
                        model.getTemplate().setIsChangable(false);
                        cdImage = vm.getIsoPath();
                        model.getVmType().setSelectedItem(vm.getVmType());
                    } else {
                        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(Linq.<StoragePool>cast(model.getDataCenterWithClustersList().getItems())));
                    }
                    model.getDataCenterWithClustersList().setIsChangable(vm == null);
                    boolean hasCd = !StringHelper.isNullOrEmpty(cdImage);
                    model.getCdImage().setIsChangable(hasCd);
                    model.getCdAttached().setEntity(hasCd);
                    if (hasCd) {
                        model.getCdImage().setSelectedItem(cdImage);
                    }
                    model.getProvisioning().setIsChangable(false);
                    model.getStorageDomain().setIsChangable(false);
                    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
                    switchModeCommand.init(model);
                    model.getCommands().add(switchModeCommand);
                    // $NON-NLS-1$
                    UICommand command = new UICommand("OnSave", poolListModel);
                    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
                    command.setIsDefault(true);
                    model.getCommands().add(command);
                    // $NON-NLS-1$
                    command = new UICommand("Cancel", poolListModel);
                    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
                    command.setIsCancel(true);
                    model.getCommands().add(command);
                }
            });
            PoolModel model = new PoolModel(behavior);
            model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
            model.startProgress("");
            setWindow(model);
            model.setTitle(ConstantsManager.getInstance().getConstants().editPoolTitle());
            model.initialize(getSystemTreeSelectedItem());
            model.getName().setEntity(pool.getName());
            model.getDescription().setEntity(pool.getVmPoolDescription());
            model.getComment().setEntity(pool.getComment());
            model.getAssignedVms().setEntity(pool.getAssignedVmsCount());
            model.getPrestartedVms().setEntity(pool.getPrestartedVms());
            // $NON-NLS-1$
            model.setPrestartedVmsHint("0-" + pool.getAssignedVmsCount());
            model.getMaxAssignedVmsPerUser().setEntity(pool.getMaxAssignedVmsPerUser());
        }
    }));
}
#method_after
public void edit() {
    final VmPool pool = (VmPool) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final PoolListModel poolListModel = this;
    Frontend.RunQuery(VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(pool.getVmPoolId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object modell, Object result) {
            final VM vm = (VM) ((VdcQueryReturnValue) result).getReturnValue();
            final ExistingPoolModelBehavior behavior = new ExistingPoolModelBehavior(vm);
            behavior.getPoolModelBehaviorInitializedEvent().addListener(new IEventListener() {

                @Override
                public void eventRaised(Event ev, Object sender, EventArgs args) {
                    final PoolModel model = behavior.getModel();
                    for (EntityModel<VmPoolType> item : model.getPoolType().getItems()) {
                        if (item.getEntity() == pool.getVmPoolType()) {
                            model.getPoolType().setSelectedItem(item);
                            break;
                        }
                    }
                    String cdImage = null;
                    if (vm != null) {
                        model.getDataCenterWithClustersList().setSelectedItem(null);
                        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(model.getDataCenterWithClustersList().getItems(), new Linq.DataCenterWithClusterPredicate(vm.getStoragePoolId(), vm.getVdsGroupId())));
                        model.getTemplate().setIsChangable(false);
                        cdImage = vm.getIsoPath();
                        model.getVmType().setSelectedItem(vm.getVmType());
                    } else {
                        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(model.getDataCenterWithClustersList().getItems()));
                    }
                    model.getDataCenterWithClustersList().setIsChangable(vm == null);
                    boolean hasCd = !StringHelper.isNullOrEmpty(cdImage);
                    model.getCdImage().setIsChangable(hasCd);
                    model.getCdAttached().setEntity(hasCd);
                    if (hasCd) {
                        model.getCdImage().setSelectedItem(cdImage);
                    }
                    model.getProvisioning().setIsChangable(false);
                    model.getStorageDomain().setIsChangable(false);
                    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
                    switchModeCommand.init(model);
                    model.getCommands().add(switchModeCommand);
                    // $NON-NLS-1$
                    UICommand command = new UICommand("OnSave", poolListModel);
                    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
                    command.setIsDefault(true);
                    model.getCommands().add(command);
                    // $NON-NLS-1$
                    command = new UICommand("Cancel", poolListModel);
                    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
                    command.setIsCancel(true);
                    model.getCommands().add(command);
                }
            });
            PoolModel model = new PoolModel(behavior);
            model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
            model.startProgress("");
            setWindow(model);
            model.setTitle(ConstantsManager.getInstance().getConstants().editPoolTitle());
            model.initialize(getSystemTreeSelectedItem());
            model.getName().setEntity(pool.getName());
            model.getDescription().setEntity(pool.getVmPoolDescription());
            model.getComment().setEntity(pool.getComment());
            model.getAssignedVms().setEntity(pool.getAssignedVmsCount());
            model.getPrestartedVms().setEntity(pool.getPrestartedVms());
            // $NON-NLS-1$
            model.setPrestartedVmsHint("0-" + pool.getAssignedVmsCount());
            model.getMaxAssignedVmsPerUser().setEntity(pool.getMaxAssignedVmsPerUser());
        }
    }));
}
#end_block

#method_before
public void onSave() {
    final PoolModel model = (PoolModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsNew() && getSelectedItem() == null) {
        cancel();
        return;
    }
    if (!model.validate()) {
        return;
    }
    final VmPool pool = model.getIsNew() ? new VmPool() : (VmPool) Cloner.clone(getSelectedItem());
    final String name = (String) model.getName().getEntity();
    // Check name unicitate.
    AsyncDataProvider.isPoolNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Boolean isUnique = (Boolean) returnValue;
            if ((model.getIsNew() && !isUnique) || (!model.getIsNew() && !isUnique && name.compareToIgnoreCase(pool.getName()) != 0)) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setIsGeneralTabValid(false);
                return;
            }
            // Save changes.
            pool.setName((String) model.getName().getEntity());
            pool.setVmPoolDescription((String) model.getDescription().getEntity());
            pool.setVdsGroupId(model.getSelectedCluster().getId());
            pool.setComment((String) model.getComment().getEntity());
            pool.setPrestartedVms(model.getPrestartedVms().asConvertible().integer());
            pool.setMaxAssignedVmsPerUser(model.getMaxAssignedVmsPerUser().asConvertible().integer());
            EntityModel poolTypeSelectedItem = (EntityModel) model.getPoolType().getSelectedItem();
            pool.setVmPoolType((VmPoolType) poolTypeSelectedItem.getEntity());
            Guid default_host;
            VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
            if ((Boolean) model.getIsAutoAssign().getEntity()) {
                default_host = null;
            } else {
                default_host = defaultHost.getId();
            }
            VM vm = new VM();
            vm.setVmtGuid(((VmTemplate) model.getTemplate().getSelectedItem()).getId());
            vm.setName(name);
            vm.setVmOs((Integer) model.getOSType().getSelectedItem());
            vm.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
            vm.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
            vm.setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
            vm.setSingleQxlPci((Boolean) model.getIsSingleQxlEnabled().getEntity());
            vm.setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : // $NON-NLS-1$
            "");
            vm.setVmMemSizeMb((Integer) model.getMemSize().getEntity());
            vm.setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
            vm.setVdsGroupId(model.getSelectedCluster().getId());
            vm.setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
            "");
            vm.setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
            vm.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
            vm.setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
            vm.setStateless(false);
            vm.setDefaultBootSequence(model.getBootSequence());
            vm.setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : // $NON-NLS-1$
            "");
            vm.setDedicatedVmForVds(default_host);
            vm.setKernelUrl((String) model.getKernel_path().getEntity());
            vm.setKernelParams((String) model.getKernel_parameters().getEntity());
            vm.setInitrdUrl((String) model.getInitrd_path().getEntity());
            vm.setMigrationSupport((MigrationSupport) (model.getMigrationMode().getSelectedItem()));
            vm.setVncKeyboardLayout((String) model.getVncKeyboardLayout().getSelectedItem());
            EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
            vm.setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
            vm.setCustomProperties(model.getCustomPropertySheet().getEntity());
            vm.setVmType((VmType) model.getVmType().getSelectedItem());
            vm.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
            AddVmPoolWithVmsParameters param = new AddVmPoolWithVmsParameters(pool, vm, model.getNumOfDesktops().asConvertible().integer(), 0);
            param.setStorageDomainId(Guid.Empty);
            param.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
            param.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
            param.setVirtioScsiEnabled((Boolean) model.getIsVirtioScsiEnabled().getEntity());
            param.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
            if (model.getQuota().getSelectedItem() != null) {
                vm.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
            }
            model.startProgress(null);
            if (model.getIsNew()) {
                Frontend.RunMultipleAction(VdcActionType.AddVmPoolWithVms, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { param })), new IFrontendMultipleActionAsyncCallback() {

                    @Override
                    public void executed(FrontendMultipleActionAsyncResult result) {
                        cancel();
                        stopProgress();
                    }
                }, this);
            } else {
                Frontend.RunMultipleAction(VdcActionType.UpdateVmPoolWithVms, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { param })), new IFrontendMultipleActionAsyncCallback() {

                    @Override
                    public void executed(FrontendMultipleActionAsyncResult result) {
                        cancel();
                        stopProgress();
                    }
                }, this);
            }
        }
    }), name);
}
#method_after
public void onSave() {
    final PoolModel model = (PoolModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsNew() && getSelectedItem() == null) {
        cancel();
        return;
    }
    if (!model.validate()) {
        return;
    }
    final VmPool pool = model.getIsNew() ? new VmPool() : (VmPool) Cloner.clone(getSelectedItem());
    final String name = model.getName().getEntity();
    // Check name unicitate.
    AsyncDataProvider.isPoolNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Boolean isUnique = (Boolean) returnValue;
            if ((model.getIsNew() && !isUnique) || (!model.getIsNew() && !isUnique && name.compareToIgnoreCase(pool.getName()) != 0)) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setIsGeneralTabValid(false);
                return;
            }
            // Save changes.
            pool.setName(model.getName().getEntity());
            pool.setVmPoolDescription(model.getDescription().getEntity());
            pool.setVdsGroupId(model.getSelectedCluster().getId());
            pool.setComment(model.getComment().getEntity());
            pool.setPrestartedVms(model.getPrestartedVms().getEntity());
            pool.setMaxAssignedVmsPerUser(model.getMaxAssignedVmsPerUser().getEntity());
            EntityModel<VmPoolType> poolTypeSelectedItem = model.getPoolType().getSelectedItem();
            pool.setVmPoolType(poolTypeSelectedItem.getEntity());
            Guid default_host;
            VDS defaultHost = model.getDefaultHost().getSelectedItem();
            if (model.getIsAutoAssign().getEntity()) {
                default_host = null;
            } else {
                default_host = defaultHost.getId();
            }
            VM vm = new VM();
            vm.setVmtGuid((model.getTemplate().getSelectedItem()).getId());
            vm.setName(name);
            vm.setVmOs(model.getOSType().getSelectedItem());
            vm.setDeleteProtected(model.getIsDeleteProtected().getEntity());
            vm.setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
            vm.setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
            vm.setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
            vm.setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : // $NON-NLS-1$
            "");
            vm.setVmMemSizeMb(model.getMemSize().getEntity());
            vm.setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
            vm.setVdsGroupId(model.getSelectedCluster().getId());
            vm.setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? model.getTimeZone().getSelectedItem().getTimeZoneKey() : // $NON-NLS-1$
            "");
            vm.setNumOfSockets(model.getNumOfSockets().getSelectedItem());
            vm.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
            vm.setUsbPolicy(model.getUsbPolicy().getSelectedItem());
            vm.setStateless(false);
            vm.setDefaultBootSequence(model.getBootSequence());
            vm.setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : // $NON-NLS-1$
            "");
            vm.setDedicatedVmForVds(default_host);
            vm.setKernelUrl(model.getKernel_path().getEntity());
            vm.setKernelParams(model.getKernel_parameters().getEntity());
            vm.setInitrdUrl(model.getInitrd_path().getEntity());
            vm.setMigrationSupport(model.getMigrationMode().getSelectedItem());
            vm.setVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
            EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
            vm.setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
            vm.setCustomProperties(model.getCustomPropertySheet().getEntity());
            vm.setVmType(model.getVmType().getSelectedItem());
            vm.setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
            AddVmPoolWithVmsParameters param = new AddVmPoolWithVmsParameters(pool, vm, model.getNumOfDesktops().getEntity(), 0);
            param.setStorageDomainId(Guid.Empty);
            param.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
            param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            if (model.getQuota().getSelectedItem() != null) {
                vm.setQuotaId(model.getQuota().getSelectedItem().getId());
            }
            model.startProgress(null);
            if (model.getIsNew()) {
                Frontend.RunMultipleAction(VdcActionType.AddVmPoolWithVms, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { param })), new IFrontendMultipleActionAsyncCallback() {

                    @Override
                    public void executed(FrontendMultipleActionAsyncResult result) {
                        cancel();
                        stopProgress();
                    }
                }, this);
            } else {
                Frontend.RunMultipleAction(VdcActionType.UpdateVmPoolWithVms, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { param })), new IFrontendMultipleActionAsyncCallback() {

                    @Override
                    public void executed(FrontendMultipleActionAsyncResult result) {
                        cancel();
                        stopProgress();
                    }
                }, this);
            }
        }
    }), name);
}
#end_block

#method_before
private void onSave() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate()) {
        return;
    }
    String name = (String) model.getName().getEntity();
    AsyncDataProvider.isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            TemplateListModel templateListModel = (TemplateListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            templateListModel.postNameUniqueCheck(isNameUnique);
        }
    }), name);
}
#method_after
private void onSave() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate()) {
        return;
    }
    String name = model.getName().getEntity();
    AsyncDataProvider.isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            TemplateListModel templateListModel = (TemplateListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            templateListModel.postNameUniqueCheck(isNameUnique);
        }
    }), name);
}
#end_block

#method_before
public void postNameUniqueCheck(boolean isNameUnique) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VmTemplate selectedItem = (VmTemplate) getSelectedItem();
    final VmTemplate template = (VmTemplate) Cloner.clone(selectedItem);
    String name = (String) model.getName().getEntity();
    // Check name unicitate.
    if (!isNameUnique && name.compareToIgnoreCase(template.getName()) != 0) {
        model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
        model.getName().setIsValid(false);
        model.setIsGeneralTabValid(false);
        return;
    }
    // Save changes.
    template.setVmType((VmType) model.getVmType().getSelectedItem());
    template.setName(name);
    template.setOsId((Integer) model.getOSType().getSelectedItem());
    template.setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    template.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    template.setDescription((String) model.getDescription().getEntity());
    template.setComment((String) model.getComment().getEntity());
    // $NON-NLS-1$
    template.setDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : "");
    template.setMemSizeMb((Integer) model.getMemSize().getEntity());
    template.setMinAllocatedMem(((Integer) model.getMinAllocatedMemory().getEntity()));
    template.setVdsGroupId((model.getSelectedCluster()).getId());
    template.setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    template.setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    template.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    template.setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    template.setStateless((Boolean) model.getIsStateless().getEntity());
    template.setRunAndPause((Boolean) model.getIsRunAndPause().getEntity());
    template.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    template.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    template.setDefaultBootSequence(model.getBootSequence());
    // $NON-NLS-1$
    template.setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : "");
    template.setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    template.setKernelUrl((String) model.getKernel_path().getEntity());
    template.setKernelParams((String) model.getKernel_parameters().getEntity());
    template.setInitrdUrl((String) model.getInitrd_path().getEntity());
    template.setVncKeyboardLayout((String) model.getVncKeyboardLayout().getSelectedItem());
    template.setCreatedByUserId(selectedItem.getCreatedByUserId());
    template.setSingleQxlPci((Boolean) model.getIsSingleQxlEnabled().getEntity());
    if (model.getQuota().getIsAvailable() && model.getQuota().getSelectedItem() != null) {
        template.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    template.setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    template.setPriority((Integer) prioritySelectedItem.getEntity());
    // host migration configuration
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        template.setDedicatedVmForVds(null);
    } else {
        template.setDedicatedVmForVds(defaultHost.getId());
    }
    template.setMigrationSupport((MigrationSupport) model.getMigrationMode().getSelectedItem());
    model.startProgress(null);
    UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
    parameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
    setVmWatchdogToParams(model, parameters);
    parameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
    Frontend.RunAction(VdcActionType.UpdateVmTemplate, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            TemplateListModel localModel = (TemplateListModel) result.getState();
            localModel.postUpdateVmTemplate(result.getReturnValue());
        }
    }, this);
}
#method_after
public void postNameUniqueCheck(boolean isNameUnique) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VmTemplate selectedItem = (VmTemplate) getSelectedItem();
    final VmTemplate template = (VmTemplate) Cloner.clone(selectedItem);
    String name = model.getName().getEntity();
    // Check name unicitate.
    if (!isNameUnique && name.compareToIgnoreCase(template.getName()) != 0) {
        model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
        model.getName().setIsValid(false);
        model.setIsGeneralTabValid(false);
        return;
    }
    // Save changes.
    template.setVmType(model.getVmType().getSelectedItem());
    template.setName(name);
    template.setOsId(model.getOSType().getSelectedItem());
    template.setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    template.setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    template.setDescription(model.getDescription().getEntity());
    template.setComment(model.getComment().getEntity());
    // $NON-NLS-1$
    template.setDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : "");
    template.setMemSizeMb(model.getMemSize().getEntity());
    template.setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    template.setVdsGroupId((model.getSelectedCluster()).getId());
    template.setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? (model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    template.setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    template.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    template.setUsbPolicy(model.getUsbPolicy().getSelectedItem());
    template.setStateless(model.getIsStateless().getEntity());
    template.setRunAndPause(model.getIsRunAndPause().getEntity());
    template.setDeleteProtected(model.getIsDeleteProtected().getEntity());
    template.setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    template.setDefaultBootSequence(model.getBootSequence());
    // $NON-NLS-1$
    template.setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : "");
    template.setAutoStartup(model.getIsHighlyAvailable().getEntity());
    template.setKernelUrl(model.getKernel_path().getEntity());
    template.setKernelParams(model.getKernel_parameters().getEntity());
    template.setInitrdUrl(model.getInitrd_path().getEntity());
    template.setVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
    template.setCreatedByUserId(selectedItem.getCreatedByUserId());
    template.setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    if (model.getQuota().getIsAvailable() && model.getQuota().getSelectedItem() != null) {
        template.setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    template.setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    template.setPriority(prioritySelectedItem.getEntity());
    // host migration configuration
    VDS defaultHost = model.getDefaultHost().getSelectedItem();
    if (model.getIsAutoAssign().getEntity()) {
        template.setDedicatedVmForVds(null);
    } else {
        template.setDedicatedVmForVds(defaultHost.getId());
    }
    template.setMigrationSupport(model.getMigrationMode().getSelectedItem());
    model.startProgress(null);
    UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    setVmWatchdogToParams(model, parameters);
    parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    Frontend.RunAction(VdcActionType.UpdateVmTemplate, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            TemplateListModel localModel = (TemplateListModel) result.getState();
            localModel.postUpdateVmTemplate(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
private void setVmWatchdogToParams(final UnitVmModel model, UpdateVmTemplateParameters updateVmParams) {
    VmWatchdogType wdModel = VmWatchdogType.getByName((String) model.getWatchdogModel().getSelectedItem());
    updateVmParams.setUpdateWatchdog(true);
    if (wdModel != null) {
        VmWatchdog vmWatchdog = new VmWatchdog();
        vmWatchdog.setAction(VmWatchdogAction.getByName((String) model.getWatchdogAction().getSelectedItem()));
        vmWatchdog.setModel(wdModel);
        updateVmParams.setWatchdog(vmWatchdog);
    }
}
#method_after
private void setVmWatchdogToParams(final UnitVmModel model, UpdateVmTemplateParameters updateVmParams) {
    VmWatchdogType wdModel = VmWatchdogType.getByName(model.getWatchdogModel().getSelectedItem());
    updateVmParams.setUpdateWatchdog(true);
    if (wdModel != null) {
        VmWatchdog vmWatchdog = new VmWatchdog();
        vmWatchdog.setAction(VmWatchdogAction.getByName(model.getWatchdogAction().getSelectedItem()));
        vmWatchdog.setModel(wdModel);
        updateVmParams.setWatchdog(vmWatchdog);
    }
}
#end_block

#method_before
protected void updateActionAvailability() {
    VmTemplate item = (VmTemplate) getSelectedItem();
    ArrayList items = (((ArrayList) getSelectedItems()) != null) ? (ArrayList) getSelectedItems() : new ArrayList();
    boolean blankSelected = isBlankTemplateSelected();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && item != null && item.getStatus() != VmTemplateStatus.Locked);
    if (getEditCommand().getIsExecutionAllowed() && blankSelected) {
        getEditCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeEdited());
        getEditCommand().setIsExecutionAllowed(false);
    }
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VmTemplate.class, VdcActionType.RemoveVmTemplate));
    if (getRemoveCommand().getIsExecutionAllowed() && blankSelected) {
        getRemoveCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeRemoved());
        getRemoveCommand().setIsExecutionAllowed(false);
    }
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VmTemplate.class, VdcActionType.ExportVmTemplate));
    if (getExportCommand().getIsExecutionAllowed() && blankSelected) {
        getExportCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeExported());
        getExportCommand().setIsExecutionAllowed(false);
    }
}
#method_after
protected void updateActionAvailability() {
    VmTemplate item = (VmTemplate) getSelectedItem();
    ArrayList items = ((getSelectedItems()) != null) ? (ArrayList) getSelectedItems() : new ArrayList();
    boolean blankSelected = isBlankTemplateSelected();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && item != null && item.getStatus() != VmTemplateStatus.Locked);
    if (getEditCommand().getIsExecutionAllowed() && blankSelected) {
        getEditCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeEdited());
        getEditCommand().setIsExecutionAllowed(false);
    }
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VmTemplate.class, VdcActionType.RemoveVmTemplate));
    if (getRemoveCommand().getIsExecutionAllowed() && blankSelected) {
        getRemoveCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeRemoved());
        getRemoveCommand().setIsExecutionAllowed(false);
    }
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VmTemplate.class, VdcActionType.ExportVmTemplate));
    if (getExportCommand().getIsExecutionAllowed() && blankSelected) {
        getExportCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeExported());
        getExportCommand().setIsExecutionAllowed(false);
    }
}
#end_block

#method_before
@Test
public void testExecuteQueryWithDirectOnly() {
    PermissionDAO permissionDAOMock = mock(PermissionDAO.class);
    when(permissionDAOMock.getAllForEntity(objectID, getUser().getUserId(), getQueryParameters().isFiltered(), false)).thenReturn(mockedPermissions);
    when(getDbFacadeMockInstance().getPermissionDao()).thenReturn(permissionDAOMock);
    assertQueryDAOCall(true);
}
#method_after
@Test
public void testExecuteQueryWithDirectOnly() {
    PermissionDAO permissionDAOMock = mock(PermissionDAO.class);
    when(permissionDAOMock.getAllForEntity(objectID, getUser().getId(), getQueryParameters().isFiltered(), false)).thenReturn(mockedPermissions);
    when(getDbFacadeMockInstance().getPermissionDao()).thenReturn(permissionDAOMock);
    assertQueryDAOCall(true);
}
#end_block

#method_before
@Test
public void testExecuteQueryWithoutDirectOnly() {
    VdcObjectType type = RandomUtils.instance().pickRandom(VdcObjectType.values());
    when(getQueryParameters().getVdcObjectType()).thenReturn(type);
    PermissionDAO permissionDAOMock = mock(PermissionDAO.class);
    when(permissionDAOMock.getTreeForEntity(objectID, type, getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(mockedPermissions);
    when(getDbFacadeMockInstance().getPermissionDao()).thenReturn(permissionDAOMock);
    assertQueryDAOCall(false);
}
#method_after
@Test
public void testExecuteQueryWithoutDirectOnly() {
    VdcObjectType type = RandomUtils.instance().pickRandom(VdcObjectType.values());
    when(getQueryParameters().getVdcObjectType()).thenReturn(type);
    PermissionDAO permissionDAOMock = mock(PermissionDAO.class);
    when(permissionDAOMock.getTreeForEntity(objectID, type, getUser().getId(), getQueryParameters().isFiltered())).thenReturn(mockedPermissions);
    when(getDbFacadeMockInstance().getPermissionDao()).thenReturn(permissionDAOMock);
    assertQueryDAOCall(false);
}
#end_block

#method_before
@Override
public List<permissions> getAllForAdElement(Guid id, Guid userID, boolean isFiltered) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("ad_element_id", id).addValue("user_id", userID).addValue("is_filtered", isFiltered);
    return getCallsHandler().executeReadList("GetPermissionsByAdElementId", PermissionRowMapper.instance, parameterSource);
}
#method_after
@Override
public List<permissions> getAllForAdElement(Guid id, Guid userID, boolean isFiltered) {
    int appMode = Config.<Integer>GetValue(ConfigValues.ApplicationMode);
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("ad_element_id", id).addValue("user_id", userID).addValue("is_filtered", isFiltered).addValue("app_mode", appMode);
    return getCallsHandler().executeReadList("GetPermissionsByAdElementId", PermissionRowMapper.instance, parameterSource);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removePermissionTitle());
    // $NON-NLS-1$
    model.setHashName("remove_permission");
    model.setMessage(ConstantsManager.getInstance().getConstants().permissionMsg());
    model.setItems(getSelectedItems());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removePermissionTitle());
    // $NON-NLS-1$
    model.setHashName("remove_permission");
    model.setItems(getSelectedItems());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsEveryoneSelected() && model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setId(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    // adGroup/user
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        permissions tempVar2 = new permissions();
        tempVar2.setad_element_id(user.getId());
        tempVar2.setrole_id(role.getId());
        permissions perm = tempVar2;
        perm.setObjectId(getEntityGuid());
        perm.setObjectType(this.getObjectType());
        if (user.isGroup()) {
            PermissionsOperationsParametes tempVar3 = new PermissionsOperationsParametes();
            tempVar3.setPermission(perm);
            tempVar3.setAdGroup(new LdapGroup(user.getId(), user.getFirstName(), user.getDomain()));
            list.add(tempVar3);
        } else {
            PermissionsOperationsParametes tempVar4 = new PermissionsOperationsParametes();
            tempVar4.setPermission(perm);
            tempVar4.setVdcUser(new VdcUser(user.getId(), user.getLoginName(), user.getDomain()));
            list.add(tempVar4);
        }
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsEveryoneSelected() && model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setId(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    // adGroup/user
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        permissions tempVar2 = new permissions();
        tempVar2.setad_element_id(user.getId());
        tempVar2.setrole_id(role.getId());
        permissions perm = tempVar2;
        perm.setObjectId(getEntityGuid());
        perm.setObjectType(this.getObjectType());
        if (user.isGroup()) {
            PermissionsOperationsParametes tempVar3 = new PermissionsOperationsParametes();
            tempVar3.setPermission(perm);
            tempVar3.setAdGroup(new LdapGroup(user.getId(), user.getFirstName(), user.getDomain()));
            list.add(tempVar3);
        } else {
            PermissionsOperationsParametes tempVar4 = new PermissionsOperationsParametes();
            tempVar4.setPermission(perm);
            tempVar4.setUser(user);
            list.add(tempVar4);
        }
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
public void showStatus(GlusterVolumeTaskStatusEntity rebalanceStatusEntity) {
    List<GlusterVolumeTaskStatusForHost> rebalanceSessionsList = rebalanceStatusEntity.getHostwiseStatusDetails();
    List<EntityModel> sessionList = new ArrayList<EntityModel>();
    for (GlusterVolumeTaskStatusForHost hostDetail : rebalanceSessionsList) {
        EntityModel sessionModel = new EntityModel(hostDetail);
        sessionList.add(sessionModel);
    }
    getStartTime().setEntity(rebalanceStatusEntity.getStartTime());
    getStatusTime().setEntity(rebalanceStatusEntity.getStatusTime());
    getRebalanceSessions().setItems(sessionList);
    if (rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.FINISHED) {
        setStatusAvailable(true);
        refresh.cancel();
    } else {
        setStatusAvailable(false);
        if ((rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.ABORTED || rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.FAILED)) {
            refresh.cancel();
            if (rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.ABORTED) {
                getStopTime().setEntity(rebalanceStatusEntity.getStopTime());
                setStopTimeAvailable(true);
            }
        }
    }
    if (GlusterTaskType.REBALANCE == getEntity().getAsyncTask().getType()) {
        getStopReblanceFromStatus().setIsExecutionAllowed(rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.STARTED);
    }
}
#method_after
public void showStatus(GlusterVolumeTaskStatusEntity rebalanceStatusEntity) {
    List<GlusterVolumeTaskStatusForHost> rebalanceSessionsList = rebalanceStatusEntity.getHostwiseStatusDetails();
    List<EntityModel> sessionList = new ArrayList<EntityModel>();
    for (GlusterVolumeTaskStatusForHost hostDetail : rebalanceSessionsList) {
        EntityModel sessionModel = new EntityModel(hostDetail);
        sessionList.add(sessionModel);
    }
    getStartTime().setEntity(rebalanceStatusEntity.getStartTime());
    getStatusTime().setEntity(rebalanceStatusEntity.getStatusTime());
    getRebalanceSessions().setItems(sessionList);
    if (rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.FINISHED) {
        setStatusAvailable(true);
        refresh.cancel();
    } else {
        setStatusAvailable(false);
        if ((rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.ABORTED || rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.FAILED)) {
            refresh.cancel();
            if (rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.ABORTED) {
                getStopTime().setEntity(rebalanceStatusEntity.getStopTime());
                setStopTimeVisible(rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.ABORTED);
            }
        }
    }
    if (GlusterTaskType.REBALANCE == getEntity().getAsyncTask().getType()) {
        getStopReblanceFromStatus().setIsExecutionAllowed(rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.STARTED);
    }
}
#end_block

#method_before
private void localize(final ApplicationConstants constants) {
    startTimeEditor.setLabel(constants.rebalanceStartTime());
    volumeEditor.setLabel(constants.rebalanceVolumeName());
    clusterEditor.setLabel(constants.rebalanceClusterVolume());
    statusTimeEditor.setLabel(constants.rebalanceStatusTime());
}
#method_after
private void localize(final ApplicationConstants constants) {
    startTimeEditor.setLabel(constants.rebalanceStartTime());
    volumeEditor.setLabel(constants.rebalanceVolumeName());
    clusterEditor.setLabel(constants.rebalanceClusterVolume());
    statusTimeEditor.setLabel(constants.rebalanceStatusTime());
    stopTimeEditor.setLabel(constants.rebalanceStopTime());
}
#end_block

#method_before
void initEditors(ApplicationConstants constants) {
    rebalanceHostsTable = new EntityModelCellTable<ListModel>(false, true);
    clusterEditor = new EntityModelLabelEditor();
    statusTimeEditor = getInstanceOfDateEditor();
    startTimeEditor = getInstanceOfDateEditor();
    stopTime = getInstanceOfDateEditor();
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getHostName();
        }
    }, constants.rebalanceSessionHost());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getFilesMoved() + "";
        }
    }, getColumnHeaderForFilesMoved());
    rebalanceHostsTable.addEntityModelColumn(new RebalanceFileSizeColumn<EntityModel>(messages) {

        @Override
        protected Long getRawValue(EntityModel object) {
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getTotalSizeMoved();
        }
    }, constants.rebalanceSize());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesFailed());
        }
    }, constants.rebalanceFailedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesSkipped());
        }
    }, constants.rebalanceSkippedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesScanned());
        }
    }, constants.rebalanceScannedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new HumanReadableTimeColumn<EntityModel>() {

        @Override
        protected Double getRawValue(EntityModel object) {
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getRunTime();
        }
    }, constants.rebalanceRunTime());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getStatus().toString();
        }
    }, constants.rebalanceStatus());
}
#method_after
void initEditors(ApplicationConstants constants) {
    rebalanceHostsTable = new EntityModelCellTable<ListModel>(false, true);
    statusTimeEditor = getInstanceOfDateEditor();
    startTimeEditor = getInstanceOfDateEditor();
    stopTimeEditor = getInstanceOfDateEditor();
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getHostName();
        }
    }, constants.rebalanceSessionHost());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getFilesMoved() + "";
        }
    }, getColumnHeaderForFilesMoved());
    rebalanceHostsTable.addEntityModelColumn(new RebalanceFileSizeColumn<EntityModel>(messages) {

        @Override
        protected Long getRawValue(EntityModel object) {
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getTotalSizeMoved();
        }
    }, constants.rebalanceSize());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesScanned());
        }
    }, constants.rebalanceScannedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesFailed());
        }
    }, constants.rebalanceFailedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesSkipped());
        }
    }, constants.rebalanceSkippedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getStatus().toString();
        }
    }, constants.rebalanceStatus());
    rebalanceHostsTable.addEntityModelColumn(new HumanReadableTimeColumn<EntityModel>() {

        @Override
        protected Double getRawValue(EntityModel object) {
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getRunTime();
        }
    }, constants.rebalanceRunTime());
}
#end_block

#method_before
@Override
public void edit(final VolumeRebalanceStatusModel object) {
    driver.edit(object);
    rebalanceHostsTable.asEditor().edit(object.getRebalanceSessions());
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName.equals("IS_STATUS_APPLICABLE")) {
                // $NON-NLS-1$
                Label completedStatus = new Label();
                completedStatus.setText(constants.rebalanceComplete());
                completedStatus.getElement().getStyle().setPaddingTop(36, Unit.PX);
                completedStatus.getElement().getStyle().setFontSize(14, Unit.PX);
                completedStatus.getElement().getStyle().setFontWeight(FontWeight.BOLD);
                completedStatus.setVisible(object.isStatusAvailable());
                status.add(completedStatus);
            } else if (e.PropertyName.equals("IS_STOP_TIME_APPLICABLE")) {
                // $NON-NLS-1$
                // $NON-NLS-1$//$NON-NLS-2$
                sdPanel.setSize("1000px", "550px");
                // $NON-NLS-1$//$NON-NLS-2$
                sPanel.setSize("981px", "415px");
                vPanel2.remove(clusterEditor);
                vPanel2.remove(statusTimeEditor);
                stopTime.setLabel(constants.rebalanceStopTime());
                stopTime.getElement().getStyle().setPaddingTop(30, Unit.PX);
                vPanel2.add(stopTime);
                status.add(clusterEditor);
                status.add(statusTimeEditor);
            }
        }
    });
}
#method_after
@Override
public void edit(final VolumeRebalanceStatusModel object) {
    driver.edit(object);
    rebalanceHostsTable.asEditor().edit(object.getRebalanceSessions());
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName.equals("IS_STATUS_APPLICABLE")) {
                // $NON-NLS-1$
                status.setText(constants.rebalanceComplete());
                status.setVisible(true);
            } else if (e.PropertyName.equals("STOP_TIME_UPDATED")) {
                // $NON-NLS-1$
                stopTimePanel.setVisible(object.isStopTimeVisible());
            }
        }
    });
}
#end_block

#method_before
@Override
public List<Guid> runFilters(List<String> filterNames, List<Guid> hostIDs, Guid vmID, Map<String, String> propertiesMap) {
    try {
        // Do not call the scheduler when there is no operation requested from it
        if (filterNames.isEmpty())
            return hostIDs;
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(FILTER, createFilterArgs(filterNames, hostIDs, vmID, propertiesMap));
        return parseFilterResults(result);
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while filtering", e);
        AuditLogableBase loggable = new AuditLogableBase();
        AuditLogDirector.log(loggable, AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY);
        return hostIDs;
    }
}
#method_after
@Override
public List<Guid> runFilters(List<String> filterNames, List<Guid> hostIDs, Guid vmID, Map<String, String> propertiesMap) {
    try {
        // Do not call the scheduler when there is no operation requested from it
        if (filterNames.isEmpty()) {
            return hostIDs;
        }
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(FILTER, createFilterArgs(filterNames, hostIDs, vmID, propertiesMap));
        return parseFilterResults(result);
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while filtering", e);
        auditLogFailedToConnect();
        return hostIDs;
    }
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> runScores(List<Pair<String, Integer>> scoreNameAndWeight, List<Guid> hostIDs, Guid vmID, Map<String, String> propertiesMap) {
    try {
        // Do not call the scheduler when there is no operation requested from it
        if (scoreNameAndWeight.isEmpty())
            return null;
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(SCORE, createScoreArgs(scoreNameAndWeight, hostIDs, vmID, propertiesMap));
        return parseScoreResults(result);
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while running weight modules", e);
        AuditLogableBase loggable = new AuditLogableBase();
        AuditLogDirector.log(loggable, AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY);
        return null;
    }
}
#method_after
@Override
public List<Pair<Guid, Integer>> runScores(List<Pair<String, Integer>> scoreNameAndWeight, List<Guid> hostIDs, Guid vmID, Map<String, String> propertiesMap) {
    try {
        // Do not call the scheduler when there is no operation requested from it
        if (scoreNameAndWeight.isEmpty()) {
            return null;
        }
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(SCORE, createScoreArgs(scoreNameAndWeight, hostIDs, vmID, propertiesMap));
        return parseScoreResults(result);
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while running weight modules", e);
        auditLogFailedToConnect();
        return null;
    }
}
#end_block

#method_before
@Override
public Pair<List<Guid>, Guid> runBalance(String balanceName, List<Guid> hostIDs, Map<String, String> propertiesMap) {
    // TODO Auto-generated method stub
    try {
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(BALANCE, createBalanceArgs(balanceName, hostIDs, propertiesMap));
        return parseBalanceResults(result);
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while balancing", e);
        AuditLogableBase loggable = new AuditLogableBase();
        AuditLogDirector.log(loggable, AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY);
        return null;
    }
}
#method_after
@Override
public Pair<List<Guid>, Guid> runBalance(String balanceName, List<Guid> hostIDs, Map<String, String> propertiesMap) {
    // TODO Auto-generated method stub
    try {
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(BALANCE, createBalanceArgs(balanceName, hostIDs, propertiesMap));
        return parseBalanceResults(result);
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while balancing", e);
        auditLogFailedToConnect();
        return null;
    }
}
#end_block

#method_before
private Pair<List<Guid>, Guid> parseBalanceResults(Object result) {
    if (!(result instanceof Object[])) {
        log.error("External scheduler error, malformed balance results");
        return null;
    }
    Object[] castedResult = (Object[]) result;
    List<Guid> hostIDs = new LinkedList<Guid>();
    for (Object hostID : (Object[]) castedResult[1]) {
        hostIDs.add(new Guid(hostID.toString()));
    }
    Pair<List<Guid>, Guid> retValue = new Pair<List<Guid>, Guid>();
    retValue.setFirst(hostIDs);
    retValue.setSecond(new Guid(castedResult[0].toString()));
    return retValue;
}
#method_after
private Pair<List<Guid>, Guid> parseBalanceResults(Object result) {
    if (!(result instanceof Object[])) {
        log.error("External scheduler error, malformed balance results");
        return null;
    }
    Object[] castedResult = (Object[]) result;
    List<Guid> hostIDs = new LinkedList<Guid>();
    for (Object hostID : (Object[]) castedResult[1]) {
        hostIDs.add(new Guid(hostID.toString()));
    }
    Pair<List<Guid>, Guid> retValue = new Pair<List<Guid>, Guid>();
    retValue.setFirst(hostIDs);
    if (castedResult[0].toString().isEmpty()) {
        return null;
    } else {
        retValue.setSecond(new Guid(castedResult[0].toString()));
    }
    return retValue;
}
#end_block

#method_before
public void init() {
    log.info("Start initializing " + getClass().getSimpleName());
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getStatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Is there any VM that is not fully Up or fully Down?
    boolean runningVmsInTransition = false;
    // Cleanup all vms dynamic data. This is defensive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!vm.isNotRunning()) {
            if (vm.getRunOnVds() != null) {
                MultiValueMapUtils.addToMap(vm.getRunOnVds(), vm.getId(), _vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
            }
            if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                SetVmUnknown(vm);
            }
        }
        if (!runningVmsInTransition && vm.isRunning() && vm.getStatus() != VMStatus.Up) {
            runningVmsInTransition = true;
        }
    }
    // (meaning we tried to start a VM and the engine crashed before telling VDSM about it)
    for (VDS _vds : allVdsList) {
        boolean _saveVdsDynamic = false;
        if (_vds.getPendingVcpusCount() != 0 && !runningVmsInTransition) {
            _vds.setPendingVcpusCount(0);
            _saveVdsDynamic = true;
        }
        if (_vds.getPendingVmemSize() != 0 && !runningVmsInTransition) {
            _vds.setPendingVmemSize(0);
            _saveVdsDynamic = true;
        }
        if (_saveVdsDynamic) {
            DbFacade.getInstance().getVdsDynamicDao().update(_vds.getDynamicData());
        }
    }
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.Init();
    log.info("Finished initializing " + getClass().getSimpleName());
}
#method_after
public void init() {
    log.info("Start initializing " + getClass().getSimpleName());
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getStatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Is there any VM that is not fully Up or fully Down?
    boolean runningVmsInTransition = false;
    // Cleanup all vms dynamic data. This is defensive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!vm.isNotRunning()) {
            if (vm.getRunOnVds() != null) {
                MultiValueMapUtils.addToMap(vm.getRunOnVds(), vm.getId(), _vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
            }
            if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                SetVmUnknown(vm);
            }
        }
        if (!runningVmsInTransition && vm.isRunning() && vm.getStatus() != VMStatus.Up) {
            runningVmsInTransition = true;
        }
    }
    // Clean pending memory and CPUs if there is no VM in transition on a given Host
    // (meaning we tried to start a VM and the engine crashed before telling VDSM about it)
    List<VdsDynamic> updatedEntities = new ArrayList<>();
    for (VDS _vds : allVdsList) {
        boolean _saveVdsDynamic = false;
        if (_vds.getPendingVcpusCount() != 0 && !runningVmsInTransition) {
            _vds.setPendingVcpusCount(0);
            _saveVdsDynamic = true;
        }
        if (_vds.getPendingVmemSize() != 0 && !runningVmsInTransition) {
            _vds.setPendingVmemSize(0);
            _saveVdsDynamic = true;
        }
        if (_saveVdsDynamic) {
            updatedEntities.add(_vds.getDynamicData());
        }
    }
    // TODO replace this with batch processing once it becomes available
    for (VdsDynamic entity : updatedEntities) {
        DbFacade.getInstance().getVdsDynamicDao().update(entity);
    }
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.init();
    log.info("Finished initializing " + getClass().getSimpleName());
}
#end_block

#method_before
public void AddVds(VDS vds, boolean isInternal) {
    VdsManager vdsManager = VdsManager.buildVdsManager(vds);
    if (isInternal) {
        VDSStatus status = vds.getStatus();
        switch(vds.getStatus()) {
            case Error:
                status = VDSStatus.Up;
                break;
            case Reboot:
            case NonResponsive:
            case Connecting:
            case Installing:
                status = VDSStatus.Unassigned;
                break;
        }
        if (status != vds.getStatus()) {
            vdsManager.setStatus(status, vds);
            vdsManager.UpdateStatisticsData(vds.getStatisticsData());
        }
        // set pending to 0
        vds.setPendingVcpusCount(0);
        vdsManager.UpdateDynamicData(vds.getDynamicData());
    }
    vdsManager.schedulJobs();
    _vdsManagersDict.put(vds.getId(), vdsManager);
    log.infoFormat("VDS {0} was added to the Resource Manager", vds.getId());
}
#method_after
public void AddVds(VDS vds, boolean isInternal) {
    VdsManager vdsManager = VdsManager.buildVdsManager(vds);
    if (isInternal) {
        VDSStatus status = vds.getStatus();
        switch(vds.getStatus()) {
            case Error:
                status = VDSStatus.Up;
                break;
            case Reboot:
            case NonResponsive:
            case Connecting:
            case Installing:
                status = VDSStatus.Unassigned;
                break;
        }
        if (status != vds.getStatus()) {
            vdsManager.setStatus(status, vds);
            vdsManager.updateStatisticsData(vds.getStatisticsData());
        }
        // set pending to 0
        vds.setPendingVcpusCount(0);
        vdsManager.updateDynamicData(vds.getDynamicData());
    }
    vdsManager.schedulJobs();
    _vdsManagersDict.put(vds.getId(), vdsManager);
    log.infoFormat("VDS {0} was added to the Resource Manager", vds.getId());
}
#end_block

#method_before
public void UpdateVdsStatisticsData(VdsStatistics vdsStatistics) {
    VdsManager vdsManager = GetVdsManager(vdsStatistics.getId());
    if (vdsManager != null) {
        vdsManager.UpdateStatisticsData(vdsStatistics);
    }
}
#method_after
public void UpdateVdsStatisticsData(VdsStatistics vdsStatistics) {
    VdsManager vdsManager = GetVdsManager(vdsStatistics.getId());
    if (vdsManager != null) {
        vdsManager.updateStatisticsData(vdsStatistics);
    }
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.UpdateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    ResourceManager.getInstance().getEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    ResourceManager.getInstance().getEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#end_block

#method_before
public void AfterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            ResourceManager.getInstance().getEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                ResourceManager.getInstance().getEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, false, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName());
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.SuccededToRunVm(vm_guid);
        }
        // run all vms that crushed that marked with auto startup
        for (Guid vm_guid : _autoVmsToRun) {
            // Refrain from auto-start HA VM during its re-run attempts.
            if (!_vmsToRerun.contains(vm_guid)) {
                ResourceManager.getInstance().getEventListener().runFailedAutoStartVM(vm_guid);
            }
        }
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            ResourceManager.getInstance().getEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            ResourceManager.getInstance().getEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void AfterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            ResourceManager.getInstance().getEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                ResourceManager.getInstance().getEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, false, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName());
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // run all vms that crushed that marked with auto startup
        for (Guid vm_guid : _autoVmsToRun) {
            // Refrain from auto-start HA VM during its re-run attempts.
            if (!_vmsToRerun.contains(vm_guid)) {
                ResourceManager.getInstance().getEventListener().runFailedAutoStartVM(vm_guid);
            }
        }
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            ResourceManager.getInstance().getEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            ResourceManager.getInstance().getEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
private boolean devicePluggable(VmDevice device) {
    return (VmDeviceType.DISK.getName().equals(device.getDevice()) && VmDeviceGeneralType.DISK == device.getType()) || (VmDeviceType.BRIDGE.getName().equals(device.getDevice()) && VmDeviceGeneralType.INTERFACE == device.getType());
}
#method_after
private boolean devicePluggable(VmDevice device) {
    return VmDeviceCommonUtils.isDisk(device) || VmDeviceCommonUtils.isBridge(device);
}
#end_block

#method_before
private Guid addNewVmDevice(Guid vmId, Map device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, false, alias, null);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#method_after
private Guid addNewVmDevice(Guid vmId, Map device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, Boolean.getBoolean((String) device.get(VdsProperties.ReadOnly)), alias, null, null);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#end_block

#method_before
private void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(_vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.infoFormat("Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#method_after
private void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(_vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.infoFormat("Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#end_block

#method_before
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("vm {0} running in db and not running in vds - add to rerun treatment. vds {1}", vmToRemove.getName(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
        }
    }
}
#method_after
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if ((_vds.getStatus() == VDSStatus.PreparingForMaintenance) && monitoringStrategy.canMoveToMaintenance(_vds)) {
        _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
        _saveVdsDynamic = true;
        _saveVdsStatistics = true;
        log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            if (_vdsManager.isTimeToRetryMaintenance()) {
                ResourceManager.getInstance().getEventListener().handleVdsMaintenanceTimeout(_vds);
                _vdsManager.calculateNextMaintenanceAttemptTime();
            }
        }
    }
}
#end_block

#method_before
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Object());
    synchronized (clusterLockMap.get(cluster.getId())) {
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker);
        if (vdsList == null || vdsList.size() == 0) {
            return null;
        }
        // it passed filters return it
        if (destHostId != null) {
            for (VDS vds : vdsList) {
                if (destHostId.equals(vds.getId())) {
                    return destHostId;
                }
            }
        }
        if (policy.getFunctions() == null || policy.getFunctions().isEmpty()) {
            return vdsList.get(0).getId();
        }
        Guid bestHost = runFunctions(policy.getFunctions(), vdsList, vm, parameters);
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), 0, 0);
        }
        return bestHost;
    }
}
#method_after
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Object());
    synchronized (clusterLockMap.get(cluster.getId())) {
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.size() == 0) {
            return null;
        }
        // it passed filters return it
        if (destHostId != null) {
            for (VDS vds : vdsList) {
                if (destHostId.equals(vds.getId())) {
                    return destHostId;
                }
            }
        }
        if (policy.getFunctions() == null || policy.getFunctions().isEmpty()) {
            return vdsList.get(0).getId();
        }
        Guid bestHost = runFunctions(policy.getFunctions(), vdsList, vm, parameters);
        if (bestHost == null && vdsList.size() > 0) {
            bestHost = vdsList.get(0).getId();
        }
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), 0, 0);
        }
        return bestHost;
    }
}
#end_block

#method_before
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVdsId, List<String> messages) {
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker);
    if (vdsList == null || vdsList.size() == 0) {
        return false;
    }
    return true;
}
#method_after
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVdsId, List<String> messages) {
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, false, null);
    if (vdsList == null || vdsList.size() == 0) {
        return false;
    }
    return true;
}
#end_block

#method_before
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker) {
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<PolicyUnitImpl>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<PolicyUnitImpl>();
    sortFilters(filters, filterPositionMap);
    if (filters != null) {
        for (Guid filter : filters) {
            PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
            if (filterPolicyUnit.isInternal()) {
                internalFilters.add(filterPolicyUnit);
            } else {
                if (filterPolicyUnit.isEnabled()) {
                    externalFilters.add(filterPolicyUnit);
                }
            }
        }
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, messages, memoryChecker);
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled) && externalFilters.size() > 0 && hostList != null && hostList.size() > 0) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages);
    }
    return hostList;
}
#method_after
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<PolicyUnitImpl>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<PolicyUnitImpl>();
    sortFilters(filters, filterPositionMap);
    if (filters != null) {
        for (Guid filter : filters) {
            PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
            if (filterPolicyUnit.isInternal()) {
                internalFilters.add(filterPolicyUnit);
            } else {
                if (filterPolicyUnit.isEnabled()) {
                    externalFilters.add(filterPolicyUnit);
                }
            }
        }
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, messages, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled) && externalFilters.size() > 0 && hostList != null && hostList.size() > 0) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList == null || hostList.size() == 0) {
        messages.add(VdcBllMessages.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#end_block

#method_before
private List<VDS> runInternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker) {
    if (filters != null) {
        for (PolicyUnitImpl filterPolicyUnit : filters) {
            if (hostList == null || hostList.isEmpty()) {
                break;
            }
            filterPolicyUnit.setMemoryChecker(memoryChecker);
            hostList = filterPolicyUnit.filter(hostList, vm, parameters, messages);
        }
    }
    return hostList;
}
#method_after
private List<VDS> runInternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId, SchedulingResult result) {
    if (filters != null) {
        for (PolicyUnitImpl filterPolicyUnit : filters) {
            if (hostList == null || hostList.isEmpty()) {
                break;
            }
            filterPolicyUnit.setMemoryChecker(memoryChecker);
            List<VDS> currentHostList = new ArrayList<VDS>(hostList);
            hostList = filterPolicyUnit.filter(hostList, vm, parameters, messages);
            logFilterActions(currentHostList, toIdSet(hostList), VdcBllMessages.VAR__FILTERTYPE__INTERNAL, filterPolicyUnit.getName(), result, correlationId);
        }
    }
    return hostList;
}
#end_block

#method_before
private List<VDS> runExternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, List<String> messages) {
    List<Guid> filteredIDs = null;
    if (filters != null) {
        List<String> filterNames = new ArrayList<String>();
        for (PolicyUnitImpl filter : filters) {
            filterNames.add(filter.getName());
        }
        List<Guid> hostIDs = new ArrayList<Guid>();
        for (VDS host : hostList) {
            hostIDs.add(host.getId());
        }
        filteredIDs = ExternalSchedulerFactory.getInstance().runFilters(filterNames, hostIDs, vm.getId(), parameters);
    }
    return intersectHosts(hostList, filteredIDs);
}
#method_after
private List<VDS> runExternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, List<String> messages, String correlationId, SchedulingResult result) {
    List<Guid> filteredIDs = null;
    if (filters != null) {
        List<String> filterNames = new ArrayList<String>();
        for (PolicyUnitImpl filter : filters) {
            filterNames.add(filter.getName());
        }
        List<Guid> hostIDs = new ArrayList<Guid>();
        for (VDS host : hostList) {
            hostIDs.add(host.getId());
        }
        filteredIDs = ExternalSchedulerFactory.getInstance().runFilters(filterNames, hostIDs, vm.getId(), parameters);
        if (filteredIDs != null) {
            logFilterActions(hostList, new HashSet<Guid>(filteredIDs), VdcBllMessages.VAR__FILTERTYPE__EXTERNAL, Arrays.toString(filterNames.toArray()), result, correlationId);
        }
    }
    return intersectHosts(hostList, filteredIDs);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    if (getEntity() != null) {
        GlusterVolumeEntity glusterVolumeEntity = (GlusterVolumeEntity) getEntity();
        // If the items are same, just fire the item changed event to make sure that items are displayed
        if (getItems() == glusterVolumeEntity.getBricks()) {
            getItemsChangedEvent().raise(this, EventArgs.Empty);
        } else {
            setItems(glusterVolumeEntity.getBricks());
        }
    } else {
        setItems(null);
    }
}
#method_after
@Override
protected void syncSearch() {
    if (getEntity() != null) {
        GlusterVolumeEntity glusterVolumeEntity = (GlusterVolumeEntity) getEntity();
        // If the items are same, just fire the item changed event to make sure that items are displayed
        if (getItems() == glusterVolumeEntity.getBricks()) {
            getItemsChangedEvent().raise(this, EventArgs.Empty);
        } else {
            setItems(glusterVolumeEntity.getBricks());
        }
    } else {
        setItems(null);
    }
}
#end_block

#method_before
public ValidationResult canRebalance(GlusterVolumeEntity volumeEntity) {
    int replicaCount = 0;
    List<GlusterBrickEntity> bricks = volumeEntity.getBricks();
    if (volumeEntity.getVolumeType().isReplicatedType()) {
        replicaCount = volumeEntity.getReplicaCount();
    } else {
        replicaCount = 1;
    }
    int brickIndex = 0, replicaIndex = 0;
    while (brickIndex < bricks.size()) {
        for (replicaIndex = 0; replicaIndex < replicaCount; replicaIndex++) {
            if (bricks.get(brickIndex + replicaIndex).isOnline()) {
                brickIndex = brickIndex + replicaCount;
                break;
            }
        }
        if (replicaIndex == replicaCount) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_BRICKS_ARE_DOWN);
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult canRebalance(GlusterVolumeEntity volumeEntity) {
    int replicaCount = 1;
    List<GlusterBrickEntity> bricks = volumeEntity.getBricks();
    if (volumeEntity.getVolumeType().isReplicatedType()) {
        replicaCount = volumeEntity.getReplicaCount();
    }
    int brickIndex = 0, replicaIndex = 0;
    while (brickIndex < bricks.size()) {
        for (replicaIndex = 0; replicaIndex < replicaCount; replicaIndex++) {
            if (bricks.get(brickIndex + replicaIndex).isOnline()) {
                brickIndex = brickIndex + replicaCount;
                break;
            }
        }
        if (replicaIndex == replicaCount) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_BRICKS_ARE_DOWN);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        // find if this is a trivial search expression (like 'Vms:' etc).
        isSafe = SearchObjects.isSafeExpression(searchText);
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().Subtract(data.getDate());
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debugFormat("ResourceManager::searchBusinessObjects(''{0}'') - entered", searchText);
            String queryDomain = null;
            ISyntaxChecker curSyntaxChecker;
            String[] splitted = searchText.split("[:@ ]");
            final String objectName = splitted[0].toUpperCase();
            if ((SearchObjects.AD_USER_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_USER_PLU_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_PLU_OBJ_NAME.equals(objectName))) {
                if (searchText.indexOf('@') > 0 && splitted.length > 1) {
                    queryDomain = splitted[1];
                    searchText = searchText.substring(0, searchText.indexOf('@')) + searchText.substring(searchText.indexOf(':'));
                } else {
                    queryDomain = getDefaultDomain();
                }
                curSyntaxChecker = SyntaxCheckerFactory.CreateADSyntaxChecker(Config.<String>GetValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.CreateBackendSyntaxChecker(Config.<String>GetValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? Integer.MAX_VALUE : getParameters().getMaxCount());
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.warnFormat("ResourceManager::searchBusinessObjects - erroneous search text - ''{0}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (searchObj.getvalid() != true) {
                log.warnFormat("ResourceManager::searchBusinessObjects - Invalid search text - ''{0}''", searchText);
                return null;
            }
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), searchObj.getSearchObjectStr(), new Date(), queryDomain);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character:" + getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: " + getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: " + getParameters().getSearchPattern(), ex);
        data = null;
    }
    return data;
}
#method_after
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        // find if this is a trivial search expression (like 'Vms:' etc).
        isSafe = SearchObjects.isSafeExpression(searchText);
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().Subtract(data.getDate());
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debugFormat("ResourceManager::searchBusinessObjects(''{0}'') - entered", searchText);
            String queryDomain = null;
            ISyntaxChecker curSyntaxChecker;
            String[] splitted = searchText.split("[:@ ]");
            final String objectName = splitted[0].toUpperCase();
            if ((SearchObjects.AD_USER_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_USER_PLU_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_PLU_OBJ_NAME.equals(objectName))) {
                if (searchText.indexOf('@') > 0 && splitted.length > 1) {
                    queryDomain = splitted[1];
                    searchText = searchText.substring(0, searchText.indexOf('@')) + searchText.substring(searchText.indexOf(':'));
                } else {
                    queryDomain = getDefaultDomain();
                }
                curSyntaxChecker = SyntaxCheckerFactory.createADSyntaxChecker(Config.<String>GetValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker(Config.<String>GetValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? Integer.MAX_VALUE : getParameters().getMaxCount());
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.warnFormat("ResourceManager::searchBusinessObjects - erroneous search text - ''{0}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (searchObj.getvalid() != true) {
                log.warnFormat("ResourceManager::searchBusinessObjects - Invalid search text - ''{0}''", searchText);
                return null;
            }
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), searchObj.getSearchObjectStr(), new Date(), queryDomain);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character:" + getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: " + getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: " + getParameters().getSearchPattern(), ex);
        data = null;
    }
    return data;
}
#end_block

#method_before
private void updateBrickStatusDown() {
    List<GlusterBrickEntity> brickEntities = getDbFacade().getGlusterBrickDao().getGlusterVolumeBricksByServerId(getVdsId());
    for (GlusterBrickEntity brick : brickEntities) {
        brick.setStatus(GlusterStatus.DOWN);
    }
    getDbFacade().getGlusterBrickDao().updateAll(brickEntities);
}
#method_after
private void updateBrickStatusDown() {
    List<GlusterBrickEntity> brickEntities = getDbFacade().getGlusterBrickDao().getGlusterVolumeBricksByServerId(getVdsId());
    for (GlusterBrickEntity brick : brickEntities) {
        brick.setStatus(GlusterStatus.DOWN);
    }
    getDbFacade().getGlusterBrickDao().updateBrickStatuses(brickEntities);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnaValue = runVdsCommand(VDSCommandType.StopRebalanceGlusterVolume, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    if (!vdsReturnaValue.getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, vdsReturnaValue.getVdsError().getMessage());
        setSucceeded(false);
        return;
    }
    GlusterVolumeTaskStatusEntity rebalanceStatusEntity = (GlusterVolumeTaskStatusEntity) vdsReturnaValue.getReturnValue();
    JobExecutionStatus stepStatus = rebalanceStatusEntity.getStatusSummary().getStatus();
    if (JobExecutionStatus.FINISHED == stepStatus || JobExecutionStatus.FAILED == stepStatus) {
        endStepJob(stepStatus, getStepMessageMap(stepStatus), true);
    } else {
        endStepJob(JobExecutionStatus.ABORTED, getStepMessageMap(JobExecutionStatus.ABORTED), false);
    }
    releaseVolumeLock();
    setSucceeded(vdsReturnaValue.getSucceeded());
    getReturnValue().setActionReturnValue(rebalanceStatusEntity);
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnaValue = runVdsCommand(VDSCommandType.StopRebalanceGlusterVolume, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    if (!vdsReturnaValue.getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, vdsReturnaValue.getVdsError().getMessage());
        setSucceeded(false);
        return;
    }
    GlusterVolumeTaskStatusEntity rebalanceStatusEntity = (GlusterVolumeTaskStatusEntity) vdsReturnaValue.getReturnValue();
    JobExecutionStatus stepStatus = rebalanceStatusEntity.getStatusSummary().getStatus();
    if (stepStatus != null) {
        endStepJob(stepStatus, getStepMessageMap(stepStatus), GlusterTaskUtils.getInstance().isTaskSuccess(stepStatus));
    } else {
        endStepJob(JobExecutionStatus.ABORTED, getStepMessageMap(JobExecutionStatus.ABORTED), false);
    }
    releaseVolumeLock();
    setSucceeded(vdsReturnaValue.getSucceeded());
    getReturnValue().setActionReturnValue(rebalanceStatusEntity);
}
#end_block

#method_before
private void processFence() {
    FenceExecutor executor = new FenceExecutor(getVds(), FenceActionType.Status);
    // actions.
    if (getVds().getpm_enabled() && executor.findProxyHost()) {
        VDSReturnValue returnValue = executor.Fence();
        fenceSucceeded = returnValue.getSucceeded();
        fenceStatusReturnValue = (FenceStatusReturnValue) returnValue.getReturnValue();
        vdsProxyFound = true;
    }
}
#method_after
private void processFence() {
    FenceExecutor executor = new FenceExecutor(getVds(), FenceActionType.Status);
    // actions.
    if (getVds().getpm_enabled() && executor.findProxyHost()) {
        VDSReturnValue returnValue = executor.fence();
        fenceSucceeded = returnValue.getSucceeded();
        fenceStatusReturnValue = (FenceStatusReturnValue) returnValue.getReturnValue();
        vdsProxyFound = true;
    }
}
#end_block

#method_before
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = getStoragePoolDAO().get(storagePoolId);
    StorageDomain masterDomain = getStorageDomainDAO().getStorageDomainByTypeAndPool(storagePoolId, StorageDomainType.Master);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.InActive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    try {
        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), storagePoolId, vds.getVdsSpmId(), masterDomain.getId(), storagePool.getmaster_domain_version()));
    } catch (VdcBLLException e) {
        if (masterDomainInactiveOrUnknown) {
            log.infoFormat("Could not connect host {0} to pool {1}, as the master domain is in inactive/unknown status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.errorFormat("Could not connect host {0} to pool {1}", vds.getName(), storagePool.getName());
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        result.setSuccess(proceedVdsStats(!masterDomainInactiveOrUnknown));
        if (!result.isSuccess()) {
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#method_after
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = getStoragePoolDAO().get(storagePoolId);
    StorageDomain masterDomain = getStorageDomainDAO().getStorageDomainByTypeAndPool(storagePoolId, StorageDomainType.Master);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.InActive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    VDSError error = null;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), storagePoolId, vds.getVdsSpmId(), masterDomain.getId(), storagePool.getmaster_domain_version()));
        if (!vdsReturnValue.getSucceeded()) {
            error = vdsReturnValue.getVdsError();
        }
    } catch (VdcBLLException e) {
        error = e.getVdsError();
    }
    if (error != null) {
        if (error.getCode() != VdcBllErrors.CannotConnectMultiplePools && masterDomainInactiveOrUnknown) {
            log.infoFormat("Could not connect host {0} to pool {1}, as the master domain is in inactive/unknown status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.errorFormat("Could not connect host {0} to pool {1} with the message: {2}", vds.getName(), storagePool.getName(), error.getMessage());
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        result.setSuccess(proceedVdsStats(!masterDomainInactiveOrUnknown));
        if (!result.isSuccess()) {
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#end_block

#method_before
private boolean initGlusterPeerProcess() {
    /* Acquiring a wait lock only during a gluster peer process
          If "gluster peer probe" and "gluster peer status" are executed simultaneously, the results
          are unpredictable. Hence locking the cluster to ensure the sync job does not lead to race
          condition.*/
    Map<String, Pair<String, String>> exclusiveLocks = new HashMap<String, Pair<String, String>>();
    exclusiveLocks.put(getVds().getVdsGroupId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.GLUSTER, VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_OPERATION_INPROGRESS));
    EngineLock lock = new EngineLock(exclusiveLocks, null);
    getLockManager().acquireLockWait(lock);
    try {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                Map<String, String> customLogValues = new HashMap<String, String>();
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!hostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                }
            }
        }
        return true;
    } finally {
        getLockManager().releaseLock(lock);
    }
}
#method_after
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<String, String>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!hostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                }
            }
        }
        return true;
    }
}
#end_block

#method_before
private void removeDetachedServers(List<VDS> existingServers, List<GlusterServerInfo> fetchedServers) {
    boolean serverRemoved = false;
    for (VDS server : existingServers) {
        if (isRemovableStatus(server.getStatus()) && serverDetached(server, fetchedServers)) {
            log.infoFormat("Server {0} has been removed directly using the gluster CLI. Removing it from engine as well.", server.getName());
            logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI);
            try {
                removeServerFromDb(server);
                // remove the server from resource manager
                runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));
                serverRemoved = true;
            } catch (Exception e) {
                log.errorFormat("Error while removing server {0} from database!", server.getName(), e);
            }
        }
    }
    if (serverRemoved) {
        log.infoFormat("Servers detached using gluster CLI  is removed from engine after inspecting the Gluster servers list {0}", fetchedServers);
    }
}
#method_after
private void removeDetachedServers(List<VDS> existingServers, List<GlusterServerInfo> fetchedServers) {
    log.debugFormat("Existing servers list returned {0} comparing with fetched servers {1)", existingServers, fetchedServers);
    boolean serverRemoved = false;
    for (VDS server : existingServers) {
        if (isRemovableStatus(server.getStatus()) && serverDetached(server, fetchedServers)) {
            log.infoFormat("Server {0} has been removed directly using the gluster CLI. Removing it from engine as well.", server.getName());
            logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI);
            try {
                removeServerFromDb(server);
                // remove the server from resource manager
                runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));
                serverRemoved = true;
            } catch (Exception e) {
                log.errorFormat("Error while removing server {0} from database!", server.getName(), e);
            }
        }
    }
    if (serverRemoved) {
        log.infoFormat("Servers detached using gluster CLI  is removed from engine after inspecting the Gluster servers list returned {0} " + "- comparing with db servers {1}", fetchedServers, existingServers);
    }
}
#end_block

#method_before
private boolean isRemovableStatus(VDSStatus status) {
    switch(status) {
        case Up:
        case Down:
        case Maintenance:
            return true;
        default:
            return false;
    }
}
#method_after
private boolean isRemovableStatus(VDSStatus status) {
    switch(status) {
        case Up:
        case Down:
            return true;
        default:
            return false;
    }
}
#end_block

#method_before
private void refreshBrickStatuses(VDS upServer, GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<GlusterBrickEntity>();
    Map<Guid, GlusterStatus> brickStatusMap = getBrickStatusMap(getVolumeAdvancedDetails(upServer, volume.getClusterId(), volume.getName()));
    for (GlusterBrickEntity brick : volume.getBricks()) {
        GlusterStatus fetchedStatus = brickStatusMap.get(brick.getId());
        // DB yet. Don't do anything, wait for it to be added by the 'lightweight' refresh job
        if (fetchedStatus != null && fetchedStatus != brick.getStatus()) {
            brick.setStatus(fetchedStatus);
            bricksToUpdate.add(brick);
        }
    }
    if (!bricksToUpdate.isEmpty()) {
        getBrickDao().updateBrickStatuses(bricksToUpdate);
    }
}
#method_after
private void refreshBrickStatuses(VDS upServer, GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<GlusterBrickEntity>();
    Map<Guid, GlusterStatus> brickStatusMap = getBrickStatusMap(getVolumeAdvancedDetails(upServer, volume.getClusterId(), volume.getName()));
    for (GlusterBrickEntity brick : volume.getBricks()) {
        GlusterStatus fetchedStatus = brickStatusMap.get(brick.getId());
        // DB yet. Don't do anything, wait for it to be added by the 'lightweight' refresh job
        if (fetchedStatus != null && fetchedStatus != brick.getStatus()) {
            logBrickStatusChange(volume, brick, fetchedStatus);
            brick.setStatus(fetchedStatus);
            bricksToUpdate.add(brick);
        }
    }
    if (!bricksToUpdate.isEmpty()) {
        getBrickDao().updateBrickStatuses(bricksToUpdate);
    }
}
#end_block

#method_before
private boolean glusterHostRemove(Guid sourceClusterId) {
    String hostName = (getVds().getHostName().isEmpty()) ? getVds().getManagementIp() : getVds().getHostName();
    VDS runningHostInSourceCluster = getClusterUtils().getUpServer(sourceClusterId);
    if (runningHostInSourceCluster == null) {
        log.error("Cannot remove host from source cluster, no host in Up status found in source cluster");
        handleError(-1, "No host in Up status found in source cluster");
        errorType = AuditLogType.GLUSTER_SERVER_REMOVE_FAILED;
        return false;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RemoveGlusterServer, new RemoveGlusterServerVDSParameters(runningHostInSourceCluster.getId(), hostName, false));
    if (!returnValue.getSucceeded()) {
        handleVdsError(returnValue);
        errorType = AuditLogType.GLUSTER_SERVER_REMOVE_FAILED;
        return false;
    }
    return true;
}
#method_after
private boolean glusterHostRemove(Guid sourceClusterId) {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(sourceClusterId)) {
        String hostName = (getVds().getHostName().isEmpty()) ? getVds().getManagementIp() : getVds().getHostName();
        VDS runningHostInSourceCluster = getClusterUtils().getUpServer(sourceClusterId);
        if (runningHostInSourceCluster == null) {
            log.error("Cannot remove host from source cluster, no host in Up status found in source cluster");
            handleError(-1, "No host in Up status found in source cluster");
            errorType = AuditLogType.GLUSTER_SERVER_REMOVE_FAILED;
            return false;
        }
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RemoveGlusterServer, new RemoveGlusterServerVDSParameters(runningHostInSourceCluster.getId(), hostName, false));
        if (!returnValue.getSucceeded()) {
            handleVdsError(returnValue);
            errorType = AuditLogType.GLUSTER_SERVER_REMOVE_FAILED;
            return false;
        }
        return true;
    }
}
#end_block

#method_before
private boolean glusterHostAdd(Guid targetClusterId) {
    String hostName = (getVds().getHostName().isEmpty()) ? getVds().getManagementIp() : getVds().getHostName();
    VDS runningHostInTargetCluster = getClusterUtils().getUpServer(targetClusterId);
    if (runningHostInTargetCluster == null) {
        log.error("Cannot add host to target cluster, no host in Up status found in target cluster");
        handleError(-1, "No host in Up status found in target cluster");
        errorType = AuditLogType.GLUSTER_SERVER_ADD_FAILED;
        return false;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(runningHostInTargetCluster.getId(), hostName));
    if (!returnValue.getSucceeded()) {
        handleVdsError(returnValue);
        errorType = AuditLogType.GLUSTER_SERVER_ADD_FAILED;
        return false;
    }
    return true;
}
#method_after
private boolean glusterHostAdd(Guid targetClusterId) {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(targetClusterId)) {
        String hostName = (getVds().getHostName().isEmpty()) ? getVds().getManagementIp() : getVds().getHostName();
        VDS runningHostInTargetCluster = getClusterUtils().getUpServer(targetClusterId);
        if (runningHostInTargetCluster == null) {
            log.error("Cannot add host to target cluster, no host in Up status found in target cluster");
            handleError(-1, "No host in Up status found in target cluster");
            errorType = AuditLogType.GLUSTER_SERVER_ADD_FAILED;
            return false;
        }
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(runningHostInTargetCluster.getId(), hostName));
        if (!returnValue.getSucceeded()) {
            handleVdsError(returnValue);
            errorType = AuditLogType.GLUSTER_SERVER_ADD_FAILED;
            return false;
        }
        return true;
    }
}
#end_block

#method_before
private void setupMock() {
    clusterUtils = mock(ClusterUtils.class);
    vdsDao = mock(VdsDAO.class);
    volumeDao = mock(GlusterVolumeDao.class);
    glusterServerDao = mock(GlusterServerDao.class);
    stepDao = mock(StepDao.class);
    jobRepository = mock(JobRepository.class);
    doReturn(vdsDao).when(getQuery()).getVdsDao();
    doReturn(volumeDao).when(getQuery()).getGlusterVolumeDao();
    doReturn(stepDao).when(getQuery()).getStepDao();
    doReturn(glusterServerDao).when(getQuery()).getGlusterServerDao();
    doReturn(CLUSTER_ID).when(getQueryParameters()).getClusterId();
    doReturn(VOLUME_ID).when(getQueryParameters()).getVolumeId();
    doReturn(jobRepository).when(getQuery()).getJobRepository();
    when(volumeDao.getById(VOLUME_ID)).thenReturn(getVolume());
    when(stepDao.getStepsByExternalId(any(Guid.class))).thenReturn(getStepsList());
    when(glusterServerDao.getByGlusterServerUuid(any(Guid.class))).thenReturn(getGlusterServer());
    when(vdsDao.get(any(Guid.class))).thenReturn(getVds(VDSStatus.Up));
    doNothing().when(jobRepository).updateStep(any(Step.class));
    doNothing().when(getQuery()).releaseVolumeLock(any(Guid.class));
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    returnValue.setReturnValue(expectedVolumeStatusDetails);
    doReturn(returnValue).when(getQuery()).runVdsCommand(eq(VDSCommandType.GetGlusterVolumeRemoveBricksStatus), any(VDSParametersBase.class));
}
#method_after
private void setupMock() {
    clusterUtils = mock(ClusterUtils.class);
    vdsDao = mock(VdsDAO.class);
    clusterDao = mock(VdsGroupDAO.class);
    volumeDao = mock(GlusterVolumeDao.class);
    glusterServerDao = mock(GlusterServerDao.class);
    stepDao = mock(StepDao.class);
    taskUtils = mock(GlusterTaskUtils.class);
    doReturn(vdsDao).when(getQuery()).getVdsDao();
    doReturn(clusterDao).when(getQuery()).getClusterDao();
    doReturn(volumeDao).when(getQuery()).getGlusterVolumeDao();
    doReturn(stepDao).when(getQuery()).getStepDao();
    doReturn(glusterServerDao).when(getQuery()).getGlusterServerDao();
    doReturn(CLUSTER_ID).when(getQueryParameters()).getClusterId();
    doReturn(VOLUME_ID).when(getQueryParameters()).getVolumeId();
    doReturn(taskUtils).when(getQuery()).getGlusterTaskUtils();
    when(volumeDao.getById(VOLUME_ID)).thenReturn(getVolume());
    when(stepDao.getStepsByExternalId(any(Guid.class))).thenReturn(getStepsList());
    when(glusterServerDao.getByGlusterServerUuid(any(Guid.class))).thenReturn(getGlusterServer());
    when(vdsDao.get(any(Guid.class))).thenReturn(getVds(VDSStatus.Up));
    when(clusterDao.get(any(Guid.class))).thenReturn(getVDSGroup());
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    returnValue.setReturnValue(expectedVolumeStatusDetails);
    doReturn(returnValue).when(getQuery()).runVdsCommand(eq(VDSCommandType.GetGlusterVolumeRemoveBricksStatus), any(VDSParametersBase.class));
}
#end_block

#method_before
@Override
protected GlusterVolumeTaskStatusEntity fetchTaskStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRemoveBricksStatus, new GlusterVolumeRemoveBricksVDSParameters(getUpServerId(clusterId), volume.getName(), getParameters().getBricks(), volume.getReplicaCount()));
    // Set the volume remove bricks start time
    GlusterVolumeTaskStatusEntity entity = setStartTime((GlusterVolumeTaskStatusEntity) returnValue.getReturnValue());
    // Set the host ip in status details
    updateHostIP(entity);
    return entity.sort();
}
#method_after
@Override
protected GlusterVolumeTaskStatusEntity fetchTaskStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRemoveBricksStatus, new GlusterVolumeRemoveBricksVDSParameters(getUpServerId(clusterId), volume.getName(), getParameters().getBricks(), volume.getReplicaCount()));
    // update the status entity with required details
    return updateStatusEntity((GlusterVolumeTaskStatusEntity) returnValue.getReturnValue());
}
#end_block

#method_before
@Override
protected GlusterVolumeTaskStatusEntity fetchTaskStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRebalanceStatus, new GlusterVolumeVDSParameters(getUpServerId(clusterId), volume.getName()));
    // Set the volume re-balance start time
    GlusterVolumeTaskStatusEntity entity = setStartTime((GlusterVolumeTaskStatusEntity) returnValue.getReturnValue());
    // Set the host ip in status details
    updateHostIP(entity);
    return entity.sort();
}
#method_after
@Override
protected GlusterVolumeTaskStatusEntity fetchTaskStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRebalanceStatus, new GlusterVolumeVDSParameters(getUpServerId(clusterId), volume.getName()));
    return updateStatusEntity((GlusterVolumeTaskStatusEntity) returnValue.getReturnValue());
}
#end_block

#method_before
@Override
public void executeQueryCommand() {
    clusterId = getParameters().getClusterId();
    Guid volumeId = getParameters().getVolumeId();
    if (volumeId != null) {
        volume = getGlusterVolumeDao().getById(volumeId);
        if (volume == null) {
            throw new RuntimeException(VdcBllMessages.GLUSTER_VOLUME_ID_INVALID.toString());
        }
    }
    if (clusterId == null) {
        clusterId = volume.getClusterId();
    }
    getQueryReturnValue().setReturnValue(fetchTaskStatusDetails());
}
#method_after
@Override
public void executeQueryCommand() {
    clusterId = getParameters().getClusterId();
    volume = getGlusterVolumeDao().getById(getParameters().getVolumeId());
    if (volume == null) {
        throw new RuntimeException(VdcBllMessages.GLUSTER_VOLUME_ID_INVALID.toString());
    }
    if (clusterId == null) {
        clusterId = volume.getClusterId();
    }
    getQueryReturnValue().setReturnValue(fetchTaskStatusDetails());
}
#end_block

#method_before
protected void updateHostIP(GlusterVolumeTaskStatusEntity taskStatus) {
    if (taskStatus != null) {
        for (GlusterVolumeTaskStatusForHost hostStatus : taskStatus.getHostwiseStatusDetails()) {
            GlusterServer glusterServer = getGlusterServerDao().getByGlusterServerUuid(hostStatus.getHostUuid());
            if (glusterServer != null) {
                VDS host = getVdsDao().get(glusterServer.getId());
                if (host != null) {
                    hostStatus.setHostName(host.getName());
                    hostStatus.setHostId(host.getId());
                }
            }
        }
    }
}
#method_after
private void updateHostIP(GlusterVolumeTaskStatusEntity taskStatus) {
    if (taskStatus != null) {
        for (GlusterVolumeTaskStatusForHost hostStatus : taskStatus.getHostwiseStatusDetails()) {
            GlusterServer glusterServer = getGlusterServerDao().getByGlusterServerUuid(hostStatus.getHostUuid());
            if (glusterServer != null) {
                VDS host = getVdsDao().get(glusterServer.getId());
                if (host != null) {
                    hostStatus.setHostName(host.getName());
                    hostStatus.setHostId(host.getId());
                }
            }
        }
    }
}
#end_block

#method_before
protected GlusterVolumeTaskStatusEntity setStartTime(GlusterVolumeTaskStatusEntity status) {
    if (status == null) {
        return null;
    }
    GlusterAsyncTask asyncTask = volume.getAsyncTask();
    if (asyncTask != null && asyncTask.getTaskId() != null) {
        List<Step> stepsList = getStepDao().getStepsByExternalId(asyncTask.getTaskId());
        if (stepsList != null && !stepsList.isEmpty()) {
            status.setStartTime(stepsList.get(0).getStartTime());
        }
    }
    return status;
}
#method_after
private GlusterVolumeTaskStatusEntity setStartTime(GlusterVolumeTaskStatusEntity status) {
    if (status == null) {
        return null;
    }
    GlusterAsyncTask asyncTask = volume.getAsyncTask();
    if (asyncTask != null && asyncTask.getTaskId() != null) {
        List<Step> stepsList = getStepDao().getStepsByExternalId(asyncTask.getTaskId());
        if (stepsList != null && !stepsList.isEmpty()) {
            status.setStartTime(stepsList.get(0).getStartTime());
        }
    }
    return status;
}
#end_block

#method_before
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_NEW, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICES_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_TYPE_ADDED_TO_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOPPED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND, AuditLogSeverity.ERROR);
}
#method_after
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_NEW, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICES_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_TYPE_ADDED_TO_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOPPED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initVMsPoolSeverities() {
    severities.put(AuditLogType.USER_ADD_VM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS_ADD_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_AD_GROUP_TO_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_AD_GROUP_TO_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_USER_TO_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_USER_TO_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VM_POOL_MAX_SUBSEQUENT_FAILURES_REACHED, AuditLogSeverity.WARNING);
}
#method_after
private static void initVMsPoolSeverities() {
    severities.put(AuditLogType.USER_ADD_VM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS_ADD_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VM_POOL_MAX_SUBSEQUENT_FAILURES_REACHED, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initMLASeverities() {
    severities.put(AuditLogType.USER_VDC_LOGIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDC_LOGOUT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGOUT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_AD_GROUP_TO_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_AD_GROUP_TO_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ADUSER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_ADUSER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_ADUSER, AuditLogSeverity.WARNING);
}
#method_after
private static void initMLASeverities() {
    severities.put(AuditLogType.USER_VDC_LOGIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDC_LOGOUT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGOUT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ADUSER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_ADUSER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_ADUSER, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initClusterPolicySeverities() {
    severities.put(AuditLogType.USER_ADD_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_ADD_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_REMOVE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_UPDATE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
}
#method_after
private static void initClusterPolicySeverities() {
    severities.put(AuditLogType.USER_ADD_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_ADD_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_REMOVE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_UPDATE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int duplicateEventsIntrvalValue = (auditLogable.isExternal()) ? // Min duration for External Events is 30 sec
    Math.max(auditLogable.getEventFloodInSec(), 30) : logType.getDuplicateEventsIntervalValue();
    if (duplicateEventsIntrvalValue > 0) {
        auditLogable.setEndTime(TimeUnit.SECONDS.toMillis(duplicateEventsIntrvalValue));
        auditLogable.setTimeoutObjectId(composeObjectId(auditLogable, logType));
    }
}
#method_after
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int eventFloodRate = (auditLogable.isExternal()) ? // Min duration for External Events is 30 sec
    Math.max(auditLogable.getEventFloodInSec(), 30) : logType.getEventFloodRate();
    if (eventFloodRate > 0) {
        auditLogable.setEndTime(TimeUnit.SECONDS.toMillis(eventFloodRate));
        auditLogable.setTimeoutObjectId(composeObjectId(auditLogable, logType));
    }
}
#end_block

#method_before
private static String composeObjectId(AuditLogableBase logable, AuditLogType logType) {
    final char DELIMITER = ',';
    StringBuilder sb = new StringBuilder();
    sb.append("type=");
    sb.append(logType);
    sb.append(DELIMITER);
    sb.append("sd=");
    sb.append(logable.getStorageDomainId() == null ? "" : logable.getStorageDomainId().toString());
    sb.append(DELIMITER);
    sb.append("dc=");
    sb.append(logable.getStoragePoolId() == null ? "" : logable.getStoragePoolId().toString());
    sb.append(DELIMITER);
    sb.append("user=");
    sb.append(logable.getUserId() == null ? "" : logable.getUserId().toString());
    sb.append(DELIMITER);
    sb.append("cluster=");
    sb.append(logable.getVdsGroupId().toString());
    sb.append(DELIMITER);
    sb.append("vds=");
    sb.append(logable.getVdsId().toString());
    sb.append(DELIMITER);
    sb.append("vm=");
    sb.append(logable.getVmId().equals(Guid.Empty) ? "" : logable.getVmId().toString());
    sb.append(DELIMITER);
    sb.append("template=");
    sb.append(logable.getVmTemplateId().equals(Guid.Empty) ? "" : logable.getVmTemplateId().toString());
    sb.append(DELIMITER);
    sb.append("customId=");
    sb.append(logable.getCustomId() == null ? "" : logable.getCustomId().toString());
    sb.append(DELIMITER);
    return sb.toString();
}
#method_after
private static String composeObjectId(AuditLogableBase logable, AuditLogType logType) {
    final char DELIMITER = ',';
    StringBuilder sb = new StringBuilder();
    sb.append("type=");
    sb.append(logType);
    sb.append(DELIMITER);
    sb.append("sd=");
    sb.append(logable.getStorageDomainId() == null ? "" : logable.getStorageDomainId().toString());
    sb.append(DELIMITER);
    sb.append("dc=");
    sb.append(logable.getStoragePoolId() == null ? "" : logable.getStoragePoolId().toString());
    sb.append(DELIMITER);
    sb.append("user=");
    sb.append(logable.getUserId() == null ? "" : logable.getUserId().toString());
    sb.append(DELIMITER);
    sb.append("cluster=");
    sb.append(logable.getVdsGroupId().toString());
    sb.append(DELIMITER);
    sb.append("vds=");
    sb.append(logable.getVdsId().toString());
    sb.append(DELIMITER);
    sb.append("vm=");
    sb.append(logable.getVmId().equals(Guid.Empty) ? "" : logable.getVmId().toString());
    sb.append(DELIMITER);
    sb.append("template=");
    sb.append(logable.getVmTemplateId().equals(Guid.Empty) ? "" : logable.getVmTemplateId().toString());
    sb.append(DELIMITER);
    sb.append("customId=");
    sb.append(StringUtils.defaultString(logable.getCustomId()));
    sb.append(DELIMITER);
    return sb.toString();
}
#end_block

#method_before
@OnTimerMethodAnnotation("gluster_async_task_poll_event")
public void updateGlusterAsyncTasks() {
    log.debug("Refreshing gluster tasks list");
    List<VDSGroup> clusters = getClusterDao().getAll();
    for (VDSGroup cluster : clusters) {
        updateTasksInCluster(cluster);
    }
}
#method_after
@OnTimerMethodAnnotation("gluster_async_task_poll_event")
public void updateGlusterAsyncTasks() {
    log.debug("Refreshing gluster tasks list");
    List<VDSGroup> clusters = getClusterDao().getAll();
    List<Guid> tasksFromClusters = new ArrayList<>();
    boolean cleanOrphanTasks = true;
    for (VDSGroup cluster : clusters) {
        if (!getGlusterTaskUtils().supportsGlusterAsyncTasksFeature(cluster)) {
            continue;
        }
        try {
            Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
            if (runningTasks != null) {
                updateTasksInCluster(cluster, runningTasks);
                tasksFromClusters.addAll(runningTasks.keySet());
            }
        } catch (VdcBLLException e) {
            cleanOrphanTasks = false;
        }
    }
    if (cleanOrphanTasks) {
        cleanUpOrphanTasks(tasksFromClusters);
    }
}
#end_block

#method_before
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            createJobForTaskFromCLI(cluster, task);
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            step.setStatus(task.getStatus());
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#method_after
private void updateTasksInCluster(final VDSGroup cluster, final Map<Guid, GlusterAsyncTask> runningTasks) {
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            createJobForTaskFromCLI(cluster, task);
        }
        getGlusterTaskUtils().updateSteps(cluster, task, steps);
    }
}
#end_block

#method_before
private Guid addAsyncTaskStep(VDSGroup cluster, GlusterAsyncTask task, StepEnum step, Guid execStepId) {
    VdcReturnValueBase result;
    result = getBackend().runInternalAction(VdcActionType.AddInternalStep, new AddStepParameters(execStepId, getTaskMessage(cluster, step, task), step));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid asyncStepId = (Guid) result.getActionReturnValue();
    return asyncStepId;
}
#method_after
private Guid addAsyncTaskStep(VDSGroup cluster, GlusterAsyncTask task, StepEnum step, Guid execStepId) {
    VdcReturnValueBase result;
    result = getBackend().runInternalAction(VdcActionType.AddInternalStep, new AddStepParameters(execStepId, getGlusterTaskUtils().getTaskMessage(cluster, step, task), step));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid asyncStepId = (Guid) result.getActionReturnValue();
    return asyncStepId;
}
#end_block

#method_before
private Guid addJob(VDSGroup cluster, GlusterAsyncTask task, VdcActionType actionType) {
    VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.AddInternalJob, new AddInternalJobParameters(ExecutionMessageDirector.resolveJobMessage(actionType, getMessageMap(cluster, task)), actionType, true));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid jobId = (Guid) result.getActionReturnValue();
    return jobId;
}
#method_after
private Guid addJob(VDSGroup cluster, GlusterAsyncTask task, VdcActionType actionType) {
    VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.AddInternalJob, new AddInternalJobParameters(ExecutionMessageDirector.resolveJobMessage(actionType, getGlusterTaskUtils().getMessageMap(cluster, task)), actionType, true));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid jobId = (Guid) result.getActionReturnValue();
    return jobId;
}
#end_block

#method_before
@Before
public void init() {
    MockitoAnnotations.initMocks(this);
    tasksSyncJob = Mockito.spy(GlusterTasksSyncJob.getInstance());
    logUtil = Mockito.spy(GlusterAuditLogUtil.getInstance());
    doNothing().when(logUtil).logClusterMessage(any(Guid.class), any(AuditLogType.class));
    doReturn(clusterDao).when(tasksSyncJob).getClusterDao();
    doReturn(getClusters()).when(clusterDao).getAll();
    doReturn(provider).when(tasksSyncJob).getProvider();
    doReturn(stepDao).when(tasksSyncJob).getStepDao();
    doReturn(volumeDao).when(tasksSyncJob).getVolumeDao();
    doReturn(jobRepository).when(tasksSyncJob).getJobRepository();
    doReturn(backend).when(tasksSyncJob).getBackend();
    doNothing().when(tasksSyncJob).releaseLock(any(Guid.class));
    doNothing().when(tasksSyncJob).endStepJob(any(Step.class));
}
#method_after
@Before
public void init() {
    MockitoAnnotations.initMocks(this);
    tasksSyncJob = Mockito.spy(GlusterTasksSyncJob.getInstance());
    logUtil = Mockito.spy(GlusterAuditLogUtil.getInstance());
    taskUtils = Mockito.spy(GlusterTaskUtils.getInstance());
    doNothing().when(logUtil).logClusterMessage(any(Guid.class), any(AuditLogType.class));
    doReturn(clusterDao).when(tasksSyncJob).getClusterDao();
    doReturn(getClusters()).when(clusterDao).getAll();
    doReturn(provider).when(tasksSyncJob).getProvider();
    doReturn(stepDao).when(tasksSyncJob).getStepDao();
    doReturn(volumeDao).when(tasksSyncJob).getVolumeDao();
    doReturn(volumeDao).when(taskUtils).getVolumeDao();
    doReturn(jobRepository).when(tasksSyncJob).getJobRepository();
    doReturn(jobRepository).when(taskUtils).getJobRepository();
    doReturn(backend).when(tasksSyncJob).getBackend();
    doReturn(taskUtils).when(tasksSyncJob).getGlusterTaskUtils();
    doNothing().when(taskUtils).releaseLock(any(Guid.class));
    doNothing().when(taskUtils).endStepJob(any(Step.class));
    doReturn(null).when(provider).getMonitoredTaskIDsInDB();
}
#end_block

#method_before
@Test
public void updateTasksInCluster() {
    doReturn(getTasks()).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(1)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(1)).endStepJob(any(Step.class));
}
#method_after
@Test
public void updateTasksInCluster() {
    doReturn(getTasks()).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(1)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(1)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void testUpdateWhenNoTasks() {
    doReturn(null).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(volumeDao, times(0)).updateVolumeTask(VOL_GUIDS[0], null);
    Mockito.verify(volumeDao, times(0)).updateVolumeTask(VOL_GUIDS[1], null);
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(0)).endStepJob(any(Step.class));
}
#method_after
@Test
public void testUpdateWhenNoTasks() {
    doReturn(null).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(volumeDao, times(0)).updateVolumeTask(VOL_GUIDS[0], null);
    Mockito.verify(volumeDao, times(0)).updateVolumeTask(VOL_GUIDS[1], null);
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(0)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void testCreateTasksStartedFromCLI() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(mockVdcReturn(true, Guid.newGuid())).when(backend).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
    prepareMocksForTasksFromCLI();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(0)).endStepJob(any(Step.class));
}
#method_after
@Test
public void testCreateTasksStartedFromCLI() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(mockVdcReturn(true, Guid.newGuid())).when(backend).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
    prepareMocksForTasksFromCLI();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(0)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void testCreateTasksStartedFromCLIWithErrors() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(mockVdcReturn(false, null)).when(backend).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
    prepareMocksForTasksFromCLI();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(0)).endStepJob(any(Step.class));
}
#method_after
@Test
public void testCreateTasksStartedFromCLIWithErrors() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(mockVdcReturn(false, null)).when(backend).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
    prepareMocksForTasksFromCLI();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(0)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void testUpdateWhenNoCompletedTasks() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(2)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(0)).endStepJob(any(Step.class));
}
#method_after
@Test
public void testUpdateWhenNoCompletedTasks() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(2)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(0)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void testUpdateWhenAbortedTasks() {
    doReturn(getTasks(JobExecutionStatus.ABORTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(2)).endStepJob(any(Step.class));
}
#method_after
@Test
public void testUpdateWhenAbortedTasks() {
    doReturn(getTasks(JobExecutionStatus.ABORTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(2)).endStepJob(any(Step.class));
}
#end_block

#method_before
private void prepareMocks() {
    doReturn(getVolume(0)).when(volumeDao).getVolumeByGlusterTask(TASK_GUIDS[0]);
    doReturn(getVolume(1)).when(volumeDao).getVolumeByGlusterTask(TASK_GUIDS[1]);
    doReturn(getSteps()).when(stepDao).getStepsByExternalId(TASK_GUIDS[0]);
    doReturn(getSteps()).when(stepDao).getStepsByExternalId(TASK_GUIDS[1]);
}
#method_after
private void prepareMocks() {
    doReturn(getVolume(0)).when(volumeDao).getVolumeByGlusterTask(TASK_GUIDS[0]);
    doReturn(getVolume(1)).when(volumeDao).getVolumeByGlusterTask(TASK_GUIDS[1]);
    doReturn(getVolume(1)).when(volumeDao).getVolumeByGlusterTask(TASK_GUIDS[2]);
    doReturn(getSteps()).when(stepDao).getStepsByExternalId(TASK_GUIDS[0]);
    doReturn(getSteps()).when(stepDao).getStepsByExternalId(TASK_GUIDS[1]);
    doReturn(getSteps()).when(stepDao).getStepsByExternalId(TASK_GUIDS[2]);
}
#end_block

#method_before
private GlusterVolumeEntity getVolume(int i) {
    GlusterVolumeEntity vol = new GlusterVolumeEntity();
    vol.setId(VOL_GUIDS[i]);
    return vol;
}
#method_after
private GlusterVolumeEntity getVolume(int i) {
    GlusterVolumeEntity vol = new GlusterVolumeEntity();
    vol.setStatus(GlusterStatus.UP);
    vol.setId(VOL_GUIDS[i]);
    return vol;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds();
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process
    if (Config.<Boolean>GetValue(ConfigValues.InstallVds) && !getParameters().getAddPending()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setProviderId(getParameters().getProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVds, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    } else {
        // Also gluster peer probe is not needed when importing an existing gluster cluster
        if (isGlusterSupportEnabled() && getAllVds(getVdsGroupId()).size() > 1) {
            String hostName = (getParameters().getvds().getHostName().isEmpty()) ? getParameters().getvds().getManagementIp() : getParameters().getvds().getHostName();
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(upServer.getId(), hostName));
            setSucceeded(returnValue.getSucceeded());
            if (!getSucceeded()) {
                getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
                getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
                errorType = AuditLogType.GLUSTER_SERVER_ADD_FAILED;
                return;
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds();
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process
    if (Config.<Boolean>GetValue(ConfigValues.InstallVds) && !getParameters().getAddPending()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setProviderId(getParameters().getProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVds, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
private void AddVdsDynamicToDb() {
    VdsDynamic vdsDynamic = new VdsDynamic();
    vdsDynamic.setId(getParameters().getVdsStaticData().getId());
    // TODO: oVirt type - here oVirt behaves like power client?
    if (Config.<Boolean>GetValue(ConfigValues.InstallVds) && getParameters().getVdsStaticData().getVdsType() == VDSType.VDS) {
        vdsDynamic.setStatus(VDSStatus.Installing);
    } else if (getParameters().getAddPending()) {
        vdsDynamic.setStatus(VDSStatus.PendingApproval);
    }
    DbFacade.getInstance().getVdsDynamicDao().save(vdsDynamic);
    getCompensationContext().snapshotNewEntity(vdsDynamic);
}
#method_after
private void AddVdsDynamicToDb() {
    VdsDynamic vdsDynamic = new VdsDynamic();
    vdsDynamic.setId(getParameters().getVdsStaticData().getId());
    // TODO: oVirt type - here oVirt behaves like power client?
    if (getParameters().getAddPending()) {
        vdsDynamic.setStatus(VDSStatus.PendingApproval);
    } else if (Config.<Boolean>GetValue(ConfigValues.InstallVds)) {
        vdsDynamic.setStatus(VDSStatus.Installing);
    }
    DbFacade.getInstance().getVdsDynamicDao().save(vdsDynamic);
    getCompensationContext().snapshotNewEntity(vdsDynamic);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    setVdsGroupId(getParameters().getVdsStaticData().getVdsGroupId());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateVdsGroup();
    if (returnValue) {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getName();
        String hostName = vds.getHostName();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
        } else if (getVdsDAO().getByName(vdsName) != null) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        } else if (getVdsDAO().getAllForHostname(hostName).size() != 0) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
        } else if (!ValidationUtils.validatePort(vds.getSshPort())) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_PORT);
        } else if ((StringUtils.isBlank(vds.getSshUsername())) || (vds.getSshUsername().length() > BusinessEntitiesDefinitions.USER_LOGIN_NAME_SIZE)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_USERNAME);
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
                returnValue = failCanDoAction(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
            } else if (!getParameters().getAddPending() && (getParameters().getAuthMethod() == AuthenticationMethod.Password) && StringUtils.isEmpty(getParameters().getPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                returnValue = failCanDoAction(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!isPowerManagementLegal()) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (returnValue && isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            upServer = getClusterUtils().getUpServer(getVdsGroupId());
            if (upServer == null) {
                returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
            }
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    setVdsGroupId(getParameters().getVdsStaticData().getVdsGroupId());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateVdsGroup();
    if (returnValue) {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getName();
        String hostName = vds.getHostName();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
        } else if (getVdsDAO().getByName(vdsName) != null) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        } else if (getVdsDAO().getAllForHostname(hostName).size() != 0) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
        } else if (!ValidationUtils.validatePort(vds.getSshPort())) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_PORT);
        } else if ((StringUtils.isBlank(vds.getSshUsername())) || (vds.getSshUsername().length() > BusinessEntitiesDefinitions.USER_LOGIN_NAME_SIZE)) {
            returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_USERNAME);
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
                returnValue = failCanDoAction(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
            } else if (!getParameters().getAddPending() && (getParameters().getAuthMethod() == AuthenticationMethod.Password) && StringUtils.isEmpty(getParameters().getPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                returnValue = failCanDoAction(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!isPowerManagementLegal()) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (returnValue && isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            VDS upServer = getClusterUtils().getUpServer(getVdsGroupId());
            if (upServer == null) {
                returnValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean canConnect(VDS vds) {
    // execute the connectivity and id uniqueness validation for VDS type hosts
    if (vds.getVdsType() == VDSType.VDS && Config.<Boolean>GetValue(ConfigValues.InstallVds)) {
        EngineSSHClient sshclient = null;
        try {
            sshclient = getSSHClient();
            sshclient.connect();
            sshclient.authenticate();
            String hostUUID = getInstalledVdsIdIfExists(sshclient);
            if (hostUUID != null && getVdsDAO().getAllWithUniqueId(hostUUID).size() != 0) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_UUID_EXIST);
            }
            return isValidGlusterPeer(sshclient, vds.getVdsGroupId());
        } catch (AuthenticationException e) {
            log.errorFormat("Failed to authenticate session with host {0}", vds.getName(), e);
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (SecurityException e) {
            log.errorFormat("Failed to connect to host {0}, fingerprint: {1}", vds.getName(), vds.getSshKeyFingerprint(), e);
            addCanDoActionMessage(VdcBllMessages.VDS_SECURITY_CONNECTION_ERROR);
            addCanDoActionMessage(String.format("$ErrorMessage %1$s", e.getMessage()));
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (Exception e) {
            log.errorFormat("Failed to establish session with host {0}", vds.getName(), e);
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_CONNECT_TO_SERVER);
        } finally {
            if (sshclient != null) {
                sshclient.disconnect();
            }
        }
    }
    return true;
}
#method_after
protected boolean canConnect(VDS vds) {
    // execute the connectivity and id uniqueness validation for VDS type hosts
    if (!getParameters().getAddPending() && Config.<Boolean>GetValue(ConfigValues.InstallVds)) {
        try (final EngineSSHClient sshclient = getSSHClient()) {
            sshclient.connect();
            sshclient.authenticate();
            String hostUUID = getInstalledVdsIdIfExists(sshclient);
            if (hostUUID != null && getVdsDAO().getAllWithUniqueId(hostUUID).size() != 0) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_UUID_EXIST);
            }
            return isValidGlusterPeer(sshclient, vds.getVdsGroupId());
        } catch (AuthenticationException e) {
            log.errorFormat("Failed to authenticate session with host {0}", vds.getName(), e);
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (SecurityException e) {
            log.errorFormat("Failed to connect to host {0}, fingerprint: {1}", vds.getName(), vds.getSshKeyFingerprint(), e);
            addCanDoActionMessage(VdcBllMessages.VDS_SECURITY_CONNECTION_ERROR);
            addCanDoActionMessage(String.format("$ErrorMessage %1$s", e.getMessage()));
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (Exception e) {
            log.errorFormat("Failed to establish session with host {0}", vds.getName(), e);
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_CONNECT_TO_SERVER);
        }
    }
    return true;
}
#end_block

#method_before
private VDSGroup getVdsGroup() {
    VDSGroup vdsGroup = new VDSGroup();
    vdsGroup.setId(CLUSTER_ID);
    vdsGroup.setcompatibility_version(Version.v3_3);
    return vdsGroup;
}
#method_after
private VDSGroup getVdsGroup(Version ver) {
    VDSGroup vdsGroup = new VDSGroup();
    vdsGroup.setId(CLUSTER_ID);
    vdsGroup.setcompatibility_version(ver);
    return vdsGroup;
}
#end_block

#method_before
private void setupExpectedGlusterServersInfo() {
    expectedServers = new ArrayList<GlusterServerInfo>();
    GlusterServerInfo server = new GlusterServerInfo();
    server = new GlusterServerInfo();
    server.setUuid(server_id3);
    server.setHostnameOrIp(TEST_SERVER3);
    server.setStatus(PeerStatus.CONNECTED);
    expectedServers.add(server);
}
#method_after
private void setupExpectedGlusterServersInfo() {
    expectedServers = new ArrayList<GlusterServerInfo>();
    GlusterServerInfo server = new GlusterServerInfo();
    server.setUuid(server_id3);
    server.setHostnameOrIp(TEST_SERVER3);
    server.setStatus(PeerStatus.CONNECTED);
    expectedServers.add(server);
}
#end_block

#method_before
private void setupMock() throws Exception {
    vdsBrokerFrontend = mock(VDSBrokerFrontend.class);
    clusterUtils = mock(ClusterUtils.class);
    vdsDaoMock = mock(VdsDAO.class);
    vdsGroupDaoMock = mock(VdsGroupDAO.class);
    dbUtils = mock(GlusterDBUtils.class);
    doReturn(vdsBrokerFrontend).when(getQuery()).getResourceManager();
    doReturn(clusterUtils).when(getQuery()).getClusterUtils();
    doReturn(dbUtils).when(getQuery()).getDbUtils();
    doReturn(getVds(VDSStatus.Up)).when(clusterUtils).getUpServer(CLUSTER_ID);
    VDSReturnValue returnValue = getVDSReturnValue();
    when(vdsBrokerFrontend.RunVdsCommand(eq(VDSCommandType.GlusterServersList), any(VDSParametersBase.class))).thenReturn(returnValue);
    when(vdsGroupDaoMock.get(any(Guid.class))).thenReturn(getVdsGroup());
    doReturn(params.getClusterId()).when(getQueryParameters()).getClusterId();
    doReturn(true).when(getQueryParameters()).isServerKeyFingerprintRequired();
    doReturn(vdsDaoMock).when(clusterUtils).getVdsDao();
    doReturn(vdsGroupDaoMock).when(getQuery()).getVdsGroupDao();
    doReturn(serversList).when(vdsDaoMock).getAllForVdsGroup(CLUSTER_ID);
    doReturn(true).when(dbUtils).serverExists(any(Guid.class), eq(TEST_SERVER1));
    doReturn(false).when(dbUtils).serverExists(any(Guid.class), eq(TEST_SERVER3));
}
#method_after
private void setupMock() throws Exception {
    vdsBrokerFrontend = mock(VDSBrokerFrontend.class);
    clusterUtils = mock(ClusterUtils.class);
    vdsDaoMock = mock(VdsDAO.class);
    vdsGroupDaoMock = mock(VdsGroupDAO.class);
    dbUtils = mock(GlusterDBUtils.class);
    backendInternal = mock(BackendInternal.class);
    doReturn(vdsBrokerFrontend).when(getQuery()).getResourceManager();
    doReturn(clusterUtils).when(getQuery()).getClusterUtils();
    doReturn(dbUtils).when(getQuery()).getDbUtils();
    doReturn(getVds(VDSStatus.Up)).when(clusterUtils).getUpServer(CLUSTER_ID);
    doReturn(backendInternal).when(getQuery()).getBackendInstance();
    VDSReturnValue returnValue = getVDSReturnValue();
    when(vdsBrokerFrontend.RunVdsCommand(eq(VDSCommandType.GlusterServersList), any(VDSParametersBase.class))).thenReturn(returnValue);
    VdcQueryReturnValue vdcReturnValue = getVdcReturnValue();
    when(backendInternal.runInternalQuery(eq(VdcQueryType.GetServerSSHKeyFingerprint), any(VdcQueryParametersBase.class))).thenReturn(vdcReturnValue);
    doReturn(params.getClusterId()).when(getQueryParameters()).getClusterId();
    doReturn(true).when(getQueryParameters()).isServerKeyFingerprintRequired();
    doReturn(vdsDaoMock).when(clusterUtils).getVdsDao();
    doReturn(vdsGroupDaoMock).when(getQuery()).getVdsGroupDao();
    doReturn(serversList).when(vdsDaoMock).getAllForVdsGroup(CLUSTER_ID);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testExecuteQueryCommand() throws IOException {
    backendInternal = mock(BackendInternal.class);
    doReturn(backendInternal).when(getQuery()).getBackendInstance();
    getQuery().executeQueryCommand();
    Map<String, String> servers = (Map<String, String>) getQuery().getQueryReturnValue().getReturnValue();
    assertNotNull(servers);
    assertEquals(getAddedServers(), servers);
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testExecuteQueryCommand() throws IOException {
    when(vdsGroupDaoMock.get(any(Guid.class))).thenReturn(getVdsGroup(Version.v3_3));
    getQuery().executeQueryCommand();
    Map<String, String> servers = (Map<String, String>) getQuery().getQueryReturnValue().getReturnValue();
    assertNotNull(servers);
    assertEquals(getAddedServers(), servers);
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
protected void executeQueryCommand() {
    Map<String, String> glusterServers = new HashMap<String, String>();
    VDS upServer = getClusterUtils().getUpServer(getParameters().getClusterId());
    if (upServer != null) {
        VDSReturnValue returnValue = getResourceManager().RunVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServer.getId()));
        glusterServers = getAddedGlusterServers((List<GlusterServerInfo>) returnValue.getReturnValue());
    }
    // Keep server details in the map only for the servers which are reachable
    Iterator<Map.Entry<String, String>> iterator = glusterServers.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, String> entry = iterator.next();
        if (entry.getValue() == null) {
            iterator.remove();
        }
    }
    getQueryReturnValue().setReturnValue(glusterServers);
}
#method_after
@Override
@SuppressWarnings("unchecked")
protected void executeQueryCommand() {
    Map<String, String> glusterServers = new HashMap<String, String>();
    VDS upServer = getClusterUtils().getUpServer(getParameters().getClusterId());
    if (upServer != null) {
        VDSReturnValue returnValue = getResourceManager().RunVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServer.getId()));
        glusterServers = getAddedGlusterServers((List<GlusterServerInfo>) returnValue.getReturnValue());
    }
    getQueryReturnValue().setReturnValue(glusterServers);
}
#end_block

#method_before
private Map<String, String> getAddedGlusterServers(List<GlusterServerInfo> glusterServers) {
    Map<String, String> serversAndFingerprint = new HashMap<String, String>();
    for (GlusterServerInfo server : glusterServers) {
        if (server.getStatus() == PeerStatus.CONNECTED && (!serverExists(server))) {
            String fingerprint = null;
            VdcQueryReturnValue returnValue;
            if (getParameters().isServerKeyFingerprintRequired()) {
                returnValue = getBackendInstance().runInternalQuery(VdcQueryType.GetServerSSHKeyFingerprint, new ServerParameters(server.getHostnameOrIp()));
                if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                    fingerprint = returnValue.getReturnValue().toString();
                }
            }
            serversAndFingerprint.put(server.getHostnameOrIp(), fingerprint == null ? "" : fingerprint);
        }
    }
    return serversAndFingerprint;
}
#method_after
private Map<String, String> getAddedGlusterServers(List<GlusterServerInfo> glusterServers) {
    Map<String, String> serversAndFingerprint = new HashMap<String, String>();
    for (GlusterServerInfo server : glusterServers) {
        if (server.getStatus() == PeerStatus.CONNECTED && (!serverExists(server))) {
            String fingerprint = null;
            VdcQueryReturnValue returnValue;
            if (getParameters().isServerKeyFingerprintRequired()) {
                returnValue = getBackendInstance().runInternalQuery(VdcQueryType.GetServerSSHKeyFingerprint, new ServerParameters(server.getHostnameOrIp()));
                if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                    fingerprint = returnValue.getReturnValue().toString();
                }
            }
            // Keep server details in the map only for the servers which are reachable
            if (fingerprint != null && !(fingerprint.isEmpty())) {
                serversAndFingerprint.put(server.getHostnameOrIp(), fingerprint);
            }
        }
    }
    return serversAndFingerprint;
}
#end_block

#method_before
private boolean serverExists(GlusterServerInfo glusterServer) {
    VDSGroup vdsGroup = getVdsGroupDao().get(getParameters().getClusterId());
    if (vdsGroup.getcompatibility_version().compareTo(Version.v3_3) >= 0) {
        return getDbUtils().serverExists(glusterServer.getUuid());
    } else {
        return getDbUtils().serverExists(getParameters().getClusterId(), glusterServer.getHostnameOrIp());
    }
}
#method_after
public boolean serverExists(GlusterServerInfo glusterServer) {
    VDSGroup cluster = getVdsGroupDao().get(getParameters().getClusterId());
    if (GlusterFeatureSupported.glusterHostUuidSupported(cluster.getcompatibility_version())) {
        return getDbUtils().serverExists(glusterServer.getUuid());
    } else {
        return getDbUtils().serverExists(getParameters().getClusterId(), glusterServer.getHostnameOrIp());
    }
}
#end_block

#method_before
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case GlusterHostRemoveFailedException:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeRemoveBricksStartFailed:
        case GlusterVolumeRemoveBricksStopFailed:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#method_after
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = getReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case GlusterHostRemoveFailedException:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeRemoveBricksStartFailed:
        case GlusterVolumeRemoveBricksStopFailed:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#end_block

#method_before
private void edit(ListModel model, final boolean topTableIsEdited) {
    EntityModelCellTable<ListModel> table = getTable(topTableIsEdited);
    IEventListener listener = topTableIsEdited ? topItemsChangedListener : bottomItemsChangedListener;
    if (listener != null) {
        table.asEditor().flush().getItemsChangedEvent().removeListener(listener);
    }
    listener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            getSelectionModel(topTableIsEdited).clear();
        }
    };
    if (topTableIsEdited) {
        topItemsChangedListener = listener;
    } else {
        bottomItemsChangedListener = listener;
    }
    model.getItemsChangedEvent().addListener(listener);
    table.asEditor().edit(model);
}
#method_after
private void edit(ListModel model, final boolean topTableIsEdited) {
    EntityModelCellTable<ListModel> table = getTable(topTableIsEdited);
    ListModel oldModel = table.asEditor().flush();
    IEventListener listener = topTableIsEdited ? topItemsChangedListener : bottomItemsChangedListener;
    if (oldModel != null) {
        oldModel.getItemsChangedEvent().removeListener(listener);
    }
    model.getItemsChangedEvent().addListener(listener);
    table.asEditor().edit(model);
}
#end_block

#method_before
private void stopRebalance() {
    if (getSelectedItem() == null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getMessages().confirmStopVolumeRebalance(volumeEntity.getName()));
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("onStopRebalance", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void stopRebalance() {
    if (getSelectedItem() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getMessages().confirmStopVolumeRebalance(volumeEntity.getName()));
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("onStopRebalance", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void updateActionAvailability() {
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    boolean allowRemove = true;
    boolean allowStopRemove = true;
    boolean allowCommitRemove = true;
    boolean allowStatusRemove = true;
    boolean allowRetain = true;
    boolean allowReplace = true;
    boolean allowAdvanced = true;
    if (volumeEntity == null || getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowRemove = false;
        allowReplace = false;
        allowAdvanced = false;
    } else {
        GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
        if (volumeTask != null && (volumeTask.getStatus() == JobExecutionStatus.STARTED || volumeTask.getType() == GlusterTaskType.REMOVE_BRICK && volumeTask.getStatus() == JobExecutionStatus.FINISHED)) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.STRIPE || getSelectedItems().size() == volumeEntity.getBricks().size()) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && (volumeEntity.getBricks().size() == VolumeListModel.REPLICATE_COUNT_DEFAULT || getSelectedItems().size() > 1)) {
            allowRemove = false;
        }
        if (getSelectedItems().size() == 1) {
            allowReplace = true;
            allowAdvanced = volumeEntity.isOnline() && ((GlusterBrickEntity) getSelectedItems().get(0)).isOnline();
        } else {
            allowReplace = false;
            allowAdvanced = false;
        }
    }
    // Stop/Commit brick removal can be invoked from the Volume(tab) Activities menu as well
    // So no need to check if there are any bricks selected or not, command availability
    // will be decided based on the task on the volume
    allowStopRemove = volumeEntity != null && volumeEntity.getAsyncTask() != null && volumeEntity.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK && volumeEntity.getAsyncTask().getStatus() == JobExecutionStatus.STARTED;
    allowCommitRemove = volumeEntity != null && volumeEntity.getAsyncTask() != null && volumeEntity.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK && volumeEntity.getAsyncTask().getStatus() == JobExecutionStatus.FINISHED;
    allowRetain = volumeEntity != null && volumeEntity.getAsyncTask() != null && volumeEntity.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK && volumeEntity.getAsyncTask().getStatus() == JobExecutionStatus.FINISHED;
    allowStatusRemove = volumeEntity != null && volumeEntity.getAsyncTask() != null && volumeEntity.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK;
    getRemoveBricksCommand().setIsExecutionAllowed(allowRemove);
    getStopRemoveBricksCommand().setIsExecutionAllowed(allowStopRemove);
    getCommitRemoveBricksCommand().setIsExecutionAllowed(allowCommitRemove);
    getStatusRemoveBricksCommand().setIsExecutionAllowed(allowStatusRemove);
    getRetainBricksCommand().setIsExecutionAllowed(allowRetain);
    getReplaceBrickCommand().setIsExecutionAllowed(allowReplace);
    getBrickAdvancedDetailsCommand().setIsExecutionAllowed(allowAdvanced);
}
#method_after
private void updateActionAvailability() {
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    boolean allowRemove = true;
    boolean allowReplace = true;
    boolean allowAdvanced = true;
    if (volumeEntity == null || getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowRemove = false;
        allowReplace = false;
        allowAdvanced = false;
    } else {
        GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
        if (volumeTask != null && (volumeTask.getStatus() == JobExecutionStatus.STARTED || volumeTask.getType() == GlusterTaskType.REMOVE_BRICK && volumeTask.getStatus() == JobExecutionStatus.FINISHED)) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.STRIPE || getSelectedItems().size() == volumeEntity.getBricks().size()) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && (volumeEntity.getBricks().size() == VolumeListModel.REPLICATE_COUNT_DEFAULT || getSelectedItems().size() > 1)) {
            allowRemove = false;
        }
        if (getSelectedItems().size() == 1) {
            allowReplace = true;
            allowAdvanced = volumeEntity.isOnline() && ((GlusterBrickEntity) getSelectedItems().get(0)).isOnline();
        } else {
            allowReplace = false;
            allowAdvanced = false;
        }
    }
    getRemoveBricksCommand().setIsExecutionAllowed(allowRemove);
    getReplaceBrickCommand().setIsExecutionAllowed(allowReplace);
    getBrickAdvancedDetailsCommand().setIsExecutionAllowed(allowAdvanced);
}
#end_block

#method_before
@Override
protected void onEntityChanged() {
    super.onEntityChanged();
    getSearchCommand().execute();
}
#method_after
@Override
protected void onEntityChanged() {
    super.onEntityChanged();
    if (getEntity() != null) {
        GlusterVolumeEntity glusterVolumeEntity = (GlusterVolumeEntity) getEntity();
        setItems(glusterVolumeEntity.getBricks());
    } else {
        setItems(null);
    }
}
#end_block

#method_before
private void stopRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().stopRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_stop");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.STARTED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnStopRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void stopRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().stopRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_stop");
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.STARTED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnStopRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onStopRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRemoveBricksStatus();
            }
        }
    }, model);
}
#method_after
private void onStopRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRemoveBricksStatus();
            }
        }
    }, model);
}
#end_block

#method_before
private void commitRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().commitRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_commit");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnCommitRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void commitRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().commitRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_commit");
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnCommitRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onCommitRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.CommitRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
        }
    }, model);
}
#method_after
private void onCommitRemoveBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.CommitRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
        }
    }, model);
}
#end_block

#method_before
private void showRemoveBricksStatus() {
    if (getWindow() != null) {
        return;
    }
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    final ArrayList<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null) {
            bricks.add(brick);
        }
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    // $NON-NLS-1$
    UICommand removeBrickStatusOk = new UICommand("removeBrickNotAvailable", VolumeBrickListModel.this);
    removeBrickStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    removeBrickStatusOk.setIsCancel(true);
    cModel.startProgress(ConstantsManager.getInstance().getConstants().rebalanceStatusFetchMessage());
    cModel.getCommands().add(removeBrickStatusOk);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksStatusTitle());
    setConfirmWindow(cModel);
    AsyncDataProvider.getGlusterRemoveBricksStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            cModel.stopProgress();
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            if (vdcValue.getSucceeded() || vdcValue.getReturnValue() != null) {
                cancelConfirmation();
                RemoveBrickStatusModel removeBrickStatusModel = new RemoveBrickStatusModel(volumeEntity, bricks);
                removeBrickStatusModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksStatusTitle());
                setWindow(removeBrickStatusModel);
                removeBrickStatusModel.getVolume().setEntity(volumeEntity.getName());
                removeBrickStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
                GlusterVolumeTaskStatusEntity removeBrickStatusEntity = vdcValue.getReturnValue();
                // $NON-NLS-1$
                UICommand stopRemoveBrickFromStatus = new UICommand("StopRemoveBricksOnStatus", VolumeBrickListModel.this);
                stopRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksButton());
                stopRemoveBrickFromStatus.setIsExecutionAllowed(false);
                removeBrickStatusModel.addStopRemoveBricksCommand(stopRemoveBrickFromStatus);
                // $NON-NLS-1$
                UICommand commitRemoveBrickFromStatus = new UICommand("CommitRemoveBricksOnStatus", VolumeBrickListModel.this);
                commitRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksButton());
                commitRemoveBrickFromStatus.setIsExecutionAllowed(false);
                removeBrickStatusModel.addCommitRemoveBricksCommand(commitRemoveBrickFromStatus);
                // $NON-NLS-1$
                UICommand retainBricksFromStatus = new UICommand("RetainBricksOnStatus", VolumeBrickListModel.this);
                retainBricksFromStatus.setTitle(ConstantsManager.getInstance().getConstants().retainBricksButton());
                retainBricksFromStatus.setIsExecutionAllowed(false);
                removeBrickStatusModel.addRetainBricksCommand(retainBricksFromStatus);
                // $NON-NLS-1$
                UICommand cancelCommand = new UICommand("CancelRemoveBricksStatus", VolumeBrickListModel.this);
                cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
                cancelCommand.setIsCancel(true);
                removeBrickStatusModel.getCommands().add(cancelCommand);
                removeBrickStatusModel.showStatus(removeBrickStatusEntity);
            } else {
                cModel.setMessage(ConstantsManager.getInstance().getMessages().removeBrickStatusFailed(bricks.toString()));
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId(), bricks);
}
#method_after
private void showRemoveBricksStatus() {
    if (getWindow() != null) {
        return;
    }
    final GlusterVolumeEntity volumeEntity = getVolumeEntity();
    final ArrayList<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null) {
            bricks.add(brick);
        }
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    // $NON-NLS-1$
    UICommand removeBrickStatusOk = new UICommand("CancelConfirmation", VolumeBrickListModel.this);
    removeBrickStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    removeBrickStatusOk.setIsCancel(true);
    cModel.startProgress(ConstantsManager.getInstance().getConstants().rebalanceStatusFetchMessage());
    cModel.getCommands().add(removeBrickStatusOk);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksStatusTitle());
    setConfirmWindow(cModel);
    // $NON-NLS-1$
    final UICommand stopRemoveBrickFromStatus = new UICommand("StopRemoveBricksOnStatus", this);
    stopRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRemoveBricksButton());
    stopRemoveBrickFromStatus.setIsExecutionAllowed(false);
    // $NON-NLS-1$
    final UICommand commitRemoveBrickFromStatus = new UICommand("CommitRemoveBricksOnStatus", this);
    commitRemoveBrickFromStatus.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksButton());
    commitRemoveBrickFromStatus.setIsExecutionAllowed(false);
    // $NON-NLS-1$
    final UICommand retainBricksFromStatus = new UICommand("RetainBricksOnStatus", this);
    retainBricksFromStatus.setTitle(ConstantsManager.getInstance().getConstants().retainBricksButton());
    retainBricksFromStatus.setIsExecutionAllowed(false);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("CancelRemoveBricksStatus", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    AsyncDataProvider.getGlusterRemoveBricksStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            cModel.stopProgress();
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            if (vdcValue.getSucceeded() && vdcValue.getReturnValue() != null) {
                cancelConfirmation();
                RemoveBrickStatusModel removeBrickStatusModel;
                GlusterVolumeTaskStatusEntity removeBrickStatusEntity = vdcValue.getReturnValue();
                if (getWindow() == null) {
                    removeBrickStatusModel = new RemoveBrickStatusModel(volumeEntity, bricks);
                    removeBrickStatusModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksStatusTitle());
                    // //$NON-NLS-1$
                    removeBrickStatusModel.setHashName("remove_bricks_status");
                    setWindow(removeBrickStatusModel);
                    removeBrickStatusModel.getVolume().setEntity(volumeEntity.getName());
                    removeBrickStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
                    removeBrickStatusModel.addStopRemoveBricksCommand(stopRemoveBrickFromStatus);
                    removeBrickStatusModel.addCommitRemoveBricksCommand(commitRemoveBrickFromStatus);
                    removeBrickStatusModel.addRetainBricksCommand(retainBricksFromStatus);
                    removeBrickStatusModel.getCommands().add(cancelCommand);
                } else {
                    removeBrickStatusModel = (RemoveBrickStatusModel) getWindow();
                }
                removeBrickStatusModel.showStatus(removeBrickStatusEntity);
            } else {
                cModel.setMessage(ConstantsManager.getInstance().getMessages().removeBrickStatusFailed(bricks.toString()));
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId(), bricks);
}
#end_block

#method_before
private void retainBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().retainBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().retainBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_retain_brick");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnRetainBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void retainBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().retainBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().retainBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_retain_brick");
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnRetainBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onRetainBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
        }
    }, model);
}
#method_after
private void onRetainBricks() {
    if (getConfirmWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    GlusterVolumeEntity volumeEntity = getVolumeEntity();
    ArrayList<GlusterBrickEntity> list = new ArrayList<GlusterBrickEntity>();
    for (Object brickName : model.getItems()) {
        GlusterBrickEntity brick = volumeEntity.getBrickWithQualifiedName((String) brickName);
        if (brick != null) {
            list.add(brick);
        }
    }
    GlusterVolumeRemoveBricksParameters parameter = new GlusterVolumeRemoveBricksParameters(volumeEntity.getId(), list);
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.StopRemoveGlusterVolumeBricks, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            setConfirmWindow(null);
        }
    }, model);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getAddBricksCommand())) {
        checkUpServerAndAddBricks();
    } else if (command.getName().equals("OnAddBricks")) {
        // $NON-NLS-1$
        onAddBricks();
    } else if (command.getName().equals("OnAddBricksInternal")) {
        // $NON-NLS-1$
        onAddBricksInternal();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if (command.getName().equals("removeBrickNotAvailable")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.equals(getRemoveBricksCommand())) {
        removeBricks();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveBricks();
    } else if (command.equals(getStopRemoveBricksCommand())) {
        stopRemoveBricks();
    } else if (command.getName().equals("OnStopRemoveBricks")) {
        // $NON-NLS-1$
        onStopRemoveBricks();
    } else if (command.equals(getCommitRemoveBricksCommand())) {
        commitRemoveBricks();
    } else if (command.getName().equals("OnCommitRemoveBricks")) {
        // $NON-NLS-1$
        onCommitRemoveBricks();
    } else if (command.equals(getStatusRemoveBricksCommand())) {
        showRemoveBricksStatus();
    } else if (command.getName().equals("StopRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getStopRemoveBricksCommand().execute();
    } else if (command.getName().equals("CommitRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getCommitRemoveBricksCommand().execute();
    } else if (command.getName().equals("CancelRemoveBricksStatus")) {
        // $NON-NLS-1$
        cancelRemoveBrickStatus();
    } else if (command.equals(getRetainBricksCommand())) {
        retainBricks();
    } else if (command.getName().equals("OnRetainBricks")) {
        // $NON-NLS-1$
        onRetainBricks();
    } else if (command.getName().equals("RetainBricksOnStatus")) {
        // $NON-NLS-1$
        getRetainBricksCommand().execute();
    } else if (command.equals(getReplaceBrickCommand())) {
        replaceBrick();
    } else if (command.getName().equals("OnReplace")) {
        // $NON-NLS-1$
        onReplaceBrick();
    } else if (command.equals(getBrickAdvancedDetailsCommand())) {
        showBrickAdvancedDetails();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getAddBricksCommand())) {
        checkUpServerAndAddBricks();
    } else if (command.getName().equals("OnAddBricks")) {
        // $NON-NLS-1$
        onAddBricks();
    } else if (command.getName().equals("OnAddBricksInternal")) {
        // $NON-NLS-1$
        onAddBricksInternal();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if (command.equals(getRemoveBricksCommand())) {
        removeBricks();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveBricks();
    } else if (command.equals(getStopRemoveBricksCommand())) {
        stopRemoveBricks();
    } else if (command.getName().equals("OnStopRemoveBricks")) {
        // $NON-NLS-1$
        onStopRemoveBricks();
    } else if (command.equals(getCommitRemoveBricksCommand())) {
        commitRemoveBricks();
    } else if (command.getName().equals("OnCommitRemoveBricks")) {
        // $NON-NLS-1$
        onCommitRemoveBricks();
    } else if (command.equals(getStatusRemoveBricksCommand())) {
        showRemoveBricksStatus();
    } else if (command.getName().equals("StopRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getStopRemoveBricksCommand().execute();
    } else if (command.getName().equals("CommitRemoveBricksOnStatus")) {
        // $NON-NLS-1$
        getCommitRemoveBricksCommand().execute();
    } else if (command.getName().equals("CancelRemoveBricksStatus")) {
        // $NON-NLS-1$
        cancelRemoveBrickStatus();
    } else if (command.equals(getRetainBricksCommand())) {
        retainBricks();
    } else if (command.getName().equals("OnRetainBricks")) {
        // $NON-NLS-1$
        onRetainBricks();
    } else if (command.getName().equals("RetainBricksOnStatus")) {
        // $NON-NLS-1$
        getRetainBricksCommand().execute();
    } else if (command.equals(getReplaceBrickCommand())) {
        replaceBrick();
    } else if (command.getName().equals("OnReplace")) {
        // $NON-NLS-1$
        onReplaceBrick();
    } else if (command.equals(getBrickAdvancedDetailsCommand())) {
        showBrickAdvancedDetails();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
@Override
public void refreshDetails(GlusterVolumeEntity volumeEntity) {
    AsyncDataProvider.getGlusterRemoveBricksStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeTaskStatusEntity statusEntity = vdcValue.getReturnValue();
            if (statusEntity != null) {
                showStatus(statusEntity);
            } else {
                cancelRefresh();
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId(), getBricks());
}
#method_after
@Override
public void refreshDetails(GlusterVolumeEntity volumeEntity) {
    AsyncDataProvider.getGlusterRemoveBricksStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeTaskStatusEntity statusEntity = vdcValue.getReturnValue();
            if (statusEntity != null) {
                showStatus(statusEntity);
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId(), getBricks());
}
#end_block

#method_before
public void onBrowserEvent(Context context, Element parent, T value, NativeEvent event, ValueUpdater<T> valueUpdater) {
    super.onBrowserEvent(context, parent, value, event, valueUpdater);
    int eventX = event.getClientX();
    int eventY = event.getClientY();
    // Handle the click event.
    if ("click".equals(event.getType())) {
        // $NON-NLS-1$
        // Ignore clicks that occur outside of the outermost element.
        EventTarget eventTarget = event.getEventTarget();
        if (parent.getFirstChildElement().isOrHasChild(Element.as(eventTarget))) {
            menuPanelPopup.asPopupPanel().showAndFitToScreen(eventX, eventY);
        }
    }
    if ("mouseover".equals(event.getType())) {
        // $NON-NLS-1$
        if (isVisible(value)) {
            // $NON-NLS-1$
            parent.getStyle().setBorderColor("#96B7D6");
        }
    } else {
        // $NON-NLS-1$
        // $NON-NLS-1$
        parent.getStyle().setBorderColor("transparent");
    }
}
#method_after
public void onBrowserEvent(Context context, Element parent, T value, NativeEvent event, ValueUpdater<T> valueUpdater) {
    super.onBrowserEvent(context, parent, value, event, valueUpdater);
    int eventX = event.getClientX();
    int eventY = event.getClientY();
    // Handle the click event.
    if ("click".equals(event.getType())) {
        // $NON-NLS-1$
        // Ignore clicks that occur outside of the outermost element.
        EventTarget eventTarget = event.getEventTarget();
        if (parent.getFirstChildElement().isOrHasChild(Element.as(eventTarget))) {
            menuPanelPopup.asPopupPanel().showAndFitToScreen(eventX, eventY);
        }
    } else if ("mouseover".equals(event.getType())) {
        // $NON-NLS-1$
        if (isVisible(value)) {
            // $NON-NLS-1$
            parent.getFirstChildElement().getStyle().setBorderColor("#96B7D6");
        }
    } else {
        // $NON-NLS-1$
        parent.getFirstChildElement().getStyle().setBorderColor("transparent");
    }
}
#end_block

#method_before
public void addMenuItem(String title, final UICommand command) {
    final MenuItem menuItem = new MenuItem(title, new Command() {

        @Override
        public void execute() {
            menuPanelPopup.asPopupPanel().hide();
            command.execute();
        }
    });
    menuItem.setEnabled(command.getIsExecutionAllowed());
    command.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName.equals("IsExecutionAllowed")) {
                // $NON-NLS-1$
                menuItem.setEnabled(command.getIsExecutionAllowed());
            }
        }
    });
    menuPanelPopup.getMenuBar().addItem(menuItem);
}
#method_after
public void addMenuItem(final ActionButtonDefinition<T> buttonDef) {
    final MenuItem menuItem = new MenuItem(buttonDef.getTitle(), new Command() {

        @Override
        public void execute() {
            menuPanelPopup.asPopupPanel().hide();
            buttonDef.onClick(null);
        }
    });
    menuItem.setEnabled(buttonDef.isEnabled(null));
    // Update button whenever its definition gets re-initialized
    buttonDef.addInitializeHandler(new InitializeHandler() {

        @Override
        public void onInitialize(InitializeEvent event) {
            menuItem.setEnabled(buttonDef.isEnabled(null));
        }
    });
    menuPanelPopup.getMenuBar().addItem(menuItem);
}
#end_block

#method_before
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = getReturnValueFromStatus(getReturnStatus());
    VDSExceptionBase outEx;
    switch(returnStatus) {
        case Done:
            return;
        case recovery:
            outEx = new VDSRecoveringException(returnStatus, getReturnStatus().mMessage);
            break;
        case SpmStatusError:
            outEx = new IRSNonOperationalException(getReturnStatus().mMessage);
            break;
        case StoragePoolMasterNotFound:
        case StoragePoolTooManyMasters:
        case StoragePoolWrongMaster:
        case StoragePoolHasPotentialMaster:
        case StorageDomainMasterError:
            outEx = new IRSNoMasterDomainException(getReturnStatus().mMessage);
            break;
        case UnicodeArgumentException:
            outEx = new IRSUnicodeArgumentException(getReturnStatus().mMessage);
            break;
        case TooManyDomainsInStoragePoolError:
        case StorageDomainAlreadyAttached:
        case StorageDomainDescriptionTooLongError:
        case TooManyPVsInVG:
        case createIllegalVolumeSnapshotError:
        case prepareIllegalVolumeError:
        case createVolumeRollbackError:
        case InvalidParameterException:
        case InvalidDefaultExceptionException:
        case NotImplementedException:
        case OperationInProgress:
        case MiscDirCleanupFailure:
        case createVolumeSizeError:
        case IncorrectFormat:
        case VolumeIsBusy:
        case VolumeImageHasChildren:
        case VolumeUnlinkError:
        case OrphanVolumeError:
        case VolumeAlreadyExists:
        case VolumeNonWritable:
        case VolumeNonShareable:
        case VolumeCannotGetParent:
        case SharedVolumeNonWritable:
        case InternalVolumeNonWritable:
        case CannotDeleteSharedVolume:
        case NonLeafVolumeNotWritable:
        case ImagesActionError:
        case ImageValidationError:
        case ImageDeleteError:
        case ImageIsNotEmpty:
        case ImageIsNotLegalChain:
        case OverwriteImageError:
        case MoveTemplateImageError:
        case StoragePoolDisconnectionError:
        case StoragePoolAlreadyExists:
        case IsoCannotBeMasterDomain:
        case CannotConnectMultiplePools:
        case BackupCannotBeMasterDomain:
        case StoragePoolConnected:
        case StoragePoolDescriptionTooLongError:
        case StorageDomainNotInPool:
        case StorageDomainNotEmpty:
        case StorageDomainMetadataCreationError:
        case StorageDomainMetadataFileMissing:
        case StorageDomainMetadataNotFound:
        case StorageDomainAlreadyExists:
        case StorageDomainMasterUnmountError:
        case BlockStorageDomainMasterFSCKError:
        case StorageDomainLayoutError:
        case StorageDomainTypeError:
        case StorageDomainNotMemberOfPool:
        case StorageDomainStatusError:
        case StorageDomainCheckError:
        case StorageDomainTypeNotBackup:
        case StorageDomainStateTransitionIllegal:
        case StorageDomainActive:
        case CannotDetachMasterStorageDomain:
        case StorageDomainInsufficientPermissions:
        case StorageDomainClassError:
        case StorageDomainIsMadeFromTooManyPVs:
        case InvalidTask:
        case UnknownTask:
        case TaskClearError:
        case TaskNotFinished:
        case InvalidTaskType:
        case AddTaskError:
        case TaskInProgress:
        case TaskStateError:
        case TaskAborted:
        case TaskPersistError:
        case InvalidJob:
        case InvalidRecovery:
        case InvalidTaskMng:
        case TaskStateTransitionError:
        case TaskHasRefs:
        case VolumeGroupSizeError:
        case VolumeGroupAlreadyExistsError:
        case VolumeGroupUninitialized:
        case VolumeGroupHasDomainTag:
        case CannotRemoveLogicalVolume:
        case CannotDeactivateLogicalVolume:
        case CannotActivateLogicalVolume:
        case LogicalVolumePermissionsError:
        case LogicalVolumeAlreadyExists:
        case PartitionedPhysDev:
        case DomainAlreadyLocked:
        case DomainLockDoesNotExist:
        case MetaDataKeyError:
        case MetaDataSealIsBroken:
        case MetaDataValidationError:
        case MetaDataMappingError:
        case MetaDataParamError:
        case MetadataOverflowError:
        case ImportUnknownType:
        case ExportError:
        case MergeVolumeRollbackError:
        case ActionStopped:
        case FAILED_CHANGE_CD_IS_MOUNTED:
        case UnsupportedDomainVersion:
        case CurrentVersionTooAdvancedError:
        case iSCSILogoutError:
        case iSCSIDiscoveryError:
        case ISCSI_LOGIN_AUTH_ERROR:
        case PoolUpgradeInProgress:
        case MixedSDVersionError:
        case NoSpaceLeftOnDomain:
        case ImageDoesNotExistInDomainError:
        case NO_IMPLEMENTATION:
        case VOLUME_WAS_NOT_PREPARED_BEFORE_TEARDOWN:
        case IMAGES_NOT_SUPPORTED_ERROR:
        case GET_FILE_LIST_ERROR:
        case STORAGE_DOMAIN_REFRESH_ERROR:
        case VOLUME_GROUP_BLOCK_SIZE_ERROR:
        case MIGRATION_DEST_INVALID_HOSTNAME:
        case ResourceTimeout:
        case DEVICE_BLOCK_SIZE_NOT_SUPPORTED:
            if (this instanceof IrsBrokerCommand) {
                outEx = new IrsOperationFailedNoFailoverException(getReturnStatus().mMessage);
            } else {
                outEx = new VDSErrorException(String.format("Failed in vdscommand to %1$s, error = %2$s", getCommandName(), getReturnStatus().mMessage));
            }
            break;
        case ERR_BAD_ADDR:
            outEx = new VDSNetworkException(getReturnStatus().mMessage);
            break;
        default:
            log.errorFormat("Failed in {0} method", getCommandName());
            outEx = createException();
            log.errorFormat("Error code {0} and error message {1}", returnStatus, outEx.getMessage());
            break;
    }
    VDSError tempVar = new VDSError();
    tempVar.setCode(returnStatus);
    tempVar.setMessage(getReturnStatus().mMessage);
    outEx.setVdsError(tempVar);
    throw new ProxyReturnValueException(outEx);
}
#method_after
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = getReturnValueFromStatus(getReturnStatus());
    VDSExceptionBase outEx;
    switch(returnStatus) {
        case Done:
            return;
        case recovery:
            outEx = new VDSRecoveringException(returnStatus, getReturnStatus().mMessage);
            break;
        case SpmStatusError:
            outEx = new IRSNonOperationalException(getReturnStatus().mMessage);
            break;
        case StoragePoolMasterNotFound:
        case StoragePoolTooManyMasters:
        case StoragePoolWrongMaster:
        case StoragePoolHasPotentialMaster:
        case StorageDomainMasterError:
            outEx = new IRSNoMasterDomainException(getReturnStatus().mMessage);
            break;
        case UnicodeArgumentException:
            outEx = new IRSUnicodeArgumentException(getReturnStatus().mMessage);
            break;
        case TooManyDomainsInStoragePoolError:
        case StorageDomainAlreadyAttached:
        case StorageDomainDescriptionTooLongError:
        case TooManyPVsInVG:
        case createIllegalVolumeSnapshotError:
        case prepareIllegalVolumeError:
        case createVolumeRollbackError:
        case InvalidParameterException:
        case InvalidDefaultExceptionException:
        case NotImplementedException:
        case OperationInProgress:
        case MiscDirCleanupFailure:
        case createVolumeSizeError:
        case IncorrectFormat:
        case VolumeIsBusy:
        case VolumeImageHasChildren:
        case VolumeUnlinkError:
        case OrphanVolumeError:
        case VolumeAlreadyExists:
        case VolumeNonWritable:
        case VolumeNonShareable:
        case VolumeCannotGetParent:
        case SharedVolumeNonWritable:
        case InternalVolumeNonWritable:
        case CannotDeleteSharedVolume:
        case NonLeafVolumeNotWritable:
        case ImagesActionError:
        case ImageValidationError:
        case ImageDeleteError:
        case ImageIsNotEmpty:
        case ImageIsNotLegalChain:
        case OverwriteImageError:
        case MoveTemplateImageError:
        case StoragePoolDisconnectionError:
        case StoragePoolAlreadyExists:
        case IsoCannotBeMasterDomain:
        case CannotConnectMultiplePools:
        case BackupCannotBeMasterDomain:
        case StoragePoolConnected:
        case StoragePoolDescriptionTooLongError:
        case StorageDomainNotInPool:
        case StorageDomainNotEmpty:
        case StorageDomainMetadataCreationError:
        case StorageDomainMetadataFileMissing:
        case StorageDomainMetadataNotFound:
        case StorageDomainAlreadyExists:
        case StorageDomainMasterUnmountError:
        case BlockStorageDomainMasterFSCKError:
        case StorageDomainLayoutError:
        case StorageDomainTypeError:
        case StorageDomainNotMemberOfPool:
        case StorageDomainStatusError:
        case StorageDomainCheckError:
        case StorageDomainTypeNotBackup:
        case StorageDomainStateTransitionIllegal:
        case StorageDomainActive:
        case CannotDetachMasterStorageDomain:
        case StorageDomainInsufficientPermissions:
        case StorageDomainClassError:
        case StorageDomainIsMadeFromTooManyPVs:
        case InvalidTask:
        case UnknownTask:
        case TaskClearError:
        case TaskNotFinished:
        case InvalidTaskType:
        case AddTaskError:
        case TaskInProgress:
        case TaskStateError:
        case TaskAborted:
        case TaskPersistError:
        case InvalidJob:
        case InvalidRecovery:
        case InvalidTaskMng:
        case TaskStateTransitionError:
        case TaskHasRefs:
        case VolumeGroupSizeError:
        case VolumeGroupAlreadyExistsError:
        case VolumeGroupUninitialized:
        case VolumeGroupHasDomainTag:
        case CannotRemoveLogicalVolume:
        case CannotDeactivateLogicalVolume:
        case CannotActivateLogicalVolume:
        case LogicalVolumePermissionsError:
        case LogicalVolumeAlreadyExists:
        case PartitionedPhysDev:
        case DomainAlreadyLocked:
        case DomainLockDoesNotExist:
        case MetaDataKeyError:
        case MetaDataSealIsBroken:
        case MetaDataValidationError:
        case MetaDataMappingError:
        case MetaDataParamError:
        case MetadataOverflowError:
        case ImportUnknownType:
        case ExportError:
        case MergeVolumeRollbackError:
        case ActionStopped:
        case FAILED_CHANGE_CD_IS_MOUNTED:
        case UnsupportedDomainVersion:
        case CurrentVersionTooAdvancedError:
        case iSCSILogoutError:
        case iSCSIDiscoveryError:
        case ISCSI_LOGIN_AUTH_ERROR:
        case PoolUpgradeInProgress:
        case MixedSDVersionError:
        case NoSpaceLeftOnDomain:
        case ImageDoesNotExistInDomainError:
        case NO_IMPLEMENTATION:
        case VOLUME_WAS_NOT_PREPARED_BEFORE_TEARDOWN:
        case IMAGES_NOT_SUPPORTED_ERROR:
        case GET_FILE_LIST_ERROR:
        case STORAGE_DOMAIN_REFRESH_ERROR:
        case VOLUME_GROUP_BLOCK_SIZE_ERROR:
        case MIGRATION_DEST_INVALID_HOSTNAME:
        case ResourceTimeout:
        case DEVICE_BLOCK_SIZE_NOT_SUPPORTED:
            if (this instanceof IrsBrokerCommand) {
                outEx = new IrsOperationFailedNoFailoverException(getReturnStatus().mMessage);
            } else {
                outEx = new VDSErrorException(String.format("Failed in vdscommand to %1$s, error = %2$s", getCommandName(), getReturnStatus().mMessage));
            }
            break;
        case ERR_BAD_ADDR:
            outEx = new VDSNetworkException(getReturnStatus().mMessage);
            break;
        default:
            log.errorFormat("Failed in {0} method", getCommandName());
            outEx = createException();
            break;
    }
    VDSError tempVar = new VDSError();
    tempVar.setCode(returnStatus);
    tempVar.setMessage(getReturnStatus().mMessage);
    outEx.setVdsError(tempVar);
    throw outEx;
}
#end_block

#method_before
private VDSExceptionBase createException() {
    final String errorMessage = String.format("Failed to %1$s, error = %2$s", getCommandName(), getReturnStatus().mMessage);
    return createDefaultConcreteException(errorMessage);
}
#method_after
private VDSExceptionBase createException() {
    final String errorMessage = String.format("Failed to %1$s, error = %2$s, code = %3$s", getCommandName(), getReturnStatus().mMessage, getReturnStatus().mCode);
    return createDefaultConcreteException(errorMessage);
}
#end_block

#method_before
@Override
protected void executeIrsBrokerCommand() {
    setReturnValue(Guid.Empty);
    log.info("-- executeIrsBrokerCommand: calling 'createVolume' with two new parameters: description and UUID");
    log.infoFormat("-- createVolume parameters: sdUUID={0} spUUID={1} imgGUID={2} size={3} bytes olFormat={4} volType={5} volUUID={6} descr={7} srcImgGUID={8} srcVolUUID={9}", getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString(), getParameters().getImageGroupId().toString(), getParameters().getImageSizeInBytes(), getParameters().getVolumeFormat().name(), getParameters().getImageType().name(), getParameters().getNewImageID().toString(), getParameters().getNewImageDescription(), Guid.Empty.toString(), Guid.Empty.toString());
    // NOTE: The 'uuidReturn' variable will contain the taskID and not the
    // created image id!
    uuidReturn = getIrsProxy().createVolume(getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString(), getParameters().getImageGroupId().toString(), (Long.valueOf(getParameters().getImageSizeInBytes())).toString(), getParameters().getVolumeFormat().getValue(), getParameters().getImageType().getValue(), 2, getParameters().getNewImageID().toString(), getParameters().getNewImageDescription(), Guid.Empty.toString(), Guid.Empty.toString());
    proceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.mUuid);
    mCreatedImageId = getParameters().getNewImageID().toString();
    setReturnValue(new Guid(mCreatedImageId));
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.createVolume, getParameters().getStoragePoolId()));
}
#method_after
@Override
protected void executeIrsBrokerCommand() {
    setReturnValue(Guid.Empty);
    log.info("-- executeIrsBrokerCommand: calling 'createVolume' with two new parameters: description and UUID");
    // NOTE: The 'uuidReturn' variable will contain the taskID and not the
    // created image id!
    uuidReturn = getIrsProxy().createVolume(getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString(), getParameters().getImageGroupId().toString(), (Long.valueOf(getParameters().getImageSizeInBytes())).toString(), getParameters().getVolumeFormat().getValue(), getParameters().getImageType().getValue(), 2, getParameters().getNewImageID().toString(), getParameters().getNewImageDescription(), Guid.Empty.toString(), Guid.Empty.toString());
    proceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.mUuid);
    mCreatedImageId = getParameters().getNewImageID().toString();
    setReturnValue(new Guid(mCreatedImageId));
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.createVolume, getParameters().getStoragePoolId()));
}
#end_block

#method_before
@Override
protected void executeIrsBrokerCommand() {
    setReturnValue(Guid.Empty);
    log.info("-- executeIrsBrokerCommand: calling 'createVolume' with two new parameters: description and UUID");
    log.infoFormat("-- createVolume parameters: sdUUID={0} spUUID={1} imgGUID={2} size={3} bytes volFormat={4} volType={5} volUUID={6} descr={7} srcImgGUID={8} srcVolUUID={9}", getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString(), getParameters().getImageGroupId().toString(), getParameters().getImageSizeInBytes(), getParameters().getVolumeFormat().name(), getParameters().getImageType().name(), getParameters().getNewImageID().toString(), getParameters().getNewImageDescription(), getParameters().getSourceImageGroupId().toString(), getParameters().getImageId().toString());
    // NOTE: The 'uuidReturn' variable will contain the taskID and not
    // the created image id!
    uuidReturn = getIrsProxy().createVolume(getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString(), getParameters().getImageGroupId().toString(), (Long.valueOf(getParameters().getImageSizeInBytes())).toString(), getParameters().getVolumeFormat().getValue(), getParameters().getImageType().getValue(), 2, getParameters().getNewImageID().toString(), getParameters().getNewImageDescription(), getParameters().getSourceImageGroupId().toString(), getParameters().getImageId().toString());
    proceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.mUuid);
    mCreatedImageId = getParameters().getNewImageID().toString();
    setReturnValue(new Guid(mCreatedImageId));
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.createVolume, getParameters().getStoragePoolId()));
}
#method_after
@Override
protected void executeIrsBrokerCommand() {
    setReturnValue(Guid.Empty);
    log.info("-- executeIrsBrokerCommand: calling 'createVolume' with two new parameters: description and UUID");
    // NOTE: The 'uuidReturn' variable will contain the taskID and not
    // the created image id!
    uuidReturn = getIrsProxy().createVolume(getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString(), getParameters().getImageGroupId().toString(), (Long.valueOf(getParameters().getImageSizeInBytes())).toString(), getParameters().getVolumeFormat().getValue(), getParameters().getImageType().getValue(), 2, getParameters().getNewImageID().toString(), getParameters().getNewImageDescription(), getParameters().getSourceImageGroupId().toString(), getParameters().getImageId().toString());
    proceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.mUuid);
    mCreatedImageId = getParameters().getNewImageID().toString();
    setReturnValue(new Guid(mCreatedImageId));
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.createVolume, getParameters().getStoragePoolId()));
}
#end_block

#method_before
public void setAlignment(String value) {
    if (privateAlignment == null || !privateAlignment.equals(value)) {
        privateAlignment = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Alignment"));
    }
}
#method_after
public void setAlignment(String value) {
    if (!StringHelper.stringsEqual(privateAlignment, value)) {
        privateAlignment = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Alignment"));
    }
}
#end_block

#method_before
@Override
public void validateEnums(VM vm) {
    if (vm.isSetType()) {
        validateEnum(VmType.class, vm.getType(), true);
    }
    if (vm.isSetUsb()) {
        usbValidator.validateEnums(vm.getUsb());
    }
    if (vm.isSetOs()) {
        osValidator.validateEnums(vm.getOs());
    }
    if (vm.isSetDisplay()) {
        displayValidator.validateEnums(vm.getDisplay());
    }
    if (vm.isSetPlacementPolicy()) {
        placementPolicyValidator.validateEnums(vm.getPlacementPolicy());
    }
    if (vm.isSetPayloads()) {
        for (Payload payload : vm.getPayloads().getPayload()) {
            payloadValidator.validateEnums(payload);
        }
    }
    if (vm.isSetInitialization()) {
        if (vm.getInitialization().isSetCloudInit()) {
            cloudInitValidator.validateEnums(vm.getInitialization().getCloudInit());
        }
    }
}
#method_after
@Override
public void validateEnums(VM vm) {
    if (vm.isSetType()) {
        validateEnum(VmType.class, vm.getType(), true);
    }
    if (vm.isSetUsb()) {
        usbValidator.validateEnums(vm.getUsb());
    }
    if (vm.isSetOs()) {
        osValidator.validateEnums(vm.getOs());
    }
    if (vm.isSetDisplay()) {
        displayValidator.validateEnums(vm.getDisplay());
    }
    if (vm.isSetPlacementPolicy()) {
        placementPolicyValidator.validateEnums(vm.getPlacementPolicy());
    }
    if (vm.isSetPayloads()) {
        for (Payload payload : vm.getPayloads().getPayload()) {
            payloadValidator.validateEnums(payload);
        }
    }
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        configurationValidator.validateEnums(vm.getInitialization().getConfiguration());
    }
    if (vm.isSetInitialization()) {
        if (vm.getInitialization().isSetCloudInit()) {
            cloudInitValidator.validateEnums(vm.getInitialization().getCloudInit());
        }
    }
}
#end_block

#method_before
@Override
public VmDisksResource getDisksResource() {
    return inject(new BackendVmDisksResource(guid, VdcQueryType.GetAllDisksByVmId, new GetAllDisksByVmIdParameters(guid)));
}
#method_after
@Override
public VmDisksResource getDisksResource() {
    return inject(new BackendVmDisksResource(guid, VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(guid)));
}
#end_block

#method_before
@Override
public Response start(Action action) {
    RunVmOnceParams params = map(map(getEntity(entityType, VdcQueryType.GetVmByVmId, new IdQueryParameters(guid), id, true), new VM()), new RunVmOnceParams(guid));
    if (action.isSetVm()) {
        validateEnums(VM.class, action.getVm());
        VM vm = action.getVm();
        params = map(vm, params);
        if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
            validateParameters(vm.getPlacementPolicy(), "host.id|name");
            params.setDestinationVdsId(getHostId(vm.getPlacementPolicy().getHost()));
        }
    }
    if (action.isSetPause() && action.isPause()) {
        params.setRunAndPause(true);
    }
    return doAction(VdcActionType.RunVmOnce, setInitializationType(params), action);
}
#method_after
@Override
public Response start(Action action) {
    RunVmParams params;
    VdcActionType actionType;
    if (action.isSetVm()) {
        VM vm = action.getVm();
        validateEnums(VM.class, vm);
        actionType = VdcActionType.RunVmOnce;
        params = map(vm, map(map(getEntity(entityType, VdcQueryType.GetVmByVmId, new IdQueryParameters(guid), id, true), new VM()), new RunVmOnceParams(guid)));
        if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
            validateParameters(vm.getPlacementPolicy(), "host.id|name");
            params.setDestinationVdsId(getHostId(vm.getPlacementPolicy().getHost()));
        }
        if (vm.isSetInitialization() && vm.getInitialization().isSetCloudInit()) {
            CloudInit cloudInit = vm.getInitialization().getCloudInit();
            // currently only 'root' user is supported, alert the user if other user sent
            if (cloudInit.isSetAuthorizedKeys()) {
                for (AuthorizedKey authKey : cloudInit.getAuthorizedKeys().getAuthorizedKeys()) {
                    if (!"root".equals(authKey.getUser().getUserName())) {
                        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity("Currently only the user 'root' is supported for authorized keys").build());
                    }
                }
            }
            params.setInitializationType(InitializationType.CloudInit);
            ((RunVmOnceParams) params).setCloudInitParameters(getMapper(CloudInit.class, CloudInitParameters.class).map(cloudInit, null));
        }
    } else {
        actionType = VdcActionType.RunVm;
        params = new RunVmParams(guid);
    }
    if (action.isSetPause() && action.isPause()) {
        params.setRunAndPause(true);
    }
    return doAction(actionType, params, action);
}
#end_block

#method_before
@Override
public Response suspend(Action action) {
    return doAction(VdcActionType.HibernateVm, new HibernateVmParameters(guid), action);
}
#method_after
@Override
public Response suspend(Action action) {
    return doAction(VdcActionType.HibernateVm, new VmOperationParameterBase(guid), action);
}
#end_block

#method_before
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    return model;
}
#method_after
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    parent.setConsoleDevice(model);
    parent.setVirtioScsiController(model);
    return model;
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(VM incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), lookupCluster(updated.getVdsGroupId())));
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    if (incoming.isSetPayloads()) {
        if (incoming.isSetPayloads() && incoming.getPayloads().isSetPayload()) {
            params.setVmPayload(parent.getPayload(incoming));
        } else {
            params.setClearPayload(true);
        }
    }
    if (incoming.isSetMemoryPolicy() && incoming.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(incoming.getMemoryPolicy().isBallooning());
    }
    return params;
}
#method_after
@Override
public VdcActionParametersBase getParameters(VM incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    updated.setUsbPolicy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), lookupCluster(updated.getVdsGroupId())));
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    if (incoming.isSetPayloads()) {
        if (incoming.isSetPayloads() && incoming.getPayloads().isSetPayload()) {
            params.setVmPayload(parent.getPayload(incoming));
        } else {
            params.setClearPayload(true);
        }
    }
    if (incoming.isSetMemoryPolicy() && incoming.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(incoming.getMemoryPolicy().isBallooning());
    }
    if (incoming.isSetConsole() && incoming.getConsole().isSetEnabled()) {
        params.setConsoleEnabled(incoming.getConsole().isEnabled());
    }
    if (incoming.isSetVirtioScsi()) {
        params.setVirtioScsiEnabled(incoming.getVirtioScsi().isEnabled());
    }
    return params;
}
#end_block

#method_before
private VDSGroup lookupCluster(Guid id) {
    return getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByVdsGroupId, new GetVdsGroupByVdsGroupIdParameters(id), "GetVdsGroupByVdsGroupId");
}
#method_after
private VDSGroup lookupCluster(Guid id) {
    return getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByVdsGroupId, new IdQueryParameters(id), "GetVdsGroupByVdsGroupId");
}
#end_block

#method_before
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version, OsType.values());
    addNfsVersions(version, NfsVersion.values());
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addAttachmentTypes(version, AttachmentType.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#method_after
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#end_block

#method_before
public String generateId(Version v) {
    NGuid guid = new NGuid((v.getMajor() + "." + v.getMinor()).getBytes(), true);
    return guid.toString();
}
#method_after
public String generateId(Version v) {
    Guid guid = new Guid((v.getMajor() + "." + v.getMinor()).getBytes(), true);
    return guid.toString();
}
#end_block

#method_before
private void addGlusterTypesAndStates(VersionCaps version) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_1)) {
        addGlusterVolumeTypes(version, GlusterVolumeType.values());
        addTransportTypes(version, TransportType.values());
        addGlusterVolumeStates(version, GlusterState.values());
        addGlusterBrickStates(version, GlusterState.values());
    }
}
#method_after
private void addGlusterTypesAndStates(VersionCaps version) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_1)) {
        addGlusterVolumeTypes(version, GlusterVolumeType.values());
        addTransportTypes(version, TransportType.values());
        addGlusterVolumeStates(version, GlusterState.values());
        addGlusterBrickStates(version, GlusterState.values());
    }
    if (VersionUtils.greaterOrEqual(version, VERSION_3_3)) {
        addGlusterHookContentTypes(version, HookContentType.values());
        addStages(version, HookStage.values());
        addGlusterHookStates(version, HookStatus.values());
    }
}
#end_block

#method_before
private void addOsTypes(VersionCaps version, OsType[] types) {
    version.setOsTypes(new OsTypes());
    for (OsType type : types) {
        version.getOsTypes().getOsTypes().add(type.value());
    }
}
#method_after
private void addOsTypes(VersionCaps version) {
    version.setOsTypes(new OsTypes());
    if (VersionUtils.greaterOrEqual(version, VERSION_3_3)) {
        version.getOsTypes().getOsTypes().addAll(OsTypeUtils.getAllValues());
    } else {
        for (OsType type : OsType.values()) {
            version.getOsTypes().getOsTypes().add(type.name());
        }
    }
}
#end_block

#method_before
private List<ServerCpu> getServerCpuList(Version version) {
    return ServerCpuParser.parseCpus(getConfigurationValue(String.class, ConfigurationValues.ServerCPUList, version));
}
#method_after
private List<ServerCpu> getServerCpuList(Version version) {
    return getEntity(List.class, VdcQueryType.GetAllServerCpuList, new GetAllServerCpuListParameters(new org.ovirt.engine.core.compat.Version(asString(version))), "List<ServerCpu>");
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setDomain(entity.getDomain());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOs(entity.getOs());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    entity.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setDomain(entity.getDomain());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    staticVm.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setSingleQxlPci(entity.getSingleQxlPci());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setOs(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setDomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.setTimeZone(vm.getTimezone());
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setDomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getVmOs() != null || entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getVmOs() != null) {
            OsType osType = VmMapper.map(entity.getOs(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        if (entity.getVmIp() != null && !entity.getVmIp().isEmpty()) {
            model.setGuestInfo(new GuestInfo());
            model.getGuestInfo().setIps(new IPs());
            for (String item : entity.getVmIp().split(" ")) {
                if (!item.equals("")) {
                    IP ip = new IP();
                    ip.setAddress(item.trim());
                    model.getGuestInfo().getIps().getIPs().add(ip);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#end_block

#method_before
@Mapping(from = VM.class, to = RunVmOnceParams.class)
public static RunVmOnceParams map(VM vm, RunVmOnceParams template) {
    RunVmOnceParams params = template != null ? template : new RunVmOnceParams();
    if (vm.isSetStateless() && vm.isStateless()) {
        params.setRunAsStateless(true);
    }
    if (vm.isSetDisplay() && vm.getDisplay().isSetType()) {
        DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
        if (displayType != null) {
            params.setUseVnc(displayType == DisplayType.VNC);
        }
    }
    if (vm.isSetOs() && vm.getOs().getBoot().size() > 0) {
        params.setBootSequence(map(vm.getOs().getBoot(), null));
    }
    if (vm.isSetCdroms() && vm.getCdroms().isSetCdRoms()) {
        String file = vm.getCdroms().getCdRoms().get(0).getFile().getId();
        if (file != null) {
            params.setDiskPath(file);
        }
    }
    if (vm.isSetFloppies() && vm.getFloppies().isSetFloppies()) {
        String file = vm.getFloppies().getFloppies().get(0).getFile().getId();
        if (file != null) {
            params.setFloppyPath(file);
        }
    }
    if (vm.isSetCustomProperties()) {
        params.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            params.setBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            params.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            params.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            params.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        params.setSysPrepDomainName(vm.getDomain().getName());
        if (vm.getDomain().isSetUser()) {
            if (vm.getDomain().getUser().isSetUserName()) {
                params.setSysPrepUserName(vm.getDomain().getUser().getUserName());
            }
            if (vm.getDomain().getUser().isSetPassword()) {
                params.setSysPrepPassword(vm.getDomain().getUser().getPassword());
            }
        }
    }
    if (vm.isSetInitialization()) {
        if (vm.getInitialization().isSetCloudInit()) {
            params.setCloudInitParameters(map(vm.getInitialization().getCloudInit(), null));
        }
    }
    return params;
}
#method_after
@Mapping(from = VM.class, to = RunVmOnceParams.class)
public static RunVmOnceParams map(VM vm, RunVmOnceParams template) {
    RunVmOnceParams params = template != null ? template : new RunVmOnceParams();
    if (vm.isSetStateless() && vm.isStateless()) {
        params.setRunAsStateless(true);
    }
    if (vm.isSetDisplay() && vm.getDisplay().isSetType()) {
        DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
        if (displayType != null) {
            params.setUseVnc(displayType == DisplayType.VNC);
        }
    }
    if (vm.isSetOs() && vm.getOs().getBoot().size() > 0) {
        params.setBootSequence(map(vm.getOs().getBoot(), null));
    }
    if (vm.isSetCdroms() && vm.getCdroms().isSetCdRoms()) {
        String file = vm.getCdroms().getCdRoms().get(0).getFile().getId();
        if (file != null) {
            params.setDiskPath(file);
        }
    }
    if (vm.isSetFloppies() && vm.getFloppies().isSetFloppies()) {
        String file = vm.getFloppies().getFloppies().get(0).getFile().getId();
        if (file != null) {
            params.setFloppyPath(file);
        }
    }
    if (vm.isSetCustomProperties()) {
        params.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            params.setBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            params.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            params.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            params.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        params.setSysPrepDomainName(vm.getDomain().getName());
        if (vm.getDomain().isSetUser()) {
            if (vm.getDomain().getUser().isSetUserName()) {
                params.setSysPrepUserName(vm.getDomain().getUser().getUserName());
            }
            if (vm.getDomain().getUser().isSetPassword()) {
                params.setSysPrepPassword(vm.getDomain().getUser().getPassword());
            }
        }
    }
    if (vm.isSetCpuShares()) {
        params.setCpuShares(vm.getCpuShares());
    }
    return params;
}
#end_block

#method_before
@Mapping(from = CloudInit.class, to = CloudInitParameters.class)
public static CloudInitParameters map(CloudInit model, CloudInitParameters template) {
    CloudInitParameters entity = template != null ? template : new CloudInitParameters();
    entity.setHostname(model.getHostname());
    if (model.getAuthorizedKeys() != null && !model.getAuthorizedKeys().getAuthorizedKey().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey key : model.getAuthorizedKeys().getAuthorizedKey()) {
            if ("root".equals(key.getUser())) {
                if (keys.length() > 0) {
                    keys.append("\n");
                }
                keys.append(key.getValue());
            }
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    entity.setRegenerateKeys(model.isRegenerateSshKeys());
    if (model.getNetwork() != null) {
        if (model.getNetwork().getInterfaces() != null && !model.getNetwork().getInterfaces().getInterface().isEmpty()) {
            for (Interface iface : model.getNetwork().getInterfaces().getInterface()) {
                VdsNetworkInterface vdsNetworkInterface = new VdsNetworkInterface();
                NetworkBootProtocol protocol = HostNicMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), null);
                vdsNetworkInterface.setBootProtocol(protocol);
                if (protocol == NetworkBootProtocol.DHCP) {
                    vdsNetworkInterface.setAddress(iface.getAddress());
                    vdsNetworkInterface.setSubnet(iface.getNetmask());
                    vdsNetworkInterface.setGateway(iface.getGateway());
                }
                if (iface.isOnboot()) {
                    if (entity.getStartOnBoot() == null) {
                        entity.setStartOnBoot(new ArrayList<String>());
                    }
                    entity.getStartOnBoot().add(iface.getName());
                }
            }
            if (model.getNetwork().getDnsServers() != null && model.getNetwork().getDnsServers().getDnsServer().isEmpty()) {
                entity.setDnsServers(model.getNetwork().getDnsServers().getDnsServer());
            }
            if (model.getNetwork().getDnsSearchDomains() != null && model.getNetwork().getDnsSearchDomains().getDnsSearchDomain().isEmpty()) {
                entity.setDnsSearch(model.getNetwork().getDnsSearchDomains().getDnsSearchDomain());
            }
        }
    }
    if (model.getTimezone() != null) {
        entity.setTimeZone(TimeZone.getTimeZone(model.getTimezone()));
    }
    if (model.getPasswords() != null && !model.getPasswords().getPassword().isEmpty()) {
        for (Password password : model.getPasswords().getPassword()) {
            if ("root".equals(password.getUser())) {
                entity.setRootPassword(password.getValue());
            }
        }
    }
    if (model.getFiles() != null && !model.getFiles().getFile().isEmpty()) {
        entity.setAttachments(new HashMap<String, Attachment>());
        for (File file : model.getFiles().getFile()) {
            Attachment attachment = new Attachment();
            attachment.setAttachmentType(map(AttachmentType.fromValue(file.getContent().getEncoding()), null));
            attachment.setContent(file.getContent().getValue());
            entity.getAttachments().put(file.getPath(), attachment);
        }
    }
    return entity;
}
#method_after
@Mapping(from = ConfigurationType.class, to = org.ovirt.engine.core.common.businessentities.ConfigurationType.class)
public static org.ovirt.engine.core.common.businessentities.ConfigurationType map(org.ovirt.engine.api.model.ConfigurationType configurationType, org.ovirt.engine.core.common.businessentities.ConfigurationType template) {
    switch(configurationType) {
        case OVF:
            return org.ovirt.engine.core.common.businessentities.ConfigurationType.OVF;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = VMStatus.class, to = VmStatus.class)
public static VmStatus map(VMStatus entityStatus, VmStatus template) {
    switch(entityStatus) {
        case Unassigned:
            return VmStatus.UNASSIGNED;
        case Down:
            return VmStatus.DOWN;
        case Up:
            return VmStatus.UP;
        case PoweringUp:
            return VmStatus.POWERING_UP;
        case PoweredDown:
            return VmStatus.POWERED_DOWN;
        case Paused:
            return VmStatus.PAUSED;
        case MigratingFrom:
            return VmStatus.MIGRATING;
        case MigratingTo:
            return VmStatus.MIGRATING;
        case Unknown:
            return VmStatus.UNKNOWN;
        case NotResponding:
            return VmStatus.NOT_RESPONDING;
        case WaitForLaunch:
            return VmStatus.WAIT_FOR_LAUNCH;
        case RebootInProgress:
            return VmStatus.REBOOT_IN_PROGRESS;
        case PreparingForHibernate:
        case SavingState:
            return VmStatus.SAVING_STATE;
        case RestoringState:
            return VmStatus.RESTORING_STATE;
        case Suspended:
            return VmStatus.SUSPENDED;
        case ImageLocked:
            return VmStatus.IMAGE_LOCKED;
        case PoweringDown:
            return VmStatus.POWERING_DOWN;
        default:
            return null;
    }
}
#method_after
@Mapping(from = VMStatus.class, to = VmStatus.class)
public static VmStatus map(VMStatus entityStatus, VmStatus template) {
    switch(entityStatus) {
        case Unassigned:
            return VmStatus.UNASSIGNED;
        case Down:
            return VmStatus.DOWN;
        case Up:
            return VmStatus.UP;
        case PoweringUp:
            return VmStatus.POWERING_UP;
        case Paused:
            return VmStatus.PAUSED;
        case MigratingFrom:
            return VmStatus.MIGRATING;
        case MigratingTo:
            return VmStatus.MIGRATING;
        case Unknown:
            return VmStatus.UNKNOWN;
        case NotResponding:
            return VmStatus.NOT_RESPONDING;
        case WaitForLaunch:
            return VmStatus.WAIT_FOR_LAUNCH;
        case RebootInProgress:
            return VmStatus.REBOOT_IN_PROGRESS;
        case PreparingForHibernate:
        case SavingState:
            return VmStatus.SAVING_STATE;
        case RestoringState:
            return VmStatus.RESTORING_STATE;
        case Suspended:
            return VmStatus.SUSPENDED;
        case ImageLocked:
            return VmStatus.IMAGE_LOCKED;
        case PoweringDown:
            return VmStatus.POWERING_DOWN;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = VmPayload.class, to = Payload.class)
public static Payload map(VmPayload entity, Payload template) {
    if (entity.getType() != null || entity.getFiles().isEmpty()) {
        Payload model = template != null ? template : new Payload();
        if (entity.getType() != null) {
            org.ovirt.engine.api.model.VmDeviceType deviceType = map(entity.getType(), null);
            if (deviceType != null) {
                model.setType(deviceType.value());
            }
        }
        model.setVolumeId(entity.getVolumeId());
        for (Map.Entry<String, String> entry : entity.getFiles().entrySet()) {
            PayloadFile file = new PayloadFile();
            file.setName(entry.getKey());
            file.setContent(entry.getValue());
            model.getFile().add(file);
        }
        return model;
    }
    return null;
}
#method_after
@Mapping(from = VmPayload.class, to = Payload.class)
public static Payload map(VmPayload entity, Payload template) {
    if (entity.getType() != null || entity.getFiles().isEmpty()) {
        Payload model = template != null ? template : new Payload();
        if (entity.getType() != null) {
            org.ovirt.engine.api.model.VmDeviceType deviceType = map(entity.getType(), null);
            if (deviceType != null) {
                model.setType(deviceType.value());
            }
        }
        model.setVolumeId(entity.getVolumeId());
        if (entity.getFiles().size() > 0) {
            model.setFiles(new Files());
            for (Map.Entry<String, String> entry : entity.getFiles().entrySet()) {
                File file = new File();
                file.setName(entry.getKey());
                file.setContent(entry.getValue());
                model.getFiles().getFiles().add(file);
            }
        }
        return model;
    }
    return null;
}
#end_block

#method_before
@Mapping(from = Payload.class, to = VmPayload.class)
public static VmPayload map(Payload model, VmPayload template) {
    VmPayload entity = template != null ? template : new VmPayload();
    if (model.getType() != null) {
        org.ovirt.engine.api.model.VmDeviceType deviceType = org.ovirt.engine.api.model.VmDeviceType.fromValue(model.getType());
        if (deviceType != null) {
            entity.setType(map(deviceType, null));
        }
    }
    entity.setVolumeId(model.getVolumeId());
    if (model.getFile() != null) {
        for (PayloadFile file : model.getFile()) {
            entity.getFiles().put(file.getName(), file.getContent());
        }
    }
    return entity;
}
#method_after
@Mapping(from = Payload.class, to = VmPayload.class)
public static VmPayload map(Payload model, VmPayload template) {
    VmPayload entity = template != null ? template : new VmPayload();
    if (model.getType() != null) {
        org.ovirt.engine.api.model.VmDeviceType deviceType = org.ovirt.engine.api.model.VmDeviceType.fromValue(model.getType());
        if (deviceType != null) {
            entity.setType(map(deviceType, null));
        }
    }
    if (model.isSetVolumeId()) {
        entity.setVolumeId(model.getVolumeId());
    }
    if (model.isSetFiles()) {
        for (File file : model.getFiles().getFiles()) {
            entity.getFiles().put(file.getName(), file.getContent());
        }
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = CloudInit.class, to = CloudInitParameters.class)
public static CloudInitParameters map(CloudInit model, CloudInitParameters template) {
    CloudInitParameters entity = template != null ? template : new CloudInitParameters();
    entity.setHostname(model.getHostname());
    if (model.getAuthorizedKeys() != null && !model.getAuthorizedKeys().getAuthorizedKey().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey key : model.getAuthorizedKeys().getAuthorizedKey()) {
            if ("root".equals(key.getUser())) {
                if (keys.length() > 0) {
                    keys.append("\n");
                }
                keys.append(key.getValue());
            }
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    entity.setRegenerateKeys(model.isRegenerateSshKeys());
    if (model.getNetwork() != null) {
        if (model.getNetwork().getInterfaces() != null && !model.getNetwork().getInterfaces().getInterface().isEmpty()) {
            for (Interface iface : model.getNetwork().getInterfaces().getInterface()) {
                VdsNetworkInterface vdsNetworkInterface = new VdsNetworkInterface();
                NetworkBootProtocol protocol = HostNicMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), null);
                vdsNetworkInterface.setBootProtocol(protocol);
                if (protocol == NetworkBootProtocol.DHCP) {
                    vdsNetworkInterface.setAddress(iface.getAddress());
                    vdsNetworkInterface.setSubnet(iface.getNetmask());
                    vdsNetworkInterface.setGateway(iface.getGateway());
                }
                if (iface.isOnboot()) {
                    if (entity.getStartOnBoot() == null) {
                        entity.setStartOnBoot(new ArrayList<String>());
                    }
                    entity.getStartOnBoot().add(iface.getName());
                }
            }
            if (model.getNetwork().getDnsServers() != null && model.getNetwork().getDnsServers().getDnsServer().isEmpty()) {
                entity.setDnsServers(model.getNetwork().getDnsServers().getDnsServer());
            }
            if (model.getNetwork().getDnsSearchDomains() != null && model.getNetwork().getDnsSearchDomains().getDnsSearchDomain().isEmpty()) {
                entity.setDnsSearch(model.getNetwork().getDnsSearchDomains().getDnsSearchDomain());
            }
        }
    }
    if (model.getTimezone() != null) {
        entity.setTimeZone(TimeZone.getTimeZone(model.getTimezone()));
    }
    if (model.getPasswords() != null && !model.getPasswords().getPassword().isEmpty()) {
        for (Password password : model.getPasswords().getPassword()) {
            if ("root".equals(password.getUser())) {
                entity.setRootPassword(password.getValue());
            }
        }
    }
    if (model.getFiles() != null && !model.getFiles().getFile().isEmpty()) {
        entity.setAttachments(new HashMap<String, Attachment>());
        for (File file : model.getFiles().getFile()) {
            Attachment attachment = new Attachment();
            attachment.setAttachmentType(map(AttachmentType.fromValue(file.getContent().getEncoding()), null));
            attachment.setContent(file.getContent().getValue());
            entity.getAttachments().put(file.getPath(), attachment);
        }
    }
    return entity;
}
#method_after
@Mapping(from = CloudInit.class, to = CloudInitParameters.class)
public static CloudInitParameters map(CloudInit model, CloudInitParameters template) {
    CloudInitParameters entity = template != null ? template : new CloudInitParameters();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetwork()) {
        if (model.getNetwork().isSetNics()) {
            Map<String, VdsNetworkInterface> interfaces = new HashMap<>();
            for (NIC iface : model.getNetwork().getNics().getNics()) {
                VdsNetworkInterface vdsNetworkInterface = new VdsNetworkInterface();
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = HostNicMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), null);
                    vdsNetworkInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vdsNetworkInterface.setAddress(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vdsNetworkInterface.setSubnet(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vdsNetworkInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                }
                interfaces.put(iface.getName(), vdsNetworkInterface);
                if (iface.isSetOnBoot() && iface.isOnBoot()) {
                    if (entity.getStartOnBoot() == null) {
                        entity.setStartOnBoot(new ArrayList<String>());
                    }
                    entity.getStartOnBoot().add(iface.getName());
                }
            }
            entity.setInterfaces(interfaces);
        }
        if (model.getNetwork().isSetDns()) {
            if (model.getNetwork().getDns().isSetServers() && model.getNetwork().getDns().getServers().isSetHosts() && !model.getNetwork().getDns().getServers().getHosts().isEmpty()) {
                List<String> dnsServers = new ArrayList<>();
                for (Host host : model.getNetwork().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.add(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers);
            }
            if (model.getNetwork().getDns().isSetSearchDomains() && model.getNetwork().getDns().getSearchDomains().isSetHosts() && !model.getNetwork().getDns().getSearchDomains().getHosts().isEmpty()) {
                List<String> searchDomains = new ArrayList<>();
                for (Host host : model.getNetwork().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.add(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains);
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            // currently only root password supported in backend
            if ("root".equals(user.getUserName())) {
                entity.setRootPassword(user.getPassword());
            }
        }
    }
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        entity.setAttachments(new HashMap<String, Attachment>());
        for (File file : model.getFiles().getFiles()) {
            Attachment attachment = new Attachment();
            attachment.setAttachmentType(map(PayloadEncoding.fromValue(file.getType()), null));
            attachment.setContent(file.getContent());
            entity.getAttachments().put(file.getName(), attachment);
        }
    }
    return entity;
}
#end_block

#method_before
static String cpuTuneToString(final CpuTune tune) {
    final StringBuilder builder = new StringBuilder();
    boolean first = true;
    for (final VCpuPin pin : tune.getVcpuPin()) {
        if (first) {
            first = false;
        } else {
            builder.append("_");
        }
        builder.append(pin.getVcpu()).append('#').append(pin.getCpuSet());
    }
    return builder.toString();
}
#method_after
static String cpuTuneToString(final CpuTune tune) {
    final StringBuilder builder = new StringBuilder();
    boolean first = true;
    for (final VCpuPin pin : tune.getVCpuPin()) {
        if (first) {
            first = false;
        } else {
            builder.append("_");
        }
        builder.append(pin.getVcpu()).append('#').append(pin.getCpuSet());
    }
    return builder.toString();
}
#end_block

#method_before
static CpuTune stringToCpuTune(String cpuPinning) {
    if (cpuPinning == null || cpuPinning.equals("")) {
        return null;
    }
    final CpuTune cpuTune = new CpuTune();
    for (String strCpu : cpuPinning.split("_")) {
        VCpuPin pin = stringToVCpupin(strCpu);
        cpuTune.getVcpuPin().add(pin);
    }
    return cpuTune;
}
#method_after
static CpuTune stringToCpuTune(String cpuPinning) {
    if (cpuPinning == null || cpuPinning.equals("")) {
        return null;
    }
    final CpuTune cpuTune = new CpuTune();
    for (String strCpu : cpuPinning.split("_")) {
        VCpuPin pin = stringToVCpupin(strCpu);
        cpuTune.getVCpuPin().add(pin);
    }
    return cpuTune;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (getDestinationDiskImage() != null) {
        Guid storagePoolId = getDestinationDiskImage().getStoragePoolId() != null ? getDestinationDiskImage().getStoragePoolId() : Guid.Empty;
        Guid newImageGroupId = getDestinationDiskImage().getId() != null ? getDestinationDiskImage().getId() : Guid.Empty;
        Guid newImageId = getDestinationDiskImage().getImageId();
        Guid newStorageDomainID = getDestinationDiskImage().getStorageIds().get(0);
        // complete IRS data to DB disk image:
        DiskImage newImageIRS = (DiskImage) runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
        if (newImageIRS != null) {
            completeImageData(newImageIRS);
        }
        // Unlock destination image:
        getDestinationDiskImage().setImageStatus(ImageStatus.OK);
        getImageDao().update(getDestinationDiskImage().getImage());
    }
    unLockImage();
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    if (getDestinationDiskImage() != null) {
        Guid storagePoolId = getDestinationDiskImage().getStoragePoolId() != null ? getDestinationDiskImage().getStoragePoolId() : Guid.Empty;
        Guid newImageGroupId = getDestinationDiskImage().getId() != null ? getDestinationDiskImage().getId() : Guid.Empty;
        Guid newImageId = getDestinationDiskImage().getImageId();
        Guid newStorageDomainID = getDestinationDiskImage().getStorageIds().get(0);
        // complete IRS data to DB disk image:
        try {
            DiskImage newImageIRS = (DiskImage) runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
            if (newImageIRS != null) {
                completeImageData(newImageIRS);
            }
        } catch (VdcBLLException e) {
            // Logging only
            log.errorFormat("Unable to update the image info for image {0} (image group: {1}) on domain {2}", newImageId, newImageGroupId, newStorageDomainID);
        } finally {
            // Unlock destination image:
            getDestinationDiskImage().setImageStatus(ImageStatus.OK);
            getImageDao().update(getDestinationDiskImage().getImage());
        }
    }
    unLockImage();
    setSucceeded(true);
}
#end_block

#method_before
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = getStoragePoolDAO().get(storagePoolId);
    StorageDomain masterDomain = getStorageDomainDAO().getStorageDomainByTypeAndPool(storagePoolId, StorageDomainType.Master);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.InActive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    VDSReturnValue returnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), storagePoolId, vds.getVdsSpmId(), masterDomain.getId(), storagePool.getmaster_domain_version()));
    if (!returnValue.getSucceeded()) {
        VDSError error = returnValue.getVdsError();
        if ((error == null || error.getCode() != VdcBllErrors.CannotConnectMultiplePools) && masterDomainInactiveOrUnknown) {
            log.infoFormat("Could not connect host {0} to pool {1}, as the master domain is in inactive/unknown status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.errorFormat("Could not connect host {0} to pool {1} with the message: {2}", vds.getName(), storagePool.getName(), error != null ? error.getMessage() : "");
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        result.setSuccess(proceedVdsStats(!masterDomainInactiveOrUnknown));
        if (!result.isSuccess()) {
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#method_after
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = getStoragePoolDAO().get(storagePoolId);
    StorageDomain masterDomain = getStorageDomainDAO().getStorageDomainByTypeAndPool(storagePoolId, StorageDomainType.Master);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.InActive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    VDSError error = null;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), storagePoolId, vds.getVdsSpmId(), masterDomain.getId(), storagePool.getmaster_domain_version()));
        if (!vdsReturnValue.getSucceeded()) {
            error = vdsReturnValue.getVdsError();
        }
    } catch (VdcBLLException e) {
        error = e.getVdsError();
    }
    if (error != null) {
        if (error.getCode() != VdcBllErrors.CannotConnectMultiplePools && masterDomainInactiveOrUnknown) {
            log.infoFormat("Could not connect host {0} to pool {1}, as the master domain is in inactive/unknown status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.errorFormat("Could not connect host {0} to pool {1} with the message: {2}", vds.getName(), storagePool.getName(), error.getMessage());
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        result.setSuccess(proceedVdsStats(!masterDomainInactiveOrUnknown));
        if (!result.isSuccess()) {
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    if (getVm() != null) {
        updateSuggestedDiskAlias();
    }
    getSizeExtend().setIsAvailable(false);
}
#method_after
@Override
public void initialize() {
    super.initialize();
    if (getVm() != null) {
        updateSuggestedDiskAlias();
    } else {
        // Read only disk can be created only in the scope of VM.
        getIsReadOnly().setIsAvailable(false);
    }
    getSizeExtend().setIsAvailable(false);
}
#end_block

#method_before
private void onAttachDisks() {
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> paramerterList = new ArrayList<VdcActionParametersBase>();
    ArrayList<IFrontendActionAsyncCallback> callbacks = new ArrayList<IFrontendActionAsyncCallback>();
    IFrontendActionAsyncCallback onFinishCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            NewDiskModel diskModel = (NewDiskModel) result.getState();
            diskModel.stopProgress();
            diskModel.cancel();
            postSave();
        }
    };
    ArrayList<EntityModel> disksToAttach = (Boolean) getIsInternal().getEntity() ? (ArrayList<EntityModel>) getInternalAttachableDisks().getSelectedItems() : (ArrayList<EntityModel>) getExternalAttachableDisks().getSelectedItems();
    for (int i = 0; i < disksToAttach.size(); i++) {
        DiskModel disk = (DiskModel) disksToAttach.get(i).getEntity();
        AttachDettachVmDiskParameters parameters = new AttachDettachVmDiskParameters(getVm().getId(), disk.getDisk().getId(), (Boolean) getIsPlugged().getEntity());
        actionTypes.add(VdcActionType.AttachDiskToVm);
        paramerterList.add(parameters);
        callbacks.add(i == disksToAttach.size() - 1 ? onFinishCallback : null);
    }
    startProgress(null);
    Frontend.RunMultipleActions(actionTypes, paramerterList, callbacks, null, this);
}
#method_after
private void onAttachDisks() {
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> paramerterList = new ArrayList<VdcActionParametersBase>();
    ArrayList<IFrontendActionAsyncCallback> callbacks = new ArrayList<IFrontendActionAsyncCallback>();
    IFrontendActionAsyncCallback onFinishCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            NewDiskModel diskModel = (NewDiskModel) result.getState();
            diskModel.stopProgress();
            diskModel.cancel();
            postSave();
        }
    };
    ArrayList<EntityModel> disksToAttach = (Boolean) getIsInternal().getEntity() ? (ArrayList<EntityModel>) getInternalAttachableDisks().getSelectedItems() : (ArrayList<EntityModel>) getExternalAttachableDisks().getSelectedItems();
    for (int i = 0; i < disksToAttach.size(); i++) {
        DiskModel disk = (DiskModel) disksToAttach.get(i).getEntity();
        // Disk is attached to VM as read only or not, null is applicable only for floating disks
        // but this is not a case here.
        AttachDettachVmDiskParameters parameters = new AttachDettachVmDiskParameters(getVm().getId(), disk.getDisk().getId(), (Boolean) getIsPlugged().getEntity(), Boolean.TRUE.equals(disk.getDisk().getReadOnly()));
        actionTypes.add(VdcActionType.AttachDiskToVm);
        paramerterList.add(parameters);
        callbacks.add(i == disksToAttach.size() - 1 ? onFinishCallback : null);
    }
    startProgress(null);
    Frontend.RunMultipleActions(actionTypes, paramerterList, callbacks, null, this);
}
#end_block

#method_before
@OnTimerMethodAnnotation("gluster_async_task_poll_event")
public void updateGlusterAsyncTasks() {
    log.debug("Refreshing gluster tasks list");
    List<VDSGroup> clusters = getClusterDao().getAll();
    List<Guid> tasksFromClusters = new ArrayList<>();
    for (VDSGroup cluster : clusters) {
        Map<Guid, GlusterAsyncTask> runningTasks = updateTasksInCluster(cluster);
        if (runningTasks != null) {
            tasksFromClusters.addAll(runningTasks.keySet());
        }
    }
    cleanUpOrphanTasks(tasksFromClusters);
}
#method_after
@OnTimerMethodAnnotation("gluster_async_task_poll_event")
public void updateGlusterAsyncTasks() {
    log.debug("Refreshing gluster tasks list");
    List<VDSGroup> clusters = getClusterDao().getAll();
    List<Guid> tasksFromClusters = new ArrayList<>();
    boolean cleanOrphanTasks = true;
    for (VDSGroup cluster : clusters) {
        if (!getGlusterTaskUtils().supportsGlusterAsyncTasksFeature(cluster)) {
            continue;
        }
        try {
            Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
            if (runningTasks != null) {
                updateTasksInCluster(cluster, runningTasks);
                tasksFromClusters.addAll(runningTasks.keySet());
            }
        } catch (VdcBLLException e) {
            cleanOrphanTasks = false;
        }
    }
    if (cleanOrphanTasks) {
        cleanUpOrphanTasks(tasksFromClusters);
    }
}
#end_block

#method_before
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            step.setStatus(task.getStatus());
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#method_after
private void updateTasksInCluster(final VDSGroup cluster, final Map<Guid, GlusterAsyncTask> runningTasks) {
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        getGlusterTaskUtils().updateSteps(cluster, task, steps);
    }
}
#end_block

#method_before
private Guid addAsyncTaskStep(VDSGroup cluster, GlusterAsyncTask task, StepEnum step, Guid execStepId) {
    VdcReturnValueBase result;
    result = getBackend().runInternalAction(VdcActionType.AddInternalStep, new AddStepParameters(execStepId, getTaskMessage(cluster, step, task), step));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid asyncStepId = (Guid) result.getActionReturnValue();
    return asyncStepId;
}
#method_after
private Guid addAsyncTaskStep(VDSGroup cluster, GlusterAsyncTask task, StepEnum step, Guid execStepId) {
    VdcReturnValueBase result;
    result = getBackend().runInternalAction(VdcActionType.AddInternalStep, new AddStepParameters(execStepId, getGlusterTaskUtils().getTaskMessage(cluster, step, task), step));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid asyncStepId = (Guid) result.getActionReturnValue();
    return asyncStepId;
}
#end_block

#method_before
private Guid addJob(VDSGroup cluster, GlusterAsyncTask task, VdcActionType actionType) {
    VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.AddInternalJob, new AddInternalJobParameters(ExecutionMessageDirector.resolveJobMessage(actionType, getMessageMap(cluster, task)), actionType, true));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid jobId = (Guid) result.getActionReturnValue();
    return jobId;
}
#method_after
private Guid addJob(VDSGroup cluster, GlusterAsyncTask task, VdcActionType actionType) {
    VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.AddInternalJob, new AddInternalJobParameters(ExecutionMessageDirector.resolveJobMessage(actionType, getGlusterTaskUtils().getMessageMap(cluster, task)), actionType, true));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid jobId = (Guid) result.getActionReturnValue();
    return jobId;
}
#end_block

#method_before
private void cleanUpOrphanTasks(List<Guid> runningTasksinCluster) {
    // Populate the list of tasks that need to be monitored from database
    List<Guid> taskListInDB = getProvider().getMonitoredTaskIDsInDB();
    if (taskListInDB == null) {
        taskListInDB = new ArrayList<Guid>();
    }
    // if task is in DB but not in running task list
    final Set<Guid> tasksNotRunning = new HashSet<Guid>(taskListInDB);
    tasksNotRunning.removeAll(runningTasksinCluster);
    for (Guid taskId : tasksNotRunning) {
        GlusterVolumeEntity vol = getVolumeDao().getVolumeByGlusterTask(taskId);
        if (vol != null && vol.getStatus() != GlusterStatus.UP) {
            // the volume is not UP. Hence gluster may not have been able to return tasks for the volume
            continue;
        }
        // Volume is up, but gluster does not know of task
        // will mark job ended with status unknown.
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        for (Step step : steps) {
            step.markStepEnded(JobExecutionStatus.UNKNOWN);
            endStepJob(step);
        }
        releaseVolumeLock(taskId);
    }
}
#method_after
private void cleanUpOrphanTasks(List<Guid> runningTasksinCluster) {
    // Populate the list of tasks that need to be monitored from database
    List<Guid> taskListInDB = getProvider().getMonitoredTaskIDsInDB();
    if (taskListInDB == null || taskListInDB.isEmpty()) {
        return;
    }
    // if task is in DB but not in running task list
    final Set<Guid> tasksNotRunning = new HashSet<Guid>(taskListInDB);
    tasksNotRunning.removeAll(runningTasksinCluster);
    for (Guid taskId : tasksNotRunning) {
        GlusterVolumeEntity vol = getVolumeDao().getVolumeByGlusterTask(taskId);
        if (vol != null && vol.getStatus() != GlusterStatus.UP) {
            // the volume is not UP. Hence gluster may not have been able to return tasks for the volume
            continue;
        }
        // Volume is up, but gluster does not know of task
        // will mark job ended with status unknown.
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        for (Step step : steps) {
            step.markStepEnded(JobExecutionStatus.UNKNOWN);
            getGlusterTaskUtils().endStepJob(step);
        }
        getGlusterTaskUtils().releaseVolumeLock(taskId);
    }
}
#end_block

#method_before
@Before
public void init() {
    MockitoAnnotations.initMocks(this);
    tasksSyncJob = Mockito.spy(GlusterTasksSyncJob.getInstance());
    logUtil = Mockito.spy(GlusterAuditLogUtil.getInstance());
    doNothing().when(logUtil).logClusterMessage(any(Guid.class), any(AuditLogType.class));
    doReturn(clusterDao).when(tasksSyncJob).getClusterDao();
    doReturn(getClusters()).when(clusterDao).getAll();
    doReturn(provider).when(tasksSyncJob).getProvider();
    doReturn(stepDao).when(tasksSyncJob).getStepDao();
    doReturn(volumeDao).when(tasksSyncJob).getVolumeDao();
    doReturn(jobRepository).when(tasksSyncJob).getJobRepository();
    doReturn(backend).when(tasksSyncJob).getBackend();
    doNothing().when(tasksSyncJob).releaseLock(any(Guid.class));
    doNothing().when(tasksSyncJob).endStepJob(any(Step.class));
    doReturn(null).when(provider).getMonitoredTaskIDsInDB();
}
#method_after
@Before
public void init() {
    MockitoAnnotations.initMocks(this);
    tasksSyncJob = Mockito.spy(GlusterTasksSyncJob.getInstance());
    logUtil = Mockito.spy(GlusterAuditLogUtil.getInstance());
    taskUtils = Mockito.spy(GlusterTaskUtils.getInstance());
    doNothing().when(logUtil).logClusterMessage(any(Guid.class), any(AuditLogType.class));
    doReturn(clusterDao).when(tasksSyncJob).getClusterDao();
    doReturn(getClusters()).when(clusterDao).getAll();
    doReturn(provider).when(tasksSyncJob).getProvider();
    doReturn(stepDao).when(tasksSyncJob).getStepDao();
    doReturn(volumeDao).when(tasksSyncJob).getVolumeDao();
    doReturn(volumeDao).when(taskUtils).getVolumeDao();
    doReturn(jobRepository).when(tasksSyncJob).getJobRepository();
    doReturn(jobRepository).when(taskUtils).getJobRepository();
    doReturn(backend).when(tasksSyncJob).getBackend();
    doReturn(taskUtils).when(tasksSyncJob).getGlusterTaskUtils();
    doNothing().when(taskUtils).releaseLock(any(Guid.class));
    doNothing().when(taskUtils).endStepJob(any(Step.class));
    doReturn(null).when(provider).getMonitoredTaskIDsInDB();
}
#end_block

#method_before
@Test
public void updateTasksInCluster() {
    doReturn(getTasks()).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(1)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(1)).endStepJob(any(Step.class));
}
#method_after
@Test
public void updateTasksInCluster() {
    doReturn(getTasks()).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(1)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(1)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void cleanOrphanTasks() {
    doReturn(getTasks()).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(Arrays.asList(TASK_GUIDS[2])).when(provider).getMonitoredTaskIDsInDB();
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(1)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(2)).endStepJob(any(Step.class));
}
#method_after
@Test
public void cleanOrphanTasks() {
    doReturn(getTasks()).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(Arrays.asList(TASK_GUIDS[2])).when(provider).getMonitoredTaskIDsInDB();
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(1)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(2)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void cleanOrphanTasksWhenNoVolume() {
    doReturn(null).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(Arrays.asList(TASK_GUIDS[2])).when(provider).getMonitoredTaskIDsInDB();
    doReturn(null).when(volumeDao).getVolumeByGlusterTask(TASK_GUIDS[2]);
    doReturn(getSteps()).when(stepDao).getStepsByExternalId(TASK_GUIDS[2]);
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(tasksSyncJob, times(1)).endStepJob(any(Step.class));
}
#method_after
@Test
public void cleanOrphanTasksWhenNoVolume() {
    doReturn(null).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(Arrays.asList(TASK_GUIDS[2])).when(provider).getMonitoredTaskIDsInDB();
    doReturn(null).when(volumeDao).getVolumeByGlusterTask(TASK_GUIDS[2]);
    doReturn(getSteps()).when(stepDao).getStepsByExternalId(TASK_GUIDS[2]);
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(taskUtils, times(1)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void testUpdateWhenNoTasks() {
    doReturn(null).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(volumeDao, times(0)).updateVolumeTask(VOL_GUIDS[0], null);
    Mockito.verify(volumeDao, times(0)).updateVolumeTask(VOL_GUIDS[1], null);
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(0)).endStepJob(any(Step.class));
}
#method_after
@Test
public void testUpdateWhenNoTasks() {
    doReturn(null).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(volumeDao, times(0)).updateVolumeTask(VOL_GUIDS[0], null);
    Mockito.verify(volumeDao, times(0)).updateVolumeTask(VOL_GUIDS[1], null);
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(0)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void testCreateTasksStartedFromCLI() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(mockVdcReturn(true, Guid.newGuid())).when(backend).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
    prepareMocksForTasksFromCLI();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(0)).endStepJob(any(Step.class));
    Mockito.verify(backend, times(6)).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
}
#method_after
@Test
public void testCreateTasksStartedFromCLI() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(mockVdcReturn(true, Guid.newGuid())).when(backend).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
    prepareMocksForTasksFromCLI();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(0)).endStepJob(any(Step.class));
    Mockito.verify(backend, times(6)).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
}
#end_block

#method_before
@Test
public void testCreateTasksStartedFromCLIWithErrors() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(mockVdcReturn(false, null)).when(backend).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
    prepareMocksForTasksFromCLI();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(0)).endStepJob(any(Step.class));
    Mockito.verify(backend, times(2)).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
}
#method_after
@Test
public void testCreateTasksStartedFromCLIWithErrors() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    doReturn(mockVdcReturn(false, null)).when(backend).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
    prepareMocksForTasksFromCLI();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(0)).endStepJob(any(Step.class));
    Mockito.verify(backend, times(2)).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class));
}
#end_block

#method_before
@Test
public void testUpdateWhenNoCompletedTasks() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(2)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(0)).endStepJob(any(Step.class));
}
#method_after
@Test
public void testUpdateWhenNoCompletedTasks() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(2)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(0)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void testUpdateWhenAbortedTasks() {
    doReturn(getTasks(JobExecutionStatus.ABORTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(2)).endStepJob(any(Step.class));
}
#method_after
@Test
public void testUpdateWhenAbortedTasks() {
    doReturn(getTasks(JobExecutionStatus.ABORTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(taskUtils, times(2)).endStepJob(any(Step.class));
}
#end_block

#method_before
public Map<Guid, GlusterAsyncTask> getTaskListForCluster(Guid id) {
    VDS upServer = ClusterUtils.getInstance().getUpServer(id);
    if (upServer == null) {
        log.info("No up server in cluster");
        return null;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterTasksList, new VdsIdVDSCommandParametersBase(upServer.getId()));
    if (returnValue.getSucceeded()) {
        List<GlusterAsyncTask> tasks = (List<GlusterAsyncTask>) returnValue.getReturnValue();
        Map<Guid, GlusterAsyncTask> tasksMap = new HashMap<>();
        for (GlusterAsyncTask task : tasks) {
            tasksMap.put(task.getTaskId(), task);
        }
        return tasksMap;
    } else {
        log.error(returnValue.getVdsError());
        return null;
    }
}
#method_after
public Map<Guid, GlusterAsyncTask> getTaskListForCluster(Guid id) {
    VDS upServer = ClusterUtils.getInstance().getUpServer(id);
    if (upServer == null) {
        log.info("No up server in cluster");
        throw new VdcBLLException(VdcBllErrors.NO_UP_SERVER_FOUND);
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterTasksList, new VdsIdVDSCommandParametersBase(upServer.getId()));
    if (returnValue.getSucceeded()) {
        List<GlusterAsyncTask> tasks = (List<GlusterAsyncTask>) returnValue.getReturnValue();
        Map<Guid, GlusterAsyncTask> tasksMap = new HashMap<>();
        for (GlusterAsyncTask task : tasks) {
            tasksMap.put(task.getTaskId(), task);
        }
        return tasksMap;
    } else {
        log.error(returnValue.getVdsError());
        throw new VdcBLLException(VdcBllErrors.GlusterVolumeStatusAllFailedException, returnValue.getVdsError().getMessage());
    }
}
#end_block

#method_before
@Test
public void canRebalanceOnDistributedVolumeWithBricksDown() {
    GlusterVolumeEntity volumeEntity = getDistributedVolume(volumeId1, 5);
    // One Brick Down
    volumeEntity.getBricks().get(3).setStatus(GlusterStatus.DOWN);
    ValidationResult validationResult = brickValidator.canRebalance(volumeEntity);
    assertFalse(validationResult.isValid());
    // Two Bricks Down
    volumeEntity.getBricks().get(4).setStatus(GlusterStatus.DOWN);
    assertFalse(validationResult.isValid());
    // One Brick Down
    volumeEntity.getBricks().get(3).setStatus(GlusterStatus.UP);
    assertFalse(validationResult.isValid());
}
#method_after
@Test
public void canRebalanceOnDistributedVolumeWithBricksDown() {
    GlusterVolumeEntity volumeEntity = getDistributedVolume(volumeId1, 5);
    // One Brick Down
    volumeEntity.getBricks().get(3).setStatus(GlusterStatus.DOWN);
    ValidationResult validationResult = brickValidator.canRebalance(volumeEntity);
    assertFalse(validationResult.isValid());
    // Two Bricks Down
    volumeEntity.getBricks().get(4).setStatus(GlusterStatus.DOWN);
    validationResult = brickValidator.canRebalance(volumeEntity);
    assertFalse(validationResult.isValid());
    // One Brick Down
    volumeEntity.getBricks().get(3).setStatus(GlusterStatus.UP);
    validationResult = brickValidator.canRebalance(volumeEntity);
    assertFalse(validationResult.isValid());
}
#end_block

#method_before
@Test
public void canRebalanceOnDistributeReplicateVolume() {
    GlusterVolumeEntity volumeEntity = getDistributeReplacatedVolume(volumeId1, 12, 4);
    ValidationResult validationResult = brickValidator.canRebalance(volumeEntity);
    assertTrue(validationResult.isValid());
}
#method_after
@Test
public void canRebalanceOnDistributeReplicateVolume() {
    GlusterVolumeEntity volumeEntity = getDistributedReplacatedVolume(volumeId1, 12, 4);
    ValidationResult validationResult = brickValidator.canRebalance(volumeEntity);
    assertTrue(validationResult.isValid());
}
#end_block

#method_before
@Test
public void canRebalanceOnDistributeReplicateVolumeWithFewBrickDown() {
    GlusterVolumeEntity volumeEntity = getDistributeReplacatedVolume(volumeId1, 12, 4);
    volumeEntity.getBricks().get(0).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(1).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(2).setStatus(GlusterStatus.DOWN);
    ValidationResult validationResult = brickValidator.canRebalance(volumeEntity);
    assertTrue(validationResult.isValid());
    volumeEntity.getBricks().get(4).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(5).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(6).setStatus(GlusterStatus.DOWN);
    validationResult = brickValidator.canRebalance(volumeEntity);
    assertTrue(validationResult.isValid());
}
#method_after
@Test
public void canRebalanceOnDistributeReplicateVolumeWithFewBrickDown() {
    GlusterVolumeEntity volumeEntity = getDistributedReplacatedVolume(volumeId1, 12, 4);
    volumeEntity.getBricks().get(0).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(1).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(2).setStatus(GlusterStatus.DOWN);
    ValidationResult validationResult = brickValidator.canRebalance(volumeEntity);
    assertTrue(validationResult.isValid());
    volumeEntity.getBricks().get(4).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(5).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(6).setStatus(GlusterStatus.DOWN);
    validationResult = brickValidator.canRebalance(volumeEntity);
    assertTrue(validationResult.isValid());
}
#end_block

#method_before
@Test
public void canRebalanceOnDistributeReplicateVolumeWithOneReplicaPairDown() {
    GlusterVolumeEntity volumeEntity = getDistributeReplacatedVolume(volumeId1, 12, 4);
    volumeEntity.getBricks().get(0).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(1).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(2).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(3).setStatus(GlusterStatus.DOWN);
    ValidationResult validationResult = brickValidator.canRebalance(volumeEntity);
    assertFalse(validationResult.isValid());
}
#method_after
@Test
public void canRebalanceOnDistributeReplicateVolumeWithOneReplicaPairDown() {
    GlusterVolumeEntity volumeEntity = getDistributedReplacatedVolume(volumeId1, 12, 4);
    volumeEntity.getBricks().get(0).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(1).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(2).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(3).setStatus(GlusterStatus.DOWN);
    ValidationResult validationResult = brickValidator.canRebalance(volumeEntity);
    assertFalse(validationResult.isValid());
}
#end_block

#method_before
@Test
public void canRebalanceOnDistributeReplicateVolumeWithTwoReplicaPairDown() {
    GlusterVolumeEntity volumeEntity = getDistributeReplacatedVolume(volumeId1, 12, 4);
    volumeEntity.getBricks().get(0).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(2).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(3).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(4).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(5).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(6).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(7).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(8).setStatus(GlusterStatus.DOWN);
    ValidationResult validationResult = brickValidator.canRebalance(volumeEntity);
    assertFalse(validationResult.isValid());
}
#method_after
@Test
public void canRebalanceOnDistributeReplicateVolumeWithTwoReplicaPairDown() {
    GlusterVolumeEntity volumeEntity = getDistributedReplacatedVolume(volumeId1, 12, 4);
    volumeEntity.getBricks().get(0).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(2).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(3).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(4).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(5).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(6).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(7).setStatus(GlusterStatus.DOWN);
    volumeEntity.getBricks().get(8).setStatus(GlusterStatus.DOWN);
    ValidationResult validationResult = brickValidator.canRebalance(volumeEntity);
    assertFalse(validationResult.isValid());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    int replicaCount = (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) ? getParameters().getReplicaCount() : 0;
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getBricks(), replicaCount, true));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        removeBricksFromVolumeInDb(getParameters().getBricks());
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    int replicaCount = (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) ? getParameters().getReplicaCount() : 0;
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getBricks(), replicaCount, true));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        GlusterDBUtils.getInstance().removeBricksFromVolumeInDb(getGlusterVolume(), getParameters().getBricks(), replicaCount);
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
public ValidationResult canRemoveBrick(List<GlusterBrickEntity> bricks, GlusterVolumeEntity volumeEntity, int replicaCount, boolean forceRemove) {
    if (bricks.isEmpty()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
    }
    if (volumeEntity.getBricks().size() == 1 || volumeEntity.getBricks().size() <= bricks.size()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REMOVE_ALL_BRICKS_FROM_VOLUME);
    }
    if (volumeEntity.getVolumeType().isReplicatedType()) {
        if (replicaCount < volumeEntity.getReplicaCount() - 1) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_REPLICA_COUNT_MORE_THAN_ONE);
        } else if (replicaCount > volumeEntity.getReplicaCount()) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_REPLICA_COUNT);
        }
    }
    for (GlusterBrickEntity brick : bricks) {
        if (brick.getId(false) == null && brick.getQualifiedName() == null) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        }
        GlusterBrickEntity brickFromVolume = volumeEntity.getBrickWithId(brick.getId());
        if (brickFromVolume == null) {
            brickFromVolume = volumeEntity.getBrickWithQualifiedName(brick.getQualifiedName());
        }
        if (brickFromVolume == null) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_BRICK_INVALID);
        } else {
            // Fill required details from volume data
            brick.setServerName(brickFromVolume.getServerName());
            brick.setBrickDirectory(brickFromVolume.getBrickDirectory());
        }
    }
    if (!forceRemove) {
        return canRebalance(volumeEntity);
    } else {
        return ValidationResult.VALID;
    }
}
#method_after
public ValidationResult canRemoveBrick(List<GlusterBrickEntity> bricks, GlusterVolumeEntity volumeEntity, int replicaCount, boolean forceRemove) {
    if (bricks.isEmpty()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
    }
    if (volumeEntity.getBricks().size() == 1 || volumeEntity.getBricks().size() <= bricks.size()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REMOVE_ALL_BRICKS_FROM_VOLUME);
    }
    if (volumeEntity.getVolumeType().isReplicatedType()) {
        if (replicaCount < volumeEntity.getReplicaCount() - 1) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_REPLICA_COUNT_MORE_THAN_ONE);
        } else if (replicaCount > volumeEntity.getReplicaCount()) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_REPLICA_COUNT);
        }
    }
    for (GlusterBrickEntity brick : bricks) {
        if (brick.getId(false) == null && brick.getQualifiedName() == null) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        }
        GlusterBrickEntity brickFromVolume = volumeEntity.getBrickWithId(brick.getId());
        if (brickFromVolume == null) {
            brickFromVolume = volumeEntity.getBrickWithQualifiedName(brick.getQualifiedName());
        }
        if (brickFromVolume == null) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_BRICK_INVALID);
        } else {
            // Fill required details from volume data
            brick.setId(brickFromVolume.getId());
            brick.setServerName(brickFromVolume.getServerName());
            brick.setBrickDirectory(brickFromVolume.getBrickDirectory());
        }
    }
    if (!forceRemove) {
        return canRebalance(volumeEntity);
    } else {
        return ValidationResult.VALID;
    }
}
#end_block

#method_before
public ValidationResult canRebalance(GlusterVolumeEntity volumeEntity) {
    int replicaCount = 0;
    List<GlusterBrickEntity> bricks = volumeEntity.getBricks();
    if (volumeEntity.getVolumeType() == GlusterVolumeType.DISTRIBUTE) {
        replicaCount = 1;
    } else if (volumeEntity.getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        replicaCount = volumeEntity.getReplicaCount();
    }
    int i = 0, j = 0;
    while (i < bricks.size()) {
        for (j = 0; j < replicaCount; j++) {
            if (bricks.get(i + j).isOnline()) {
                i = i + replicaCount;
                break;
            }
        }
        if (j == replicaCount) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_BRICKS_ARE_DOWN);
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult canRebalance(GlusterVolumeEntity volumeEntity) {
    int replicaCount = 1;
    List<GlusterBrickEntity> bricks = volumeEntity.getBricks();
    if (volumeEntity.getVolumeType().isReplicatedType()) {
        replicaCount = volumeEntity.getReplicaCount();
    }
    int brickIndex = 0, replicaIndex = 0;
    while (brickIndex < bricks.size()) {
        for (replicaIndex = 0; replicaIndex < replicaCount; replicaIndex++) {
            if (bricks.get(brickIndex + replicaIndex).isOnline()) {
                brickIndex = brickIndex + replicaCount;
                break;
            }
        }
        if (replicaIndex == replicaCount) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_BRICKS_ARE_DOWN);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected Step doPopulate(Step model, org.ovirt.engine.core.common.job.Step entity) {
    if (entity.getExternalSystem() != null && entity.getExternalSystem().getType() != null) {
        return populateExternalTaskDetails(model, entity);
    }
    return model;
}
#method_after
@Override
protected Step doPopulate(Step model, org.ovirt.engine.core.common.job.Step entity) {
    return model;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.job.Step.class, to = Step.class)
public static Step map(org.ovirt.engine.core.common.job.Step entity, Step step) {
    Step model = step != null ? step : new Step();
    model.setId(entity.getId().toString());
    if (entity.getParentStepId() != null) {
        Step parentStep = new Step();
        parentStep.setId(entity.getParentStepId().toString());
        model.setParentStep(parentStep);
    }
    Job job = new Job();
    job.setId(entity.getJobId().toString());
    model.setJob(job);
    StepEnum type = map(entity.getStepType());
    model.setType(type == null ? null : type.value());
    model.setDescription(entity.getDescription());
    model.setNumber(entity.getStepNumber());
    model.setStatus(JobMapper.map(entity.getStatus(), null));
    model.setStartTime(DateMapper.map(entity.getStartTime(), null));
    if (entity.getEndTime() != null) {
        model.setEndTime(TypeConversionHelper.toXMLGregorianCalendar(entity.getEndTime(), null));
    }
    model.setExternal(entity.isExternal());
    if (entity.getExternalSystem() != null && entity.getExternalSystem().getType() != null) {
        model.setExternalType(entity.getExternalSystem().getType().name());
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.job.Step.class, to = Step.class)
public static Step map(org.ovirt.engine.core.common.job.Step entity, Step step) {
    Step model = step != null ? step : new Step();
    model.setId(entity.getId().toString());
    if (entity.getParentStepId() != null) {
        Step parentStep = new Step();
        parentStep.setId(entity.getParentStepId().toString());
        model.setParentStep(parentStep);
    }
    Job job = new Job();
    job.setId(entity.getJobId().toString());
    model.setJob(job);
    StepEnum type = map(entity.getStepType());
    model.setType(type == null ? null : type.value());
    model.setDescription(entity.getDescription());
    model.setNumber(entity.getStepNumber());
    model.setStatus(JobMapper.map(entity.getStatus(), null));
    model.setStartTime(DateMapper.map(entity.getStartTime(), null));
    if (entity.getEndTime() != null) {
        model.setEndTime(TypeConversionHelper.toXMLGregorianCalendar(entity.getEndTime(), null));
    }
    model.setExternal(entity.isExternal());
    if (entity.getExternalSystem() != null && entity.getExternalSystem().getType() != null) {
        model.setExternalType(map(entity.getExternalSystem().getType()));
    }
    return model;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.job.StepEnum.class, to = StepEnum.class)
public static StepEnum map(org.ovirt.engine.core.common.job.StepEnum type) {
    if (StepEnum.VALIDATING.name().equals(type.name())) {
        return StepEnum.VALIDATING;
    }
    if (StepEnum.EXECUTING.name().equals(type.name())) {
        return StepEnum.EXECUTING;
    }
    if (StepEnum.FINALIZING.name().equals(type.name())) {
        return StepEnum.FINALIZING;
    }
    return StepEnum.UNKNOWN;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.job.ExternalSystemType.class, to = ExternalSystemType.class)
public static String map(org.ovirt.engine.core.common.job.ExternalSystemType type) {
    switch(type) {
        case VDSM:
            return ExternalSystemType.VDSM.toString();
        case GLUSTER:
            return ExternalSystemType.GLUSTER.toString();
        default:
            return null;
    }
}
#end_block

#method_before
public Map<String, String> getMessageMap(VDSGroup cluster, GlusterAsyncTask task) {
    Map<String, String> values = new HashMap<String, String>();
    values.put(GlusterConstants.CLUSTER, cluster.getName());
    values.put(GlusterConstants.VOLUME, task.getTaskParameters().getVolumeName());
    String jobStatus = getJobStatusInfo(task);
    values.put(GlusterConstants.JOB_STATUS, jobStatus);
    values.put(GlusterConstants.JOB_INFO, task.getMessage());
    return values;
}
#method_after
public Map<String, String> getMessageMap(VDSGroup cluster, GlusterAsyncTask task) {
    Map<String, String> values = new HashMap<String, String>();
    values.put(GlusterConstants.CLUSTER, cluster.getName());
    GlusterTaskParameters params = task.getTaskParameters();
    values.put(GlusterConstants.VOLUME, params != null ? params.getVolumeName() : "");
    String jobStatus = getJobStatusInfo(task);
    values.put(GlusterConstants.JOB_STATUS, jobStatus);
    values.put(GlusterConstants.JOB_INFO, task.getMessage());
    return values;
}
#end_block

#method_before
@Override
public void Initialize() {
    log.info("Start initializing " + getClass().getSimpleName());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    log.info("Running ovirt-engine " + Config.<String>GetValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.InitDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initOsRepository();
    initSearchDependencies();
    InitHandlers();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark incomplete jobs as {0}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    Integer sessionTimeoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    Integer sessionTimeOutInvalidationInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInvalidationInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimeoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimeoutInterval, sessionTimeOutInvalidationInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    poolMonitoringJobId = SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    int autoStartVmsRunnerIntervalInSeconds = Config.<Integer>GetValue(ConfigValues.AutoStartVmsRunnerIntervalInSeconds);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(AutoStartVmsRunner.getInstance(), "startFailedAutoStartVms", new Class[] {}, new Object[] {}, autoStartVmsRunnerIntervalInSeconds, autoStartVmsRunnerIntervalInSeconds, TimeUnit.SECONDS);
    int quotaCacheIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    // initializes attestation
    initAttestation();
}
#method_after
@Override
public void Initialize() {
    log.info("Start initializing " + getClass().getSimpleName());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    log.info("Running ovirt-engine " + Config.<String>GetValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.InitDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initOsRepository();
    initSearchDependencies();
    initHandlers();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark incomplete jobs as {0}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    Integer sessionTimeoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    Integer sessionTimeOutInvalidationInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInvalidationInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimeoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimeoutInterval, sessionTimeOutInvalidationInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    poolMonitoringJobId = SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    int autoStartVmsRunnerIntervalInSeconds = Config.<Integer>GetValue(ConfigValues.AutoStartVmsRunnerIntervalInSeconds);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(AutoStartVmsRunner.getInstance(), "startFailedAutoStartVms", new Class[] {}, new Object[] {}, autoStartVmsRunnerIntervalInSeconds, autoStartVmsRunnerIntervalInSeconds, TimeUnit.SECONDS);
    int quotaCacheIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    // initializes attestation
    initAttestation();
}
#end_block

#method_before
@Override
public VdcReturnValueBase endAction(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext context) {
    CommandBase<?> command = CommandsFactory.CreateCommand(actionType, parameters);
    command.setContext(context);
    return command.endAction();
}
#method_after
@Override
public VdcReturnValueBase endAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return endAction(actionType, parameters, null);
}
#end_block

#method_before
@OnTimerMethodAnnotation("startFailedAutoStartVms")
public void startFailedAutoStartVms() {
    LinkedList<Guid> idsToRemove = new LinkedList<>();
    for (Guid vmId : autoStartVmsToRun) {
        EngineLock runVmLock = createLockForRunVmCommand(vmId);
        if (!getLockManager().acquireLock(runVmLock).getFirst()) {
            continue;
        }
        runVm(vmId, runVmLock);
        idsToRemove.add(vmId);
    }
    autoStartVmsToRun.removeAll(idsToRemove);
}
#method_after
@OnTimerMethodAnnotation("startFailedAutoStartVms")
public void startFailedAutoStartVms() {
    LinkedList<Guid> idsToRemove = new LinkedList<>();
    for (Guid vmId : autoStartVmsToRun) {
        EngineLock runVmLock = createEngineLockForRunVm(vmId, getLockMessage());
        if (!getLockManager().acquireLock(runVmLock).getFirst()) {
            continue;
        }
        runVm(vmId, runVmLock);
        idsToRemove.add(vmId);
    }
    autoStartVmsToRun.removeAll(idsToRemove);
}
#end_block

#method_before
public static void warnMemorySizeLegal(VmBase vm, Version clusterVersion) {
    if (!VmValidationUtils.isMemorySizeLegal(vm.getOsId(), vm.getMemSizeMb(), clusterVersion)) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.addCustomValue("VmName", vm.getName());
        logable.addCustomValue("VmMemInMb", String.valueOf(vm.getMemSizeMb()));
        logable.addCustomValue("VmMinMemInMb", String.valueOf(VmValidationUtils.getMinMemorySizeInMb(vm.getOsId(), clusterVersion)));
        logable.addCustomValue("VmMaxMemInMb", String.valueOf(VmValidationUtils.getMaxMemorySizeInMb(vm.getOsId(), clusterVersion)));
        AuditLogDirector.log(logable, AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE);
    }
}
#method_after
public static void warnMemorySizeLegal(VmBase vm, Version clusterVersion) {
    if (!VmValidationUtils.isMemorySizeLegal(vm.getOsId(), vm.getMemSizeMb(), clusterVersion)) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVmId(vm.getId());
        logable.addCustomValue("VmName", vm.getName());
        logable.addCustomValue("VmMemInMb", String.valueOf(vm.getMemSizeMb()));
        logable.addCustomValue("VmMinMemInMb", String.valueOf(VmValidationUtils.getMinMemorySizeInMb(vm.getOsId(), clusterVersion)));
        logable.addCustomValue("VmMaxMemInMb", String.valueOf(VmValidationUtils.getMaxMemorySizeInMb(vm.getOsId(), clusterVersion)));
        AuditLogDirector.log(logable, AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE);
    }
}
#end_block

#method_before
@SuppressWarnings("synthetic-access")
public void InitDictionaries(Version ver) {
    // init dictionaries
    _intelCpuByNameDictionary.clear();
    _amdCpuByNameDictionary.clear();
    _ibmCpuByNameDictionary.clear();
    _allCpuList.clear();
    String[] cpus = Config.<String>GetValue(ConfigValues.ServerCPUList, ver.toString()).split("[;]", -1);
    for (String cpu : cpus) {
        if (!StringUtils.isEmpty(cpu)) {
            // [0]-level, [1]-name, [2]-flags, [3]-verb, [4]-arch
            final String[] info = cpu.split("[:]", -1);
            if (info.length == 5) {
                // if no flags at all create new list instead of split
                HashSet<String> flgs = (StringUtils.isEmpty(info[2])) ? new HashSet<String>() : new HashSet<String>(Arrays.asList(info[2].split("[,]", -1)));
                String arch = info[4].trim();
                ArchitectureType archType = ArchitectureType.valueOf(arch);
                String levelString = info[0].trim();
                int level = 0;
                if (StringUtils.isNotEmpty(levelString)) {
                    level = Integer.parseInt(levelString);
                }
                ServerCpu sc = new ServerCpu(info[1], level, flgs, info[3], archType);
                if (sc.getFlags().contains(_intelFlag)) {
                    _intelCpuByNameDictionary.put(sc.getCpuName(), sc);
                } else if (sc.getFlags().contains(_amdFlag)) {
                    _amdCpuByNameDictionary.put(sc.getCpuName(), sc);
                } else if (sc.getFlags().contains(_ibmFlag)) {
                    _ibmCpuByNameDictionary.put(sc.getCpuName(), sc);
                }
                _allCpuList.add(sc);
            } else {
                log.errorFormat("Error getting info for CPU: {0}, not in expected format.", cpu);
            }
        }
    }
    _intelCpuList = new ArrayList<ServerCpu>(_intelCpuByNameDictionary.values());
    _amdCpuList = new ArrayList<ServerCpu>(_amdCpuByNameDictionary.values());
    _ibmCpuList = new ArrayList<ServerCpu>(_ibmCpuByNameDictionary.values());
    Comparator<ServerCpu> cpuComparator = new Comparator<ServerCpu>() {

        @Override
        public int compare(ServerCpu o1, ServerCpu o2) {
            return Integer.valueOf(o1.getLevel()).compareTo(o2.getLevel());
        }
    };
    // Sort by the highest cpu level so the highest cpu match will be
    // selected first
    Collections.sort(_intelCpuList, cpuComparator);
    Collections.sort(_amdCpuList, cpuComparator);
}
#method_after
@SuppressWarnings("synthetic-access")
public void InitDictionaries(Version ver) {
    // init dictionaries
    _intelCpuByNameDictionary.clear();
    _amdCpuByNameDictionary.clear();
    _ibmCpuByNameDictionary.clear();
    _allCpuList.clear();
    String[] cpus = Config.<String>GetValue(ConfigValues.ServerCPUList, ver.toString()).split("[;]", -1);
    for (String cpu : cpus) {
        if (!StringUtils.isEmpty(cpu)) {
            // [0]-level, [1]-name, [2]-flags, [3]-verb, [4]-arch
            final String[] info = cpu.split("[:]", -1);
            if (info.length == 5) {
                // if no flags at all create new list instead of split
                HashSet<String> flgs = (StringUtils.isEmpty(info[2])) ? new HashSet<String>() : new HashSet<String>(Arrays.asList(info[2].split("[,]", -1)));
                String arch = info[4].trim();
                ArchitectureType archType = ArchitectureType.valueOf(arch);
                String levelString = info[0].trim();
                int level = 0;
                if (StringUtils.isNotEmpty(levelString)) {
                    level = Integer.parseInt(levelString);
                }
                ServerCpu sc = new ServerCpu(info[1], level, flgs, info[3], archType);
                if (sc.getFlags().contains(_intelFlag)) {
                    _intelCpuByNameDictionary.put(sc.getCpuName(), sc);
                } else if (sc.getFlags().contains(_amdFlag)) {
                    _amdCpuByNameDictionary.put(sc.getCpuName(), sc);
                } else if (sc.getFlags().contains(_ibmFlag)) {
                    _ibmCpuByNameDictionary.put(sc.getCpuName(), sc);
                }
                _allCpuList.add(sc);
            } else {
                log.errorFormat("Error getting info for CPU: {0}, not in expected format.", cpu);
            }
        }
    }
    _intelCpuList = new ArrayList<ServerCpu>(_intelCpuByNameDictionary.values());
    _amdCpuList = new ArrayList<ServerCpu>(_amdCpuByNameDictionary.values());
    _ibmCpuList = new ArrayList<ServerCpu>(_ibmCpuByNameDictionary.values());
    Comparator<ServerCpu> cpuComparator = new Comparator<ServerCpu>() {

        @Override
        public int compare(ServerCpu o1, ServerCpu o2) {
            return Integer.valueOf(o1.getLevel()).compareTo(o2.getLevel());
        }
    };
    // Sort by the highest cpu level so the highest cpu match will be
    // selected first
    Collections.sort(_intelCpuList, cpuComparator);
    Collections.sort(_amdCpuList, cpuComparator);
    Collections.sort(_ibmCpuList, cpuComparator);
}
#end_block

#method_before
public ArchitectureType getArchitecture() {
    return architectureType;
}
#method_after
public ArchitectureType getArchitecture() {
    return privateArchitecture;
}
#end_block

#method_before
private boolean refreshImageDomain(final StorageDomain storageDomain, List<RepoImage> problematicRepoFileList, final ImageFileType imageType) {
    final RepoFileMetaDataDAO repoFileMetaDataDao = repoStorageDom;
    Provider provider = providerDao.get(new Guid(storageDomain.getStorage()));
    final OpenStackImageProviderProxy client = ProviderProxyFactory.getInstance().create(provider);
    Lock syncObject = getSyncObject(storageDomain.getId(), imageType);
    try {
        syncObject.lock();
        return (Boolean) TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                repoFileMetaDataDao.removeRepoDomainFileList(storageDomain.getId(), imageType);
                for (RepoImage repoImage : client.getAllImagesAsRepoImages()) {
                    repoImage.setRepoDomainId(storageDomain.getId());
                    repoFileMetaDataDao.addRepoFileMap(repoImage);
                }
                return true;
            }
        });
    } finally {
        syncObject.unlock();
    }
}
#method_after
private boolean refreshImageDomain(final StorageDomain storageDomain, List<RepoImage> problematicRepoFileList, final ImageFileType imageType) {
    final RepoFileMetaDataDAO repoFileMetaDataDao = repoStorageDom;
    Provider provider = providerDao.get(new Guid(storageDomain.getStorage()));
    final OpenStackImageProviderProxy client = ProviderProxyFactory.getInstance().create(provider);
    Lock syncObject = getSyncObject(storageDomain.getId(), imageType);
    try {
        syncObject.lock();
        return (Boolean) TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                repoFileMetaDataDao.removeRepoDomainFileList(storageDomain.getId(), imageType);
                Integer totalListSize = Config.<Integer>GetValue(ConfigValues.GlanceImageTotalListSize);
                List<RepoImage> repoImages = client.getAllImagesAsRepoImages(Config.<Integer>GetValue(ConfigValues.GlanceImageListSize), totalListSize);
                if (repoImages.size() >= totalListSize) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.addCustomValue("imageDomain", storageDomain.getName());
                    logable.addCustomValue("imageListSize", String.valueOf(repoImages.size()));
                    AuditLogDirector.log(logable, AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE);
                }
                for (RepoImage repoImage : repoImages) {
                    repoImage.setRepoDomainId(storageDomain.getId());
                    repoFileMetaDataDao.addRepoFileMap(repoImage);
                }
                return true;
            }
        });
    } finally {
        syncObject.unlock();
    }
}
#end_block

#method_before
private boolean refreshIsoDomain(Guid storageDomainId, List<RepoImage> problematicRepoFileList, ImageFileType imageType) {
    boolean refreshSucceeded = false;
    List<RepoImage> tempProblematicRepoFileList = new ArrayList<RepoImage>();
    // Fetch all the Storage pools for this Iso domain Id.
    List<StoragePoolIsoMap> isoMapList = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStorage(storageDomainId);
    log.debugFormat("Fetched {0} storage pools for {1} file type, in Iso domain {2}.", isoMapList.size(), imageType, storageDomainId);
    Iterator<StoragePoolIsoMap> iter = isoMapList.iterator();
    while (iter.hasNext() && !refreshSucceeded) {
        StoragePoolIsoMap storagePoolIsoMap = iter.next();
        Guid storagePoolId = storagePoolIsoMap.getstorage_pool_id();
        StorageDomainStatus status = storagePoolIsoMap.getstatus();
        if (status != StorageDomainStatus.Active) {
            log.debugFormat("Storage domain id {0}, is not active, and therefore could not be refreshed for {1} file type (Iso domain status is {2}).", storageDomainId, imageType, status);
        } else {
            // Try to refresh the domain of the storage pool id because its status is active.
            refreshSucceeded = refreshIsoDomainFileForStoragePool(storageDomainId, storagePoolId, imageType);
            if (!refreshSucceeded) {
                log.debugFormat("Failed refreshing Storage domain id {0}, for {1} file type in storage pool id {2}.", storageDomainId, imageType, storagePoolId);
                // set a mock repository file meta data with storage domain id and storage pool id.
                RepoImage repoImage = new RepoImage();
                repoImage.setStoragePoolId(storagePoolId);
                repoImage.setRepoDomainId(storageDomainId);
                repoImage.setFileType(imageType);
                // Add the repository file to the list of problematic Iso domains.
                tempProblematicRepoFileList.add(repoImage);
            }
        }
    }
    // If refreshed was not succeeded add the problematic storage Iso domain to the list.
    if (!refreshSucceeded) {
        problematicRepoFileList.addAll(tempProblematicRepoFileList);
    }
    return refreshSucceeded;
}
#method_after
private boolean refreshIsoDomain(Guid storageDomainId, List<RepoImage> problematicRepoFileList, ImageFileType imageType) {
    boolean refreshSucceeded = false;
    List<RepoImage> tempProblematicRepoFileList = new ArrayList<RepoImage>();
    // Fetch all the Storage pools for this Iso domain Id.
    List<StoragePoolIsoMap> isoMapList = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStorage(storageDomainId);
    log.debugFormat("Fetched {0} storage pools for {1} file type, in Iso domain {2}.", isoMapList.size(), imageType, storageDomainId);
    Iterator<StoragePoolIsoMap> iter = isoMapList.iterator();
    while (iter.hasNext() && !refreshSucceeded) {
        StoragePoolIsoMap storagePoolIsoMap = iter.next();
        Guid storagePoolId = storagePoolIsoMap.getstorage_pool_id();
        StorageDomainStatus status = storagePoolIsoMap.getStatus();
        if (status != StorageDomainStatus.Active) {
            log.debugFormat("Storage domain id {0}, is not active, and therefore could not be refreshed for {1} file type (Iso domain status is {2}).", storageDomainId, imageType, status);
        } else {
            // Try to refresh the domain of the storage pool id because its status is active.
            refreshSucceeded = refreshIsoDomainFileForStoragePool(storageDomainId, storagePoolId, imageType);
            if (!refreshSucceeded) {
                log.debugFormat("Failed refreshing Storage domain id {0}, for {1} file type in storage pool id {2}.", storageDomainId, imageType, storagePoolId);
                // set a mock repository file meta data with storage domain id and storage pool id.
                RepoImage repoImage = new RepoImage();
                repoImage.setStoragePoolId(storagePoolId);
                repoImage.setRepoDomainId(storageDomainId);
                repoImage.setFileType(imageType);
                // Add the repository file to the list of problematic Iso domains.
                tempProblematicRepoFileList.add(repoImage);
            }
        }
    }
    // If refreshed was not succeeded add the problematic storage Iso domain to the list.
    if (!refreshSucceeded) {
        problematicRepoFileList.addAll(tempProblematicRepoFileList);
    }
    return refreshSucceeded;
}
#end_block

#method_before
private static boolean refreshIsoFileListMetaData(final Guid repoStorageDomainId, final RepoFileMetaDataDAO repoFileMetaDataDao, final List<String> isoDomainList, final ImageFileType imageType) {
    Lock syncObject = getSyncObject(repoStorageDomainId, imageType);
    try {
        syncObject.lock();
        return (Boolean) TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                long currentTime = System.currentTimeMillis();
                repoFileMetaDataDao.removeRepoDomainFileList(repoStorageDomainId, imageType);
                RepoImage repo_md;
                for (String isoFile : isoDomainList) {
                    repo_md = new RepoImage();
                    repo_md.setLastRefreshed(currentTime);
                    repo_md.setSize(0);
                    repo_md.setRepoDomainId(repoStorageDomainId);
                    repo_md.setDateCreated(null);
                    repo_md.setRepoImageId(isoFile);
                    repo_md.setRepoImageName(null);
                    repo_md.setFileType(imageType);
                    repoFileMetaDataDao.addRepoFileMap(repo_md);
                }
                return true;
            }
        });
    } finally {
        syncObject.unlock();
    }
}
#method_after
private static boolean refreshIsoFileListMetaData(final Guid repoStorageDomainId, final RepoFileMetaDataDAO repoFileMetaDataDao, final Map<String, Map<String, Object>> fileStats, final ImageFileType imageType) {
    Lock syncObject = getSyncObject(repoStorageDomainId, imageType);
    try {
        syncObject.lock();
        return (Boolean) TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                long currentTime = System.currentTimeMillis();
                repoFileMetaDataDao.removeRepoDomainFileList(repoStorageDomainId, imageType);
                RepoImage repo_md;
                for (Map.Entry<String, Map<String, Object>> entry : fileStats.entrySet()) {
                    repo_md = new RepoImage();
                    repo_md.setLastRefreshed(currentTime);
                    repo_md.setSize(retrieveIsoFileSize(entry));
                    repo_md.setRepoDomainId(repoStorageDomainId);
                    repo_md.setDateCreated(null);
                    repo_md.setRepoImageId(entry.getKey());
                    repo_md.setRepoImageName(null);
                    repo_md.setFileType(imageType);
                    repoFileMetaDataDao.addRepoFileMap(repo_md);
                }
                return true;
            }
        });
    } finally {
        syncObject.unlock();
    }
}
#end_block

#method_before
private boolean updateIsoListFromVDSM(Guid repoStoragePoolId, Guid repoStorageDomainId) {
    boolean refreshIsoSucceeded = false;
    if (repoStorageDomainId != null) {
        try {
            // Get Iso domain file list from storage pool.
            VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetIsoList, new IrsBaseVDSCommandParameters(repoStoragePoolId));
            @SuppressWarnings("unchecked")
            List<String> isoDomainList = (List<String>) returnValue.getReturnValue();
            if (returnValue.getSucceeded() && isoDomainList != null) {
                log.debugFormat("The refresh process from VDSM, for Iso files succeeded.");
                // Set the Iso domain file list fetched from VDSM into the DB.
                refreshIsoSucceeded = refreshIsoFileListMetaData(repoStorageDomainId, repoStorageDom, isoDomainList, ImageFileType.ISO);
            }
        } catch (Exception e) {
            refreshIsoSucceeded = false;
            log.warnFormat("The refresh process from VDSM, for Iso files failed.");
            log.error(e);
        }
    }
    return refreshIsoSucceeded;
}
#method_after
private boolean updateIsoListFromVDSM(Guid repoStoragePoolId, Guid repoStorageDomainId) {
    boolean refreshIsoSucceeded = false;
    if (repoStorageDomainId != null) {
        try {
            // Get Iso domain file list from storage pool.
            VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetIsoList, new IrsBaseVDSCommandParameters(repoStoragePoolId));
            @SuppressWarnings("unchecked")
            Map<String, Map<String, Object>> fileStats = (Map<String, Map<String, Object>>) returnValue.getReturnValue();
            if (returnValue.getSucceeded() && fileStats != null) {
                log.debugFormat("The refresh process from VDSM, for Iso files succeeded.");
                // Set the Iso domain file list fetched from VDSM into the DB.
                refreshIsoSucceeded = refreshIsoFileListMetaData(repoStorageDomainId, repoStorageDom, fileStats, ImageFileType.ISO);
            }
        } catch (Exception e) {
            refreshIsoSucceeded = false;
            log.warnFormat("The refresh process from VDSM, for Iso files failed.");
            log.error(e);
        }
    }
    return refreshIsoSucceeded;
}
#end_block

#method_before
private boolean updateFloppyListFromVDSM(Guid repoStoragePoolId, Guid repoStorageDomainId) {
    boolean refreshFloppySucceeded = false;
    if (repoStorageDomainId != null) {
        try {
            // Get Iso domain floppy file list from storage pool.
            VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetFloppyList, new IrsBaseVDSCommandParameters(repoStoragePoolId));
            @SuppressWarnings("unchecked")
            List<String> isoDomainFloppyList = (List<String>) returnValue.getReturnValue();
            if (returnValue.getSucceeded() && isoDomainFloppyList != null) {
                // Set the Iso domain floppy file list fetched from VDSM into the DB.
                refreshFloppySucceeded = refreshIsoFileListMetaData(repoStorageDomainId, repoStorageDom, isoDomainFloppyList, ImageFileType.Floppy);
            }
            log.debugFormat("The refresh process from VDSM, for Floppy files succeeded.");
        } catch (Exception e) {
            refreshFloppySucceeded = false;
            log.warnFormat("The refresh process from VDSM, for Floppy files failed.");
            log.error(e);
        }
    }
    return refreshFloppySucceeded;
}
#method_after
private boolean updateFloppyListFromVDSM(Guid repoStoragePoolId, Guid repoStorageDomainId) {
    boolean refreshFloppySucceeded = false;
    if (repoStorageDomainId != null) {
        try {
            // Get Iso domain floppy file list from storage pool.
            VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetFloppyList, new IrsBaseVDSCommandParameters(repoStoragePoolId));
            @SuppressWarnings("unchecked")
            Map<String, Map<String, Object>> fileStats = (Map<String, Map<String, Object>>) returnValue.getReturnValue();
            if (returnValue.getSucceeded() && fileStats != null) {
                // Set the Iso domain floppy file list fetched from VDSM into the DB.
                refreshFloppySucceeded = refreshIsoFileListMetaData(repoStorageDomainId, repoStorageDom, fileStats, ImageFileType.Floppy);
            }
            log.debugFormat("The refresh process from VDSM, for Floppy files succeeded.");
        } catch (Exception e) {
            refreshFloppySucceeded = false;
            log.warnFormat("The refresh process from VDSM, for Floppy files failed.");
            log.error(e);
        }
    }
    return refreshFloppySucceeded;
}
#end_block

#method_before
public void init() {
    log.info("Initializing Scheduling manager");
    loadPolicyUnits();
    loadClusterPolicies();
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler dicovery thread");
        ExternalSchedulerDiscoveryThread discoveryThread = new ExternalSchedulerDiscoveryThread();
        discoveryThread.start();
    } else {
        log.info("External scheduler disabled, discovery skipped");
    }
    log.info("Initialized Scheduling manager");
}
#method_after
public void init() {
    log.info("Initializing Scheduling manager");
    loadPolicyUnits();
    loadClusterPolicies();
    ExternalSchedulerDiscoveryThread discoveryThread = new ExternalSchedulerDiscoveryThread();
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler dicovery thread");
        discoveryThread.start();
    } else {
        discoveryThread.markAllExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
    log.info("Initialized Scheduling manager");
}
#end_block

#method_before
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Object());
    synchronized (clusterLockMap.get(cluster.getId())) {
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        if (destHostId != null) {
            if (checkDestinationHost(vm, vdsList, destHostId, messages, policy, parameters, memoryChecker)) {
                return destHostId;
            } else if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
                return null;
            }
        }
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker);
        if (vdsList == null || vdsList.size() == 0) {
            return null;
        }
        if (policy.getFunctions() == null || policy.getFunctions().isEmpty()) {
            return vdsList.get(0).getId();
        }
        Guid bestHost = runFunctions(policy.getFunctions(), vdsList, vm, parameters);
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), vm.getVmMemSizeMb(), vm.getNumOfCpus());
        }
        return bestHost;
    }
}
#method_after
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Object());
    synchronized (clusterLockMap.get(cluster.getId())) {
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.size() == 0) {
            return null;
        }
        // it passed filters return it
        if (destHostId != null) {
            for (VDS vds : vdsList) {
                if (destHostId.equals(vds.getId())) {
                    return destHostId;
                }
            }
        }
        if (policy.getFunctions() == null || policy.getFunctions().isEmpty()) {
            return vdsList.get(0).getId();
        }
        Guid bestHost = runFunctions(policy.getFunctions(), vdsList, vm, parameters);
        if (bestHost == null && vdsList.size() > 0) {
            bestHost = vdsList.get(0).getId();
        }
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), vm.getVmMemSizeMb(), vm.getNumOfCpus());
        }
        return bestHost;
    }
}
#end_block

#method_before
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVdsId, List<String> messages) {
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    if (destVdsId != null) {
        if (checkDestinationHost(vm, vdsList, destVdsId, messages, policy, parameters, noWaitingMemoryChecker)) {
            return true;
        } else if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
            return false;
        }
    }
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker);
    if (vdsList == null || vdsList.size() == 0) {
        return false;
    }
    return true;
}
#method_after
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVdsId, List<String> messages) {
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, false, null);
    if (vdsList == null || vdsList.size() == 0) {
        return false;
    }
    return true;
}
#end_block

#method_before
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker) {
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<PolicyUnitImpl>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<PolicyUnitImpl>();
    sortFilters(filters, filterPositionMap);
    if (filters != null) {
        for (Guid filter : filters) {
            PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
            if (filterPolicyUnit.isInternal()) {
                internalFilters.add(filterPolicyUnit);
            } else {
                if (filterPolicyUnit.isEnabled()) {
                    externalFilters.add(filterPolicyUnit);
                }
            }
        }
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, messages, memoryChecker);
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled) && externalFilters.size() > 0 && hostList != null && hostList.size() > 0) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages);
    }
    return hostList;
}
#method_after
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<PolicyUnitImpl>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<PolicyUnitImpl>();
    sortFilters(filters, filterPositionMap);
    if (filters != null) {
        for (Guid filter : filters) {
            PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
            if (filterPolicyUnit.isInternal()) {
                internalFilters.add(filterPolicyUnit);
            } else {
                if (filterPolicyUnit.isEnabled()) {
                    externalFilters.add(filterPolicyUnit);
                }
            }
        }
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, messages, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled) && externalFilters.size() > 0 && hostList != null && hostList.size() > 0) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList == null || hostList.size() == 0) {
        messages.add(VdcBllMessages.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#end_block

#method_before
private List<VDS> runInternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker) {
    if (filters != null) {
        for (PolicyUnitImpl filterPolicyUnit : filters) {
            if (hostList == null || hostList.isEmpty()) {
                break;
            }
            filterPolicyUnit.setMemoryChecker(memoryChecker);
            hostList = filterPolicyUnit.filter(hostList, vm, parameters, messages);
        }
    }
    return hostList;
}
#method_after
private List<VDS> runInternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId, SchedulingResult result) {
    if (filters != null) {
        for (PolicyUnitImpl filterPolicyUnit : filters) {
            if (hostList == null || hostList.isEmpty()) {
                break;
            }
            filterPolicyUnit.setMemoryChecker(memoryChecker);
            List<VDS> currentHostList = new ArrayList<VDS>(hostList);
            hostList = filterPolicyUnit.filter(hostList, vm, parameters, messages);
            logFilterActions(currentHostList, toIdSet(hostList), VdcBllMessages.VAR__FILTERTYPE__INTERNAL, filterPolicyUnit.getName(), result, correlationId);
        }
    }
    return hostList;
}
#end_block

#method_before
private List<VDS> runExternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, List<String> messages) {
    List<Guid> filteredIDs = null;
    if (filters != null) {
        List<String> filterNames = new ArrayList<String>();
        for (PolicyUnitImpl filter : filters) {
            filterNames.add(filter.getName());
        }
        List<Guid> hostIDs = new ArrayList<Guid>();
        for (VDS host : hostList) {
            hostIDs.add(host.getId());
        }
        filteredIDs = ExternalSchedulerFactory.getInstance().runFilters(filterNames, hostIDs, vm.getId(), parameters);
    }
    return intersectHosts(hostList, filteredIDs);
}
#method_after
private List<VDS> runExternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, List<String> messages, String correlationId, SchedulingResult result) {
    List<Guid> filteredIDs = null;
    if (filters != null) {
        List<String> filterNames = new ArrayList<String>();
        for (PolicyUnitImpl filter : filters) {
            filterNames.add(filter.getName());
        }
        List<Guid> hostIDs = new ArrayList<Guid>();
        for (VDS host : hostList) {
            hostIDs.add(host.getId());
        }
        filteredIDs = ExternalSchedulerFactory.getInstance().runFilters(filterNames, hostIDs, vm.getId(), parameters);
        if (filteredIDs != null) {
            logFilterActions(hostList, new HashSet<Guid>(filteredIDs), VdcBllMessages.VAR__FILTERTYPE__EXTERNAL, Arrays.toString(filterNames.toArray()), result, correlationId);
        }
    }
    return intersectHosts(hostList, filteredIDs);
}
#end_block

#method_before
@OnTimerMethodAnnotation("PerformLoadBalancing")
public void PerformLoadBalancing() {
    log.debugFormat("Load Balancer timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    for (VDSGroup cluster : clusters) {
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        PolicyUnitImpl policyUnit = policyUnits.get(policy.getBalance());
        Pair<List<Guid>, Guid> balanceResult = null;
        if (policyUnit.isEnabled()) {
            List<VDS> hosts = getVdsDAO().getAllForVdsGroupWithoutMigrating(cluster.getId());
            if (policyUnit.isInternal()) {
                balanceResult = internalRunBalance(policyUnit, cluster, hosts);
            } else if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled)) {
                balanceResult = externalRunBalance(policyUnit, cluster, hosts);
            }
        }
        if (balanceResult != null && balanceResult.getSecond() != null) {
            migrationHandler.migrateVM((ArrayList<Guid>) balanceResult.getFirst(), balanceResult.getSecond());
        }
    }
}
#method_after
@OnTimerMethodAnnotation("PerformLoadBalancing")
public void PerformLoadBalancing() {
    log.debugFormat("Load Balancer timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    for (VDSGroup cluster : clusters) {
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        PolicyUnitImpl policyUnit = policyUnits.get(policy.getBalance());
        Pair<List<Guid>, Guid> balanceResult = null;
        if (policyUnit.isEnabled()) {
            List<VDS> hosts = getVdsDAO().getAllForVdsGroupWithoutMigrating(cluster.getId());
            if (policyUnit.isInternal()) {
                balanceResult = internalRunBalance(policyUnit, cluster, hosts);
            } else if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled)) {
                balanceResult = externalRunBalance(policyUnit, cluster, hosts);
            }
        }
        if (balanceResult != null && balanceResult.getSecond() != null) {
            migrationHandler.migrateVM(balanceResult.getFirst(), balanceResult.getSecond());
        }
    }
}
#end_block

#method_before
@Test
public void testDoNotUpdateDeviceWhenReadOnlyIsNotChanged() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(false);
    DiskImage diskFromDb = createDiskImage();
    diskFromDb.setReadOnly(false);
    when(diskDao.get(diskImageGuid)).thenReturn(diskFromDb);
    initializeCommand(parameters);
    command.executeVmCommand();
    verify(vmDeviceDAO, never()).update(any(VmDevice.class));
}
#method_after
@Test
public void testDoNotUpdateDeviceWhenReadOnlyIsNotChanged() {
    // New disk is a read write
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setReadOnly(false);
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    // Disk is already attached to VM as a read write
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    // To be sure that readOnly property is not changed
    assertEquals(device.getIsReadOnly(), parameters.getDiskInfo().getReadOnly());
    initializeCommand(parameters);
    command.executeVmCommand();
    assertFalse(command.shouldUpdateReadOnly());
    verify(command, atLeast(1)).shouldUpdateReadOnly();
    verify(vmDeviceDAO, never()).update(any(VmDevice.class));
}
#end_block

#method_before
private GlusterVolumeRemoveBricksParameters toParameters(Action action) {
    GlusterVolumeRemoveBricksParameters params = new GlusterVolumeRemoveBricksParameters();
    List<GlusterBrickEntity> entityBricks = new ArrayList<GlusterBrickEntity>();
    for (GlusterBrick brick : action.getBricks().getGlusterBricks()) {
        GlusterBrickEntity entity = new GlusterBrickEntity();
        entity.setBrickDirectory(brick.getBrickDir());
        entity.setVolumeId(new Guid(getVolumeId()));
        if (brick.getId() != null) {
            entity.setId(new Guid(brick.getId()));
        } else {
            entity.setId(null);
        }
        if (brick.getName() != null) {
            String[] arr = brick.getName().split("\\:");
            if (arr.length > 1) {
                entity.setServerName(arr[0]);
                entity.setBrickDirectory(arr[1]);
            }
        }
        entityBricks.add(entity);
    }
    params.setVolumeId(new Guid(getVolumeId()));
    params.setBricks(entityBricks);
    params.setCommandType(VdcActionType.StartRemoveGlusterVolumeBricks);
    return params;
}
#method_after
private GlusterVolumeRemoveBricksParameters toParameters(Action action) {
    GlusterVolumeRemoveBricksParameters params = new GlusterVolumeRemoveBricksParameters();
    List<GlusterBrickEntity> entityBricks = new ArrayList<GlusterBrickEntity>();
    for (GlusterBrick brick : action.getBricks().getGlusterBricks()) {
        GlusterBrickEntity entity = new GlusterBrickEntity();
        entity.setBrickDirectory(brick.getBrickDir());
        entity.setVolumeId(new Guid(getVolumeId()));
        if (brick.getName() != null) {
            String[] arr = brick.getName().split("\\:");
            if (arr.length > 1) {
                entity.setServerName(arr[0]);
                entity.setBrickDirectory(arr[1]);
            } else {
                continue;
            }
        }
        entityBricks.add(entity);
    }
    params.setVolumeId(asGuid(getVolumeId()));
    params.setBricks(entityBricks);
    params.setCommandType(VdcActionType.StartRemoveGlusterVolumeBricks);
    return params;
}
#end_block

#method_before
@Override
public Response migrate(Action action) {
    validateParameters(action, "bricks");
    GlusterVolumeRemoveBricksParameters params = toParameters(action);
    return performAction(VdcActionType.StartRemoveGlusterVolumeBricks, params, action, false);
}
#method_after
@Override
public Response migrate(Action action) {
    validateParameters(action, "bricks");
    validateBrickNames(action);
    GlusterVolumeRemoveBricksParameters params = toParameters(action);
    return performAction(VdcActionType.StartRemoveGlusterVolumeBricks, params, action, false);
}
#end_block

#method_before
@Override
public Response stopMigrate(Action action) {
    validateParameters(action, "bricks");
    GlusterVolumeRemoveBricksParameters params = toParameters(action);
    return performAction(VdcActionType.StopRemoveGlusterVolumeBricks, params, action, false);
}
#method_after
@Override
public Response stopMigrate(Action action) {
    validateParameters(action, "bricks");
    validateBrickNames(action);
    GlusterVolumeRemoveBricksParameters params = toParameters(action);
    return performAction(VdcActionType.StopRemoveGlusterVolumeBricks, params, action, false);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public GlusterBricks list() {
    boolean flag = QueryHelper.hasMatrixParam(getUriInfo(), "force");
    List<GlusterBrickEntity> bricks = getBackendCollection(VdcQueryType.GetGlusterVolumeBricks, new IdQueryParameters(asGuid(getVolumeId())));
    GlusterBricks bricksModel = mapCollection(bricks);
    return addActions(bricksModel);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public GlusterBricks list() {
    List<GlusterBrickEntity> bricks = getBackendCollection(VdcQueryType.GetGlusterVolumeBricks, new IdQueryParameters(asGuid(getVolumeId())));
    GlusterBricks bricksModel = mapCollection(bricks);
    return addActions(bricksModel);
}
#end_block

#method_before
@Override
public Response remove(GlusterBricks bricks) {
    if (bricks.getGlusterBricks().size() > 0) {
        for (GlusterBrick brick : bricks.getGlusterBricks()) {
            validateParameters(brick, "id|name");
        }
    }
    int replicaCount = bricks.isSetReplicaCount() ? bricks.getReplicaCount() : 0;
    GlusterVolumeRemoveBricksParameters params = toParameters(bricks);
    params.setReplicaCount(replicaCount);
    GlusterVolumeEntity volume = getEntity(GlusterVolumeEntity.class, VdcQueryType.GetGlusterVolumeById, new IdQueryParameters(asGuid(getVolumeId())), "");
    if (volume.getAsyncTask() != null && volume.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK && volume.getAsyncTask().getStatus() == JobExecutionStatus.FINISHED) {
        return performAction(VdcActionType.CommitRemoveGlusterVolumeBricks, params);
    } else {
        return performAction(VdcActionType.GlusterVolumeRemoveBricks, params);
    }
// // if (isForceRemove()) {
// if (QueryHelper.hasMatrixParam(uriInfo, FORCE_CONSTRAINT)) {
// return performAction(VdcActionType.GlusterVolumeRemoveBricks, params);
// } else {
// return performAction(VdcActionType.CommitRemoveGlusterVolumeBricks, params);
// }
}
#method_after
@Override
public Response remove(GlusterBricks bricks) {
    if (bricks.getGlusterBricks().size() > 0) {
        for (GlusterBrick brick : bricks.getGlusterBricks()) {
            validateParameters(brick, "id|name");
        }
    }
    int replicaCount = bricks.isSetReplicaCount() ? bricks.getReplicaCount() : 0;
    GlusterVolumeRemoveBricksParameters params = toParameters(bricks);
    params.setReplicaCount(replicaCount);
    GlusterVolumeEntity volume = getEntity(GlusterVolumeEntity.class, VdcQueryType.GetGlusterVolumeById, new IdQueryParameters(asGuid(getVolumeId())), "");
    if (volume.getAsyncTask() != null && volume.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK && volume.getAsyncTask().getStatus() == JobExecutionStatus.FINISHED) {
        return performAction(VdcActionType.CommitRemoveGlusterVolumeBricks, params);
    } else {
        return performAction(VdcActionType.GlusterVolumeRemoveBricks, params);
    }
}
#end_block

#method_before
@Override
public Response migrate(Action action) {
    validateParameters(action, "bricks");
    validateBrickNames(action);
    GlusterVolumeRemoveBricksParameters params = toParameters(action);
    return performAction(VdcActionType.StartRemoveGlusterVolumeBricks, params, action, false);
}
#method_after
@Override
public Response migrate(Action action) {
    validateParameters(action, "bricks");
    validateBrickNames(action);
    GlusterVolumeRemoveBricksParameters params = toParameters(action.getBricks());
    return performAction(VdcActionType.StartRemoveGlusterVolumeBricks, params, action, false);
}
#end_block

#method_before
@Override
public Response stopMigrate(Action action) {
    validateParameters(action, "bricks");
    validateBrickNames(action);
    GlusterVolumeRemoveBricksParameters params = toParameters(action);
    return performAction(VdcActionType.StopRemoveGlusterVolumeBricks, params, action, false);
}
#method_after
@Override
public Response stopMigrate(Action action) {
    validateParameters(action, "bricks");
    validateBrickNames(action);
    GlusterVolumeRemoveBricksParameters params = toParameters(action.getBricks());
    return performAction(VdcActionType.StopRemoveGlusterVolumeBricks, params, action, false);
}
#end_block

#method_before
@Test
public void testMigrate() throws Exception {
    GlusterBrick brick = new GlusterBrick();
    GlusterVolume volume = new GlusterVolume();
    brick.setId(GUIDS[0].toString());
    brick.setBrickDir(brickDir);
    brick.setServerId(serverId.toString());
    volume.setId(volumeId.toString());
    brick.setGlusterVolume(volume);
    GlusterBricks bricks = control.createMock(GlusterBricks.class);
    expect(bricks.getGlusterBricks()).andReturn(Collections.singletonList(brick)).anyTimes();
    setUriInfo(setUpActionExpectations(VdcActionType.StartRemoveGlusterVolumeBricks, GlusterVolumeRemoveBricksParameters.class, // new Object[] {volumeId, getBricksToRemove()},
    new String[] {}, new Object[] {}, true, true));
    Action action = new Action();
    action.setBricks(bricks);
    collection.migrate(action);
}
#method_after
@Test
public void testMigrate() throws Exception {
    GlusterBrick brick = new GlusterBrick();
    GlusterVolume volume = new GlusterVolume();
    brick.setName(serverName + ":" + brickDir);
    volume.setId(volumeId.toString());
    brick.setGlusterVolume(volume);
    GlusterBricks bricks = control.createMock(GlusterBricks.class);
    expect(bricks.getGlusterBricks()).andReturn(Collections.singletonList(brick)).anyTimes();
    setUriInfo(setUpActionExpectations(VdcActionType.StartRemoveGlusterVolumeBricks, GlusterVolumeRemoveBricksParameters.class, new String[] {}, new Object[] {}, true, true));
    Action action = new Action();
    action.setBricks(bricks);
    collection.migrate(action);
}
#end_block

#method_before
private GlusterVolumeRemoveBricksParameters toParameters(Action action) {
    GlusterVolumeRemoveBricksParameters params = new GlusterVolumeRemoveBricksParameters();
    List<GlusterBrickEntity> entityBricks = new ArrayList<GlusterBrickEntity>();
    for (GlusterBrick brick : action.getBricks().getGlusterBricks()) {
        GlusterBrickEntity entity = new GlusterBrickEntity();
        entity.setBrickDirectory(brick.getBrickDir());
        entity.setVolumeId(new Guid(getVolumeId()));
        if (brick.getId() != null) {
            entity.setId(new Guid(brick.getId()));
        } else {
            entity.setId(null);
        }
        if (brick.getName() != null) {
            String[] arr = brick.getName().split("\\:");
            if (arr.length > 1) {
                entity.setServerName(arr[0]);
                entity.setBrickDirectory(arr[1]);
            }
        }
        entityBricks.add(entity);
    }
    params.setVolumeId(new Guid(getVolumeId()));
    params.setBricks(entityBricks);
    params.setCommandType(VdcActionType.StartRemoveGlusterVolumeBricks);
    return params;
}
#method_after
private GlusterVolumeRemoveBricksParameters toParameters(Action action) {
    GlusterVolumeRemoveBricksParameters params = new GlusterVolumeRemoveBricksParameters();
    List<GlusterBrickEntity> entityBricks = new ArrayList<GlusterBrickEntity>();
    for (GlusterBrick brick : action.getBricks().getGlusterBricks()) {
        GlusterBrickEntity entity = new GlusterBrickEntity();
        entity.setBrickDirectory(brick.getBrickDir());
        entity.setVolumeId(new Guid(getVolumeId()));
        if (brick.getName() != null) {
            String[] arr = brick.getName().split("\\:");
            if (arr.length > 1) {
                entity.setServerName(arr[0]);
                entity.setBrickDirectory(arr[1]);
            } else {
                continue;
            }
        }
        entityBricks.add(entity);
    }
    params.setVolumeId(asGuid(getVolumeId()));
    params.setBricks(entityBricks);
    params.setCommandType(VdcActionType.StartRemoveGlusterVolumeBricks);
    return params;
}
#end_block

#method_before
@Override
public Response migrate(Action action) {
    validateParameters(action, "bricks");
    GlusterVolumeRemoveBricksParameters params = toParameters(action);
    return performAction(VdcActionType.StartRemoveGlusterVolumeBricks, params, action, false);
}
#method_after
@Override
public Response migrate(Action action) {
    validateParameters(action, "bricks");
    validateBrickNames(action);
    GlusterVolumeRemoveBricksParameters params = toParameters(action);
    return performAction(VdcActionType.StartRemoveGlusterVolumeBricks, params, action, false);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((clusterId == null) ? 0 : clusterId.hashCode());
    result = prime * result + ((volumeType == null) ? 0 : volumeType.hashCode());
    result = prime * result + ((transportTypes == null) ? 0 : transportTypes.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((replicaCount == null) ? 0 : replicaCount.hashCode());
    result = prime * result + ((stripeCount == null) ? 0 : stripeCount.hashCode());
    result = prime * result + ((options == null) ? 0 : options.hashCode());
    result = prime * result + ((accessProtocols == null) ? 0 : accessProtocols.hashCode());
    result = prime * result + ((bricks == null) ? 0 : bricks.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((clusterId == null) ? 0 : clusterId.hashCode());
    result = prime * result + ((volumeType == null) ? 0 : volumeType.hashCode());
    result = prime * result + ((transportTypes == null) ? 0 : transportTypes.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((replicaCount == null) ? 0 : replicaCount.hashCode());
    result = prime * result + ((stripeCount == null) ? 0 : stripeCount.hashCode());
    result = prime * result + ((options == null) ? 0 : options.hashCode());
    result = prime * result + ((accessProtocols == null) ? 0 : accessProtocols.hashCode());
    result = prime * result + ((bricks == null) ? 0 : bricks.hashCode());
    result = prime * result + ((asyncTask == null) ? 0 : asyncTask.hashCode());
    return result;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + getId().hashCode();
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    result = prime * result + ((serverId == null) ? 0 : serverId.hashCode());
    result = prime * result + ((brickDirectory == null) ? 0 : brickDirectory.hashCode());
    result = prime * result + ((brickOrder == null) ? 0 : brickOrder.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + getId().hashCode();
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    result = prime * result + ((serverId == null) ? 0 : serverId.hashCode());
    result = prime * result + ((brickDirectory == null) ? 0 : brickDirectory.hashCode());
    result = prime * result + ((brickOrder == null) ? 0 : brickOrder.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((asyncTask == null) ? 0 : asyncTask.hashCode());
    return result;
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    setHash(getHashName() + new Date());
    // Add progress listeners
    Frontend.getQueryStartedEvent().addListener(this);
    Frontend.getQueryCompleteEvent().addListener(this);
    Frontend.subscribeAdditionalQueries(new VdcQueryType[] { VdcQueryType.Search, VdcQueryType.GetStoragePoolById, VdcQueryType.GetNextAvailableDiskAliasNameByVMId, VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, VdcQueryType.GetAllVdsByStoragePool, VdcQueryType.GetAllAttachableDisks, VdcQueryType.GetAllDisksByVmId, VdcQueryType.GetAllRelevantQuotasForStorage });
    // Create and set commands
    // $NON-NLS-1$
    UICommand onSaveCommand = new UICommand("OnSave", this);
    onSaveCommand.setTitle(CONSTANTS.ok());
    onSaveCommand.setIsDefault(true);
    getCommands().add(onSaveCommand);
    getCommands().add(getCancelCommand());
    // Update data
    if (getVm() != null) {
        updateBootableDiskAvailable();
    }
    updateDatacenters();
}
#method_after
@Override
public void initialize() {
    super.initialize();
    setHash(getHashName() + new Date());
    // Add progress listeners
    Frontend.getInstance().getQueryStartedEvent().addListener(this);
    Frontend.getInstance().getQueryCompleteEvent().addListener(this);
    Frontend.getInstance().subscribeAdditionalQueries(new VdcQueryType[] { VdcQueryType.Search, VdcQueryType.GetStoragePoolById, VdcQueryType.GetNextAvailableDiskAliasNameByVMId, VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, VdcQueryType.GetAllVdsByStoragePool, VdcQueryType.GetAllAttachableDisks, VdcQueryType.GetAllDisksByVmId, VdcQueryType.GetAllRelevantQuotasForStorage, VdcQueryType.OsRepository });
    // Create and set commands
    // $NON-NLS-1$
    UICommand onSaveCommand = new UICommand("OnSave", this);
    onSaveCommand.setTitle(CONSTANTS.ok());
    onSaveCommand.setIsDefault(true);
    getCommands().add(onSaveCommand);
    getCommands().add(getCancelCommand());
    // Update data
    if (getVm() != null) {
        updateBootableDiskAvailable();
    }
    updateDatacenters();
}
#end_block

#method_before
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            diskModel.getIsBootable().setEntity(true);
            for (Disk disk : disks) {
                if (disk.isBoot() && !disk.equals(getDisk())) {
                    diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                    diskModel.getIsBootable().setEntity(false);
                    diskModel.getIsBootable().setIsChangable(false);
                    break;
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#method_after
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            diskModel.getIsBootable().setEntity(true);
            if (getDisk() == null || !getDisk().isDiskSnapshot()) {
                for (Disk disk : disks) {
                    if (disk.isBoot() && !disk.equals(getDisk())) {
                        diskModel.getIsBootable().setEntity(false);
                        if (!disk.isDiskSnapshot()) {
                            diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                            diskModel.getIsBootable().setIsChangable(false);
                            break;
                        }
                    }
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#end_block

#method_before
public void updateInterface(Version clusterVersion) {
    final ArrayList<DiskInterface> diskInterfaces = AsyncDataProvider.getDiskInterfaceList(clusterVersion);
    if (getVm() != null) {
        AsyncDataProvider.isVirtioScsiEnabledForVm(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                if (Boolean.FALSE.equals(returnValue)) {
                    diskInterfaces.remove(DiskInterface.VirtIO_SCSI);
                }
                setInterfaces(diskInterfaces);
            }
        }), getVm().getId());
    } else {
        setInterfaces(diskInterfaces);
    }
}
#method_after
public void updateInterface(final Version clusterVersion) {
    if (getVm() != null) {
        AsyncDataProvider.isVirtioScsiEnabledForVm(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue1) {
                final boolean isVirtioScsiDisabled = Boolean.FALSE.equals(returnValue1);
                AsyncQuery asyncQuery = new AsyncQuery(this, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue2) {
                        ArrayList<DiskInterface> diskInterfaces = (ArrayList<DiskInterface>) returnValue2;
                        if (isVirtioScsiDisabled) {
                            diskInterfaces.remove(DiskInterface.VirtIO_SCSI);
                        }
                        setInterfaces(diskInterfaces);
                    }
                });
                AsyncDataProvider.getDiskInterfaceList(getVm().getOs(), clusterVersion, asyncQuery);
            }
        }), getVm().getId());
    } else {
        setInterfaces(AsyncDataProvider.getDiskInterfaceList());
    }
}
#end_block

#method_before
public void onSave() {
    boolean isInternal = (Boolean) getIsInternal().getEntity();
    if (isInternal) {
        DiskImage diskImage = getDiskImage();
        if (getQuota().getIsAvailable() && getQuota().getSelectedItem() != null) {
            diskImage.setQuotaId(((Quota) getQuota().getSelectedItem()).getId());
        }
        long sizeToAddInGigabytes = Long.valueOf((String) getSizeExtend().getEntity());
        if (sizeToAddInGigabytes > 0) {
            diskImage.setSizeInGigabytes(diskImage.getSizeInGigabytes() + sizeToAddInGigabytes);
        }
        setDisk(diskImage);
    } else {
        LunDisk lunDisk = getLunDisk();
        DiskInterface diskInterface = (DiskInterface) getDiskInterface().getSelectedItem();
        if (DiskInterface.VirtIO_SCSI.equals(diskInterface)) {
            lunDisk.setSgio(Boolean.TRUE.equals((Boolean) getIsSgIoUnfiltered().getEntity()) ? ScsiGenericIO.UNFILTERED : ScsiGenericIO.FILTERED);
        }
        setDisk(lunDisk);
    }
    getDisk().setDiskAlias((String) getAlias().getEntity());
    getDisk().setDiskDescription((String) getDescription().getEntity());
    getDisk().setDiskInterface((DiskInterface) getDiskInterface().getSelectedItem());
    getDisk().setWipeAfterDelete((Boolean) getIsWipeAfterDelete().getEntity());
    getDisk().setBoot((Boolean) getIsBootable().getEntity());
    getDisk().setShareable((Boolean) getIsShareable().getEntity());
    getDisk().setPlugged((Boolean) getIsPlugged().getEntity());
    getDisk().setPropagateErrors(PropagateErrors.Off);
    if (getIsReadOnly().getIsAvailable()) {
        getDisk().setReadOnly((Boolean) getIsReadOnly().getEntity());
    } else {
        getDisk().setReadOnly(false);
    }
}
#method_after
public void onSave() {
    boolean isInternal = (Boolean) getIsInternal().getEntity();
    if (isInternal) {
        DiskImage diskImage = getDiskImage();
        if (getQuota().getIsAvailable() && getQuota().getSelectedItem() != null) {
            diskImage.setQuotaId(((Quota) getQuota().getSelectedItem()).getId());
        }
        long sizeToAddInGigabytes = Long.valueOf((String) getSizeExtend().getEntity());
        if (sizeToAddInGigabytes > 0) {
            diskImage.setSizeInGigabytes(diskImage.getSizeInGigabytes() + sizeToAddInGigabytes);
        }
        setDisk(diskImage);
    } else {
        LunDisk lunDisk = getLunDisk();
        DiskInterface diskInterface = (DiskInterface) getDiskInterface().getSelectedItem();
        if (DiskInterface.VirtIO_SCSI.equals(diskInterface)) {
            lunDisk.setSgio(Boolean.TRUE.equals(getIsSgIoUnfiltered().getEntity()) ? ScsiGenericIO.UNFILTERED : ScsiGenericIO.FILTERED);
        }
        setDisk(lunDisk);
    }
    getDisk().setDiskAlias((String) getAlias().getEntity());
    getDisk().setDiskDescription((String) getDescription().getEntity());
    getDisk().setDiskInterface((DiskInterface) getDiskInterface().getSelectedItem());
    getDisk().setWipeAfterDelete((Boolean) getIsWipeAfterDelete().getEntity());
    getDisk().setBoot((Boolean) getIsBootable().getEntity());
    getDisk().setShareable((Boolean) getIsShareable().getEntity());
    getDisk().setPlugged((Boolean) getIsPlugged().getEntity());
    getDisk().setPropagateErrors(PropagateErrors.Off);
    getDisk().setReadOnly(getIsReadOnly().getIsAvailable() ? (Boolean) getIsReadOnly().getEntity() : null);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsWipeAfterDelete()) {
        wipeAfterDelete_EntityChanged(args);
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsAttachDisk()) {
        attachDisk_EntityChanged(args);
    } else if (ev.matchesDefinition(ListModel.EntityChangedEventDefinition) && sender == getIsInternal()) {
        isInternal_EntityChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getStorageDomain()) {
        storageDomain_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsWipeAfterDelete()) {
        wipeAfterDelete_EntityChanged(args);
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsAttachDisk()) {
        attachDisk_EntityChanged(args);
    } else if (ev.matchesDefinition(ListModel.EntityChangedEventDefinition) && sender == getIsInternal()) {
        isInternal_EntityChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getStorageDomain()) {
        storageDomain_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    disableNonChangeableEntities();
    getAlias().setEntity(getDisk().getDiskAlias());
    getDescription().setEntity(getDisk().getDiskDescription());
    getIsShareable().setEntity(getDisk().isShareable());
    getIsWipeAfterDelete().setEntity(getDisk().isWipeAfterDelete());
    getIsSgIoUnfiltered().setEntity(getDisk().getSgio() == ScsiGenericIO.UNFILTERED);
    getIsReadOnly().setEntity(getDisk().getReadOnly());
    if (getDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) getDisk();
        getSize().setEntity(diskImage.getSizeInGigabytes());
        getIsInternal().setEntity(true);
        getVolumeType().setSelectedItem(diskImage.getVolumeType());
        setVolumeFormat(diskImage.getVolumeFormat());
        boolean isExtendImageSizeEnabled = getVm() != null && VdcActionUtils.canExecute(Arrays.asList(getVm()), VM.class, VdcActionType.ExtendImageSize);
        getSizeExtend().setIsChangable(isExtendImageSizeEnabled);
        Guid storageDomainId = diskImage.getStorageIds().get(0);
        AsyncDataProvider.getStorageDomainById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                DiskModel diskModel = (DiskModel) target;
                StorageDomain storageDomain = (StorageDomain) returnValue;
                diskModel.getStorageDomain().setSelectedItem(storageDomain);
            }
        }, getHash()), storageDomainId);
    } else {
        LunDisk lunDisk = (LunDisk) getDisk();
        getSize().setEntity(lunDisk.getLun().getDeviceSize());
        getIsInternal().setEntity(false);
        getSizeExtend().setIsAvailable(false);
    }
}
#method_after
@Override
public void initialize() {
    super.initialize();
    disableNonChangeableEntities();
    getAlias().setEntity(getDisk().getDiskAlias());
    getDescription().setEntity(getDisk().getDiskDescription());
    getIsShareable().setEntity(getDisk().isShareable());
    getIsWipeAfterDelete().setEntity(getDisk().isWipeAfterDelete());
    getIsSgIoUnfiltered().setEntity(getDisk().getSgio() == ScsiGenericIO.UNFILTERED);
    getIsReadOnly().setEntity(getDisk().getReadOnly());
    if (getDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) getDisk();
        getSize().setEntity(diskImage.getSizeInGigabytes());
        getIsInternal().setEntity(true);
        getVolumeType().setSelectedItem(diskImage.getVolumeType());
        setVolumeFormat(diskImage.getVolumeFormat());
        boolean isExtendImageSizeEnabled = getVm() != null && !diskImage.isDiskSnapshot() && VdcActionUtils.canExecute(Arrays.asList(getVm()), VM.class, VdcActionType.ExtendImageSize);
        getSizeExtend().setIsChangable(isExtendImageSizeEnabled);
        Guid storageDomainId = diskImage.getStorageIds().get(0);
        AsyncDataProvider.getStorageDomainById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                DiskModel diskModel = (DiskModel) target;
                StorageDomain storageDomain = (StorageDomain) returnValue;
                diskModel.getStorageDomain().setSelectedItem(storageDomain);
            }
        }, getHash()), storageDomainId);
    } else {
        LunDisk lunDisk = (LunDisk) getDisk();
        getSize().setEntity(lunDisk.getLun().getDeviceSize());
        getIsInternal().setEntity(false);
        getSizeExtend().setIsAvailable(false);
    }
}
#end_block

#method_before
private void onAttachDisks() {
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> paramerterList = new ArrayList<VdcActionParametersBase>();
    ArrayList<IFrontendActionAsyncCallback> callbacks = new ArrayList<IFrontendActionAsyncCallback>();
    IFrontendActionAsyncCallback onFinishCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            NewDiskModel diskModel = (NewDiskModel) result.getState();
            diskModel.stopProgress();
            diskModel.cancel();
        }
    };
    ArrayList<EntityModel> disksToAttach = (Boolean) getIsInternal().getEntity() ? (ArrayList<EntityModel>) getInternalAttachableDisks().getSelectedItems() : (ArrayList<EntityModel>) getExternalAttachableDisks().getSelectedItems();
    for (int i = 0; i < disksToAttach.size(); i++) {
        DiskModel disk = (DiskModel) disksToAttach.get(i).getEntity();
        AttachDettachVmDiskParameters parameters = new AttachDettachVmDiskParameters(getVm().getId(), disk.getDisk().getId(), (Boolean) getIsPlugged().getEntity(), (Boolean) getIsReadOnly().getEntity());
        actionTypes.add(VdcActionType.AttachDiskToVm);
        paramerterList.add(parameters);
        callbacks.add(i == disksToAttach.size() - 1 ? onFinishCallback : null);
    }
    startProgress(null);
    Frontend.RunMultipleActions(actionTypes, paramerterList, callbacks, null, this);
}
#method_after
private void onAttachDisks() {
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> paramerterList = new ArrayList<VdcActionParametersBase>();
    ArrayList<IFrontendActionAsyncCallback> callbacks = new ArrayList<IFrontendActionAsyncCallback>();
    IFrontendActionAsyncCallback onFinishCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            NewDiskModel diskModel = (NewDiskModel) result.getState();
            diskModel.stopProgress();
            diskModel.cancel();
        }
    };
    ArrayList<EntityModel> disksToAttach = (Boolean) getIsInternal().getEntity() ? (ArrayList<EntityModel>) getInternalAttachableDisks().getSelectedItems() : (ArrayList<EntityModel>) getExternalAttachableDisks().getSelectedItems();
    for (int i = 0; i < disksToAttach.size(); i++) {
        DiskModel disk = (DiskModel) disksToAttach.get(i).getEntity();
        // Disk is attached to VM as read only or not, null is applicable only for floating disks
        // but this is not a case here.
        AttachDettachVmDiskParameters parameters = new AttachDettachVmDiskParameters(getVm().getId(), disk.getDisk().getId(), (Boolean) getIsPlugged().getEntity(), Boolean.TRUE.equals(disk.getDisk().getReadOnly()));
        actionTypes.add(VdcActionType.AttachDiskToVm);
        paramerterList.add(parameters);
        callbacks.add(i == disksToAttach.size() - 1 ? onFinishCallback : null);
    }
    startProgress(null);
    Frontend.RunMultipleActions(actionTypes, paramerterList, callbacks, null, this);
}
#end_block

#method_before
private void onChangeQuota() {
    ChangeQuotaModel model = (ChangeQuotaModel) getWindow();
    ArrayList<VdcActionParametersBase> paramerterList = new ArrayList<VdcActionParametersBase>();
    for (Object item : model.getItems()) {
        ChangeQuotaItemModel itemModel = (ChangeQuotaItemModel) item;
        DiskImage disk = (DiskImage) itemModel.getEntity();
        VdcActionParametersBase parameters = new ChangeQuotaParameters(((Quota) itemModel.getQuota().getSelectedItem()).getId(), disk.getId(), disk.getStorageIds().get(0), disk.getStoragePoolId());
        paramerterList.add(parameters);
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.ChangeQuotaForDisk, paramerterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            cancel();
        }
    }, this);
}
#method_after
private void onChangeQuota() {
    ChangeQuotaModel model = (ChangeQuotaModel) getWindow();
    ArrayList<VdcActionParametersBase> paramerterList = new ArrayList<VdcActionParametersBase>();
    for (Object item : model.getItems()) {
        ChangeQuotaItemModel itemModel = (ChangeQuotaItemModel) item;
        DiskImage disk = (DiskImage) itemModel.getEntity();
        VdcActionParametersBase parameters = new ChangeQuotaParameters(((Quota) itemModel.getQuota().getSelectedItem()).getId(), disk.getId(), itemModel.getStorageDomainId(), disk.getStoragePoolId());
        paramerterList.add(parameters);
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.ChangeQuotaForDisk, paramerterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            cancel();
        }
    }, this);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.setMessage(ConstantsManager.getInstance().getConstants().disksMsg());
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk or a disk snapshot can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void cancel() {
    setWindow(null);
    Frontend.Unsubscribe();
}
#method_after
private void cancel() {
    setWindow(null);
    Frontend.getInstance().unsubscribe();
}
#end_block

#method_before
private boolean isPlugAvailableByDisks(boolean plug) {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        boolean isLocked = disk.getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED;
        if (disk.getPlugged() == plug || isLocked || (disk.getDiskInterface() == DiskInterface.IDE && !isVmDown())) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isPlugAvailableByDisks(boolean plug) {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        boolean isLocked = disk.getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED;
        boolean isDiskHotpluggableInterface = false;
        if (getEntity() != null) {
            isDiskHotpluggableInterface = AsyncDataProvider.getDiskHotpluggableInterfaces(getEntity().getOs(), getEntity().getVdsGroupCompatibilityVersion()).contains(disk.getDiskInterface());
        }
        if (disk.getPlugged() == plug || isLocked || (!isDiskHotpluggableInterface && !isVmDown())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isMoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || (!isVmDown() && disk.getPlugged())) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isMoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || (!isVmDown() && disk.getPlugged()) || disk.isDiskSnapshot()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isLiveMoveCommandAvailable() {
    if (!getIsLiveStorageMigrationEnabled()) {
        return false;
    }
    VM vm = getEntity();
    if (vm == null || !vm.getStatus().isUpOrPaused() || vm.isStateless()) {
        return false;
    }
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isLiveMoveCommandAvailable() {
    if (!getIsLiveStorageMigrationEnabled()) {
        return false;
    }
    VM vm = getEntity();
    if (vm == null || !vm.getStatus().isUpOrPaused() || vm.isStateless()) {
        return false;
    }
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || disk.isDiskSnapshot()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected void updateIsDiskHotPlugAvailable() {
    VM vm = getEntity();
    Version clusterCompatibilityVersion = vm.getVdsGroupCompatibilityVersion();
    if (clusterCompatibilityVersion == null) {
        setIsDiskHotPlugSupported(false);
    } else {
        setIsDiskHotPlugSupported((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.HotPlugEnabled, clusterCompatibilityVersion.toString()));
    }
}
#method_after
protected void updateIsDiskHotPlugAvailable() {
    VM vm = getEntity();
    Version clusterCompatibilityVersion = vm.getVdsGroupCompatibilityVersion();
    if (clusterCompatibilityVersion == null) {
        setIsDiskHotPlugSupported(false);
    } else {
        setIsDiskHotPlugSupported((Boolean) !AsyncDataProvider.getDiskHotpluggableInterfaces(getEntity().getOs(), clusterCompatibilityVersion).isEmpty());
    }
}
#end_block

#method_before
protected void updateExtendImageSizeSupported() {
    VM vm = (VM) getEntity();
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmDiskListModel model = (VmDiskListModel) target;
            model.setExtendImageSizeSupported((Boolean) returnValue);
        }
    });
    AsyncDataProvider.isCommandCompatible(query, VdcActionType.ExtendImageSize, vm.getVdsGroupCompatibilityVersion(), dataCenterVersion);
}
#method_after
protected void updateExtendImageSizeSupported() {
    VM vm = getEntity();
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmDiskListModel model = (VmDiskListModel) target;
            model.setExtendImageSizeSupported((Boolean) returnValue);
        }
    });
    AsyncDataProvider.isCommandCompatible(query, VdcActionType.ExtendImageSize, vm.getVdsGroupCompatibilityVersion(), dataCenterVersion);
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, List<String> messages) {
    // pinned, allow to select all hosts.
    if (vm.getRunOnVds() == null && vm.getDedicatedVmForVds() == null) {
        return hosts;
    }
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        for (VDS host : hosts) {
            if (host.getId().equals(vm.getDedicatedVmForVds())) {
                return Arrays.asList(host);
            }
        }
        // if flow reaches here, the VM is pinned but there is no dedicated host.
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST.toString());
        return new ArrayList<>();
    }
    return hosts;
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, List<String> messages) {
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        // host has been specified for pin to host.
        if (vm.getDedicatedVmForVds() != null) {
            for (VDS host : hosts) {
                if (host.getId().equals(vm.getDedicatedVmForVds())) {
                    return Arrays.asList(host);
                }
            }
        } else {
            // check pin to any (the VM should be down/ no migration allowed).
            if (vm.getRunOnVds() == null) {
                return hosts;
            }
        }
        // if flow reaches here, the VM is pinned but there is no dedicated host.
        return new ArrayList<>();
    }
    return hosts;
}
#end_block

#method_before
public ValidationResult validateIsoPath(VM vm, String diskPath, String floppyPath) {
    if (vm.isAutoStartup() || (StringUtils.isEmpty(diskPath) && StringUtils.isEmpty(floppyPath))) {
        return ValidationResult.VALID;
    }
    Guid storageDomainId = getIsoDomainListSyncronizer().findActiveISODomain(vm.getStoragePoolId());
    if (storageDomainId == null) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    if (!StringUtils.isEmpty(diskPath) && !isDiskPathImageExists(diskPath, storageDomainId)) {
        return new ValidationResult(VdcBllMessages.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
    }
    if (!StringUtils.isEmpty(floppyPath) && !isFloppyPathImageExists(floppyPath, storageDomainId)) {
        return new ValidationResult(VdcBllMessages.ERROR_CANNOT_FIND_FLOPPY_IMAGE_PATH);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateIsoPath(VM vm, String diskPath, String floppyPath) {
    if (vm.isAutoStartup() || (StringUtils.isEmpty(diskPath) && StringUtils.isEmpty(floppyPath))) {
        return ValidationResult.VALID;
    }
    Guid storageDomainId = getIsoDomainListSyncronizer().findActiveISODomain(vm.getStoragePoolId());
    if (storageDomainId == null) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    if (!StringUtils.isEmpty(diskPath) && !isRepoImageExists(diskPath, storageDomainId, ImageFileType.ISO)) {
        return new ValidationResult(VdcBllMessages.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
    }
    if (!StringUtils.isEmpty(floppyPath) && !isRepoImageExists(floppyPath, storageDomainId, ImageFileType.Floppy)) {
        return new ValidationResult(VdcBllMessages.ERROR_CANNOT_FIND_FLOPPY_IMAGE_PATH);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult validateVmStatusUsingMatrix(VM vm) {
    if (!VdcActionUtils.CanExecute(Arrays.asList(vm), VM.class, VdcActionType.RunVm)) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateVmStatusUsingMatrix(VM vm) {
    if (!VdcActionUtils.canExecute(Arrays.asList(vm), VM.class, VdcActionType.RunVm)) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public boolean canRunVm(VM vm, List<String> messages, List<Disk> vmDisks, BootSequence bootSequence, StoragePool storagePool, boolean isInternalExecution, String diskPath, String floppyPath, Boolean runAsStateless, List<Guid> vdsBlackList, Guid destVds, VDSGroup vdsGroup) {
    if (!validateVmProperties(vm, messages) || !validate(validateBootSequence(vm, bootSequence, vmDisks), messages) || !validate(new VmValidator(vm).vmNotLocked(), messages) || !validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) || !validate(validateVmStatusUsingMatrix(vm), messages) || !validate(validateStoragePoolUp(vm, storagePool), messages) || !validate(validateIsoPath(vm, diskPath, floppyPath), messages) || !validate(vmDuringInitialization(vm), messages) || !validate(validateVdsStatus(vm), messages) || !validate(validateStatelessVm(vm, vmDisks, runAsStateless), messages)) {
        return false;
    }
    List<DiskImage> images = ImagesHandler.filterImageDisks(vmDisks, true, false);
    if (!images.isEmpty() && (!validate(validateStorageDomains(vm, isInternalExecution, images), messages) || !validate(validateImagesForRunVm(vm, images), messages))) {
        return false;
    }
    if (!SchedulingManager.getInstance().canSchedule(vdsGroup, vm, vdsBlackList, null, destVds, messages)) {
        return false;
    }
    return true;
}
#method_after
public boolean canRunVm(VM vm, List<String> messages, List<Disk> vmDisks, BootSequence bootSequence, StoragePool storagePool, boolean isInternalExecution, String diskPath, String floppyPath, Boolean runAsStateless, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVds, VDSGroup vdsGroup) {
    if (!validateVmProperties(vm, messages) || !validate(validateBootSequence(vm, bootSequence, vmDisks), messages) || !validate(new VmValidator(vm).vmNotLocked(), messages) || !validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) || !validate(validateVmStatusUsingMatrix(vm), messages) || !validate(validateIsoPath(vm, diskPath, floppyPath), messages) || !validate(vmDuringInitialization(vm), messages) || !validate(validateVdsStatus(vm), messages) || !validate(validateStatelessVm(vm, vmDisks, runAsStateless), messages)) {
        return false;
    }
    List<DiskImage> images = ImagesHandler.filterImageDisks(vmDisks, true, false, false);
    if (!images.isEmpty() && (!validate(validateStoragePoolUp(vm, storagePool), messages) || !validate(validateStorageDomains(vm, isInternalExecution, images), messages) || !validate(validateImagesForRunVm(vm, images), messages))) {
        return false;
    }
    if (!SchedulingManager.getInstance().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVds, messages)) {
        return false;
    }
    return true;
}
#end_block

#method_before
public ValidationResult validateNetworkInterfaces(VM vm) {
    Map<String, VmNetworkInterface> interfaceNetworkMap = Entities.vmInterfacesByNetworkName(vm.getInterfaces());
    Set<String> interfaceNetworkNames = interfaceNetworkMap.keySet();
    List<Network> clusterNetworks = getNetworkDAO().getAllForCluster(vm.getVdsGroupId());
    Set<String> clusterNetworksNames = Entities.objectNames(clusterNetworks);
    ValidationResult validationResult = isVmInterfacesConfigured(vm);
    if (!validationResult.isValid()) {
        return validationResult;
    }
    validationResult = isVmInterfacesAttachedToClusterNetworks(vm, clusterNetworksNames, interfaceNetworkNames);
    if (!validationResult.isValid()) {
        return validationResult;
    }
    validationResult = isVmInterfacesAttachedToVmNetworks(clusterNetworks, interfaceNetworkNames);
    if (!validationResult.isValid()) {
        return validationResult;
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateNetworkInterfaces(VM vm) {
    Map<String, VmNetworkInterface> interfaceNetworkMap = Entities.vmInterfacesByNetworkName(vm.getInterfaces());
    Set<String> interfaceNetworkNames = interfaceNetworkMap.keySet();
    List<Network> clusterNetworks = getNetworkDao().getAllForCluster(vm.getVdsGroupId());
    Set<String> clusterNetworksNames = Entities.objectNames(clusterNetworks);
    ValidationResult validationResult = isVmInterfacesConfigured(vm);
    if (!validationResult.isValid()) {
        return validationResult;
    }
    validationResult = isVmInterfacesAttachedToClusterNetworks(vm, clusterNetworksNames, interfaceNetworkNames);
    if (!validationResult.isValid()) {
        return validationResult;
    }
    validationResult = isVmInterfacesAttachedToVmNetworks(clusterNetworks, interfaceNetworkNames);
    if (!validationResult.isValid()) {
        return validationResult;
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult isVmInterfacesConfigured(VM vm) {
    for (VmNetworkInterface nic : vm.getInterfaces()) {
        if (nic.getVnicProfileId() == null) {
            return !FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion()) ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_NETWORK_NOT_CONFIGURED) : ValidationResult.VALID;
        }
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult isVmInterfacesConfigured(VM vm) {
    for (VmNetworkInterface nic : vm.getInterfaces()) {
        if (nic.getVnicProfileId() == null) {
            return FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion()) ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_NETWORK_NOT_CONFIGURED);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult isVmInterfacesAttachedToClusterNetworks(VM vm, final Set<String> clusterNetworkNames, final Set<String> interfaceNetworkNames) {
    Set<String> result = new HashSet<String>(interfaceNetworkNames);
    result.removeAll(clusterNetworkNames);
    if (FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion())) {
        result.remove(null);
    }
    // attached to the cluster
    if (result.size() > 0) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NOT_IN_CLUSTER, String.format("$networks %1$s", StringUtils.join(result, ",")));
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult isVmInterfacesAttachedToClusterNetworks(VM vm, final Set<String> clusterNetworkNames, final Set<String> interfaceNetworkNames) {
    Set<String> result = new HashSet<String>(interfaceNetworkNames);
    result.removeAll(clusterNetworkNames);
    if (FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion())) {
        result.remove(null);
    }
    // aren't attached to the cluster
    return result.isEmpty() ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NOT_IN_CLUSTER, String.format("$networks %1$s", StringUtils.join(result, ",")));
}
#end_block

#method_before
private ValidationResult isVmInterfacesAttachedToVmNetworks(final List<Network> clusterNetworks, Set<String> interfaceNetworkNames) {
    List<String> nonVmNetworkNames = NetworkUtils.filterNonVmNetworkNames(clusterNetworks, interfaceNetworkNames);
    if (nonVmNetworkNames.size() > 0) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK, String.format("$networks %1$s", StringUtils.join(nonVmNetworkNames, ",")));
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult isVmInterfacesAttachedToVmNetworks(final List<Network> clusterNetworks, Set<String> interfaceNetworkNames) {
    List<String> nonVmNetworkNames = NetworkUtils.filterNonVmNetworkNames(clusterNetworks, interfaceNetworkNames);
    return nonVmNetworkNames.isEmpty() ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK, String.format("$networks %1$s", StringUtils.join(nonVmNetworkNames, ",")));
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            VmHandler.UpdateVmGuestAgentVersion(getVm());
            incrementVdsPendingVmsCount();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    throw e;
                default:
                    log.warnFormat("Failed to run VM {0}: {1}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.infoFormat("Trying to rerun VM {0}", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            VmHandler.updateVmGuestAgentVersion(getVm());
            incrementVdsPendingVmsCount();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    throw e;
                default:
                    log.warnFormat("Failed to run VM {0}: {1}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.infoFormat("Trying to rerun VM {0}", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#end_block

#method_before
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (isStatelessSnapshotExistsForVm()) {
        log.errorFormat("RunVmAsStateless - {0} - found stateless snapshots for this vm  - skipped creating snapshots.", getVm().getName());
        removeVmStatlessImages();
    } else {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getName(), getVm().getId());
        CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
        Map<String, String> values = getVmValuesForMsgResolving();
        // Creating snapshots as sub step of run stateless
        Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
        // Add the step as the first step of the new context
        ExecutionContext createSnapshotsCtx = new ExecutionContext();
        createSnapshotsCtx.setMonitored(true);
        createSnapshotsCtx.setStep(createSnapshotsStep);
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, new CommandContext(createSnapshotsCtx, getCompensationContext(), getLock()));
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getName());
        }
    }
}
#method_after
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (isStatelessSnapshotExistsForVm()) {
        log.errorFormat("RunVmAsStateless - {0} - found stateless snapshots for this vm  - skipped creating snapshots.", getVm().getName());
        removeVmStatlessImages();
    } else {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getName(), getVm().getId());
        CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
        Map<String, String> values = getVmValuesForMsgResolving();
        // Creating snapshots as sub step of run stateless
        Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
        // Add the step as the first step of the new context
        ExecutionContext createSnapshotsCtx = new ExecutionContext();
        createSnapshotsCtx.setMonitored(true);
        createSnapshotsCtx.setStep(createSnapshotsStep);
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, new CommandContext(createSnapshotsCtx, getCompensationContext(), getLock()));
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the endAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getName());
        }
    }
}
#end_block

#method_before
protected CreateVmVDSCommandParameters initCreateVmParams() {
    VM vmToBeCreated = getVm();
    vmToBeCreated.setRunOnce(false);
    if (!vmToBeCreated.getInterfaces().isEmpty()) {
        initParametersForExternalNetworks();
    }
    if (vmToBeCreated.getStatus() == VMStatus.Suspended) {
        return new CreateVmVDSCommandParameters(getVdsId(), vmToBeCreated);
    }
    if (!memorySnapshotSupported || memoryFromSnapshotIrrelevant) {
        vmToBeCreated.setHibernationVolHandle(StringUtils.EMPTY);
        return new CreateVmVDSCommandParameters(getVdsId(), vmToBeCreated);
    }
    // otherwise, use the memory that is saved on the active snapshot (might be empty)
    vmToBeCreated.setHibernationVolHandle(memoryVolumeFromSnapshot);
    CreateVmVDSCommandParameters parameters = new CreateVmVDSCommandParameters(getVdsId(), vmToBeCreated);
    // Mark that the hibernation volume should be cleared from the VM right after the sync part of
    // the create verb is finished (unlike hibernation volume that is created by hibernate command)
    parameters.setClearHibernationVolumes(true);
    return parameters;
}
#method_after
protected CreateVmVDSCommandParameters initCreateVmParams() {
    VM vmToBeCreated = getVm();
    vmToBeCreated.setRunOnce(false);
    vmToBeCreated.setCpuName(getVdsGroup().getcpu_name());
    if (!vmToBeCreated.getInterfaces().isEmpty()) {
        initParametersForExternalNetworks();
    }
    if (vmToBeCreated.getStatus() == VMStatus.Suspended) {
        return new CreateVmVDSCommandParameters(getVdsId(), vmToBeCreated);
    }
    if (!memorySnapshotSupported || memoryFromSnapshotIrrelevant) {
        vmToBeCreated.setHibernationVolHandle(StringUtils.EMPTY);
        return new CreateVmVDSCommandParameters(getVdsId(), vmToBeCreated);
    }
    // otherwise, use the memory that is saved on the active snapshot (might be empty)
    vmToBeCreated.setHibernationVolHandle(memoryVolumeFromSnapshot);
    CreateVmVDSCommandParameters parameters = new CreateVmVDSCommandParameters(getVdsId(), vmToBeCreated);
    // Mark that the hibernation volume should be cleared from the VM right after the sync part of
    // the create verb is finished (unlike hibernation volume that is created by hibernate command)
    parameters.setClearHibernationVolumes(true);
    return parameters;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isFailedStatlessSnapshot) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (mResume) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                return getSucceeded() ? (isStatelessSnapshotExistsForVm() ? AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS : AuditLogType.VDS_INITIATED_RUN_VM) : AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? getParameters() != null && getParameters().getDestinationVdsId() == null && getVm().getDedicatedVmForVds() != null && !getVm().getRunOnVds().equals(getVm().getDedicatedVmForVds()) ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : (isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM) : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isVmRunningStateless() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isVmRunningStateless() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isFailedStatlessSnapshot) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (mResume) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    boolean isVdsKnown = getVds() != null;
                    if (isStateless && isVdsKnown) {
                        return AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS;
                    } else if (isStateless) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? getParameters() != null && getParameters().getDestinationVdsId() == null && getVm().getDedicatedVmForVds() != null && !getVm().getRunOnVds().equals(getVm().getDedicatedVmForVds()) ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : (isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM) : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isVmRunningStateless() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isVmRunningStateless() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    // use destination vds or default vds or none
    VDS destinationVds = getDestinationVds();
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), null, destinationVds == null ? null : destinationVds.getId(), new ArrayList<String>(), new VdsFreeMemoryChecker(this));
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.UpdateVmGuestAgentVersion(getVm());
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    // use destination vds or default vds or none
    VDS destinationVds = getDestinationVds();
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), destinationVds == null ? null : destinationVds.getId(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (vm.getStatus() == VMStatus.Paused) {
        // if VM is paused, it was already checked before that it is capable to run
        return true;
    }
    if (!getRunVmValidator().canRunVm(vm, getReturnValue().getCanDoActionMessages(), getDiskDao().getAllForVm(vm.getId(), true), getParameters().getBootSequence(), getStoragePool(), isInternalExecution(), getParameters().getDiskPath(), getParameters().getFloppyPath(), getParameters().getRunAsStateless(), getRunVdssList(), getDestinationVds() != null ? getDestinationVds().getId() : null, getVdsGroup())) {
        return false;
    }
    if (!validate(getRunVmValidator().validateNetworkInterfaces(vm))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!vm.isAutoStartup() && !StringUtils.isEmpty(getVm().getIsoPath()) && getIsoDomainListSyncronizer().findActiveISODomain(getVm().getStoragePoolId()) == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (vm.getStatus() == VMStatus.Paused) {
        // if VM is paused, it was already checked before that it is capable to run
        return true;
    }
    if (!getRunVmValidator().canRunVm(vm, getReturnValue().getCanDoActionMessages(), getDiskDao().getAllForVm(vm.getId(), true), getParameters().getBootSequence(), getStoragePool(), isInternalExecution(), getParameters().getDiskPath(), getParameters().getFloppyPath(), getParameters().getRunAsStateless(), getRunVdssList(), getVdsWhiteList(), getDestinationVds() != null ? getDestinationVds().getId() : null, getVdsGroup())) {
        return false;
    }
    if (!validate(getRunVmValidator().validateNetworkInterfaces(vm))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    // we don't run the VM
    if (!vm.isAutoStartup() && !StringUtils.isEmpty(getVm().getIsoPath()) && getIsoDomainListSyncronizer().findActiveISODomain(getVm().getStoragePoolId()) == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    return true;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (isVmRunningStateless()) {
        CreateAllSnapshotsFromVmParameters createSnapshotParameters = buildCreateSnapshotParameters();
        createSnapshotParameters.setImagesParameters(getParameters().getImagesParameters());
        getBackend().EndAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        ExecutionContext runStatelessVmCtx = new ExecutionContext();
        Step step = getExecutionContext().getStep();
        // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
        // at this is a new instance of the command is used
        // (comparing with the execution state) so all information on the job and steps should be retrieved.
        Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
        Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
        // We would like to to set the run stateless step as substep of executing step
        setInternalExecution(true);
        // The internal command should be monitored for tasks
        runStatelessVmCtx.setMonitored(true);
        Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
        // This is needed in order to end the job upon exextuion of the steps of the child command
        runStatelessVmCtx.setShouldEndJob(true);
        // Since run stateless step involves invocation of command, we should set the run stateless vm step as
        // the "beginning step" of the child command.
        runStatelessVmCtx.setStep(runStatelessStep);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), new CommandContext(runStatelessVmCtx)).getSucceeded());
        if (!getSucceeded()) {
            // could not run the vm don't try to run the end action again
            log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getName());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#method_after
@Override
protected void endSuccessfully() {
    if (isVmRunningStateless()) {
        CreateAllSnapshotsFromVmParameters createSnapshotParameters = buildCreateSnapshotParameters();
        createSnapshotParameters.setImagesParameters(getParameters().getImagesParameters());
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        ExecutionContext runStatelessVmCtx = new ExecutionContext();
        Step step = getExecutionContext().getStep();
        // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
        // at this is a new instance of the command is used
        // (comparing with the execution state) so all information on the job and steps should be retrieved.
        Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
        Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
        // We would like to to set the run stateless step as substep of executing step
        setInternalExecution(true);
        // The internal command should be monitored for tasks
        runStatelessVmCtx.setMonitored(true);
        Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
        // This is needed in order to end the job upon exextuion of the steps of the child command
        runStatelessVmCtx.setShouldEndJob(true);
        // Since run stateless step involves invocation of command, we should set the run stateless vm step as
        // the "beginning step" of the child command.
        runStatelessVmCtx.setStep(runStatelessStep);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), new CommandContext(runStatelessVmCtx)).getSucceeded());
        if (!getSucceeded()) {
            // could not run the vm don't try to run the end action again
            log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getName());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#end_block

#method_before
private VM mockVm(RunVmCommand<RunVmParams> spyVmCommand) {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    doReturn(vmDAO).when(command).getVmDAO();
    when(vmDAO.get(command.getParameters().getVmId())).thenReturn(vm);
    return vm;
}
#method_after
private VM mockVm(RunVmCommand<RunVmParams> spyVmCommand) {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    doReturn(vmDAO).when(command).getVmDAO();
    when(vmDAO.get(command.getParameters().getVmId())).thenReturn(vm);
    doReturn(new VDSGroup()).when(command).getVdsGroup();
    return vm;
}
#end_block

#method_before
@Before
public void createCommand() {
    RunVmParams param = new RunVmParams(Guid.newGuid());
    command = spy(new RunVmCommand<RunVmParams>(param));
    mockIsoDomainListSyncronizer();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    mockSuccessfulSnapshotValidator();
    mockBackend();
}
#method_after
@Before
public void createCommand() {
    when(osRepository.isWindows(Mockito.anyInt())).thenReturn(false);
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    RunVmParams param = new RunVmParams(Guid.newGuid());
    command = spy(new RunVmCommand<RunVmParams>(param));
    mockIsoDomainListSyncronizer();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    mockSuccessfulSnapshotValidator();
    mockBackend();
}
#end_block

#method_before
private RunVmValidator mockSuccessfulRunVmValidator() {
    RunVmValidator runVmValidator = mock(RunVmValidator.class);
    when(runVmValidator.canRunVm(any(VM.class), Matchers.anyListOf(String.class), Matchers.anyListOf(Disk.class), any(BootSequence.class), any(StoragePool.class), anyBoolean(), anyString(), anyString(), anyBoolean(), Matchers.anyListOf(Guid.class), any(Guid.class), any(VDSGroup.class))).thenReturn(true);
    when(runVmValidator.validateNetworkInterfaces(any(VM.class))).thenReturn(ValidationResult.VALID);
    doReturn(runVmValidator).when(command).getRunVmValidator();
    return runVmValidator;
}
#method_after
private RunVmValidator mockSuccessfulRunVmValidator() {
    RunVmValidator runVmValidator = mock(RunVmValidator.class);
    when(runVmValidator.canRunVm(any(VM.class), Matchers.anyListOf(String.class), Matchers.anyListOf(Disk.class), any(BootSequence.class), any(StoragePool.class), anyBoolean(), anyString(), anyString(), anyBoolean(), Matchers.anyListOf(Guid.class), Matchers.anyListOf(Guid.class), any(Guid.class), any(VDSGroup.class))).thenReturn(true);
    when(runVmValidator.validateNetworkInterfaces(any(VM.class))).thenReturn(ValidationResult.VALID);
    doReturn(runVmValidator).when(command).getRunVmValidator();
    return runVmValidator;
}
#end_block

#method_before
@Override
public void execute() {
    if (!enclosingCommand.getParameters().getLiveSnapshotSucceeded()) {
        throw new VdcBLLException(VdcBllErrors.imageErr, "Auto-generated live snapshot for VM " + enclosingCommand.getParameters().getVmId() + " failed");
    }
    for (LiveMigrateDiskParameters parameters : enclosingCommand.getParameters().getParametersList()) {
        CommandContext commandContext = ExecutionHandler.createInternalJobContext();
        ExecutionHandler.setAsyncJob(commandContext.getExecutionContext(), true);
        parameters.setSessionId(enclosingCommand.getParameters().getSessionId());
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.LiveMigrateDisk, parameters, commandContext);
        enclosingCommand.getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        if (!parameters.getTaskGroupSuccess()) {
            ExecutionHandler.endTaskJob(commandContext.getExecutionContext(), false);
            log.errorFormat("Failed LiveMigrateDisk (Disk {0} , VM {1})", parameters.getImageGroupID(), parameters.getVmId());
        }
    }
    enclosingCommand.getReturnValue().setSucceeded(true);
}
#method_after
@Override
public void execute() {
    if (!enclosingCommand.getReturnValue().getSucceeded()) {
        throw new VdcBLLException(VdcBllErrors.imageErr, "Auto-generated live snapshot for VM " + enclosingCommand.getParameters().getVmId() + " failed");
    }
    for (LiveMigrateDiskParameters parameters : enclosingCommand.getParameters().getParametersList()) {
        CommandContext commandContext = ExecutionHandler.createInternalJobContext();
        ExecutionHandler.setAsyncJob(commandContext.getExecutionContext(), true);
        parameters.setSessionId(enclosingCommand.getParameters().getSessionId());
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.LiveMigrateDisk, parameters, commandContext);
        enclosingCommand.getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        if (!parameters.getTaskGroupSuccess()) {
            ExecutionHandler.endTaskJob(commandContext.getExecutionContext(), false);
            log.errorFormat("Failed LiveMigrateDisk (Disk {0} , VM {1})", parameters.getImageGroupID(), parameters.getVmId());
        }
    }
    enclosingCommand.getReturnValue().setSucceeded(true);
}
#end_block

#method_before
private void endCreateAllSnapshots() {
    CreateAllSnapshotsFromVmParameters snapshotsParameters = getCreateSnapshotParameters();
    Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, snapshotsParameters, ExecutionHandler.createDefaultContexForTasks(enclosingCommand.getExecutionContext()));
    enclosingCommand.getParameters().setLiveSnapshotSucceeded(snapshotsParameters.getLiveSnapshotSucceeded());
}
#method_after
private void endCreateAllSnapshots() {
    VdcReturnValueBase returnValue = Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(), ExecutionHandler.createDefaultContexForTasks(enclosingCommand.getExecutionContext()));
    enclosingCommand.getReturnValue().setSucceeded(returnValue.getSucceeded());
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (isLiveSnapshotApplicable()) {
            performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // If the removed snapshot contained memory, remove the memory volumes
            // Note that the memory volumes might not have been created
            removeMemoryVolumesOfSnapshot(createdSnapshot);
        } else {
            log.warnFormat("No snapshot was created for VM {0} which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded);
    getReturnValue().setEndActionTryAgain(false);
}
#method_after
@Override
protected void endVmCommand() {
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    boolean liveSnapshotRequired = isLiveSnapshotApplicable();
    boolean liveSnapshotSucceeded = false;
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (liveSnapshotRequired) {
            liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // If the removed snapshot contained memory, remove the memory volumes
            // Note that the memory volumes might not have been created
            removeMemoryVolumesOfSnapshot(createdSnapshot);
        } else {
            log.warnFormat("No snapshot was created for VM {0} which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded));
    getReturnValue().setEndActionTryAgain(false);
}
#end_block

#method_before
protected void performLiveSnapshot(final Snapshot snapshot) {
    try {
        TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                runVdsCommand(VDSCommandType.Snapshot, buildLiveSnapshotParameters(snapshot));
                getParameters().setLiveSnapshotSucceeded(true);
                return null;
            }
        });
    } catch (VdcBLLException e) {
        getParameters().setLiveSnapshotSucceeded(false);
        handleVdsLiveSnapshotFailure(e);
    }
}
#method_after
protected boolean performLiveSnapshot(final Snapshot snapshot) {
    try {
        TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                runVdsCommand(VDSCommandType.Snapshot, buildLiveSnapshotParameters(snapshot));
                return null;
            }
        });
    } catch (VdcBLLException e) {
        handleVdsLiveSnapshotFailure(e);
        return false;
    }
    return true;
}
#end_block

#method_before
private void updateActionAvailability() {
    VDS host = getEntity();
    VdsNetworkInterface selectedItem = (VdsNetworkInterface) getSelectedItem();
    ArrayList<VdsNetworkInterface> selectedItems = getSelectedItems();
    getEditCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItem != null && selectedItems.size() == 1 && StringHelper.isNullOrEmpty(selectedItem.getBondName()) && !selectedItem.getIsManagement());
    getBondCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItems.size() >= 2 && !isAnyBond(selectedItems) && Linq.findAllInterfaceNetworkNameNotEmpty(selectedItems).size() <= 1 && Linq.findAllInterfaceBondNameIsEmpty(selectedItems).size() == selectedItems.size() && Linq.findAllInterfaceVlanIdIsEmpty(selectedItems).size() == selectedItems.size());
    // to bond, selected lines must not have more that 1 networks (vlan or not)
    if (getItems() != null) {
        ArrayList<HostInterfaceLineModel> itemList = (ArrayList<HostInterfaceLineModel>) getItems();
        // total network count cannot be more than 1
        int totalNetworkCount = 0;
        for (HostInterfaceLineModel lineModel : itemList) {
            if (lineModel.getIsSelected()) {
                int lineNetworkCount = lineModel.getVlanSize() + (lineModel.getNetworkName() != null ? 1 : 0);
                if (lineNetworkCount > 1) {
                    // bailout
                    getBondCommand().setIsExecutionAllowed(false);
                    break;
                }
                totalNetworkCount += lineNetworkCount;
                if (totalNetworkCount > 1) {
                    // bailout
                    getBondCommand().setIsExecutionAllowed(false);
                    break;
                }
            }
        }
    }
    getDetachCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItems.size() == 1 && selectedItem != null && !StringHelper.isNullOrEmpty(selectedItem.getNetworkName()) && !selectedItem.getIsManagement());
    getSaveNetworkConfigCommand().setIsExecutionAllowed(host != null && (host.getNetConfigDirty() == null ? false : host.getNetConfigDirty()));
    getEditManagementNetworkCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItems.size() == 1 && selectedItem != null && selectedItem.getIsManagement());
    // available only on less than 3.1 Clusters
    if (host != null) {
        boolean isLessThan31 = host.getVdsGroupCompatibilityVersion().compareTo(Version.v3_1) < 0;
        getSetupNetworksCommand().setIsAvailable(!isLessThan31);
        getSaveNetworkConfigCommand().setIsAvailable(true);
        getEditCommand().setIsAvailable(isLessThan31);
        getBondCommand().setIsAvailable(isLessThan31);
        getDetachCommand().setIsAvailable(isLessThan31);
        getEditManagementNetworkCommand().setIsAvailable(isLessThan31);
        setSelectionAvailable(isLessThan31);
        // disable subtab refresh for pre-3.1 clusters, to avoid interfering with row selection
        setIsTimerDisabled(isLessThan31);
        if (isLessThan31) {
            stopRefresh();
        }
    }
}
#method_after
private void updateActionAvailability() {
    VDS host = getEntity();
    VdsNetworkInterface selectedItem = (VdsNetworkInterface) getSelectedItem();
    ArrayList<VdsNetworkInterface> selectedItems = getSelectedItems();
    getEditCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItem != null && selectedItems.size() == 1 && StringHelper.isNullOrEmpty(selectedItem.getBondName()) && !selectedItem.getIsManagement());
    getBondCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItems.size() >= 2 && !isAnyBond(selectedItems) && Linq.findAllInterfaceNetworkNameNotEmpty(selectedItems).size() <= 1 && Linq.findAllInterfaceBondNameIsEmpty(selectedItems).size() == selectedItems.size() && Linq.findAllInterfaceVlanIdIsEmpty(selectedItems).size() == selectedItems.size());
    // to bond, selected lines must not have more that 1 networks (vlan or not)
    if (getItems() != null) {
        ArrayList<HostInterfaceLineModel> itemList = (ArrayList<HostInterfaceLineModel>) getItems();
        // total network count cannot be more than 1
        int totalNetworkCount = 0;
        for (HostInterfaceLineModel lineModel : itemList) {
            if (lineModel.getIsSelected()) {
                int lineNetworkCount = lineModel.getVlanSize() + (lineModel.getNetworkName() != null ? 1 : 0);
                if (lineNetworkCount > 1) {
                    // bailout
                    getBondCommand().setIsExecutionAllowed(false);
                    break;
                }
                totalNetworkCount += lineNetworkCount;
                if (totalNetworkCount > 1) {
                    // bailout
                    getBondCommand().setIsExecutionAllowed(false);
                    break;
                }
            }
        }
    }
    getDetachCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItems.size() == 1 && selectedItem != null && !StringHelper.isNullOrEmpty(selectedItem.getNetworkName()) && !selectedItem.getIsManagement());
    getSaveNetworkConfigCommand().setIsExecutionAllowed(host != null && (host.getNetConfigDirty() == null ? false : host.getNetConfigDirty()));
    getEditManagementNetworkCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItems.size() == 1 && selectedItem != null && selectedItem.getIsManagement());
    // available only on less than 3.1 Clusters
    if (host != null) {
        boolean isLessThan31 = host.getVdsGroupCompatibilityVersion().compareTo(Version.v3_1) < 0;
        getSetupNetworksCommand().setIsAvailable(!isLessThan31);
        getSaveNetworkConfigCommand().setIsAvailable(true);
        getEditCommand().setIsAvailable(isLessThan31);
        getBondCommand().setIsAvailable(isLessThan31);
        getDetachCommand().setIsAvailable(isLessThan31);
        getEditManagementNetworkCommand().setIsAvailable(isLessThan31);
        setSelectionAvailable(isLessThan31);
        // disable subtab refresh for pre-3.1 clusters, to avoid interfering with row selection
        setIsTimerDisabled(isLessThan31);
        if (isLessThan31) {
            getTimer().stop();
        } else {
            getTimer().start();
        }
    }
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.UpdateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    ResourceManager.getInstance().getEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    ResourceManager.getInstance().getEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#end_block

#method_before
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            // _vds = loadVDS(_vds.getId());
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void reloadVds(VDS vds) {
    DbFacade.getInstance().getVdsDao().reloadVDS(vds);
}
#method_after
private void reloadVds(VDS vds) {
    DbFacade.getInstance().getVdsDao().reloadPartial(vds);
}
#end_block

#method_before
private boolean devicePluggable(VmDevice device) {
    return (VmDeviceType.DISK.getName().equals(device.getDevice()) && VmDeviceGeneralType.DISK == device.getType()) || (VmDeviceType.BRIDGE.getName().equals(device.getDevice()) && VmDeviceGeneralType.INTERFACE == device.getType());
}
#method_after
private boolean devicePluggable(VmDevice device) {
    return VmDeviceCommonUtils.isDisk(device) || VmDeviceCommonUtils.isBridge(device);
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if ((_vds.getStatus() == VDSStatus.PreparingForMaintenance) && monitoringStrategy.canMoveToMaintenance(_vds)) {
        _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
        _saveVdsDynamic = true;
        _saveVdsStatistics = true;
        log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            if (_vdsManager.isTimeToRetryMaintenance()) {
                ResourceManager.getInstance().getEventListener().handleVdsMaintenanceTimeout(_vds);
                _vdsManager.calculateNextMaintenanceAttemptTime();
            }
        }
    }
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.calculateFreeVirtualMemory();
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.calculateFreeVirtualMemory();
    return entity;
}
#end_block

#method_before
@Override
public VDS getPartial(Guid vdsId) {
    VDS vdsPartial = new VDS();
    // TODO: From cache
    vdsPartial.setStaticData(DbFacade.getInstance().getVdsStaticDao().get(vdsId));
    vdsPartial.setDynamicData(DbFacade.getInstance().getVdsDynamicDao().get(vdsId));
    // vdsPartial.setStatisticsData(DbFacade.getInstance().getVdsStatisticsDao().get(vdsId));
    // TODO: From cache
    VDSGroup group = DbFacade.getInstance().getVdsGroupDao().get(vdsPartial.getVdsGroupId());
    vdsPartial.setVdsGroupCompatibilityVersion(group.getcompatibility_version());
    vdsPartial.setVdsGroupCpuName(group.getcpu_name());
    vdsPartial.setVdsGroupDescription(group.getdescription());
    vdsPartial.setVdsGroupName(group.getName());
    vdsPartial.setStoragePoolId(group.getStoragePoolId());
    vdsPartial.setStoragePoolName(group.getStoragePoolName());
    vdsPartial.setMaxVdsMemoryOverCommit(group.getmax_vds_memory_over_commit());
    return vdsPartial;
}
#method_after
@Override
public VDS getPartial(Guid vdsId) {
    VDS vdsPartial = new VDS();
    // TODO: From cache
    vdsPartial.setStaticData(DbFacade.getInstance().getVdsStaticDao().get(vdsId));
    vdsPartial.setDynamicData(DbFacade.getInstance().getVdsDynamicDao().get(vdsId));
    // TODO: From cache
    VDSGroup group = DbFacade.getInstance().getVdsGroupDao().get(vdsPartial.getVdsGroupId());
    vdsPartial.setVdsGroupCompatibilityVersion(group.getcompatibility_version());
    vdsPartial.setVdsGroupCpuName(group.getcpu_name());
    vdsPartial.setVdsGroupDescription(group.getdescription());
    vdsPartial.setVdsGroupName(group.getName());
    vdsPartial.setStoragePoolId(group.getStoragePoolId());
    vdsPartial.setStoragePoolName(group.getStoragePoolName());
    vdsPartial.setMaxVdsMemoryOverCommit(group.getmax_vds_memory_over_commit());
    return vdsPartial;
}
#end_block

#method_before
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            VDS tmpVds;
            synchronized (getLockObj()) {
                tmpVds = _vds = DbFacade.getInstance().getVdsDao().getPartial(getVdsId());
                if (_vds == null) {
                    log.errorFormat("VdsManager::refreshVdsRunTimeInfo - OnTimer is NULL for {0}", getVdsId());
                    return;
                }
                try {
                    if (_refreshIteration == _numberRefreshesBeforeSave) {
                        _refreshIteration = 1;
                    } else {
                        _refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        _vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, _vds, monitoringStrategy);
                        _vdsUpdater.Refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!getInitialized() && _vds.getStatus() != VDSStatus.NonResponsive && _vds.getStatus() != VDSStatus.PendingApproval) {
                        log.infoFormat("Initializing Host: {0}", _vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(_vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    HandleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (_vdsUpdater != null) {
                        _vdsUpdater.AfterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (_vds != null && _vds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = _vds.getStoragePoolId();
                            domainsList = _vds.getDomains();
                        }
                    }
                    _vds = null;
                    _vdsUpdater = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.UpdateVdsDomainsData(tmpVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            VDS tmpVds;
            synchronized (getLockObj()) {
                tmpVds = _vds = DbFacade.getInstance().getVdsDao().getPartial(getVdsId());
                if (_vds == null) {
                    log.errorFormat("VdsManager::refreshVdsRunTimeInfo - OnTimer is NULL for {0}", getVdsId());
                    return;
                }
                try {
                    if (_refreshIteration == _numberRefreshesBeforeSave) {
                        _refreshIteration = 1;
                    } else {
                        _refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        _vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, _vds, monitoringStrategy);
                        _vdsUpdater.Refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!getInitialized() && _vds.getStatus() != VDSStatus.NonResponsive && _vds.getStatus() != VDSStatus.PendingApproval) {
                        log.infoFormat("Initializing Host: {0}", _vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(_vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    HandleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (_vdsUpdater != null) {
                        _vdsUpdater.AfterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (_vds != null && _vds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = _vds.getStoragePoolId();
                            domainsList = _vds.getDomains();
                        }
                    }
                    _vds = null;
                    _vdsUpdater = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(tmpVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#end_block

#method_before
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getPreviousStatus() != vds.getStatus()) {
            vds.setPreviousStatus(vds.getStatus());
            if (_vds != null) {
                _vds.setPreviousStatus(vds.getStatus());
            }
        }
        // update to new status
        vds.setStatus(status);
        if (_vds != null) {
            _vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (_vds != null) {
                    _vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (_vds != null) {
                    _vds.setCpuSys(Double.valueOf(0));
                    _vds.setCpuUser(Double.valueOf(0));
                    _vds.setCpuIdle(Double.valueOf(0));
                    _vds.setCpuLoad(Double.valueOf(0));
                    _vds.setUsageCpuPercent(0);
                    _vds.setUsageMemPercent(0);
                    _vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#method_after
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getPreviousStatus() != vds.getStatus()) {
            vds.setPreviousStatus(vds.getStatus());
            if (_vds != null) {
                _vds.setPreviousStatus(vds.getStatus());
                if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                    calculateNextMaintenanceAttemptTime();
                }
            }
        }
        // update to new status
        vds.setStatus(status);
        if (_vds != null) {
            _vds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (_vds != null) {
                    _vds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (_vds != null) {
                    _vds.setCpuSys(Double.valueOf(0));
                    _vds.setCpuUser(Double.valueOf(0));
                    _vds.setCpuIdle(Double.valueOf(0));
                    _vds.setCpuLoad(Double.valueOf(0));
                    _vds.setUsageCpuPercent(0);
                    _vds.setUsageMemPercent(0);
                    _vds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("GetCapabilitiesVDSCommand started method");
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by vdsm.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds, false);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                if (log.isDebugEnabled()) {
                    log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
                }
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
                returnStatus = vds.getStatus();
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            UpdateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("GetCapabilitiesVDSCommand started method");
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by vdsm.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds, false);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                if (log.isDebugEnabled()) {
                    log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
                }
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
                returnStatus = vds.getStatus();
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getProblematicVdsId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VDS_FENCE, VdcBllMessages.SAME_ACTION_ON_ENTITY_ALREADY_IN_PROGRESS));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return FenceVdsBaseCommand.createFenceExclusiveLocksMap(getProblematicVdsId());
}
#end_block

#method_before
private void executeFenceVdsManuallyAction(final Guid vdsId, String sessionId) {
    FenceVdsManualyParameters fenceVdsManuallyParams = new FenceVdsManualyParameters(false);
    fenceVdsManuallyParams.setStoragePoolId(getVds().getStoragePoolId());
    fenceVdsManuallyParams.setVdsId(vdsId);
    fenceVdsManuallyParams.setSessionId(sessionId);
    // if fencing succeeded, call to reset irs in order to try select new spm
    Backend.getInstance().runInternalAction(VdcActionType.FenceVdsManualy, fenceVdsManuallyParams, getContext());
}
#method_after
private void executeFenceVdsManuallyAction(final Guid vdsId, String sessionId) {
    FenceVdsManualyParameters fenceVdsManuallyParams = new FenceVdsManualyParameters(false);
    fenceVdsManuallyParams.setStoragePoolId(getVds().getStoragePoolId());
    fenceVdsManuallyParams.setVdsId(vdsId);
    fenceVdsManuallyParams.setSessionId(sessionId);
    fenceVdsManuallyParams.setParentCommand(VdcActionType.RestartVds);
    // if fencing succeeded, call to reset irs in order to try select new spm
    Backend.getInstance().runInternalAction(VdcActionType.FenceVdsManualy, fenceVdsManuallyParams, getContext());
}
#end_block

#method_before
private CommandContext getContext() {
    if (commandContext == null) {
        commandContext = new CommandContext(getExecutionContext(), getLock());
    }
    return commandContext;
}
#method_after
private CommandContext getContext() {
    if (commandContext == null) {
        commandContext = new CommandContext(getExecutionContext(), new EngineLock(getExclusiveLocks(), null));
    }
    return commandContext;
}
#end_block

#method_before
private void commitRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().commitRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_commit");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnCommitRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void commitRemoveBricks() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().commitRemoveBricksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().commitRemoveBricksMessage());
    // $NON-NLS-1$
    model.setHashName("volume_remove_bricks_commit");
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity brick : volumeEntity.getBricks()) {
        if (brick.getAsyncTask() != null && volumeTask != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volumeTask.getTaskId()) && volumeTask.getStatus() == JobExecutionStatus.FINISHED) {
            list.add(brick.getQualifiedName());
        }
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnCommitRemoveBricks", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.UpdateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    ResourceManager.getInstance().getEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    ResourceManager.getInstance().getEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if ((_vds.getStatus() == VDSStatus.PreparingForMaintenance) && monitoringStrategy.canMoveToMaintenance(_vds)) {
        _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
        _saveVdsDynamic = true;
        _saveVdsStatistics = true;
        log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if (_vds.getStatus() == VDSStatus.PreparingForMaintenance) {
        if (monitoringStrategy.canMoveToMaintenance(_vds)) {
            _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
            _saveVdsDynamic = true;
            _saveVdsStatistics = true;
            log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getName());
        } else {
            if (_vdsManager.isTimeToRetryMaintenance()) {
                ResourceManager.getInstance().getEventListener().handleVdsMaintenanceTimeout(_vds);
                _vdsManager.calculateNextMaintenanceAttemptTime();
            }
        }
    }
}
#end_block

#method_before
public static void updateDisksFromDb(VM vm) {
    List<Disk> imageList = DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId());
    vm.getDiskList().clear();
    vm.getDiskMap().clear();
    updateDisksForVm(vm, imageList);
}
#method_after
public static void updateDisksFromDb(VM vm) {
    List<Disk> imageList = DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId());
    vm.clearDisks();
    updateDisksForVm(vm, imageList);
}
#end_block

#method_before
public static void updateDisksForVm(VM vm, List<? extends Disk> diskList) {
    for (Disk disk : diskList) {
        if (disk.isAllowSnapshot()) {
            DiskImage image = (DiskImage) disk;
            if (image.getActive() != null && image.getActive()) {
                vm.getDiskMap().put(image.getId(), image);
                vm.getDiskList().add(image);
            }
        } else {
            vm.getDiskMap().put(disk.getId(), disk);
        }
    }
}
#method_after
public static void updateDisksForVm(VM vm, Collection<? extends Disk> disks) {
    for (Disk disk : disks) {
        if (disk.isAllowSnapshot() && !disk.isDiskSnapshot()) {
            DiskImage image = (DiskImage) disk;
            vm.getDiskMap().put(image.getId(), image);
            vm.getDiskList().add(image);
        } else {
            vm.getDiskMap().put(disk.getId(), disk);
        }
    }
}
#end_block

#method_before
public ArrayList<DiskImage> getDiskList() {
    return diskList;
}
#method_after
@JsonIgnore
public ArrayList<DiskImage> getDiskList() {
    return diskList;
}
#end_block

#method_before
@Test
public void addPosixNonEmptyVFSType() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void addPosixNonEmptyVFSType() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection, null);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
@Test
public void addISCSINonEmptyIqn() {
    StorageServerConnections newISCSIConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "user1", "mypassword123");
    parameters.setStorageServerConnection(newISCSIConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(false).when(command).isConnWithSameDetailsExists(newISCSIConnection);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void addISCSINonEmptyIqn() {
    StorageServerConnections newISCSIConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "user1", "mypassword123");
    parameters.setStorageServerConnection(newISCSIConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(false).when(command).isConnWithSameDetailsExists(newISCSIConnection, null);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
@Test
public void addExistingConnection() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(true).when(command).isConnWithSameDetailsExists(newPosixConnection);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
}
#method_after
@Test
public void addExistingConnection() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(true).when(command).isConnWithSameDetailsExists(newPosixConnection, null);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
}
#end_block

#method_before
@Test
public void addNewConnectionWithVds() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    newPosixConnection.setid("");
    parameters.setStorageServerConnection(newPosixConnection);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection);
    Pair<Boolean, Integer> connectResult = new Pair(true, 0);
    doReturn(connectResult).when(command).connectHostToStorage();
    doReturn(null).when(command).getConnectionFromDbById(newPosixConnection.getid());
    doNothing().when(command).saveConnection(newPosixConnection);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#method_after
@Test
public void addNewConnectionWithVds() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    newPosixConnection.setid("");
    parameters.setStorageServerConnection(newPosixConnection);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection, null);
    Pair<Boolean, Integer> connectResult = new Pair(true, 0);
    doReturn(connectResult).when(command).connectHostToStorage();
    doReturn(null).when(command).getConnectionFromDbById(newPosixConnection.getid());
    doNothing().when(command).saveConnection(newPosixConnection);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#end_block

#method_before
@Test
public void addNewConnectionEmptyVdsId() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    newPosixConnection.setid("");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection);
    doReturn(null).when(command).getConnectionFromDbById(newPosixConnection.getid());
    doNothing().when(command).saveConnection(newPosixConnection);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#method_after
@Test
public void addNewConnectionEmptyVdsId() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    newPosixConnection.setid("");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection, null);
    doReturn(null).when(command).getConnectionFromDbById(newPosixConnection.getid());
    doNothing().when(command).saveConnection(newPosixConnection);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#end_block

#method_before
@Test
public void addNewConnectionNullVdsId() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    newPosixConnection.setid("");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(null);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection);
    doReturn(null).when(command).getConnectionFromDbById(newPosixConnection.getid());
    doNothing().when(command).saveConnection(newPosixConnection);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#method_after
@Test
public void addNewConnectionNullVdsId() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    newPosixConnection.setid("");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(null);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection, null);
    doReturn(null).when(command).getConnectionFromDbById(newPosixConnection.getid());
    doNothing().when(command).saveConnection(newPosixConnection);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#end_block

#method_before
@Test
public void addNotEmptyIdConnection() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    newPosixConnection.setid(Guid.newGuid().toString());
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(true).when(command).isConnWithSameDetailsExists(newPosixConnection);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY);
}
#method_after
@Test
public void addNotEmptyIdConnection() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    newPosixConnection.setid(Guid.newGuid().toString());
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(true).when(command).isConnWithSameDetailsExists(newPosixConnection, null);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY);
}
#end_block

#method_before
@Test
public void isConnWithSameDetailsExist() {
    StorageServerConnections newISCSIConnection = createISCSIConnection("1.2.3.4", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "user1", "mypassword123");
    StorageServerConnections existingConn = createISCSIConnection("1.2.3.4", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "user1", "mypassword123");
    existingConn.setid(Guid.newGuid().toString());
    List<StorageServerConnections> connections = new ArrayList<>();
    connections.add(existingConn);
    when(storageConnDao.getAllForConnection(newISCSIConnection)).thenReturn(connections);
    boolean isExists = command.isConnWithSameDetailsExists(newISCSIConnection);
    assertTrue(isExists);
}
#method_after
@Test
public void isConnWithSameDetailsExist() {
    StorageServerConnections newISCSIConnection = createISCSIConnection("1.2.3.4", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "user1", "mypassword123");
    StorageServerConnections existingConn = createISCSIConnection("1.2.3.4", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "user1", "mypassword123");
    existingConn.setid(Guid.newGuid().toString());
    List<StorageServerConnections> connections = new ArrayList<>();
    connections.add(existingConn);
    when(storageConnDao.getAllForConnection(newISCSIConnection)).thenReturn(connections);
    boolean isExists = command.isConnWithSameDetailsExists(newISCSIConnection, null);
    assertTrue(isExists);
}
#end_block

#method_before
protected boolean isConnWithSameDetailsExists(StorageServerConnections connection) {
    List<StorageServerConnections> connections = null;
    if (connection.getstorage_type() == StorageType.LOCALFS) {
        Guid storagePoolId = getStoragePoolIdByConnId(connection.getid());
        connections = storagePoolId == null ? Collections.<StorageServerConnections>emptyList() : getStorageConnDao().getAllConnectableStorageSeverConnection(storagePoolId);
    } else if (connection.getstorage_type().isFileDomain()) {
        String connectionField = connection.getconnection();
        connections = getStorageConnDao().getAllForStorage(connectionField);
    } else {
        connections = getStorageConnDao().getAllForConnection(connection);
    }
    boolean isDuplicateConnExists = (connections.size() > 1 || (connections.size() == 1 && !connections.get(0).getid().equalsIgnoreCase(connection.getid())));
    return isDuplicateConnExists;
}
#method_after
protected boolean isConnWithSameDetailsExists(StorageServerConnections connection, Guid storagePoolId) {
    List<StorageServerConnections> connections = null;
    if (connection.getstorage_type() == StorageType.LOCALFS) {
        List<StorageServerConnections> connectionsForPool = storagePoolId == null ? Collections.<StorageServerConnections>emptyList() : getStorageConnDao().getAllConnectableStorageSeverConnection(storagePoolId);
        List<StorageServerConnections> connectionsForPath = getStorageConnDao().getAllForStorage(connection.getconnection());
        connections = (List<StorageServerConnections>) CollectionUtils.intersection(connectionsForPool, connectionsForPath);
    } else if (connection.getstorage_type().isFileDomain()) {
        String connectionField = connection.getconnection();
        connections = getStorageConnDao().getAllForStorage(connectionField);
    } else {
        connections = getStorageConnDao().getAllForConnection(connection);
    }
    boolean isDuplicateConnExists = (connections.size() > 1 || (connections.size() == 1 && !connections.get(0).getid().equalsIgnoreCase(connection.getid())));
    return isDuplicateConnExists;
}
#end_block

